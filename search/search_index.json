{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the consulo.dev - the primary source of documentation for extending the Consulo by creating plugins. Getting Started Creating Your First Plugin Open Source This guide is Open Source and licensed under Apache 2.0. The source (as Markdown) is hosted on GitHub . Please see README.md for details on hosting the docs locally and contributing. Helpful Links consulo.io - home page discuss.consulo.io - forum hub.consulo.io - hub where you can find info about plugins, your error reports, statistics, e tc ci.consulo.io - jenkins maven.consulo.io - maven repository upm.consulo.io - NPM registry for Unity consulo.app - download page","title":"Welcome"},{"location":"#getting-started","text":"Creating Your First Plugin","title":"Getting Started"},{"location":"#open-source","text":"This guide is Open Source and licensed under Apache 2.0. The source (as Markdown) is hosted on GitHub . Please see README.md for details on hosting the docs locally and contributing.","title":"Open Source"},{"location":"#helpful-links","text":"consulo.io - home page discuss.consulo.io - forum hub.consulo.io - hub where you can find info about plugins, your error reports, statistics, e tc ci.consulo.io - jenkins maven.consulo.io - maven repository upm.consulo.io - NPM registry for Unity consulo.app - download page","title":"Helpful Links"},{"location":"basics/action_system/","text":"Introduction The actions system is an extension point that allows plugins to add their items to Consulo-based IDE menus and toolbars. For example, one of the action classes is responsible for the File | Open File... menu item and the Open File toolbar button. Actions in the Consulo require a code implementation and must be registered . The action implementation determines the contexts in which an action is available, and its functionality when selected in the UI. Registration determines where an action appears in the IDE UI. Once implemented and registered, an action receives callbacks from the Consulo in response to user gestures. The Creating Actions tutorial describes the process of adding a custom action to a plugin. The Grouping Actions tutorial demonstrates three types of groups that can contain actions. The rest of this page is an overview of actions as an extension point. bullet list {:toc} Action Implementation An action is a class derived from the abstract class AnAction . The Consulo calls methods of an action when a user interacts with a menu item or toolbar button. WARNING Classes based on AnAction do not have class fields of any kind. This is because an instance of AnAction class exists for the entire lifetime of the application. If the AnAction class uses a field to store data that has a shorter lifetime and doesn't clear this data promptly, the data leaks. For example, any AnAction data that exists only within the context of a Project causes the Project to be kept in memory after the user has closed it. Principal Implementation Overrides Every Consulo action should override AnAction.update() and must override AnAction.actionPerformed() . * An action's method AnAction.update() is called by the Consulo framework to update an action state. The state (enabled, visible) of an action determines whether the action is available in the UI of an IDE. An object of the AnActionEvent type is passed to this method and contains information about the current context for the action. Actions are made available by changing state in the Presentation object associated with the event context. As explained in Overriding the AnAction.update() Method , it is vital update() methods execute quickly and return execution to the Consulo. * An action's method AnAction.actionPerformed() is called by the Consulo if available and selected by the user. This method does the heavy lifting for the action - it contains the code executed when the action gets invoked. The actionPerformed() method also receives AnActionEvent as a parameter, which is used to access projects, files, selection, etc. See Overriding the AnAction.actionPerformed() Method for more information. There are other methods to override in the AnAction class, such as changing the default Presentation object for the action. There is also a use case for overriding action constructors when registering them with dynamic action groups, demonstrated in the Grouping Actions tutorial. However, the update() and actionPerformed() methods are essential to basic operation. Overriding the AnAction.update Method The method AnAction.update() is periodically called by the Consulo in response to user gestures. The update() method gives an action to evaluate the current context and enable or disable its functionality. WARNING The AnAction.update() method can be called frequently and on a UI thread. This method needs to execute very quickly ; no real work should be performed in this method. For example, checking selection in a tree or a list is considered valid, but working with the file system is not. TIP If the new state of an action cannot be determined quickly, then evaluation should be performed in the AnAction.actionPerformed() method, and notify the user that the action cannot be executed if the context isn't suitable. Determining the Action Context The AnActionEvent object passed to update() carries information about the current context for the action. Context information is available from the methods of AnActionEvent , providing information such as the Presentation and whether the action is triggered by a Toolbar. Additional context information is available using the method AnActionEvent.getData() . Keys defined in CommonDataKeys are passed to the getData() method to retrieve objects such as Project , Editor , PsiFile , and other information. Accessing this information is relatively light-weight and is suited for AnAction.update() . Enabling and Setting Visibility for an Action Based on information about the action context, the AnAction.update() method can enable, disable, or hide an action. An action's enable/disable state and visibility are set using methods of the Presentation object, which is accessed using AnActionEvent.getPresentation() . The default Presentation object is a set of descriptive information about a menu or toolbar action. Every context for an action - it might appear in multiple menus, toolbars, or Navigation search locations - has a unique presentation. Attributes such as an action's text, description, and icons and visibility and enable/disable state, are stored in the presentation. The attributes in a presentation get initialized from the action registration . However, some can be changed at runtime using the methods of the Presentation object associated with an action. The enabled/disabled state of an action is set using Presentation.setEnabled() . The visibility state of an action is set using Presentation.setVisible() If an action is enabled, the AnAction.actionPerformed() can be called if an action is selected in the IDE by a user. A menu action shows in the UI location specified in the registration. A toolbar action displays its enabled (or selected) icon, depending on the user interaction. When an action is disabled AnAction.actionPerformed() will not be called. Toolbar actions display their respective icons for the disabled state. The visibility of a disabled action in a menu depends on whether the host menu (e.g., \"ToolsMenu\") containing the action has the compact attribute set. See Grouping Actions for more information about the compact attribute and menu actions' visibility. NOTE If an action is added to a toolbar, its update() can be called if there was any user activity or focus transfer. If the action's availability changes in the absence of these events, then call ActivityTracker.getInstance().inc() to notify the action subsystem to update all toolbar actions. An example of enabling a menu action based on whether a project is open is demonstrated in PopupDialogAction.update() method. Overriding the AnAction.actionPerformed Method When the user selects an enabled action, be it from a menu or toolbar, the action's AnAction.actionPerformed() method is called. This method contains the code executed to perform the action, and it is here that the real work gets done. By using the AnActionEvent methods and CommonDataKeys , objects such as the Project , Editor , PsiFile , and other information is available. For example, the actionPerformed() method can modify, remove, or add PSI elements to a file open in the editor. The code that executes in the AnAction.actionPerformed() method should execute efficiently, but it does not have to meet the same stringent requirements as the update() method. An example of inspecting PSI elements is demonstrated in the SDK code sample action_basics PopupDialogAction.actionPerformed() method. Action IDs Every action and action group has a unique identifier. Basing the identifier for a custom action on the FQN of the implementation is the best practice, assuming the package incorporates the <id> of the plugin. An action must have a unique identifier for each place. It is used in the IDE UI, even though the FQN of the implementation is the same. Definitions of identifiers for the standard Consulo actions are in IdeActions . Grouping Actions Groups organize actions into logical UI structures, which in turn can contain other groups. A group of actions can form a toolbar or a menu. Subgroups of a group can form submenus of a menu. Actions can be included in multiple groups, and thus appear in different places within the IDE UI. An action must have a unique identifier for each place it appears in the IDE UI. See the Action Declaration Reference section for information about how to specify locations in the IDE UI. Presentation A new Presentation gets created for every place where the action appears. Therefore, the same action can have different text or icons when it appears in different places of the user interface. Different presentations for the action are created by copying the Presentation returned by the AnAction.getTemplatePresentation() method. Compact Attribute A group's \"compact\" attribute specifies whether an action within that group is visible when disabled. See Registering Actions in plugin.xml for an explanation of how the compact attribute is set for a group. If the compact attribute is true for a menu group, an action in the menu only appears if its state is both enabled and visible. In contrast, if the compact attribute is false , an action in the menu appears if its state is disabled but visible. Some menus like Tools have the compact attribute set, so there isn't a way to show an action on the tools menu if it is not enabled. Host Menu compact Setting Action Enabled Visibility Enabled Menu Item Visible? Menu Item Appears Gray? T F T F N/A T T T T F F F T T T F T T T F All other combinations of compact , visibility, and enablement produce N/A for gray appearance because the menu item isn't visible. See the Grouping Actions tutorial for examples of creating action groups. Registering Actions There are two main ways to register an action: either by listing it in the <actions> section of a plugin's plugin.xml file or through code. Registering Actions in plugin.xml Registering actions in plugin.xml is demonstrated in the following reference examples, which document all elements and attributes used in the <actions> section and describe each element's meaning. Setting the Override-Text Element Beginning in 2020.1, an alternate version of an action's menu text can be declared for use depending on where an action appears. Using the <override-text> element, the menu text for an action can be different depending on context: menu location, toolbar, etc. This is also available for groups in 2020.3 and later. In the action element reference example (below) with id attribute VssIntegration.GarbageCollection , the default is to use the menu text \"Garbage Collector: Collect _Garbage.\" The add-to-group element declares the action is added to the Tools Menu. However, the override-text element declares that text for VssIntegration.GarbageCollection displayed anywhere in the Main Menu system should be the alternate text \"Collect _Garbage.\" The Tools Menu is part of the Main Menu, so the displayed menu text is \"Collect _Garbage.\" A different context, such as searching for the action using Help | Find Action... , displays the default text \"Garbage Collector: Collect _Garbage\" to give the user additional information about the action. A second override-text element uses place and use-text-of-place attributes to declare the same version of the text used in the Main Menu is also used in the Editor Popup Menu. Additional override-text elements could be used to specify other places where the Main Menu text should be used. An example of using <override-text> is demonstrated in the Creating Actions tutorial. Setting the Synonym Element 2020.3 Users can locate actions via their name by invoking Help | Find Action . To allow using alternative names in search, add one or more <synonym> elements inside <action> or <reference> : <action id= \"MyAction\" text= \"My Action Name\" ... > <synonym text= \"Another Search Term\" /> </action> To provide a localized synonym, specify key instead of text attribute. Disabling Search for Group 2020.3 To exclude a group from appearing in Help | Find Action results (e.g., New... popup), specify searchable=\"false\" . Localizing Actions and Groups Action and group localization use resource bundles containing property files named *Bundle.properties , each file consisting of key=value pairs. The action_basics plugin demonstrates using a resource bundle to localize the group and action entries added to the Editor Popup Menu. When localizing actions and groups, the text and description attributes are not declared in plugin.xml . Instead, those attribute values vary depending on the locale and get declared in a resource bundle. The name and location of the resource bundle must be declared in the plugin.xml file. In the case of action_basics , only a default localization resource bundle ( /resources/messages/BasicActionsBundle.properties ) is provided: <resource-bundle> messages.BasicActionsBundle </resource-bundle> 2020.1 If necessary, a dedicated resource bundle to use for actions and groups can be defined on <actions> : <actions resource-bundle= \"messages.MyActionsBundle\" > <!-- action/group defined here will use keys from MyActionsBundle.properties --> </actions> Actions For Actions, the key in property files incorporates the action id in this specific structure: * action.<action-id>.text=Translated Action Text * action.<action-id>.description=Translated Action Description 2020.1 If <override-text> is used for an action id , the key includes the <place> attribute: * action.<action-id>.<place>.text=Place-dependent Translated Action Text Groups For Groups, the key in the property files incorporates the group id in this specific structure: * group.<group-id>.text=Translated Group Text * group.<group-id>.description=Translated Group Description 2020.3 If <override-text> is used for an group id , the key includes the <place> attribute: * group.<group-id>.<place>.text=Place-dependent Translated Group Text See Extending DefaultActionGroup for a tutorial of localizing Actions and Groups. Action Declaration Reference The places where actions can appear are defined by constants in ActionPlaces . Group IDs for the Consulo are defined in PlatformActions.xml . This, and additional information can also be found by using the Code Completion , Quick Definition and Quick Documentation features. TIP To lookup existing Action ID (e.g. for use in relative-to-action ), UI Inspector can be used. <!-- Actions --> <actions> <!-- The <action> element defines an action to register. The mandatory \"id\" attribute specifies a unique identifier for the action. The mandatory \"class\" attribute specifies the FQN of the class implementing the action. The mandatory \"text\" attribute specifies the default long-version text to be displayed for the action (tooltip for toolbar button or text for menu item). The optional \"use-shortcut-of\" attribute specifies the ID of the action whose keyboard shortcut this action will use. The optional \"description\" attribute specifies the text which is displayed in the status bar when the action is focused. The optional \"icon\" attribute specifies the icon which is displayed on the toolbar button or next to the menu item. --> <action id= \"VssIntegration.GarbageCollection\" class= \"com.foo.impl.CollectGarbage\" text= \"Garbage Collector: Collect _Garbage\" description= \"Run garbage collector\" icon= \"icons/garbage.png\" > <!-- The <override-text> element defines an alternate version of the text for the menu action. The mandatory \"text\" attribute defines the text to be displayed for the action. The mandatory \"place\" attribute declares where the alternate text should be used. In this example, any time the action is displayed in the IDE Main Menu (and submenus) the override-text version should be used. The second <override-text> element uses the alternate attribute \"use-text-of-place\" to define a location (EditorPopup) to use the same text as is used in MainMenu. It is a way to specify use of alternate menu text in multiple discrete menu groups. --> <override-text place= \"MainMenu\" text= \"Collect _Garbage\" /> <override-text place= \"EditorPopup\" use-text-of-place= \"MainMenu\" /> <!-- Provide alternative names for searching action by name --> <synonym text= \"GC\" /> <!-- The <add-to-group> node specifies that the action should be added to an existing group. An action can be added to several groups. The mandatory \"group-id\" attribute specifies the ID of the group to which the action is added. The group must be implemented by an instance of the DefaultActionGroup class. The mandatory \"anchor\" attribute specifies the position of the action in the relative to other actions. It can have the values \"first\", \"last\", \"before\" and \"after\". The \"relative-to-action\" attribute is mandatory if the anchor is set to \"before\" and \"after\", and specifies the action before or after which the current action is inserted. --> <add-to-group group-id= \"ToolsMenu\" relative-to-action= \"GenerateJavadoc\" anchor= \"after\" /> <!-- The <keyboard-shortcut> node specifies the keyboard shortcut for the action. An action can have several keyboard shortcuts. The mandatory \"first-keystroke\" attribute specifies the first keystroke of the action. The keystrokes are specified according to the regular Swing rules. The optional \"second-keystroke\" attribute specifies the second keystroke of the action. The mandatory \"keymap\" attribute specifies the keymap for which the action is active. IDs of the standard keymaps are defined as constants in the com.intellij.openapi.keymap.KeymapManager class. The optional \"remove\" attribute in the second <keyboard-shortcut> element below means the specified shortcut should be removed from the specified action. The optional \"replace-all\" attribute in the third <keyboard-shortcut> element below means remove all keyboard and mouse shortcuts from the specified action before adding the specified shortcut. --> <!-- Add the first and second keystrokes to all keymaps --> <keyboard-shortcut keymap= \"$default\" first-keystroke= \"control alt G\" second-keystroke= \"C\" /> <!-- Except to the \"Mac OS X\" keymap and its children --> <keyboard-shortcut keymap= \"Mac OS X\" first-keystroke= \"control alt G\" second-keystroke= \"C\" remove= \"true\" /> <!-- The \"Mac OS X 10.5+\" keymap and its children will have only this keyboard shortcut for this action. --> <keyboard-shortcut keymap= \"Mac OS X 10.5+\" first-keystroke= \"control alt G\" second-keystroke= \"C\" replace-all= \"true\" /> <!-- The <mouse-shortcut> node specifies the mouse shortcut for the action. An action can have several mouse shortcuts. The mandatory \"keystroke\" attribute specifies the clicks and modifiers for the action. It is defined as a sequence of words separated by spaces: \"button1\", \"button2\", \"button3\" for the mouse buttons; \"shift\", \"control\", \"meta\", \"alt\", \"altGraph\" for the modifier keys; \"doubleClick\" if the action is activated by a double-click of the button. The mandatory \"keymap\" attribute specifies the keymap for which the action is active. IDs of the standard keymaps are defined as constants in the com.intellij.openapi.keymap.KeymapManager class. The \"remove\" and \"replace-all\" attributes can also be used in a <mouse-shortcut> element. See <keyboard-shortcut> for documentation. --> <mouse-shortcut keymap= \"$default\" keystroke= \"control button3 doubleClick\" /> </action> <!-- This action declares neither a text nor description attribute. If it has a resource bundle declared the text and descriptions will be retrieved based on the action-id incorporated in the key for a translated string --> <action id= \"sdk.action.PopupDialogAction\" class= \"sdk.action.PopupDialogAction\" icon= \"SdkIcons.Sdk_default_icon\" > </action> <!-- The <group> element defines an action group. <action>, <group> and <separator> elements defined within it are automatically included in the group. The mandatory \"id\" attribute specifies a unique identifier for the group. The optional \"class\" attribute specifies the FQN of the class implementing the group. If not specified, com.intellij.openapi.actionSystem.DefaultActionGroup is used. The optional \"text\" attribute specifies the text of the group (text for the menu item showing the submenu). The optional \"description\" attribute specifies the text which is displayed in the status bar when the group has focus. The optional \"icon\" attribute specifies the icon which is displayed on the toolbar button or next to the menu group. The optional \"popup\" attribute specifies how the group is presented in the menu. If a group has popup=\"true\", actions in it are placed in a submenu; for popup=\"false\", actions are displayed as a section of the same menu delimited by separators. The optional \"compact\" attribute specifies whether an action within that group is visible when disabled. Setting compact=\"true\" specifies an action in the group isn't visible unless the action is enabled. --> <group class= \"com.foo.impl.MyActionGroup\" id= \"TestActionGroup\" text= \"Test Group\" description= \"Group with test actions\" icon= \"icons/testgroup.png\" popup= \"true\" compact= \"true\" > <action id= \"VssIntegration.TestAction\" class= \"com.foo.impl.TestAction\" text= \"My Test Action\" description= \"My test action\" /> <!-- The <separator> element defines a separator between actions. It can also have an <add-to-group> child element. --> <separator/> <group id= \"TestActionSubGroup\" /> <!-- The <reference> element allows to add an existing action to the group. The mandatory \"ref\" attribute specifies the ID of the action to add. --> <reference ref= \"EditorCopy\" /> <add-to-group group-id= \"MainMenu\" relative-to-action= \"HelpMenu\" anchor= \"before\" /> </group> </actions> Registering Actions from Code Two steps are required to register an action from code: * First, an instance of the class derived from AnAction must be passed to the registerAction() method of ActionManager , to associate the action with an ID. * Second, the action needs to be added to one or more groups. To get an instance of an action group by ID, it is necessary to call ActionManager.getAction() and cast the returned value to DefaultActionGroup . Building UI from Actions If a plugin needs to include a toolbar or popup menu built from a group of actions in its user interface, that is accomplished through ActionPopupMenu and ActionToolbar . These objects can be created through calls to the ActionManager.createActionPopupMenu() and createActionToolbar() methods. To get a Swing component from such an object, call the respective getComponent() method. If an action toolbar is attached to a specific component (for example, a panel in a tool window), call ActionToolbar.setTargetComponent() and pass the related component's instance as a parameter. Setting the target ensures that the toolbar buttons' state depends on the state of the related component, not on the current focus location within the IDE frame. See Toolbar in Consulo UI Guidelines for an overview.","title":"Overview"},{"location":"basics/action_system/#introduction","text":"The actions system is an extension point that allows plugins to add their items to Consulo-based IDE menus and toolbars. For example, one of the action classes is responsible for the File | Open File... menu item and the Open File toolbar button. Actions in the Consulo require a code implementation and must be registered . The action implementation determines the contexts in which an action is available, and its functionality when selected in the UI. Registration determines where an action appears in the IDE UI. Once implemented and registered, an action receives callbacks from the Consulo in response to user gestures. The Creating Actions tutorial describes the process of adding a custom action to a plugin. The Grouping Actions tutorial demonstrates three types of groups that can contain actions. The rest of this page is an overview of actions as an extension point. bullet list {:toc}","title":"Introduction"},{"location":"basics/action_system/#action-implementation","text":"An action is a class derived from the abstract class AnAction . The Consulo calls methods of an action when a user interacts with a menu item or toolbar button. WARNING Classes based on AnAction do not have class fields of any kind. This is because an instance of AnAction class exists for the entire lifetime of the application. If the AnAction class uses a field to store data that has a shorter lifetime and doesn't clear this data promptly, the data leaks. For example, any AnAction data that exists only within the context of a Project causes the Project to be kept in memory after the user has closed it.","title":"Action Implementation"},{"location":"basics/action_system/#principal-implementation-overrides","text":"Every Consulo action should override AnAction.update() and must override AnAction.actionPerformed() . * An action's method AnAction.update() is called by the Consulo framework to update an action state. The state (enabled, visible) of an action determines whether the action is available in the UI of an IDE. An object of the AnActionEvent type is passed to this method and contains information about the current context for the action. Actions are made available by changing state in the Presentation object associated with the event context. As explained in Overriding the AnAction.update() Method , it is vital update() methods execute quickly and return execution to the Consulo. * An action's method AnAction.actionPerformed() is called by the Consulo if available and selected by the user. This method does the heavy lifting for the action - it contains the code executed when the action gets invoked. The actionPerformed() method also receives AnActionEvent as a parameter, which is used to access projects, files, selection, etc. See Overriding the AnAction.actionPerformed() Method for more information. There are other methods to override in the AnAction class, such as changing the default Presentation object for the action. There is also a use case for overriding action constructors when registering them with dynamic action groups, demonstrated in the Grouping Actions tutorial. However, the update() and actionPerformed() methods are essential to basic operation.","title":"Principal Implementation Overrides"},{"location":"basics/action_system/#overriding-the-anactionupdate-method","text":"The method AnAction.update() is periodically called by the Consulo in response to user gestures. The update() method gives an action to evaluate the current context and enable or disable its functionality. WARNING The AnAction.update() method can be called frequently and on a UI thread. This method needs to execute very quickly ; no real work should be performed in this method. For example, checking selection in a tree or a list is considered valid, but working with the file system is not. TIP If the new state of an action cannot be determined quickly, then evaluation should be performed in the AnAction.actionPerformed() method, and notify the user that the action cannot be executed if the context isn't suitable.","title":"Overriding the AnAction.update Method"},{"location":"basics/action_system/#determining-the-action-context","text":"The AnActionEvent object passed to update() carries information about the current context for the action. Context information is available from the methods of AnActionEvent , providing information such as the Presentation and whether the action is triggered by a Toolbar. Additional context information is available using the method AnActionEvent.getData() . Keys defined in CommonDataKeys are passed to the getData() method to retrieve objects such as Project , Editor , PsiFile , and other information. Accessing this information is relatively light-weight and is suited for AnAction.update() .","title":"Determining the Action Context"},{"location":"basics/action_system/#enabling-and-setting-visibility-for-an-action","text":"Based on information about the action context, the AnAction.update() method can enable, disable, or hide an action. An action's enable/disable state and visibility are set using methods of the Presentation object, which is accessed using AnActionEvent.getPresentation() . The default Presentation object is a set of descriptive information about a menu or toolbar action. Every context for an action - it might appear in multiple menus, toolbars, or Navigation search locations - has a unique presentation. Attributes such as an action's text, description, and icons and visibility and enable/disable state, are stored in the presentation. The attributes in a presentation get initialized from the action registration . However, some can be changed at runtime using the methods of the Presentation object associated with an action. The enabled/disabled state of an action is set using Presentation.setEnabled() . The visibility state of an action is set using Presentation.setVisible() If an action is enabled, the AnAction.actionPerformed() can be called if an action is selected in the IDE by a user. A menu action shows in the UI location specified in the registration. A toolbar action displays its enabled (or selected) icon, depending on the user interaction. When an action is disabled AnAction.actionPerformed() will not be called. Toolbar actions display their respective icons for the disabled state. The visibility of a disabled action in a menu depends on whether the host menu (e.g., \"ToolsMenu\") containing the action has the compact attribute set. See Grouping Actions for more information about the compact attribute and menu actions' visibility. NOTE If an action is added to a toolbar, its update() can be called if there was any user activity or focus transfer. If the action's availability changes in the absence of these events, then call ActivityTracker.getInstance().inc() to notify the action subsystem to update all toolbar actions. An example of enabling a menu action based on whether a project is open is demonstrated in PopupDialogAction.update() method.","title":"Enabling and Setting Visibility for an Action"},{"location":"basics/action_system/#overriding-the-anactionactionperformed-method","text":"When the user selects an enabled action, be it from a menu or toolbar, the action's AnAction.actionPerformed() method is called. This method contains the code executed to perform the action, and it is here that the real work gets done. By using the AnActionEvent methods and CommonDataKeys , objects such as the Project , Editor , PsiFile , and other information is available. For example, the actionPerformed() method can modify, remove, or add PSI elements to a file open in the editor. The code that executes in the AnAction.actionPerformed() method should execute efficiently, but it does not have to meet the same stringent requirements as the update() method. An example of inspecting PSI elements is demonstrated in the SDK code sample action_basics PopupDialogAction.actionPerformed() method.","title":"Overriding the AnAction.actionPerformed Method"},{"location":"basics/action_system/#action-ids","text":"Every action and action group has a unique identifier. Basing the identifier for a custom action on the FQN of the implementation is the best practice, assuming the package incorporates the <id> of the plugin. An action must have a unique identifier for each place. It is used in the IDE UI, even though the FQN of the implementation is the same. Definitions of identifiers for the standard Consulo actions are in IdeActions .","title":"Action IDs"},{"location":"basics/action_system/#grouping-actions","text":"Groups organize actions into logical UI structures, which in turn can contain other groups. A group of actions can form a toolbar or a menu. Subgroups of a group can form submenus of a menu. Actions can be included in multiple groups, and thus appear in different places within the IDE UI. An action must have a unique identifier for each place it appears in the IDE UI. See the Action Declaration Reference section for information about how to specify locations in the IDE UI.","title":"Grouping Actions"},{"location":"basics/action_system/#presentation","text":"A new Presentation gets created for every place where the action appears. Therefore, the same action can have different text or icons when it appears in different places of the user interface. Different presentations for the action are created by copying the Presentation returned by the AnAction.getTemplatePresentation() method.","title":"Presentation"},{"location":"basics/action_system/#compact-attribute","text":"A group's \"compact\" attribute specifies whether an action within that group is visible when disabled. See Registering Actions in plugin.xml for an explanation of how the compact attribute is set for a group. If the compact attribute is true for a menu group, an action in the menu only appears if its state is both enabled and visible. In contrast, if the compact attribute is false , an action in the menu appears if its state is disabled but visible. Some menus like Tools have the compact attribute set, so there isn't a way to show an action on the tools menu if it is not enabled. Host Menu compact Setting Action Enabled Visibility Enabled Menu Item Visible? Menu Item Appears Gray? T F T F N/A T T T T F F F T T T F T T T F All other combinations of compact , visibility, and enablement produce N/A for gray appearance because the menu item isn't visible. See the Grouping Actions tutorial for examples of creating action groups.","title":"Compact Attribute"},{"location":"basics/action_system/#registering-actions","text":"There are two main ways to register an action: either by listing it in the <actions> section of a plugin's plugin.xml file or through code.","title":"Registering Actions"},{"location":"basics/action_system/#registering-actions-in-pluginxml","text":"Registering actions in plugin.xml is demonstrated in the following reference examples, which document all elements and attributes used in the <actions> section and describe each element's meaning.","title":"Registering Actions in plugin.xml"},{"location":"basics/action_system/#setting-the-override-text-element","text":"Beginning in 2020.1, an alternate version of an action's menu text can be declared for use depending on where an action appears. Using the <override-text> element, the menu text for an action can be different depending on context: menu location, toolbar, etc. This is also available for groups in 2020.3 and later. In the action element reference example (below) with id attribute VssIntegration.GarbageCollection , the default is to use the menu text \"Garbage Collector: Collect _Garbage.\" The add-to-group element declares the action is added to the Tools Menu. However, the override-text element declares that text for VssIntegration.GarbageCollection displayed anywhere in the Main Menu system should be the alternate text \"Collect _Garbage.\" The Tools Menu is part of the Main Menu, so the displayed menu text is \"Collect _Garbage.\" A different context, such as searching for the action using Help | Find Action... , displays the default text \"Garbage Collector: Collect _Garbage\" to give the user additional information about the action. A second override-text element uses place and use-text-of-place attributes to declare the same version of the text used in the Main Menu is also used in the Editor Popup Menu. Additional override-text elements could be used to specify other places where the Main Menu text should be used. An example of using <override-text> is demonstrated in the Creating Actions tutorial.","title":"Setting the Override-Text Element"},{"location":"basics/action_system/#setting-the-synonym-element","text":"2020.3 Users can locate actions via their name by invoking Help | Find Action . To allow using alternative names in search, add one or more <synonym> elements inside <action> or <reference> : <action id= \"MyAction\" text= \"My Action Name\" ... > <synonym text= \"Another Search Term\" /> </action> To provide a localized synonym, specify key instead of text attribute.","title":"Setting the Synonym Element"},{"location":"basics/action_system/#disabling-search-for-group","text":"2020.3 To exclude a group from appearing in Help | Find Action results (e.g., New... popup), specify searchable=\"false\" .","title":"Disabling Search for Group"},{"location":"basics/action_system/#localizing-actions-and-groups","text":"Action and group localization use resource bundles containing property files named *Bundle.properties , each file consisting of key=value pairs. The action_basics plugin demonstrates using a resource bundle to localize the group and action entries added to the Editor Popup Menu. When localizing actions and groups, the text and description attributes are not declared in plugin.xml . Instead, those attribute values vary depending on the locale and get declared in a resource bundle. The name and location of the resource bundle must be declared in the plugin.xml file. In the case of action_basics , only a default localization resource bundle ( /resources/messages/BasicActionsBundle.properties ) is provided: <resource-bundle> messages.BasicActionsBundle </resource-bundle> 2020.1 If necessary, a dedicated resource bundle to use for actions and groups can be defined on <actions> : <actions resource-bundle= \"messages.MyActionsBundle\" > <!-- action/group defined here will use keys from MyActionsBundle.properties --> </actions>","title":"Localizing Actions and Groups"},{"location":"basics/action_system/#actions","text":"For Actions, the key in property files incorporates the action id in this specific structure: * action.<action-id>.text=Translated Action Text * action.<action-id>.description=Translated Action Description 2020.1 If <override-text> is used for an action id , the key includes the <place> attribute: * action.<action-id>.<place>.text=Place-dependent Translated Action Text","title":"Actions"},{"location":"basics/action_system/#groups","text":"For Groups, the key in the property files incorporates the group id in this specific structure: * group.<group-id>.text=Translated Group Text * group.<group-id>.description=Translated Group Description 2020.3 If <override-text> is used for an group id , the key includes the <place> attribute: * group.<group-id>.<place>.text=Place-dependent Translated Group Text See Extending DefaultActionGroup for a tutorial of localizing Actions and Groups.","title":"Groups"},{"location":"basics/action_system/#action-declaration-reference","text":"The places where actions can appear are defined by constants in ActionPlaces . Group IDs for the Consulo are defined in PlatformActions.xml . This, and additional information can also be found by using the Code Completion , Quick Definition and Quick Documentation features. TIP To lookup existing Action ID (e.g. for use in relative-to-action ), UI Inspector can be used. <!-- Actions --> <actions> <!-- The <action> element defines an action to register. The mandatory \"id\" attribute specifies a unique identifier for the action. The mandatory \"class\" attribute specifies the FQN of the class implementing the action. The mandatory \"text\" attribute specifies the default long-version text to be displayed for the action (tooltip for toolbar button or text for menu item). The optional \"use-shortcut-of\" attribute specifies the ID of the action whose keyboard shortcut this action will use. The optional \"description\" attribute specifies the text which is displayed in the status bar when the action is focused. The optional \"icon\" attribute specifies the icon which is displayed on the toolbar button or next to the menu item. --> <action id= \"VssIntegration.GarbageCollection\" class= \"com.foo.impl.CollectGarbage\" text= \"Garbage Collector: Collect _Garbage\" description= \"Run garbage collector\" icon= \"icons/garbage.png\" > <!-- The <override-text> element defines an alternate version of the text for the menu action. The mandatory \"text\" attribute defines the text to be displayed for the action. The mandatory \"place\" attribute declares where the alternate text should be used. In this example, any time the action is displayed in the IDE Main Menu (and submenus) the override-text version should be used. The second <override-text> element uses the alternate attribute \"use-text-of-place\" to define a location (EditorPopup) to use the same text as is used in MainMenu. It is a way to specify use of alternate menu text in multiple discrete menu groups. --> <override-text place= \"MainMenu\" text= \"Collect _Garbage\" /> <override-text place= \"EditorPopup\" use-text-of-place= \"MainMenu\" /> <!-- Provide alternative names for searching action by name --> <synonym text= \"GC\" /> <!-- The <add-to-group> node specifies that the action should be added to an existing group. An action can be added to several groups. The mandatory \"group-id\" attribute specifies the ID of the group to which the action is added. The group must be implemented by an instance of the DefaultActionGroup class. The mandatory \"anchor\" attribute specifies the position of the action in the relative to other actions. It can have the values \"first\", \"last\", \"before\" and \"after\". The \"relative-to-action\" attribute is mandatory if the anchor is set to \"before\" and \"after\", and specifies the action before or after which the current action is inserted. --> <add-to-group group-id= \"ToolsMenu\" relative-to-action= \"GenerateJavadoc\" anchor= \"after\" /> <!-- The <keyboard-shortcut> node specifies the keyboard shortcut for the action. An action can have several keyboard shortcuts. The mandatory \"first-keystroke\" attribute specifies the first keystroke of the action. The keystrokes are specified according to the regular Swing rules. The optional \"second-keystroke\" attribute specifies the second keystroke of the action. The mandatory \"keymap\" attribute specifies the keymap for which the action is active. IDs of the standard keymaps are defined as constants in the com.intellij.openapi.keymap.KeymapManager class. The optional \"remove\" attribute in the second <keyboard-shortcut> element below means the specified shortcut should be removed from the specified action. The optional \"replace-all\" attribute in the third <keyboard-shortcut> element below means remove all keyboard and mouse shortcuts from the specified action before adding the specified shortcut. --> <!-- Add the first and second keystrokes to all keymaps --> <keyboard-shortcut keymap= \"$default\" first-keystroke= \"control alt G\" second-keystroke= \"C\" /> <!-- Except to the \"Mac OS X\" keymap and its children --> <keyboard-shortcut keymap= \"Mac OS X\" first-keystroke= \"control alt G\" second-keystroke= \"C\" remove= \"true\" /> <!-- The \"Mac OS X 10.5+\" keymap and its children will have only this keyboard shortcut for this action. --> <keyboard-shortcut keymap= \"Mac OS X 10.5+\" first-keystroke= \"control alt G\" second-keystroke= \"C\" replace-all= \"true\" /> <!-- The <mouse-shortcut> node specifies the mouse shortcut for the action. An action can have several mouse shortcuts. The mandatory \"keystroke\" attribute specifies the clicks and modifiers for the action. It is defined as a sequence of words separated by spaces: \"button1\", \"button2\", \"button3\" for the mouse buttons; \"shift\", \"control\", \"meta\", \"alt\", \"altGraph\" for the modifier keys; \"doubleClick\" if the action is activated by a double-click of the button. The mandatory \"keymap\" attribute specifies the keymap for which the action is active. IDs of the standard keymaps are defined as constants in the com.intellij.openapi.keymap.KeymapManager class. The \"remove\" and \"replace-all\" attributes can also be used in a <mouse-shortcut> element. See <keyboard-shortcut> for documentation. --> <mouse-shortcut keymap= \"$default\" keystroke= \"control button3 doubleClick\" /> </action> <!-- This action declares neither a text nor description attribute. If it has a resource bundle declared the text and descriptions will be retrieved based on the action-id incorporated in the key for a translated string --> <action id= \"sdk.action.PopupDialogAction\" class= \"sdk.action.PopupDialogAction\" icon= \"SdkIcons.Sdk_default_icon\" > </action> <!-- The <group> element defines an action group. <action>, <group> and <separator> elements defined within it are automatically included in the group. The mandatory \"id\" attribute specifies a unique identifier for the group. The optional \"class\" attribute specifies the FQN of the class implementing the group. If not specified, com.intellij.openapi.actionSystem.DefaultActionGroup is used. The optional \"text\" attribute specifies the text of the group (text for the menu item showing the submenu). The optional \"description\" attribute specifies the text which is displayed in the status bar when the group has focus. The optional \"icon\" attribute specifies the icon which is displayed on the toolbar button or next to the menu group. The optional \"popup\" attribute specifies how the group is presented in the menu. If a group has popup=\"true\", actions in it are placed in a submenu; for popup=\"false\", actions are displayed as a section of the same menu delimited by separators. The optional \"compact\" attribute specifies whether an action within that group is visible when disabled. Setting compact=\"true\" specifies an action in the group isn't visible unless the action is enabled. --> <group class= \"com.foo.impl.MyActionGroup\" id= \"TestActionGroup\" text= \"Test Group\" description= \"Group with test actions\" icon= \"icons/testgroup.png\" popup= \"true\" compact= \"true\" > <action id= \"VssIntegration.TestAction\" class= \"com.foo.impl.TestAction\" text= \"My Test Action\" description= \"My test action\" /> <!-- The <separator> element defines a separator between actions. It can also have an <add-to-group> child element. --> <separator/> <group id= \"TestActionSubGroup\" /> <!-- The <reference> element allows to add an existing action to the group. The mandatory \"ref\" attribute specifies the ID of the action to add. --> <reference ref= \"EditorCopy\" /> <add-to-group group-id= \"MainMenu\" relative-to-action= \"HelpMenu\" anchor= \"before\" /> </group> </actions>","title":"Action Declaration Reference"},{"location":"basics/action_system/#registering-actions-from-code","text":"Two steps are required to register an action from code: * First, an instance of the class derived from AnAction must be passed to the registerAction() method of ActionManager , to associate the action with an ID. * Second, the action needs to be added to one or more groups. To get an instance of an action group by ID, it is necessary to call ActionManager.getAction() and cast the returned value to DefaultActionGroup .","title":"Registering Actions from Code"},{"location":"basics/action_system/#building-ui-from-actions","text":"If a plugin needs to include a toolbar or popup menu built from a group of actions in its user interface, that is accomplished through ActionPopupMenu and ActionToolbar . These objects can be created through calls to the ActionManager.createActionPopupMenu() and createActionToolbar() methods. To get a Swing component from such an object, call the respective getComponent() method. If an action toolbar is attached to a specific component (for example, a panel in a tool window), call ActionToolbar.setTargetComponent() and pass the related component's instance as a parameter. Setting the target ensures that the toolbar buttons' state depends on the state of the related component, not on the current focus location within the IDE frame. See Toolbar in Consulo UI Guidelines for an overview.","title":"Building UI from Actions"},{"location":"basics/basics/","text":"This section covers the basics of working with the Consulo . It will familiarize you with the working environment, project structure, and frequently used API components. Main Types of Consulo Plugins Creating Your First Plugin Plugin Structure IDE Development Instances","title":"Overview"},{"location":"basics/disposers/","text":"The Consulo's Disposer facilitates resource cleanup. If a subsystem keeps a set of resources alive coincident with a parent object's lifetime, the subsystem's resources should be registered with the Disposer to be released before or at the same time as the parent object. The most common resource type managed by Disposer is listeners, but there are other possible types: * File handles, and database connections, * Caches and other significant data structures. The Disposer is a singleton that manages a tree of Disposable instances. A Disposable is an interface for any object providing a Disposable.dispose() method to release heavyweight resources after a specific lifetime. The Disposer supports chaining Disposables in parent-child relationships. bullet list {:toc} Automatically Disposed Objects Many objects are disposed automatically by the platform if they implement the Disposable interface. The most important type of such objects is services . Application-level services are automatically disposed by the platform when the IDE is closed or the plugin providing the service is unloaded. Project-level services are disposed when the project is closed, or the plugin is unloaded. Note that extensions registered in plugin.xml are not automatically disposed. If an extension requires executing some code to dispose it, you need to define a service and to put the code in its dispose() method or use it as a parent disposable. The Disposer Singleton The primary purpose of the Disposer singleton is to enforce the rule that a child Disposable never outlives its parent . The Disposer organizes Disposable objects in a tree of parent-child relationships. The tree of Disposable objects ensures the Disposer releases children of a parent first. See The Disposable Interface for more information about creating Disposable classes. Registering a disposable is performed by calling Disposer.register() : Disposer . register ( parentDisposable , childDisposable ); Choosing a Disposable Parent To register a child Disposable , a parent Disposable of a suitable lifetime is used to establish the parent-child relationship. One of the parent Disposables provided by the Consulo can be chosen, or it can be another Disposable . Use the following guidelines to choose the correct parent: For resources required for a plugin's entire lifetime, use an application or project level service . For resources required while a dialog is displayed, use DialogWrapper.getDisposable() . For resources required while a tool window tab is displayed, pass your instance implementing Disposable to Content.setDisposer() . For resources with a shorter lifetime, create a disposable using Disposer.newDisposable() and dispose it manually using Disposable.dispose() . Note that it's always best to specify a parent for such a disposable (e.g., a project-level service), so that there is no memory leak if the Disposable.dispose() call is not reached because of an exception or a programming error. WARNING Even though Application and Project implement Disposable , they must NEVER be used as parent disposables in plugin code. Disposables registered using those objects as parents will not be disposed when the plugin is unloaded, leading to memory leaks. The Disposer API's flexibility means that if the parent instance is chosen unwisely, the child may consume resources for longer than required. Continuing to use resources when they are no longer needed can be a severe source of contention due to leaving some zombie objects behind due to each invocation. An additional challenge is that these kinds of issues won't be reported by the regular leak checker utilities, because technically, it's not a memory leak from the test suite perspective. For example, suppose a UI component created for a specific operation uses a project-level service as a parent disposable. In that case, the entire component will remain in memory after the operation is complete. This creates memory pressure and can waste CPU cycles on processing events that are no longer relevant. Registering Listeners with Parent Disposable Many Consulo APIs for registering listeners either require passing a parent disposable or have overloads that take a parent disposable. For example: public abstract class EditorFactory { // ... public abstract void addEditorFactoryListener ( @NotNull EditorFactoryListener listener ); public abstract void addEditorFactoryListener ( @NotNull EditorFactoryListener listener , @NotNull Disposable parentDisposable ); public abstract void removeEditorFactoryListener ( @NotNull EditorFactoryListener listener ); } Methods with a parentDisposable parameter automatically unsubscribe the listener when the corresponding parent disposable is disposed. Using such methods is always preferable to removing listeners explicitly from the dispose method because it requires less code and is easier to verify for correctness. To choose the correct parent disposable, use the guidelines from the previous section. The same rules apply to message bus connections. Always pass a parent disposable to MessageBus.connect() , and make sure it has the shortest possible lifetime. Determining Disposal Status You can use Disposer.isDisposed() to check whether a Disposable has already been disposed. This check is useful, for example, for an asynchronous callback to a Disposable that may be disposed before the callback is executed. In such a case, the best strategy is usually to do nothing and return early. WARNING Non-disposed objects shouldn't hold onto references to disposed objects, as this constitutes a memory leak. Once a Disposable is released, it should be completely inactive, and there's no reason to refer to it anymore. Ending a Disposable Lifecycle A plugin can manually end a Disposable lifecycle by calling Disposer.dispose(Disposable) . This method handles recursively disposing of all the Disposable child descendants as well. Implementing the Disposable Interface Creating a class requires implementing the Disposable interface and defining the dispose() method. In many cases, when the object implements Disposable only to be used as a parent disposable, the method's implementation will be completely empty. An example of a non-trivial dispose implementation is shown below: public class Foo < T > extends JBFoo implements Disposable { public Foo ( @NotNull Project project , @NotNull String name , @Nullable FileEditor fileEditor , @NotNull Disposable parentDisposable ) { this ( project , name , fileEditor , InitParams . createParams ( project ), DetachedToolWindowManager . getInstance ( project )); Disposer . register ( parentDisposable , this ); } @Override public void dispose () { myFooManager . unregister ( this ); myDetachedToolWindowManager . unregister ( myFileEditor ); KeyboardFocusManager . getCurrentKeyboardFocusManager (). removePropertyChangeListener ( \"focusOwner\" , myMyPropertyChangeListener ); setToolContext ( null ); } } A lot of code setting-up all the conditions requiring release in dispose() has been omitted for simplicity. Regardless, it illustrates the basic pattern, which is: * In this case, the parent disposable is passed into the constructor, * The Foo disposable is registered as a child of parentDisposable in the constructor. * The dispose() method consolidates the necessary release actions and will be called by the Disposer . WARNING Never call Disposable.dispose() directly because it bypasses the parent-child relationships established in Disposer . Always call Disposer.dispose(Disposable) instead. Diagnosing Disposer Leaks When the application exits, it performs a final sanity check to verify everything was disposed. If something was registered with the Disposer but remains undisposed, the Consulo reports it before shutting down. In test and Debug mode ( idea.disposer.debug is set to on ), registering a Disposable with the Disposer also registers a stack trace for the object's allocation path. The Disposer accomplishes this by creating a dummy Throwable at the time of registration. The following snippet represents the sort of \"memory leak detected\" error encountered in practice: java.lang.RuntimeException: Memory leak detected: <Instance> of class <com.example.classtype> See the cause for the corresponding Disposer.register() stacktrace: at ObjectTree.assertIsEmpty(ObjectTree.java:209) at Disposer.assertIsEmpty(Disposer.java:125) at Disposer.assertIsEmpty(Disposer.java:121) at ApplicationImpl.disposeSelf(ApplicationImpl.java:323) at ApplicationImpl.doExit(ApplicationImpl.java:780) \u2026 Caused by: java.lang.Throwable at ObjectTree.getOrCreateNodeFor(ObjectTree.java:101) at ObjectTree.register(ObjectTree.java:62) at Disposer.register(Disposer.java:81) at Disposer.register(Disposer.java:75) \u2026 at ProjectManagerEx.createProject(ProjectManagerEx.java:69) at NewProjectWizardDynamic.doFinish(NewProjectWizardDynamic.java:235) at DynamicWizard$1.run(DynamicWizard.java:433) at CoreProgressManager$5.run(CoreProgressManager.java:237) at CoreProgressManager$TaskRunnable.run(CoreProgressManager.java:563) \u2026 TIP The first part of the callstack is unrelated to diagnosing the memory leak. Instead, pay attention to the second part of the call stack, after Caused by: java.lang.Throwable . In this specific case, the Consulo ( CoreProgressManager ) started a task that contained the DynamicWizard code. In turn, that code allocated a Project that was never disposed by the time the application exited. That is a promising place to start digging. The above memory leak was ultimately caused by failing to pass a Project instance to a function responsible for registering it for disposal. Often the fix for a memory leak is as simple as understanding the memory scope of the object being allocated - usually a UI container, project, or application - and making sure a Disposer.register() call is made appropriately for it.","title":"Disposer and Disposable"},{"location":"basics/disposers/#automatically-disposed-objects","text":"Many objects are disposed automatically by the platform if they implement the Disposable interface. The most important type of such objects is services . Application-level services are automatically disposed by the platform when the IDE is closed or the plugin providing the service is unloaded. Project-level services are disposed when the project is closed, or the plugin is unloaded. Note that extensions registered in plugin.xml are not automatically disposed. If an extension requires executing some code to dispose it, you need to define a service and to put the code in its dispose() method or use it as a parent disposable.","title":"Automatically Disposed Objects"},{"location":"basics/disposers/#the-disposer-singleton","text":"The primary purpose of the Disposer singleton is to enforce the rule that a child Disposable never outlives its parent . The Disposer organizes Disposable objects in a tree of parent-child relationships. The tree of Disposable objects ensures the Disposer releases children of a parent first. See The Disposable Interface for more information about creating Disposable classes. Registering a disposable is performed by calling Disposer.register() : Disposer . register ( parentDisposable , childDisposable );","title":"The Disposer Singleton"},{"location":"basics/disposers/#choosing-a-disposable-parent","text":"To register a child Disposable , a parent Disposable of a suitable lifetime is used to establish the parent-child relationship. One of the parent Disposables provided by the Consulo can be chosen, or it can be another Disposable . Use the following guidelines to choose the correct parent: For resources required for a plugin's entire lifetime, use an application or project level service . For resources required while a dialog is displayed, use DialogWrapper.getDisposable() . For resources required while a tool window tab is displayed, pass your instance implementing Disposable to Content.setDisposer() . For resources with a shorter lifetime, create a disposable using Disposer.newDisposable() and dispose it manually using Disposable.dispose() . Note that it's always best to specify a parent for such a disposable (e.g., a project-level service), so that there is no memory leak if the Disposable.dispose() call is not reached because of an exception or a programming error. WARNING Even though Application and Project implement Disposable , they must NEVER be used as parent disposables in plugin code. Disposables registered using those objects as parents will not be disposed when the plugin is unloaded, leading to memory leaks. The Disposer API's flexibility means that if the parent instance is chosen unwisely, the child may consume resources for longer than required. Continuing to use resources when they are no longer needed can be a severe source of contention due to leaving some zombie objects behind due to each invocation. An additional challenge is that these kinds of issues won't be reported by the regular leak checker utilities, because technically, it's not a memory leak from the test suite perspective. For example, suppose a UI component created for a specific operation uses a project-level service as a parent disposable. In that case, the entire component will remain in memory after the operation is complete. This creates memory pressure and can waste CPU cycles on processing events that are no longer relevant.","title":"Choosing a Disposable Parent"},{"location":"basics/disposers/#registering-listeners-with-parent-disposable","text":"Many Consulo APIs for registering listeners either require passing a parent disposable or have overloads that take a parent disposable. For example: public abstract class EditorFactory { // ... public abstract void addEditorFactoryListener ( @NotNull EditorFactoryListener listener ); public abstract void addEditorFactoryListener ( @NotNull EditorFactoryListener listener , @NotNull Disposable parentDisposable ); public abstract void removeEditorFactoryListener ( @NotNull EditorFactoryListener listener ); } Methods with a parentDisposable parameter automatically unsubscribe the listener when the corresponding parent disposable is disposed. Using such methods is always preferable to removing listeners explicitly from the dispose method because it requires less code and is easier to verify for correctness. To choose the correct parent disposable, use the guidelines from the previous section. The same rules apply to message bus connections. Always pass a parent disposable to MessageBus.connect() , and make sure it has the shortest possible lifetime.","title":"Registering Listeners with Parent Disposable"},{"location":"basics/disposers/#determining-disposal-status","text":"You can use Disposer.isDisposed() to check whether a Disposable has already been disposed. This check is useful, for example, for an asynchronous callback to a Disposable that may be disposed before the callback is executed. In such a case, the best strategy is usually to do nothing and return early. WARNING Non-disposed objects shouldn't hold onto references to disposed objects, as this constitutes a memory leak. Once a Disposable is released, it should be completely inactive, and there's no reason to refer to it anymore.","title":"Determining Disposal Status"},{"location":"basics/disposers/#ending-a-disposable-lifecycle","text":"A plugin can manually end a Disposable lifecycle by calling Disposer.dispose(Disposable) . This method handles recursively disposing of all the Disposable child descendants as well.","title":"Ending a Disposable Lifecycle"},{"location":"basics/disposers/#implementing-the-disposable-interface","text":"Creating a class requires implementing the Disposable interface and defining the dispose() method. In many cases, when the object implements Disposable only to be used as a parent disposable, the method's implementation will be completely empty. An example of a non-trivial dispose implementation is shown below: public class Foo < T > extends JBFoo implements Disposable { public Foo ( @NotNull Project project , @NotNull String name , @Nullable FileEditor fileEditor , @NotNull Disposable parentDisposable ) { this ( project , name , fileEditor , InitParams . createParams ( project ), DetachedToolWindowManager . getInstance ( project )); Disposer . register ( parentDisposable , this ); } @Override public void dispose () { myFooManager . unregister ( this ); myDetachedToolWindowManager . unregister ( myFileEditor ); KeyboardFocusManager . getCurrentKeyboardFocusManager (). removePropertyChangeListener ( \"focusOwner\" , myMyPropertyChangeListener ); setToolContext ( null ); } } A lot of code setting-up all the conditions requiring release in dispose() has been omitted for simplicity. Regardless, it illustrates the basic pattern, which is: * In this case, the parent disposable is passed into the constructor, * The Foo disposable is registered as a child of parentDisposable in the constructor. * The dispose() method consolidates the necessary release actions and will be called by the Disposer . WARNING Never call Disposable.dispose() directly because it bypasses the parent-child relationships established in Disposer . Always call Disposer.dispose(Disposable) instead.","title":"Implementing the Disposable Interface"},{"location":"basics/disposers/#diagnosing-disposer-leaks","text":"When the application exits, it performs a final sanity check to verify everything was disposed. If something was registered with the Disposer but remains undisposed, the Consulo reports it before shutting down. In test and Debug mode ( idea.disposer.debug is set to on ), registering a Disposable with the Disposer also registers a stack trace for the object's allocation path. The Disposer accomplishes this by creating a dummy Throwable at the time of registration. The following snippet represents the sort of \"memory leak detected\" error encountered in practice: java.lang.RuntimeException: Memory leak detected: <Instance> of class <com.example.classtype> See the cause for the corresponding Disposer.register() stacktrace: at ObjectTree.assertIsEmpty(ObjectTree.java:209) at Disposer.assertIsEmpty(Disposer.java:125) at Disposer.assertIsEmpty(Disposer.java:121) at ApplicationImpl.disposeSelf(ApplicationImpl.java:323) at ApplicationImpl.doExit(ApplicationImpl.java:780) \u2026 Caused by: java.lang.Throwable at ObjectTree.getOrCreateNodeFor(ObjectTree.java:101) at ObjectTree.register(ObjectTree.java:62) at Disposer.register(Disposer.java:81) at Disposer.register(Disposer.java:75) \u2026 at ProjectManagerEx.createProject(ProjectManagerEx.java:69) at NewProjectWizardDynamic.doFinish(NewProjectWizardDynamic.java:235) at DynamicWizard$1.run(DynamicWizard.java:433) at CoreProgressManager$5.run(CoreProgressManager.java:237) at CoreProgressManager$TaskRunnable.run(CoreProgressManager.java:563) \u2026 TIP The first part of the callstack is unrelated to diagnosing the memory leak. Instead, pay attention to the second part of the call stack, after Caused by: java.lang.Throwable . In this specific case, the Consulo ( CoreProgressManager ) started a task that contained the DynamicWizard code. In turn, that code allocated a Project that was never disposed by the time the application exited. That is a promising place to start digging. The above memory leak was ultimately caused by failing to pass a Project instance to a function responsible for registering it for disposal. Often the fix for a memory leak is as simple as understanding the memory scope of the object being allocated - usually a UI container, project, or application - and making sure a Disposer.register() call is made appropriately for it.","title":"Diagnosing Disposer Leaks"},{"location":"basics/editing/","text":"Code Completion Templates QuickDoc Intentions","title":"Overview"},{"location":"basics/getting_started/","text":"This documentation section will help you get started with developing plugins for the Consulo . You can use either IntelliJ IDEA Community Edition or IntelliJ IDEA Ultimate as your IDE (it is highly recommended to use the latest available version). Both include the complete set of plugin development tools. To become more familiar with IntelliJ IDEA , please refer to the IntelliJ IDEA Web Help . There are three supported workflows available for building plugins. The recommended workflow for new projects is to use GitHub Template or to use Gradle to create everything from scratch. The old Plugin DevKit workflow still supports existing projects. NOTE If a new plugin will be Scala-based, a dedicated SBT plugin sbt-idea-plugin is available. The Gradle workflow offers several advantages: * Representations of source sets, modules, and projects are portable, * Projects of any size or complexity usually require scripts for build management, which Gradle handles natively, * Training, documentation, and community help for general Gradle topics are widely available. Specific to development of Consulo plugins with the Gradle plugin for IntelliJ IDEA: * Changing plugin targets is more comfortable because it is all done in build.gradle : * Switching the version of the target Consulo (IDE), * Changing the target Consulo-based IDE, e.g., from IntelliJ IDEA to PyCharm, * Running a plugin against alternate versions of the JetBrains runtime. * Gradle is fully integrated with Continuous Integration systems and JetBrains Plugin Repository , so it is easy to customize and extend the build and publishing processes. * Built-in verification task for plugin.xml and plugin distribution structure. * Built-in integration with IntelliJ Plugin Verifier tool used for running the compatibility checks as performed on JetBrains Plugin Repository . Using GitHub Template Developing plugins using GitHub Template Using Gradle Developing plugins using Gradle Getting Started with Gradle Configuring Gradle Projects Publishing Plugins with Gradle Using DevKit Developing plugins using DevKit Setting Up a Development Environment Creating a Plugin Project Creating Actions Running and Debugging a Plugin Deploying a Plugin Publishing a Plugin","title":"Creating Your First Plugin"},{"location":"basics/getting_started/#using-github-template","text":"Developing plugins using GitHub Template","title":"Using GitHub Template"},{"location":"basics/getting_started/#using-gradle","text":"Developing plugins using Gradle Getting Started with Gradle Configuring Gradle Projects Publishing Plugins with Gradle","title":"Using Gradle"},{"location":"basics/getting_started/#using-devkit","text":"Developing plugins using DevKit Setting Up a Development Environment Creating a Plugin Project Creating Actions Running and Debugging a Plugin Deploying a Plugin Publishing a Plugin","title":"Using DevKit"},{"location":"basics/ide_development_instance/","text":"A JetBrains feature for developing plugins is running or debugging a plugin project from within an Consulo-based IDE such as IntelliJ IDEA. Selecting the runIde task for a Gradle-based project (or Run menu for a DevKit-based project) will launch a Development Instance of the IDE with the plugin enabled. This page describes how to control some of the settings for the Development Instance. TIP Please see also Advanced Configuration for general VM options and properties. Using a JetBrains Runtime for the Development Instance An everyday use case is to develop (build) a plugin project against a JDK, e.g., Java 8, and then run or debug the plugin in a Development Instance of the IDE. In such a situation, Development Instance must use a JetBrains Runtime (JBR) rather than the JDK used to build the plugin project. The JetBrains Runtime is an environment for running Consulo-based IDEs on Windows, macOS, and Linux. It has some modifications by JetBrains, such as fixes for native crashes not present in official JDK builds. A version of the JetBrains Runtime is bundled with all Consulo-based IDEs. To produce accurate results while running or debugging a plugin project in a Development Instance, follow the procedures below to ensure the Development Instance uses a JetBrains Runtime. Determining a JetBrains Runtime Version The JetBrains Runtime is determined from the JDK version used to build the plugin project, regardless of whether it is built on macOS, Windows, or Linux. For example, if a plugin is developed against the Java 8 SE Development Kit 8 for macOS ( jdk-8u212-macosx-x64.dmg ) to acquire the compatible JetBrains Runtime: Go to the JetBrains Runtime Site for general information and the latest build. Open the Release notes page to access all releases. Select the package name corresponding to the platform and SDK version. In this case, the package name is jbrsdk8-osx-x64 for J et B rains R untime SDK version 8, macOS x64 hardware. On the macOS package page of the JetBrains Bintray site, select the Files menu. In the list of files, find the name that satisfies: The version and build number match the JDK used to build the plugin project. For example, jbrx-8u252-osx-x64 matches the Java 8 JDK, build 252: jdk-8u252-macosx-x64 . Pick the highest JetBrains Runtime build number available. For example, the file is jbrx-8u252-osx-x64-b1649.2.tar.gz , meaning build 1649.2 for this JetBrains Runtime matching Java 8 JDK build 252. Setting a JetBrains Runtime for Gradle-Based Plugin Projects By default, the Gradle plugin will fetch and use the version of the JetBrains Runtime for the Development Instance corresponding to the version of the Consulo used for building the plugin project. If required, an alternative version can be specified using jbrVersion attribute of runIde task . Setting a JetBrains Runtime for DevKit-Based Plugin Projects The Run Configuration for a DevKit-based plugin project controls the JDK used to run and debug a plugin project in a Development Instance. The default Run Configuration uses the same JDK for building the plugin project and running the plugin in a Development Instance. To change the runtime for the Development Instance, set the JRE field in the Run Configuration edit dialog to download a JetBrains Runtime. Gradle plugin 0.4.22 and Later Enabled by default for target platform 2020.2 or later. Set autoReloadPlugins = true in runIde task to enable it for earlier platform versions or autoReloadPlugins = false to disable it explicitly. Gradle plugin 0.4.21 and Earlier/DevKit Add system property idea.auto.reload.plugins in the run configuration (DevKit-based) or runIde task (Gradle-based). For Gradle-based plugins using gradle-intellij-plugin 0.4.17 or later, this property is set automatically. To disable auto-reload, set idea.auto.reload.plugins to false explicitly (2020.1.2+). The Development Instance Sandbox Directory The Sandbox Home directory contains the settings, caches, logs, and plugins for a Development Instance of the IDE. This information is stored in a different location than for the installed IDE itself . Sandbox Home Location for Gradle-Based Plugin Projects For Gradle-based plugins, the default Sandbox Home location is defined by the Consulo gradle-intellij-plugin . See Configuring a Gradle Plugin Project for more information about specifying a Sandbox Home location. The default Sandbox Home location for Gradle-based plugin projects is: * Windows <Project Dir>\\build\\idea-sandbox * Linux or macOS <Project Dir>/build/idea-sandbox Sandbox Home Location for DevKit-Based Plugin Projects For DevKit-based plugins, the default Sandbox Home location is defined in the Consulo Plugin SDK. See specifying the Sandbox Home for DevKit Projects for more information. The default Sandbox Home directory location for DevKit-based plugin projects is: * Windows: <User home>\\.<product_system_name><product_version>\\system\\plugins-sandbox\\ * Linux: ~/.<product_system_name><product_version>/system/plugins-sandbox/ * macOS ~/Library/Caches/<product_system_name><product_version>/plugins-sandbox/ Development Instance Settings, Caches, Logs, and Plugins Within the Sandbox Home directory are subdirectories of the Development Instance: * config contains settings for the IDE instance. * plugins contains folders for each plugin being run in the IDE instance. * system/caches or system\\caches holds the IDE instance data. * system/log or system\\log contains the idea.log file for the IDE instance. Each of these Sandbox Home subdirectories can be manually cleared to reset the IDE Development Instance. At the next launch of a Development Instance, the subdirectories will be repopulated with the appropriate information.","title":"IDE Development Instances"},{"location":"basics/ide_development_instance/#using-a-jetbrains-runtime-for-the-development-instance","text":"An everyday use case is to develop (build) a plugin project against a JDK, e.g., Java 8, and then run or debug the plugin in a Development Instance of the IDE. In such a situation, Development Instance must use a JetBrains Runtime (JBR) rather than the JDK used to build the plugin project. The JetBrains Runtime is an environment for running Consulo-based IDEs on Windows, macOS, and Linux. It has some modifications by JetBrains, such as fixes for native crashes not present in official JDK builds. A version of the JetBrains Runtime is bundled with all Consulo-based IDEs. To produce accurate results while running or debugging a plugin project in a Development Instance, follow the procedures below to ensure the Development Instance uses a JetBrains Runtime.","title":"Using a JetBrains Runtime for the Development Instance"},{"location":"basics/ide_development_instance/#determining-a-jetbrains-runtime-version","text":"The JetBrains Runtime is determined from the JDK version used to build the plugin project, regardless of whether it is built on macOS, Windows, or Linux. For example, if a plugin is developed against the Java 8 SE Development Kit 8 for macOS ( jdk-8u212-macosx-x64.dmg ) to acquire the compatible JetBrains Runtime: Go to the JetBrains Runtime Site for general information and the latest build. Open the Release notes page to access all releases. Select the package name corresponding to the platform and SDK version. In this case, the package name is jbrsdk8-osx-x64 for J et B rains R untime SDK version 8, macOS x64 hardware. On the macOS package page of the JetBrains Bintray site, select the Files menu. In the list of files, find the name that satisfies: The version and build number match the JDK used to build the plugin project. For example, jbrx-8u252-osx-x64 matches the Java 8 JDK, build 252: jdk-8u252-macosx-x64 . Pick the highest JetBrains Runtime build number available. For example, the file is jbrx-8u252-osx-x64-b1649.2.tar.gz , meaning build 1649.2 for this JetBrains Runtime matching Java 8 JDK build 252.","title":"Determining a JetBrains Runtime Version"},{"location":"basics/ide_development_instance/#setting-a-jetbrains-runtime-for-gradle-based-plugin-projects","text":"By default, the Gradle plugin will fetch and use the version of the JetBrains Runtime for the Development Instance corresponding to the version of the Consulo used for building the plugin project. If required, an alternative version can be specified using jbrVersion attribute of runIde task .","title":"Setting a JetBrains Runtime for Gradle-Based Plugin Projects"},{"location":"basics/ide_development_instance/#setting-a-jetbrains-runtime-for-devkit-based-plugin-projects","text":"The Run Configuration for a DevKit-based plugin project controls the JDK used to run and debug a plugin project in a Development Instance. The default Run Configuration uses the same JDK for building the plugin project and running the plugin in a Development Instance. To change the runtime for the Development Instance, set the JRE field in the Run Configuration edit dialog to download a JetBrains Runtime.","title":"Setting a JetBrains Runtime for DevKit-Based Plugin Projects"},{"location":"basics/ide_development_instance/#gradle-plugin-0422-and-later","text":"Enabled by default for target platform 2020.2 or later. Set autoReloadPlugins = true in runIde task to enable it for earlier platform versions or autoReloadPlugins = false to disable it explicitly.","title":"Gradle plugin 0.4.22 and Later"},{"location":"basics/ide_development_instance/#gradle-plugin-0421-and-earlierdevkit","text":"Add system property idea.auto.reload.plugins in the run configuration (DevKit-based) or runIde task (Gradle-based). For Gradle-based plugins using gradle-intellij-plugin 0.4.17 or later, this property is set automatically. To disable auto-reload, set idea.auto.reload.plugins to false explicitly (2020.1.2+).","title":"Gradle plugin 0.4.21 and Earlier/DevKit"},{"location":"basics/ide_development_instance/#the-development-instance-sandbox-directory","text":"The Sandbox Home directory contains the settings, caches, logs, and plugins for a Development Instance of the IDE. This information is stored in a different location than for the installed IDE itself .","title":"The Development Instance Sandbox Directory"},{"location":"basics/ide_development_instance/#sandbox-home-location-for-gradle-based-plugin-projects","text":"For Gradle-based plugins, the default Sandbox Home location is defined by the Consulo gradle-intellij-plugin . See Configuring a Gradle Plugin Project for more information about specifying a Sandbox Home location. The default Sandbox Home location for Gradle-based plugin projects is: * Windows <Project Dir>\\build\\idea-sandbox * Linux or macOS <Project Dir>/build/idea-sandbox","title":"Sandbox Home Location for Gradle-Based Plugin Projects"},{"location":"basics/ide_development_instance/#sandbox-home-location-for-devkit-based-plugin-projects","text":"For DevKit-based plugins, the default Sandbox Home location is defined in the Consulo Plugin SDK. See specifying the Sandbox Home for DevKit Projects for more information. The default Sandbox Home directory location for DevKit-based plugin projects is: * Windows: <User home>\\.<product_system_name><product_version>\\system\\plugins-sandbox\\ * Linux: ~/.<product_system_name><product_version>/system/plugins-sandbox/ * macOS ~/Library/Caches/<product_system_name><product_version>/plugins-sandbox/","title":"Sandbox Home Location for DevKit-Based Plugin Projects"},{"location":"basics/ide_development_instance/#development-instance-settings-caches-logs-and-plugins","text":"Within the Sandbox Home directory are subdirectories of the Development Instance: * config contains settings for the IDE instance. * plugins contains folders for each plugin being run in the IDE instance. * system/caches or system\\caches holds the IDE instance data. * system/log or system\\log contains the idea.log file for the IDE instance. Each of these Sandbox Home subdirectories can be manually cleared to reset the IDE Development Instance. At the next launch of a Development Instance, the subdirectories will be repopulated with the appropriate information.","title":"Development Instance Settings, Caches, Logs, and Plugins"},{"location":"basics/indexing_and_psi_stubs/","text":"Indices The indexing framework provides a quick way to locate specific elements, e.g., files containing a certain word or methods with a particular name, in large codebases. Plugin developers can use the existing indexes built by the IDE itself and build and use their own indexes. It supports two main types of indexes: File-based indices Stub indices File-based indexes are built directly over the content of files. Stub indexes are built over serialized stub trees . A stub tree for a source file is a subset of its PSI tree, which contains only externally visible declarations and is serialized in a compact binary format. Querying a file-based index gets you the set of files matching a specific condition. Querying a stub index gets you the set of matching PSI elements. Therefore, custom language plugin developers should typically use stub indexes in their plugin implementations. TIP Indices Viewer is a plugin that helps to inspect indices' contents and properties. Please see also Improving indexing performance . Dumb Mode Indexing is a potentially lengthy process. It's performed in the background, and during this time, IDE's features are restricted to the ones that don't require index: basic text editing, version control, etc. This restriction is managed by DumbService . Violations are reported via IndexNotReadyException , please see its javadoc on how to adapt callers. DumbService provides API to query whether the IDE is currently in \"dumb\" mode (where index access is not allowed) or \"smart\" mode (with all index built and ready to use). It also provides ways of delaying code execution until indices are ready. Please see its JavaDoc for more details. Gists Sometimes, the following conditions hold: the aggregation functionality of file-based indices is not needed. One just needs to calculate some data based on a particular file's contents and cache it on disk. eagerly calculating the data for the entire project during indexing isn't needed (e.g., it slows down the indexing, and/or this data probably will ever be required for a minor subset of all project files). the data can be recalculated lazily on request without significant performance penalties. A file-based index can be used in such cases, but file gists provide a way to perform data calculation lazily, caching on disk, and a more lightweight API. Please see VirtualFileGist and PsiFileGist documentation. Example: - ImageInfoIndex calculating image dimensions/bit depth needed to be displayed in specific parts of UI.","title":"Overview"},{"location":"basics/indexing_and_psi_stubs/#indices","text":"The indexing framework provides a quick way to locate specific elements, e.g., files containing a certain word or methods with a particular name, in large codebases. Plugin developers can use the existing indexes built by the IDE itself and build and use their own indexes. It supports two main types of indexes: File-based indices Stub indices File-based indexes are built directly over the content of files. Stub indexes are built over serialized stub trees . A stub tree for a source file is a subset of its PSI tree, which contains only externally visible declarations and is serialized in a compact binary format. Querying a file-based index gets you the set of files matching a specific condition. Querying a stub index gets you the set of matching PSI elements. Therefore, custom language plugin developers should typically use stub indexes in their plugin implementations. TIP Indices Viewer is a plugin that helps to inspect indices' contents and properties. Please see also Improving indexing performance .","title":"Indices"},{"location":"basics/indexing_and_psi_stubs/#dumb-mode","text":"Indexing is a potentially lengthy process. It's performed in the background, and during this time, IDE's features are restricted to the ones that don't require index: basic text editing, version control, etc. This restriction is managed by DumbService . Violations are reported via IndexNotReadyException , please see its javadoc on how to adapt callers. DumbService provides API to query whether the IDE is currently in \"dumb\" mode (where index access is not allowed) or \"smart\" mode (with all index built and ready to use). It also provides ways of delaying code execution until indices are ready. Please see its JavaDoc for more details.","title":"Dumb Mode"},{"location":"basics/indexing_and_psi_stubs/#gists","text":"Sometimes, the following conditions hold: the aggregation functionality of file-based indices is not needed. One just needs to calculate some data based on a particular file's contents and cache it on disk. eagerly calculating the data for the entire project during indexing isn't needed (e.g., it slows down the indexing, and/or this data probably will ever be required for a minor subset of all project files). the data can be recalculated lazily on request without significant performance penalties. A file-based index can be used in such cases, but file gists provide a way to perform data calculation lazily, caching on disk, and a more lightweight API. Please see VirtualFileGist and PsiFileGist documentation. Example: - ImageInfoIndex calculating image dimensions/bit depth needed to be displayed in specific parts of UI.","title":"Gists"},{"location":"basics/intellij.to.consulo.api/","text":"Migration from Consulo to Consulo Platform changes Plugins removed from platform. They plugin ids: Java > consulo.java (and removed his old id, com.intellij.modules.java ) Xml > com.intellij.xml RegExp > com.intellij.regexp Images > com.intellij.images Added plugin named Platform: base have id com.intellij . It holder for all extensions/actions/extensionPoints for platform IDEA build number != Consulo build number. Now some Consulo plugins ids is not working anymore com.intellij.modules.lang > not need to write. It will throw 'plugin not found' com.intellij.modules.platform > not need to write. It will throw 'plugin not found' com.intellij.modules.vcs > not need to write. It will throw 'plugin not found' com.intellij.modules.xdebugger > not need to write. It will throw 'plugin not found' com.intellij.modules.ultimate > obsolete (we don't have Ultimate version) com.intellij.modules.ruby > obsolete. Use consulo.ruby . See plugin repo com.intellij.modules.python > obsolete. Use consulo.python . See plugin repo com.intellij.modules.objc > obsolete (we don't have ObjC implementation) API changes Parsing API changes: language version api. ParserDefinition#createLexer(Project) -> ParserDefinition#createLexer(LanguageVersion) ParserDefinition#createParser(Project) -> ParserDefinition#createParser(LanguageVersion) ParserDefinition#getWhitespaceTokens() -> ParserDefinition#createParser(LanguageVersion) ParserDefinition#getCommentTokens() -> ParserDefinition#getCommentTokens(LanguageVersion) ParserDefinition#getStringLiteralElements() -> ParserDefinition#getStringLiteralElements(LanguageVersion) Injections com.intellij.lang.injection.MultiHostInjector changes: getLanguagesToInject renamed to injectLanguages elementsToInjectIn removed Declaration changed from <multiHostInjector implementation=\"org.intellij.plugins.intelliLang.inject.xml.XmlLanguageInjector\"/> to <multiHostInjector forClass=\"com.intellij.psi.xml.XmlAttributeValue\" implementationClass=\"org.intellij.plugins.intelliLang.inject.xml.XmlLanguageInjector\"/> Attribute forClass is value of elementsToInjectIn method Module Facets & Module Types was replaced by Module Extensions JPS support was dropped , that why external build is not supported for now com.intellij.openapi.module.Module.getModuleFilePath dropped due, Consulo dont have module files , all info stored in .consulo dir. Use com.intellij.openapi.module.Module#getModuleDirPath for it .impl & .ipr files are not supported anymore. Now all module info stored in .consulo dir","title":"Migration from IntelliJ Platform to Consulo"},{"location":"basics/intellij.to.consulo.api/#migration-from-consulo-to-consulo","text":"","title":"Migration from Consulo to Consulo"},{"location":"basics/intellij.to.consulo.api/#platform-changes","text":"Plugins removed from platform. They plugin ids: Java > consulo.java (and removed his old id, com.intellij.modules.java ) Xml > com.intellij.xml RegExp > com.intellij.regexp Images > com.intellij.images Added plugin named Platform: base have id com.intellij . It holder for all extensions/actions/extensionPoints for platform IDEA build number != Consulo build number. Now some Consulo plugins ids is not working anymore com.intellij.modules.lang > not need to write. It will throw 'plugin not found' com.intellij.modules.platform > not need to write. It will throw 'plugin not found' com.intellij.modules.vcs > not need to write. It will throw 'plugin not found' com.intellij.modules.xdebugger > not need to write. It will throw 'plugin not found' com.intellij.modules.ultimate > obsolete (we don't have Ultimate version) com.intellij.modules.ruby > obsolete. Use consulo.ruby . See plugin repo com.intellij.modules.python > obsolete. Use consulo.python . See plugin repo com.intellij.modules.objc > obsolete (we don't have ObjC implementation)","title":"Platform changes"},{"location":"basics/intellij.to.consulo.api/#api-changes","text":"Parsing API changes: language version api. ParserDefinition#createLexer(Project) -> ParserDefinition#createLexer(LanguageVersion) ParserDefinition#createParser(Project) -> ParserDefinition#createParser(LanguageVersion) ParserDefinition#getWhitespaceTokens() -> ParserDefinition#createParser(LanguageVersion) ParserDefinition#getCommentTokens() -> ParserDefinition#getCommentTokens(LanguageVersion) ParserDefinition#getStringLiteralElements() -> ParserDefinition#getStringLiteralElements(LanguageVersion) Injections com.intellij.lang.injection.MultiHostInjector changes: getLanguagesToInject renamed to injectLanguages elementsToInjectIn removed Declaration changed from <multiHostInjector implementation=\"org.intellij.plugins.intelliLang.inject.xml.XmlLanguageInjector\"/> to <multiHostInjector forClass=\"com.intellij.psi.xml.XmlAttributeValue\" implementationClass=\"org.intellij.plugins.intelliLang.inject.xml.XmlLanguageInjector\"/> Attribute forClass is value of elementsToInjectIn method Module Facets & Module Types was replaced by Module Extensions JPS support was dropped , that why external build is not supported for now com.intellij.openapi.module.Module.getModuleFilePath dropped due, Consulo dont have module files , all info stored in .consulo dir. Use com.intellij.openapi.module.Module#getModuleDirPath for it .impl & .ipr files are not supported anymore. Now all module info stored in .consulo dir","title":"API changes"},{"location":"basics/intellij_coding_guidelines/","text":"If you are writing code that you would like to contribute to the Consulo (either as a patch or as a plugin), following these guidelines will make it easier for the JetBrains development team to review and accept your changes. Following the Latest Source Code If you submit patches, we strongly recommend building your patches against the latest version of the code from the Git repository. The easiest way to do so is to clone the JetBrains Git repository, track your work in Git, and create patches using the \"git format-patch\" command. General Architectural Principles Please do your best to follow common Java architectural principles. \"Effective Java\" by Joshua Bloch is the right place to start. Tests Functional tests cover most of the existing functionality of IntelliJ IDEA. If tests cover the area you're modifying, you must run the tests and make sure that your changes do not introduce any new test failures. It's also strongly recommended that you provide new functional tests that cover the bugs you fix or the new features that you add. Code Formatting We're generally pretty lax about code formatting, but at least the following conventions must be observed: 2 space indents in source files my prefix for instance variables and our prefix for class variables new source code files must include a copyright statement with the Apache 2 license and the name of the contributor. The easiest way to follow our code formatting guidelines is to reformat your code submissions using the shared code style, which is included in the IntelliJ IDEA Community Edition project directory. Inspections The IntelliJ IDEA Community Edition project includes a shared inspection profile. We strongly recommend making sure that the code you submit does not contain any warnings highlighted by the inspections configured in that inspection profile. JavaDoc Comments If your code adds new OpenAPI interfaces, classes, methods, or extension points, you must provide JavaDoc comments describing the parameters and intended usage of the APIs. Providing JavaDoc or other comments for other parts of the code is a good idea but isn't required. Commits To avoid unnecessary work when reviewing your changes, please follow these guidelines: Look through all of your changes in your patch or pull request before you submit it to us. Make sure that everything you've changed is there for a reason. Please don't include unfinished work to the patch. Make sure that it doesn't contain any TODO comments. If you added some code and ended up not needing it, please make sure that you delete it before you submit your patch. Please don't include any changes that affect formatting, fixing \"yellow code\" (warnings), or code style along with actual changes that fix a bug or implement a feature. No one likes to leave poor code, but remember that having these changes mixed complicates the process of review. Please don't fix multiple problems within a single patch or pull request. Please don't commit your changes to configuration files (runConfigurations/IDEA.xml, codeStyleSettings.xml, misc.xml, etc.) unless it is essential for the fix itself. Please avoid moving or renaming classes unless it is necessary for the fix. The ideal pull request would contain one commit with everything needed to fix the bug or implement a feature, but nothing else. \"Commit early, commit often\" perfectly applies only to local commits, but such \"public commits\" are hard to review (the reviewer needs either to go commit by commit spending more time to review work-in-progress, or to review all changes at once thus losing valuable information stored in commit messages). The best would be to commit early, but then to squash all commits into one with a descriptive commit message. Sometimes several commits for a single issue are also acceptable, but each of these should be self-contained \"steps\" to solve the problem.","title":"Consulo Coding Guidelines"},{"location":"basics/intellij_coding_guidelines/#following-the-latest-source-code","text":"If you submit patches, we strongly recommend building your patches against the latest version of the code from the Git repository. The easiest way to do so is to clone the JetBrains Git repository, track your work in Git, and create patches using the \"git format-patch\" command.","title":"Following the Latest Source Code"},{"location":"basics/intellij_coding_guidelines/#general-architectural-principles","text":"Please do your best to follow common Java architectural principles. \"Effective Java\" by Joshua Bloch is the right place to start.","title":"General Architectural Principles"},{"location":"basics/intellij_coding_guidelines/#tests","text":"Functional tests cover most of the existing functionality of IntelliJ IDEA. If tests cover the area you're modifying, you must run the tests and make sure that your changes do not introduce any new test failures. It's also strongly recommended that you provide new functional tests that cover the bugs you fix or the new features that you add.","title":"Tests"},{"location":"basics/intellij_coding_guidelines/#code-formatting","text":"We're generally pretty lax about code formatting, but at least the following conventions must be observed: 2 space indents in source files my prefix for instance variables and our prefix for class variables new source code files must include a copyright statement with the Apache 2 license and the name of the contributor. The easiest way to follow our code formatting guidelines is to reformat your code submissions using the shared code style, which is included in the IntelliJ IDEA Community Edition project directory.","title":"Code Formatting"},{"location":"basics/intellij_coding_guidelines/#inspections","text":"The IntelliJ IDEA Community Edition project includes a shared inspection profile. We strongly recommend making sure that the code you submit does not contain any warnings highlighted by the inspections configured in that inspection profile.","title":"Inspections"},{"location":"basics/intellij_coding_guidelines/#javadoc-comments","text":"If your code adds new OpenAPI interfaces, classes, methods, or extension points, you must provide JavaDoc comments describing the parameters and intended usage of the APIs. Providing JavaDoc or other comments for other parts of the code is a good idea but isn't required.","title":"JavaDoc Comments"},{"location":"basics/intellij_coding_guidelines/#commits","text":"To avoid unnecessary work when reviewing your changes, please follow these guidelines: Look through all of your changes in your patch or pull request before you submit it to us. Make sure that everything you've changed is there for a reason. Please don't include unfinished work to the patch. Make sure that it doesn't contain any TODO comments. If you added some code and ended up not needing it, please make sure that you delete it before you submit your patch. Please don't include any changes that affect formatting, fixing \"yellow code\" (warnings), or code style along with actual changes that fix a bug or implement a feature. No one likes to leave poor code, but remember that having these changes mixed complicates the process of review. Please don't fix multiple problems within a single patch or pull request. Please don't commit your changes to configuration files (runConfigurations/IDEA.xml, codeStyleSettings.xml, misc.xml, etc.) unless it is essential for the fix itself. Please avoid moving or renaming classes unless it is necessary for the fix. The ideal pull request would contain one commit with everything needed to fix the bug or implement a feature, but nothing else. \"Commit early, commit often\" perfectly applies only to local commits, but such \"public commits\" are hard to review (the reviewer needs either to go commit by commit spending more time to review work-in-progress, or to review all changes at once thus losing valuable information stored in commit messages). The best would be to commit early, but then to squash all commits into one with a descriptive commit message. Sometimes several commits for a single issue are also acceptable, but each of these should be self-contained \"steps\" to solve the problem.","title":"Commits"},{"location":"basics/persistence/","text":"The Consulo Persistence Model is used to store a variety of information. For example, Run Configurations and Settings are stored using the Persistence Model. There are two distinct approaches, depending on the type of data being persisted: * Persisting State of Components * Persisting Sensitive Data","title":"Overview"},{"location":"basics/persisting_sensitive_data/","text":"The Credentials Store API allows you to store sensitive user data securely, like passwords, server URLs, etc. How to Use Use PasswordSafe to work with credentials. Retrieve Stored Credentials String key = null ; // e.g. serverURL, accountID CredentialAttributes credentialAttributes = createCredentialAttributes ( key ); Credentials credentials = PasswordSafe . getInstance (). get ( credentialAttributes ); if ( credentials != null ) { String password = credentials . getPasswordAsString (); } // or get password only String password = PasswordSafe . getInstance (). getPassword ( credentialAttributes ); private CredentialAttributes createCredentialAttributes ( String key ) { return new CredentialAttributes ( CredentialAttributesKt . generateServiceName ( \"MySystem\" , key )); } Store Credentials CredentialAttributes credentialAttributes = createCredentialAttributes ( serverId ); // see previous sample Credentials credentials = new Credentials ( username , password ); PasswordSafe . getInstance (). set ( credentialAttributes , credentials ); To remove stored credentials, pass null for the credentials parameter. Storage The default storage format depends on the OS. OS Storage Windows File in KeePass format macOS Keychain using Security Framework Linux Secret Service API using [libsecret][linux2] Users can override the default behavior in Preferences | Appearance & Behavior | System Settings | Passwords.","title":"Persisting Sensitive Data"},{"location":"basics/persisting_sensitive_data/#how-to-use","text":"Use PasswordSafe to work with credentials.","title":"How to Use"},{"location":"basics/persisting_sensitive_data/#retrieve-stored-credentials","text":"String key = null ; // e.g. serverURL, accountID CredentialAttributes credentialAttributes = createCredentialAttributes ( key ); Credentials credentials = PasswordSafe . getInstance (). get ( credentialAttributes ); if ( credentials != null ) { String password = credentials . getPasswordAsString (); } // or get password only String password = PasswordSafe . getInstance (). getPassword ( credentialAttributes ); private CredentialAttributes createCredentialAttributes ( String key ) { return new CredentialAttributes ( CredentialAttributesKt . generateServiceName ( \"MySystem\" , key )); }","title":"Retrieve Stored Credentials"},{"location":"basics/persisting_sensitive_data/#store-credentials","text":"CredentialAttributes credentialAttributes = createCredentialAttributes ( serverId ); // see previous sample Credentials credentials = new Credentials ( username , password ); PasswordSafe . getInstance (). set ( credentialAttributes , credentials ); To remove stored credentials, pass null for the credentials parameter.","title":"Store Credentials"},{"location":"basics/persisting_sensitive_data/#storage","text":"The default storage format depends on the OS. OS Storage Windows File in KeePass format macOS Keychain using Security Framework Linux Secret Service API using [libsecret][linux2] Users can override the default behavior in Preferences | Appearance & Behavior | System Settings | Passwords.","title":"Storage"},{"location":"basics/persisting_state_of_components/","text":"The Consulo provides an API that allows components or services to persist their state between restarts of the IDE. You can use either a simple API to persist a few values or persist the state of more complicated components using the PersistentStateComponent interface. WARNING If you need to persist sensitive data like passwords, please see Persisting Sensitive Data . Using PropertiesComponent for Simple Non-Roamable Persistence If the plugin needs to persist just a few simple values, the easiest way to do so is to use the com.intellij.ide.util.PropertiesComponent service. It can save both application-level values and project-level values in the workspace file. Roaming is disabled for PropertiesComponent , so use it only for temporary, non-roamable properties. Use the PropertiesComponent.getInstance() method for storing application-level values, and the PropertiesComponent.getInstance(Project) method for storing project-level values. Since all plugins share the same namespace, it is highly recommended to prefix key names (e.g., using plugin ID com.myplugin.myCustomSetting ). Using PersistentStateComponent The com.intellij.openapi.components.PersistentStateComponent interface gives you the most flexibility for defining the values to be persisted, their format, and storage location. To use it: - mark a service as implementing the PersistentStateComponent interface - define the state class - specify the storage location using @com.intellij.openapi.components.State Note that instances of extensions cannot persist their state by implementing PersistentStateComponent . If your extension needs to have a persistent state, you need to define a separate service responsible for managing that state. Implementing the PersistentStateComponent Interface The implementation of PersistentStateComponent needs to be parameterized with the type of state class. The state class can either be a separate JavaBean class, or the class implementing PersistentStateComponent . In the former case, the state class instance is typically stored as a field in the PersistentStateComponent class: @State (...) class MyService implements PersistentStateComponent < MyService . State > { static class State { public String value ; } private State myState = new State (); public State getState () { return myState ; } public void loadState ( State state ) { myState = state ; } } In the latter case, you can use the following pattern to implement getState() and loadState() methods: @State (...) class MyService implements PersistentStateComponent < MyService > { public String stateValue ; public MyService getState () { return this ; } public void loadState ( MyService state ) { XmlSerializerUtil . copyBean ( state , this ); } } Implementing the State Class The implementation of PersistentStateComponent works by serializing public fields, annotated private fields (see also Customizing the XML format of persisted values ), and bean properties into an XML format. To exclude a public field or bean property from serialization, annotate the field or getter with @com.intellij.util.xmlb.annotations.Transient . Note that the state class must have a default constructor. It should return the component's default state: the one used if there is nothing persisted in the XML files yet. State class should have an equals() method, but state objects are compared by fields if it is not implemented. When using Kotlin, use Data Classes . The following types of values can be persisted: numbers (both primitive types, such as int , and boxed types, such as Integer ) booleans strings collections maps enums For other types, extend com.intellij.util.xmlb.Converter : class LocalDateTimeConverter extends Converter < LocalDateTime > { public LocalDateTime fromString ( String value ) { final long epochMilli = Long . parseLong ( value ); final ZoneId zoneId = ZoneId . systemDefault (); return Instant . ofEpochMilli ( epochMilli ). atZone ( zoneId ). toLocalDateTime (); } public String toString ( LocalDateTime value ) { final ZoneId zoneId = ZoneId . systemDefault (); final long toEpochMilli = value . atZone ( zoneId ). toInstant (). toEpochMilli (); return Long . toString ( toEpochMilli ); } } Define the converter above in @com.intellij.util.xmlb.annotations.OptionTag or @com.intellij.util.xmlb.annotations.Attribute : class State { @OptionTag ( converter = LocalDateTimeConverter . class ) public LocalDateTime dateTime ; } Defining the Storage Location To specify where precisely the persisted values are stored, add @State annotation to the PersistentStateComponent class. It has the following fields: * name (required) \u2014 specifies the name of the state (name of the root tag in XML). * storages \u2014 one or more of @com.intellij.openapi.components.Storage annotations to specify the storage locations. Optional for project-level values \u2014 standard project file is used in this case. * reloadable (optional) \u2014 if set to false, complete project (or application) reload is required when the XML file is changed externally, and the state has changed. The simplest ways of specifying the @Storage annotation are as follows (since 2016.x; for previous versions, please see old version of this document): @Storage(\"yourName.xml\") If a component is project-level \u2014 for .ipr based projects standard project file is used automatically - no need to specify anything. @Storage(StoragePathMacros.WORKSPACE_FILE) for values stored in the workspace file. The state is persisted in a separate file by specifying a different setting for the value parameter, which was the file parameter before 2016.x. NOTE For application-level components, it is strongly recommended to use a custom file, using of other.xml is deprecated. The roamingType parameter of the @Storage annotation specifies the roaming type when the Settings Repository plugin is used. Customizing the XML Format of Persisted Values NOTE Please consider using annotation parameters only to achieve backward compatibility. Otherwise, please feel free to file issues about serialization cosmetics. If you want to use the default bean serialization but need to customize the storage format in XML (for example, for compatibility with previous versions of your plugin or externally defined XML formats), you can use the @Tag , @Attribute , @Property , @MapAnnotation , @AbstractCollection annotations. Please see com.intellij.util.xmlb.annotations 's package.html for more information. If the state you need to serialize doesn't map cleanly to a JavaBean, you can use org.jdom.Element as the state class. In that case, you can use the getState() method to build an XML element with an arbitrary structure, which then is saved directly in the state XML file. In the loadState() method, you can deserialize the JDOM element tree using any custom logic. Please note this is not recommended and should be avoided whenever possible. Migrating Persisted Values If the underlying persistence model or storage format has changed, a ConverterProvider can provide ProjectConverter whose getAdditionalAffectedFiles() method returns affected files to migrate and performs programmatic migration of stored values. Persistent Component Lifecycle The loadState() method is called after the component has been created (only if there is some non-default state persisted for the component), and after the XML file with the persisted state is changed externally (for example, if the project file was updated from the version control system). In the latter case, the component is responsible for updating the UI and other related components according to the changed state. The getState() method is called every time the settings are saved (for example, on frame deactivation or when closing the IDE). If the state returned from getState() is equal to the default state (obtained by creating the state class with a default constructor), nothing is persisted in the XML. Otherwise, the returned state is serialized in XML and stored. Legacy API (JDOMExternalizable) Older components use the JDOMExternalizable interface for persisting state. It uses the readExternal() method for reading the state from a JDOM element, and writeExternal() to write the state. Implementations can manually store the state in attributes and sub-elements or use the DefaultJDOMExternalizer class to store the values of all public fields automatically. Components save their state in the following files: Project-level: project ( .ipr ) file. However, if the workspace option in the plugin.xml file is set to true , then the workspace ( .iws ) file is used instead. Module-level: module ( .iml ) file.","title":"Persisting State of Components"},{"location":"basics/persisting_state_of_components/#using-propertiescomponent-for-simple-non-roamable-persistence","text":"If the plugin needs to persist just a few simple values, the easiest way to do so is to use the com.intellij.ide.util.PropertiesComponent service. It can save both application-level values and project-level values in the workspace file. Roaming is disabled for PropertiesComponent , so use it only for temporary, non-roamable properties. Use the PropertiesComponent.getInstance() method for storing application-level values, and the PropertiesComponent.getInstance(Project) method for storing project-level values. Since all plugins share the same namespace, it is highly recommended to prefix key names (e.g., using plugin ID com.myplugin.myCustomSetting ).","title":"Using PropertiesComponent for Simple Non-Roamable Persistence"},{"location":"basics/persisting_state_of_components/#using-persistentstatecomponent","text":"The com.intellij.openapi.components.PersistentStateComponent interface gives you the most flexibility for defining the values to be persisted, their format, and storage location. To use it: - mark a service as implementing the PersistentStateComponent interface - define the state class - specify the storage location using @com.intellij.openapi.components.State Note that instances of extensions cannot persist their state by implementing PersistentStateComponent . If your extension needs to have a persistent state, you need to define a separate service responsible for managing that state.","title":"Using PersistentStateComponent"},{"location":"basics/persisting_state_of_components/#implementing-the-persistentstatecomponent-interface","text":"The implementation of PersistentStateComponent needs to be parameterized with the type of state class. The state class can either be a separate JavaBean class, or the class implementing PersistentStateComponent . In the former case, the state class instance is typically stored as a field in the PersistentStateComponent class: @State (...) class MyService implements PersistentStateComponent < MyService . State > { static class State { public String value ; } private State myState = new State (); public State getState () { return myState ; } public void loadState ( State state ) { myState = state ; } } In the latter case, you can use the following pattern to implement getState() and loadState() methods: @State (...) class MyService implements PersistentStateComponent < MyService > { public String stateValue ; public MyService getState () { return this ; } public void loadState ( MyService state ) { XmlSerializerUtil . copyBean ( state , this ); } }","title":"Implementing the PersistentStateComponent Interface"},{"location":"basics/persisting_state_of_components/#implementing-the-state-class","text":"The implementation of PersistentStateComponent works by serializing public fields, annotated private fields (see also Customizing the XML format of persisted values ), and bean properties into an XML format. To exclude a public field or bean property from serialization, annotate the field or getter with @com.intellij.util.xmlb.annotations.Transient . Note that the state class must have a default constructor. It should return the component's default state: the one used if there is nothing persisted in the XML files yet. State class should have an equals() method, but state objects are compared by fields if it is not implemented. When using Kotlin, use Data Classes . The following types of values can be persisted: numbers (both primitive types, such as int , and boxed types, such as Integer ) booleans strings collections maps enums For other types, extend com.intellij.util.xmlb.Converter : class LocalDateTimeConverter extends Converter < LocalDateTime > { public LocalDateTime fromString ( String value ) { final long epochMilli = Long . parseLong ( value ); final ZoneId zoneId = ZoneId . systemDefault (); return Instant . ofEpochMilli ( epochMilli ). atZone ( zoneId ). toLocalDateTime (); } public String toString ( LocalDateTime value ) { final ZoneId zoneId = ZoneId . systemDefault (); final long toEpochMilli = value . atZone ( zoneId ). toInstant (). toEpochMilli (); return Long . toString ( toEpochMilli ); } } Define the converter above in @com.intellij.util.xmlb.annotations.OptionTag or @com.intellij.util.xmlb.annotations.Attribute : class State { @OptionTag ( converter = LocalDateTimeConverter . class ) public LocalDateTime dateTime ; }","title":"Implementing the State Class"},{"location":"basics/persisting_state_of_components/#defining-the-storage-location","text":"To specify where precisely the persisted values are stored, add @State annotation to the PersistentStateComponent class. It has the following fields: * name (required) \u2014 specifies the name of the state (name of the root tag in XML). * storages \u2014 one or more of @com.intellij.openapi.components.Storage annotations to specify the storage locations. Optional for project-level values \u2014 standard project file is used in this case. * reloadable (optional) \u2014 if set to false, complete project (or application) reload is required when the XML file is changed externally, and the state has changed. The simplest ways of specifying the @Storage annotation are as follows (since 2016.x; for previous versions, please see old version of this document): @Storage(\"yourName.xml\") If a component is project-level \u2014 for .ipr based projects standard project file is used automatically - no need to specify anything. @Storage(StoragePathMacros.WORKSPACE_FILE) for values stored in the workspace file. The state is persisted in a separate file by specifying a different setting for the value parameter, which was the file parameter before 2016.x. NOTE For application-level components, it is strongly recommended to use a custom file, using of other.xml is deprecated. The roamingType parameter of the @Storage annotation specifies the roaming type when the Settings Repository plugin is used.","title":"Defining the Storage Location"},{"location":"basics/persisting_state_of_components/#customizing-the-xml-format-of-persisted-values","text":"NOTE Please consider using annotation parameters only to achieve backward compatibility. Otherwise, please feel free to file issues about serialization cosmetics. If you want to use the default bean serialization but need to customize the storage format in XML (for example, for compatibility with previous versions of your plugin or externally defined XML formats), you can use the @Tag , @Attribute , @Property , @MapAnnotation , @AbstractCollection annotations. Please see com.intellij.util.xmlb.annotations 's package.html for more information. If the state you need to serialize doesn't map cleanly to a JavaBean, you can use org.jdom.Element as the state class. In that case, you can use the getState() method to build an XML element with an arbitrary structure, which then is saved directly in the state XML file. In the loadState() method, you can deserialize the JDOM element tree using any custom logic. Please note this is not recommended and should be avoided whenever possible.","title":"Customizing the XML Format of Persisted Values"},{"location":"basics/persisting_state_of_components/#migrating-persisted-values","text":"If the underlying persistence model or storage format has changed, a ConverterProvider can provide ProjectConverter whose getAdditionalAffectedFiles() method returns affected files to migrate and performs programmatic migration of stored values.","title":"Migrating Persisted Values"},{"location":"basics/persisting_state_of_components/#persistent-component-lifecycle","text":"The loadState() method is called after the component has been created (only if there is some non-default state persisted for the component), and after the XML file with the persisted state is changed externally (for example, if the project file was updated from the version control system). In the latter case, the component is responsible for updating the UI and other related components according to the changed state. The getState() method is called every time the settings are saved (for example, on frame deactivation or when closing the IDE). If the state returned from getState() is equal to the default state (obtained by creating the state class with a default constructor), nothing is persisted in the XML. Otherwise, the returned state is serialized in XML and stored.","title":"Persistent Component Lifecycle"},{"location":"basics/persisting_state_of_components/#legacy-api-jdomexternalizable","text":"Older components use the JDOMExternalizable interface for persisting state. It uses the readExternal() method for reading the state from a JDOM element, and writeExternal() to write the state. Implementations can manually store the state in attributes and sub-elements or use the DefaultJDOMExternalizer class to store the values of all public fields automatically. Components save their state in the following files: Project-level: project ( .ipr ) file. However, if the workspace option in the plugin.xml file is set to true , then the workspace ( .iws ) file is used instead. Module-level: module ( .iml ) file.","title":"Legacy API (JDOMExternalizable)"},{"location":"basics/platform_contributions/","text":"Please make sure to read the Code of Conduct . Participate in the Community Participate in Newsgroups and Forums There are several community forums and newsgroups you can join to discuss the Consulo. The forums are an excellent source for users and contributors interested in having technical discussions, answering questions, or resolving potential issues for newcomers. Link to jetbrains.org The success of any open-source project depends on the number of people who use the product and contribute back to the project. By linking to jetbrains.org, you can increase the chances of a new user or contributor finding out about the project and joining the community. If you're as excited about IntelliJ IDEA Community Edition as we are, you can show it by linking to us. Project logos and other assets are also available . Promote Consulo and IntelliJ IDEA Community Edition Help promote the platform and IDE by using your blog, Twitter, Facebook, or submitting an article to your favorite local magazine. If you are a member of a different open-source community, why not mention IntelliJ IDEA on their discussion forums or at conferences? If you love IntelliJ IDEA, don't hold back - speak up! The more developers use IntelliJ IDEA, the more bugs will be caught, the more plugins will be written, the more visible the project, and the more benefits the community will get! Help Others Learn Write Documents We're always looking for new articles about IntelliJ IDEA features as well as documentation for the Consulo. You can write tutorials, how-tos, sample applications, or share your experience with the Consulo. You can publish your documentation on a website or blog, or submit a pull request to the SDK Docs. Produce Screencasts Screencasts have recently become very popular as a way to show other developers how to use the tool effectively. You can record a screencast about a particular feature or use case you discovered and would like to share it with the community. Contribute Code File a Bug Report Bug reports take little time to file and are very helpful to developers. This is one of the easiest contributions you can make. When you discover a problem with the IDE or the platform, please report it. Make sure you provide information about your environment (OS, JDK version), steps to reproduce the issue, as well as a written description of the problem. You can file a bug in our YouTrack issue tracker . Before submitting an issue, please search for already submitted ones describing the same problem - and if you find one, feel free to vote for it. Help Triage Existing Bug Reports Over the years, users have submitted thousands of issues to the IntelliJ issue tracker. Many of the unresolved issues are no longer applicable to the latest version of IntelliJ IDEA, are duplicates, or require additional information to be resolved. Leaving comments notifying about the status of such issues helps the team keep the issue tracker clean and useful for everyone. Write a Plugin One of the best ways to contribute a larger piece of code, adding extra functionality to IntelliJ IDEA or any of the other Consulo-based IDEs, is by writing a plugin. You can submit a plugin to the JetBrains Plugins Repository , making it available for all users. When writing a plugin, you have control over the code and don't need to sign the contribution agreement. Submit a Patch If you would like to improve the code in the Consulo or the core functionality of IntelliJ IDEA, you can submit a patch in the YouTrack bug database . You can either file a new issue with the patch attached or attach a patch to an issue submitted by another user. When writing a patch, please make sure to follow the Consulo Coding Guidelines . Alternatively, you can fork the IntelliJ IDEA Community Edition repository on GitHub , make the changes in your fork and send us a pull request. A developer will review your patch and, if it meets the quality criteria and fits well with the rest of the code, you'll be notified about the acceptance of the patch. You will also need to sign the JetBrains Contributor License Agreement (CLA) to complete your contribution. Become a Committer Developers with a long history of submitting high-quality patches can gain direct commit rights.","title":"Contributing to the Consulo"},{"location":"basics/platform_contributions/#participate-in-the-community","text":"","title":"Participate in the Community"},{"location":"basics/platform_contributions/#participate-in-newsgroups-and-forums","text":"There are several community forums and newsgroups you can join to discuss the Consulo. The forums are an excellent source for users and contributors interested in having technical discussions, answering questions, or resolving potential issues for newcomers.","title":"Participate in Newsgroups and Forums"},{"location":"basics/platform_contributions/#link-to-jetbrainsorg","text":"The success of any open-source project depends on the number of people who use the product and contribute back to the project. By linking to jetbrains.org, you can increase the chances of a new user or contributor finding out about the project and joining the community. If you're as excited about IntelliJ IDEA Community Edition as we are, you can show it by linking to us. Project logos and other assets are also available .","title":"Link to jetbrains.org"},{"location":"basics/platform_contributions/#promote-consulo-and-intellij-idea-community-edition","text":"Help promote the platform and IDE by using your blog, Twitter, Facebook, or submitting an article to your favorite local magazine. If you are a member of a different open-source community, why not mention IntelliJ IDEA on their discussion forums or at conferences? If you love IntelliJ IDEA, don't hold back - speak up! The more developers use IntelliJ IDEA, the more bugs will be caught, the more plugins will be written, the more visible the project, and the more benefits the community will get!","title":"Promote Consulo and IntelliJ IDEA Community Edition"},{"location":"basics/platform_contributions/#help-others-learn","text":"","title":"Help Others Learn"},{"location":"basics/platform_contributions/#write-documents","text":"We're always looking for new articles about IntelliJ IDEA features as well as documentation for the Consulo. You can write tutorials, how-tos, sample applications, or share your experience with the Consulo. You can publish your documentation on a website or blog, or submit a pull request to the SDK Docs.","title":"Write Documents"},{"location":"basics/platform_contributions/#produce-screencasts","text":"Screencasts have recently become very popular as a way to show other developers how to use the tool effectively. You can record a screencast about a particular feature or use case you discovered and would like to share it with the community.","title":"Produce Screencasts"},{"location":"basics/platform_contributions/#contribute-code","text":"","title":"Contribute Code"},{"location":"basics/platform_contributions/#file-a-bug-report","text":"Bug reports take little time to file and are very helpful to developers. This is one of the easiest contributions you can make. When you discover a problem with the IDE or the platform, please report it. Make sure you provide information about your environment (OS, JDK version), steps to reproduce the issue, as well as a written description of the problem. You can file a bug in our YouTrack issue tracker . Before submitting an issue, please search for already submitted ones describing the same problem - and if you find one, feel free to vote for it.","title":"File a Bug Report"},{"location":"basics/platform_contributions/#help-triage-existing-bug-reports","text":"Over the years, users have submitted thousands of issues to the IntelliJ issue tracker. Many of the unresolved issues are no longer applicable to the latest version of IntelliJ IDEA, are duplicates, or require additional information to be resolved. Leaving comments notifying about the status of such issues helps the team keep the issue tracker clean and useful for everyone.","title":"Help Triage Existing Bug Reports"},{"location":"basics/platform_contributions/#write-a-plugin","text":"One of the best ways to contribute a larger piece of code, adding extra functionality to IntelliJ IDEA or any of the other Consulo-based IDEs, is by writing a plugin. You can submit a plugin to the JetBrains Plugins Repository , making it available for all users. When writing a plugin, you have control over the code and don't need to sign the contribution agreement.","title":"Write a Plugin"},{"location":"basics/platform_contributions/#submit-a-patch","text":"If you would like to improve the code in the Consulo or the core functionality of IntelliJ IDEA, you can submit a patch in the YouTrack bug database . You can either file a new issue with the patch attached or attach a patch to an issue submitted by another user. When writing a patch, please make sure to follow the Consulo Coding Guidelines . Alternatively, you can fork the IntelliJ IDEA Community Edition repository on GitHub , make the changes in your fork and send us a pull request. A developer will review your patch and, if it meets the quality criteria and fits well with the rest of the code, you'll be notified about the acceptance of the patch. You will also need to sign the JetBrains Contributor License Agreement (CLA) to complete your contribution.","title":"Submit a Patch"},{"location":"basics/platform_contributions/#become-a-committer","text":"Developers with a long history of submitting high-quality patches can gain direct commit rights.","title":"Become a Committer"},{"location":"basics/plugin_structure/","text":"Click the following topics to learn more about the plugin system structure and plugin lifecycles: Plugin Content Plugin Class Loaders Plugin Actions Plugin Extensions Plugin Services Plugin Listeners Plugin Extension Points Plugin Components Plugin Configuration File Plugin Logo (Icon) Plugin Dependencies","title":"Overview"},{"location":"basics/project_structure/","text":"This topic considers the concept of projects based on the Consulo and related subjects, such as modules , libraries , and SDK . Project and Its Components This section briefly discusses the Consulo project structure, project components, and related terms. For more information about projects and their components, refer to Project , Module , Library , Facet in the IntelliJ IDEA Web Help. Project In the Consulo, a project encapsulates all of a project's source code, libraries, and build instructions into a single organizational unit. Everything done using the Consulo SDK is done within the context of a project. A project defines collections referred to as modules and libraries . Depending on the project's logical and functional requirements, you can create a single-module or a multi-module project. Module A module is a discrete unit of functionality that can be run, tested, and debugged independently. Modules include such things as source code, build scripts, unit tests, deployment descriptors, etc. In a project, each module can use a specific SDK or inherit the SDK defined at the project level (see the SDK section below in this document). A module can depend on other modules of the project. Library A library is an archive of compiled code (such as JAR files) on which modules depend. The Consulo supports three types of libraries: * Module Library : the library classes are visible only in this module, and the library information is recorded in the module's .iml file. * Project Library : the library classes are visible within the project, and the library information is recorded in the project's .ipr file or in .idea/libraries . For more information about libraries, refer to Library . SDK Every project uses a Software Development Kit ( SDK ). For Java projects, SDK is referred to as JDK (Java Development Kit). The SDK determines which API library is used to build the project. If a project is multi-module, the project SDK is common for all modules within the project by default. Optionally, a project can configure an individual SDK for each module. For more information about SDKs, see Working with SDKs in the IntelliJ IDEA Web Help. Facet A facet represents a certain configuration, specific for a particular framework/technology associated with a module. A module can have multiple facets. E.g., Spring-specific configuration is stored in a Spring facet. Facets are documented under Facet and Language and Framework Specific Guidelines in the IntelliJ IDEA Web Help. Additional Information For more information on each of these entities, see: Project Module SDK Library External system integration (for projects imported from Gradle or similar build systems)","title":"Introduction"},{"location":"basics/project_structure/#project-and-its-components","text":"This section briefly discusses the Consulo project structure, project components, and related terms. For more information about projects and their components, refer to Project , Module , Library , Facet in the IntelliJ IDEA Web Help.","title":"Project and Its Components"},{"location":"basics/project_structure/#project","text":"In the Consulo, a project encapsulates all of a project's source code, libraries, and build instructions into a single organizational unit. Everything done using the Consulo SDK is done within the context of a project. A project defines collections referred to as modules and libraries . Depending on the project's logical and functional requirements, you can create a single-module or a multi-module project.","title":"Project"},{"location":"basics/project_structure/#module","text":"A module is a discrete unit of functionality that can be run, tested, and debugged independently. Modules include such things as source code, build scripts, unit tests, deployment descriptors, etc. In a project, each module can use a specific SDK or inherit the SDK defined at the project level (see the SDK section below in this document). A module can depend on other modules of the project.","title":"Module"},{"location":"basics/project_structure/#library","text":"A library is an archive of compiled code (such as JAR files) on which modules depend. The Consulo supports three types of libraries: * Module Library : the library classes are visible only in this module, and the library information is recorded in the module's .iml file. * Project Library : the library classes are visible within the project, and the library information is recorded in the project's .ipr file or in .idea/libraries . For more information about libraries, refer to Library .","title":"Library"},{"location":"basics/project_structure/#sdk","text":"Every project uses a Software Development Kit ( SDK ). For Java projects, SDK is referred to as JDK (Java Development Kit). The SDK determines which API library is used to build the project. If a project is multi-module, the project SDK is common for all modules within the project by default. Optionally, a project can configure an individual SDK for each module. For more information about SDKs, see Working with SDKs in the IntelliJ IDEA Web Help.","title":"SDK"},{"location":"basics/project_structure/#facet","text":"A facet represents a certain configuration, specific for a particular framework/technology associated with a module. A module can have multiple facets. E.g., Spring-specific configuration is stored in a Spring facet. Facets are documented under Facet and Language and Framework Specific Guidelines in the IntelliJ IDEA Web Help.","title":"Facet"},{"location":"basics/project_structure/#additional-information","text":"For more information on each of these entities, see: Project Module SDK Library External system integration (for projects imported from Gradle or similar build systems)","title":"Additional Information"},{"location":"basics/project_view/","text":"Modifying Project View Structure","title":"Overview"},{"location":"basics/psi_cookbook/","text":"This page gives recipes for the most common operations for working with the PSI (Program Structure Interface). Unlike Developing Custom Language Plugins , it talks about working with the PSI of existing languages (such as Java). TIP Please see also Working with PSI efficiently . How do I find a file if I know its name but don't know the path? FilenameIndex.getFilesByName() How do I find where a particular PSI element is used? ReferencesSearch.search() How do I rename a PSI element? RefactoringFactory.createRename() How can I cause the PSI for a virtual file to be rebuilt? FileContentUtil.reparseFiles() Java Specific How do I find all inheritors of a class? ClassInheritorsSearch.search() How do I find a class by qualified name? JavaPsiFacade.findClass() How do I find a class by short name? PsiShortNamesCache.getInstance().getClassesByName() How do I find a superclass of a Java class? PsiClass.getSuperClass() How do I get a reference to the containing package of a Java class? PsiJavaFile javaFile = ( PsiJavaFile ) psiClass . getContainingFile (); PsiPackage pkg = JavaPsiFacade . getInstance ( project ). findPackage ( javaFile . getPackageName ()); or com.intellij.psi.util.PsiUtil.getPackageName() How do I find the methods overriding a specific method? OverridingMethodsSearch.search()","title":"PSI Cookbook"},{"location":"basics/psi_cookbook/#how-do-i-find-a-file-if-i-know-its-name-but-dont-know-the-path","text":"FilenameIndex.getFilesByName()","title":"How do I find a file if I know its name but don't know the path?"},{"location":"basics/psi_cookbook/#how-do-i-find-where-a-particular-psi-element-is-used","text":"ReferencesSearch.search()","title":"How do I find where a particular PSI element is used?"},{"location":"basics/psi_cookbook/#how-do-i-rename-a-psi-element","text":"RefactoringFactory.createRename()","title":"How do I rename a PSI element?"},{"location":"basics/psi_cookbook/#how-can-i-cause-the-psi-for-a-virtual-file-to-be-rebuilt","text":"FileContentUtil.reparseFiles()","title":"How can I cause the PSI for a virtual file to be rebuilt?"},{"location":"basics/psi_cookbook/#java-specific","text":"","title":"Java Specific"},{"location":"basics/psi_cookbook/#how-do-i-find-all-inheritors-of-a-class","text":"ClassInheritorsSearch.search()","title":"How do I find all inheritors of a class?"},{"location":"basics/psi_cookbook/#how-do-i-find-a-class-by-qualified-name","text":"JavaPsiFacade.findClass()","title":"How do I find a class by qualified name?"},{"location":"basics/psi_cookbook/#how-do-i-find-a-class-by-short-name","text":"PsiShortNamesCache.getInstance().getClassesByName()","title":"How do I find a class by short name?"},{"location":"basics/psi_cookbook/#how-do-i-find-a-superclass-of-a-java-class","text":"PsiClass.getSuperClass()","title":"How do I find a superclass of a Java class?"},{"location":"basics/psi_cookbook/#how-do-i-get-a-reference-to-the-containing-package-of-a-java-class","text":"PsiJavaFile javaFile = ( PsiJavaFile ) psiClass . getContainingFile (); PsiPackage pkg = JavaPsiFacade . getInstance ( project ). findPackage ( javaFile . getPackageName ()); or com.intellij.psi.util.PsiUtil.getPackageName()","title":"How do I get a reference to the containing package of a Java class?"},{"location":"basics/psi_cookbook/#how-do-i-find-the-methods-overriding-a-specific-method","text":"OverridingMethodsSearch.search()","title":"How do I find the methods overriding a specific method?"},{"location":"basics/run_configurations/","text":"Run Configurations allow users to run specific external processes from within the IDE, e.g., a script, an application, a server, etc. You can provide the UI for the user to specify execution options, and an option to create a run configuration based on a specific location in the source code. Architectural Overview Classes used to manipulate run configurations can be split into the following groups: Run configuration management . This includes creation, persistence, and modification. Execution . This diagram shows the main classes: See Run Configurations Tutorial for a fully working sample.","title":"Overview"},{"location":"basics/run_configurations/#architectural-overview","text":"Classes used to manipulate run configurations can be split into the following groups: Run configuration management . This includes creation, persistence, and modification. Execution . This diagram shows the main classes: See Run Configurations Tutorial for a fully working sample.","title":"Architectural Overview"},{"location":"basics/settings/","text":"Introduction to Settings Settings are but one application of the Consulo Persistence Model . For more information, see: * Settings Guide for information about Settings Extension Points and implementations. * Custom Settings Groups for information about creating custom Settings groups and parent-child relationships. * Settings Tutorial for step-by-step instructions for creating a simple set of custom Settings.","title":"Overview"},{"location":"basics/settings/#introduction-to-settings","text":"Settings are but one application of the Consulo Persistence Model . For more information, see: * Settings Guide for information about Settings Extension Points and implementations. * Custom Settings Groups for information about creating custom Settings groups and parent-child relationships. * Settings Tutorial for step-by-step instructions for creating a simple set of custom Settings.","title":"Introduction to Settings"},{"location":"basics/templates/","text":"Live Templates Adding Live Templates to a Plugin Creating New Functions for Live Templates Surround Templates File Templates","title":"Overview"},{"location":"basics/types_of_plugins/","text":"Products based on the Consulo can be modified and adjusted for custom purposes by adding plugins. All downloadable plugins are available at the JetBrains Plugins Repository . The most common types of plugins include: UI Themes Custom language support Framework integration Tool integration User interface add-ons UI Themes UI Themes give designers the ability to customize the appearance of built-in IDE UI elements. Custom UI Themes can: substitute icons, change the colors of icons and UI controls, alter the borders and insets of UI controls, provide custom editor schemes, add background images. The UI Themes available for download illustrate the creative possibilities. Custom Language Support Custom language support provides basic functionality for working with a particular programming language, that includes: File type recognition Lexical analysis Syntax highlighting Formatting Code insight and code completion Inspections and quick-fixes Intention actions Plugins can also augment existing (bundled) custom languages, e.g., by providing additional inspections, intentions, or any other features. Refer to the Custom Language Support Tutorial to learn more about the topic. Framework Integration Framework integration consists of improved code insight features, which are typical for a given framework, as well as the option to use framework-specific functionality directly from the IDE. Sometimes it also includes language support elements for a custom syntax or DSL. Specific code insight Direct access to framework-specific functionality Refer to the Struts 2 plugin as an example of framework integration. More reference plugins can be found on JetBrains Plugins Repository . Tool Integration Tool integration makes it possible to manipulate third-party tools and components directly from the IDE without switching contexts, that implies: Implementation of additional actions Related UI components Access to external resources Refer to the Gerrit integration plugin as an example. User Interface Add-Ons Plugins in this category apply various changes to the standard user interface of the IDE. Some newly added components are interactive and provide new functionality, while others are limited to visual modifications only. The Random Background plugin may serve as an example.","title":"Main Types of Plugins"},{"location":"basics/types_of_plugins/#ui-themes","text":"UI Themes give designers the ability to customize the appearance of built-in IDE UI elements. Custom UI Themes can: substitute icons, change the colors of icons and UI controls, alter the borders and insets of UI controls, provide custom editor schemes, add background images. The UI Themes available for download illustrate the creative possibilities.","title":"UI Themes"},{"location":"basics/types_of_plugins/#custom-language-support","text":"Custom language support provides basic functionality for working with a particular programming language, that includes: File type recognition Lexical analysis Syntax highlighting Formatting Code insight and code completion Inspections and quick-fixes Intention actions Plugins can also augment existing (bundled) custom languages, e.g., by providing additional inspections, intentions, or any other features. Refer to the Custom Language Support Tutorial to learn more about the topic.","title":"Custom Language Support"},{"location":"basics/types_of_plugins/#framework-integration","text":"Framework integration consists of improved code insight features, which are typical for a given framework, as well as the option to use framework-specific functionality directly from the IDE. Sometimes it also includes language support elements for a custom syntax or DSL. Specific code insight Direct access to framework-specific functionality Refer to the Struts 2 plugin as an example of framework integration. More reference plugins can be found on JetBrains Plugins Repository .","title":"Framework Integration"},{"location":"basics/types_of_plugins/#tool-integration","text":"Tool integration makes it possible to manipulate third-party tools and components directly from the IDE without switching contexts, that implies: Implementation of additional actions Related UI components Access to external resources Refer to the Gerrit integration plugin as an example.","title":"Tool Integration"},{"location":"basics/types_of_plugins/#user-interface-add-ons","text":"Plugins in this category apply various changes to the standard user interface of the IDE. Some newly added components are interactive and provide new functionality, while others are limited to visual modifications only. The Random Background plugin may serve as an example.","title":"User Interface Add-Ons"},{"location":"basics/virtual_file_system/","text":"The virtual file system (VFS) is a component of the Consulo that encapsulates most of its activity for working with files represented as Virtual File . It serves the following main purposes: Providing a universal API for working with files regardless of their actual location (on disk, in an archive, on an HTTP server, etc.) Tracking file modifications and providing both old and new versions of the file content when a change is detected. Providing a possibility to associate additional persistent data with a file in the VFS. To provide the last two features, the VFS manages a persistent snapshot of some of the user's hard disk contents. The snapshot stores only those files which have been requested at least once through the VFS API, and is asynchronously updated to match the changes happening on the disk. The snapshot is application level, not project level - so, if some file (for example, a class in the JDK) is referenced by multiple projects, only one copy of its contents will be stored in the VFS. All VFS access operations go through the snapshot. If some information is requested through the VFS APIs and is not available in the snapshot, it is loaded from disk and stored into the snapshot. If the information is available in the snapshot, the snapshot data is returned. The contents of files and the lists of files in directories are stored in the snapshot only if that specific information was accessed. Otherwise, only file metadata like name, length, timestamp, attributes are stored. NOTE This means that the state of the file system and the file contents displayed in the Consulo UI comes from the snapshot, which may not always match the disk's actual contents. For example, in some cases, deleted files can still be visible in the UI for some time before the deletion is picked up by the Consulo. The snapshot is updated from disk during refresh operations , which generally happen asynchronously. All write operations made through the VFS are synchronous - i.e., the contents are saved to disk immediately. A refresh operation synchronizes the state of a part of the VFS with the actual disk contents. Refresh operations are explicitly invoked by the Consulo or plugin code - i.e., when a file is changed on disk while the IDE is running, the change will not be immediately picked up by the VFS. The VFS will be updated during the next refresh operation, which includes the file in its scope. Consulo refreshes the entire project contents asynchronously on startup. By default, it performs a refresh operation when the user switches to it from another app. Still, users can turn this off via Settings | Appearance & Behavior | System Settings | Synchronize external changes [...] . On Windows, Mac, and Linux, a native file watcher process is started that receives file change notifications from the file system and reports them to the Consulo . If a file watcher is available, a refresh operation looks only at the files that have been reported as changed by the file watcher. If no file watcher is present, a refresh operation walks through all directories and files in the refresh scope. Refresh operations are based on file timestamps. If a file's contents were changed, but its timestamp remained the same, the Consulo will not pick up the updated contents. There is currently no facility for removing files from the snapshot. If a file was loaded there once, it remains there forever unless it was deleted from the disk, and a refresh operation was called on one of its parent directories. The VFS itself does not honor ignored files listed in Settings | Editor | File Types and folders to ignore and excluded folders listed in Project Structure | Modules | Sources | Excluded . If the application code accesses them, the VFS will load and return their contents. In most cases, the ignored files and excluded folders must be skipped from processing by higher-level code. During the lifetime of a running instance of an Consulo IDE, multiple VirtualFile instances may correspond to the same disk file. They are equal, have the same hashCode , and share the user data. Synchronous and Asynchronous Refreshes From the point of view of the caller, refresh operations can be either synchronous or asynchronous. In fact, the refresh operations are executed according to their own threading policy. The synchronous flag simply means that the calling thread will be blocked until the refresh operation (which will most likely run on a different thread) is completed. Both synchronous and asynchronous refreshes can be initiated from any thread. If a refresh is initiated from a background thread, the calling thread must not hold a read action, because otherwise, a deadlock would occur. See Consulo Architectural Overview for more details on the threading model and read/write actions. The same threading requirements also apply to functions like LocalFileSystem.refreshAndFindFileByPath() , which perform a partial refresh if the file with the specified path is not found in the snapshot. In nearly all cases, using asynchronous refreshes is strongly preferred. If there is some code that needs to be executed after the refresh is complete, the code should be passed as a postRunnable parameter to one of the refresh methods: RefreshQueue.createSession() VirtualFile.refresh() In some cases, synchronous refreshes can cause deadlocks, depending on which locks are held by the thread invoking the refresh operation. Virtual File System Events All changes happening in the virtual file system, either due to refresh operations or caused by user actions, are reported as virtual file system events . VFS events are always fired in the event dispatch thread and in a write action. The most efficient way to listen to VFS events is to implement BulkFileListener and to subscribe with it to the VirtualFileManager.VFS_CHANGES topic. A non-blocking variant AsyncFileListener is also available in 2019.2 or later. See How do I get notified when VFS changes? for implementation details. WARNING VFS listeners are application level and will receive events for changes happening in all the projects opened by the user. You may need to filter out events that aren't relevant to your task (e.g., via ProjectFileIndex.isInContent() ). VFS events are sent both before and after each change, and you can access the old contents of the file in the before event. Note that events caused by a refresh are sent after the changes have already occurred on disk. So when you process the beforeFileDeletion event, for example, the file has already been deleted from disk. However, it is still present in the VFS snapshot, and you can access its last contents using the VFS API. Note that a refresh operation fires events only for changes in files that have been loaded in the snapshot. For example, if you accessed a VirtualFile for a directory but never loaded its contents using VirtualFile.getChildren() , you may not get fileCreated notifications when files are created in that directory. If you loaded only a single file in a directory using VirtualFile.findChild() , you will get notifications for changes to that file, but you may not get created/deleted notifications for other files in the same directory.","title":"Virtual File System"},{"location":"basics/virtual_file_system/#synchronous-and-asynchronous-refreshes","text":"From the point of view of the caller, refresh operations can be either synchronous or asynchronous. In fact, the refresh operations are executed according to their own threading policy. The synchronous flag simply means that the calling thread will be blocked until the refresh operation (which will most likely run on a different thread) is completed. Both synchronous and asynchronous refreshes can be initiated from any thread. If a refresh is initiated from a background thread, the calling thread must not hold a read action, because otherwise, a deadlock would occur. See Consulo Architectural Overview for more details on the threading model and read/write actions. The same threading requirements also apply to functions like LocalFileSystem.refreshAndFindFileByPath() , which perform a partial refresh if the file with the specified path is not found in the snapshot. In nearly all cases, using asynchronous refreshes is strongly preferred. If there is some code that needs to be executed after the refresh is complete, the code should be passed as a postRunnable parameter to one of the refresh methods: RefreshQueue.createSession() VirtualFile.refresh() In some cases, synchronous refreshes can cause deadlocks, depending on which locks are held by the thread invoking the refresh operation.","title":"Synchronous and Asynchronous Refreshes"},{"location":"basics/virtual_file_system/#virtual-file-system-events","text":"All changes happening in the virtual file system, either due to refresh operations or caused by user actions, are reported as virtual file system events . VFS events are always fired in the event dispatch thread and in a write action. The most efficient way to listen to VFS events is to implement BulkFileListener and to subscribe with it to the VirtualFileManager.VFS_CHANGES topic. A non-blocking variant AsyncFileListener is also available in 2019.2 or later. See How do I get notified when VFS changes? for implementation details. WARNING VFS listeners are application level and will receive events for changes happening in all the projects opened by the user. You may need to filter out events that aren't relevant to your task (e.g., via ProjectFileIndex.isInContent() ). VFS events are sent both before and after each change, and you can access the old contents of the file in the before event. Note that events caused by a refresh are sent after the changes have already occurred on disk. So when you process the beforeFileDeletion event, for example, the file has already been deleted from disk. However, it is still present in the VFS snapshot, and you can access its last contents using the VFS API. Note that a refresh operation fires events only for changes in files that have been loaded in the snapshot. For example, if you accessed a VirtualFile for a directory but never loaded its contents using VirtualFile.getChildren() , you may not get fileCreated notifications when files are created in that directory. If you loaded only a single file in a directory using VirtualFile.findChild() , you will get notifications for changes to that file, but you may not get created/deleted notifications for other files in the same directory.","title":"Virtual File System Events"},{"location":"basics/architectural_overview/documents/","text":"A Document is an editable sequence of Unicode characters, typically corresponding to the text contents of a virtual file . Line breaks in a document are always normalized to \\n . The Consulo handles encoding and line break conversions when loading and saving documents transparently. How do I get a document? From an action : e.getData(PlatformDataKeys.EDITOR).getDocument() From a virtual file : FileDocumentManager.getDocument() . This call forces the document content to be loaded from disk if it wasn't loaded previously. If only open documents or documents which may have been modified are considered relevant, use FileDocumentManager.getCachedDocument() instead. From a PSI file : PsiDocumentManager.getInstance().getDocument() or PsiDocumentManager.getInstance().getCachedDocument() What can I do with a Document? You may perform any operations that access or modify the file contents on the \"plain text\" level (as a sequence of characters, not as a tree of PSI elements). Where does a Document come from? Document instances are created when some operation needs to access the text contents of a file (in particular, this is necessary to build the PSI for a file). Also, document instances not linked to any virtual files can be created temporarily, for example, representing the contents of a text editor field in a dialog. How long does a Document persist? Document instances are weakly referenced from VirtualFile instances. Thus, an unmodified Document instance can be garbage-collected if no one references it, and a new instance is created if the document contents are reaccessed later. WARNING Storing Document references in long-term data structures of a plugin will cause memory leaks. How do I create a Document? For creating a new file on disk, please do not create a Document but a PSI file and get its Document . To create a Document instance that isn't bound to anything, use EditorFactory.createDocument() . How do I get notified when Documents change? Document.addDocumentListener() allows receiving notifications about changes in a particular Document instance. EditorFactory.getEventMulticaster().addDocumentListener() allows receiving notifications about changes in all open documents. Subscribe to AppTopics.FILE_DOCUMENT_SYNC on any level bus to receive notifications when a Document is saved or reloaded from disk. What are the rules of working with Documents? The general read/write action rules are in effect. Besides, any operations which modify the contents of the document must be wrapped in a command ( CommandProcessor.getInstance().executeCommand() ). executeCommand() calls can be nested, and the outermost executeCommand() call is added to the undo stack. If multiple documents are modified within a command, undoing this command will, by default, show a confirmation dialog to the user. If the file corresponding to a Document is read-only (for example, not checked out from the version control system), document modifications will fail. Thus, before modifying the Document , it is necessary to call ReadonlyStatusHandler.getInstance(project).ensureFilesWritable() to check out the file. All text strings passed to Document modification methods ( setText() , insertString() , replaceString() ) must use only \\n as line separators. Are there any utilities available for working with Documents? DocumentUtil contains utility methods for Document processing. This allows you to get information like the text offsets of particular lines. This is particularly useful when you need text location/offset information about a given PsiElement .","title":"Documents"},{"location":"basics/architectural_overview/documents/#how-do-i-get-a-document","text":"From an action : e.getData(PlatformDataKeys.EDITOR).getDocument() From a virtual file : FileDocumentManager.getDocument() . This call forces the document content to be loaded from disk if it wasn't loaded previously. If only open documents or documents which may have been modified are considered relevant, use FileDocumentManager.getCachedDocument() instead. From a PSI file : PsiDocumentManager.getInstance().getDocument() or PsiDocumentManager.getInstance().getCachedDocument()","title":"How do I get a document?"},{"location":"basics/architectural_overview/documents/#what-can-i-do-with-a-document","text":"You may perform any operations that access or modify the file contents on the \"plain text\" level (as a sequence of characters, not as a tree of PSI elements).","title":"What can I do with a Document?"},{"location":"basics/architectural_overview/documents/#where-does-a-document-come-from","text":"Document instances are created when some operation needs to access the text contents of a file (in particular, this is necessary to build the PSI for a file). Also, document instances not linked to any virtual files can be created temporarily, for example, representing the contents of a text editor field in a dialog.","title":"Where does a Document come from?"},{"location":"basics/architectural_overview/documents/#how-long-does-a-document-persist","text":"Document instances are weakly referenced from VirtualFile instances. Thus, an unmodified Document instance can be garbage-collected if no one references it, and a new instance is created if the document contents are reaccessed later. WARNING Storing Document references in long-term data structures of a plugin will cause memory leaks.","title":"How long does a Document persist?"},{"location":"basics/architectural_overview/documents/#how-do-i-create-a-document","text":"For creating a new file on disk, please do not create a Document but a PSI file and get its Document . To create a Document instance that isn't bound to anything, use EditorFactory.createDocument() .","title":"How do I create a Document?"},{"location":"basics/architectural_overview/documents/#how-do-i-get-notified-when-documents-change","text":"Document.addDocumentListener() allows receiving notifications about changes in a particular Document instance. EditorFactory.getEventMulticaster().addDocumentListener() allows receiving notifications about changes in all open documents. Subscribe to AppTopics.FILE_DOCUMENT_SYNC on any level bus to receive notifications when a Document is saved or reloaded from disk.","title":"How do I get notified when Documents change?"},{"location":"basics/architectural_overview/documents/#what-are-the-rules-of-working-with-documents","text":"The general read/write action rules are in effect. Besides, any operations which modify the contents of the document must be wrapped in a command ( CommandProcessor.getInstance().executeCommand() ). executeCommand() calls can be nested, and the outermost executeCommand() call is added to the undo stack. If multiple documents are modified within a command, undoing this command will, by default, show a confirmation dialog to the user. If the file corresponding to a Document is read-only (for example, not checked out from the version control system), document modifications will fail. Thus, before modifying the Document , it is necessary to call ReadonlyStatusHandler.getInstance(project).ensureFilesWritable() to check out the file. All text strings passed to Document modification methods ( setText() , insertString() , replaceString() ) must use only \\n as line separators.","title":"What are the rules of working with Documents?"},{"location":"basics/architectural_overview/documents/#are-there-any-utilities-available-for-working-with-documents","text":"DocumentUtil contains utility methods for Document processing. This allows you to get information like the text offsets of particular lines. This is particularly useful when you need text location/offset information about a given PsiElement .","title":"Are there any utilities available for working with Documents?"},{"location":"basics/architectural_overview/file_view_providers/","text":"A file view provider ( FileViewProvider ) manages access to multiple PSI trees within a single file. For example, a JSPX page has a separate PSI tree for the Java code in it ( PsiJavaFile ), a separate tree for the XML code ( XmlFile ), and a separate tree for JSP as a whole ( JspFile ). Each of the PSI trees covers the entire contents of the file and contains special \"outer language elements\" in the places where contents in a different language can be found. A FileViewProvider instance corresponds to a single VirtualFile , a single Document , and can retrieve multiple PsiFile instances. How do I get a FileViewProvider? From a VirtualFile : PsiManager.getInstance(project).findViewProvider() From a PsiFile : psiFile.getViewProvider() What can I do with a FileViewProvider? To get the set of all languages for which PSI trees exist in a file: fileViewProvider.getLanguages() To get the PSI tree for a particular language: fileViewProvider.getPsi(language) . For example, to get the PSI tree for XML, use fileViewProvider.getPsi(XMLLanguage.INSTANCE) . To find an element of a particular language at the specified offset in the file: fileViewProvider.findElementAt(offset, language) How do I extend the FileViewProvider? To create a file type that has multiple interspersing trees for different languages, a plugin must contain an extension to the com.intellij.fileType.fileViewProviderFactory extension point. Implement FileViewProviderFactory and return your FileViewProvider implementation from createFileViewProvider() method. Register as follows in plugin.xml : <extensions defaultExtensionNs= \"com.intellij\" > <fileType.fileViewProviderFactory filetype= \"%file_type%\" implementationClass= \"com.plugin.MyFileViewProviderFactory\" /> </extensions> Where %file_type% refers to the type of the file being created (for example, \"JFS\").","title":"File View Providers"},{"location":"basics/architectural_overview/file_view_providers/#how-do-i-get-a-fileviewprovider","text":"From a VirtualFile : PsiManager.getInstance(project).findViewProvider() From a PsiFile : psiFile.getViewProvider()","title":"How do I get a FileViewProvider?"},{"location":"basics/architectural_overview/file_view_providers/#what-can-i-do-with-a-fileviewprovider","text":"To get the set of all languages for which PSI trees exist in a file: fileViewProvider.getLanguages() To get the PSI tree for a particular language: fileViewProvider.getPsi(language) . For example, to get the PSI tree for XML, use fileViewProvider.getPsi(XMLLanguage.INSTANCE) . To find an element of a particular language at the specified offset in the file: fileViewProvider.findElementAt(offset, language)","title":"What can I do with a FileViewProvider?"},{"location":"basics/architectural_overview/file_view_providers/#how-do-i-extend-the-fileviewprovider","text":"To create a file type that has multiple interspersing trees for different languages, a plugin must contain an extension to the com.intellij.fileType.fileViewProviderFactory extension point. Implement FileViewProviderFactory and return your FileViewProvider implementation from createFileViewProvider() method. Register as follows in plugin.xml : <extensions defaultExtensionNs= \"com.intellij\" > <fileType.fileViewProviderFactory filetype= \"%file_type%\" implementationClass= \"com.plugin.MyFileViewProviderFactory\" /> </extensions> Where %file_type% refers to the type of the file being created (for example, \"JFS\").","title":"How do I extend the FileViewProvider?"},{"location":"basics/architectural_overview/files/","text":"Virtual File System Virtual Files","title":"Overview"},{"location":"basics/architectural_overview/general_threading_rules/","text":"Read/Write Lock In general, code-related data structures in the Consulo are covered by a single reader/writer lock. You must not access the model outside a read or write action for the following subsystems: - Program Structure Interface (PSI) - Virtual File System (VFS) - Project root model . Reading data is allowed from any thread. Reading data from the UI thread does not require any special effort. However, read operations performed from any other thread need to be wrapped in a read action by using ApplicationManager.getApplication().runReadAction() or, shorter, ReadAction run() / compute() . The corresponding objects are not guaranteed to survive between several consecutive read actions. As a rule of thumb, whenever starting a read action, check if the PSI/VFS/project/module is still valid. Writing data is only allowed from the UI thread, and write operations always need to be wrapped in a write action with ApplicationManager.getApplication().runWriteAction() or, shorter, WriteAction run() / compute() . Modifying the model is only allowed from write-safe contexts, including user actions and invokeLater() calls from them (see the next section). You may not modify PSI, VFS, or project model from inside UI renderers or SwingUtilities.invokeLater() calls. Modality and invokeLater() To pass control from a background thread to the Event Dispatch Thread (EDT), instead of the standard SwingUtilities.invokeLater() , plugins should use ApplicationManager.getApplication().invokeLater() . The latter API allows specifying the modality state ( ModalityState ) for the call, i.e., the stack of modal dialogs under which the call is allowed to execute: ModalityState.NON_MODAL : The operation will be executed after all modal dialogs are closed. If any of the open (unrelated) project displays a per-project modal dialog, the action will be performed after the dialog is closed. ModalityState.stateForComponent() : The operation can be executed when the topmost shown dialog is the one that contains the specified component or is one of its parent dialogs. None specified : ModalityState.defaultModalityState() will be used. This is the optimal choice in most cases that uses the current modality state when invoked from UI thread. It has special handling for background processes started with ProgressManager : invokeLater() from such a process may run in the same dialog that the process started. ModalityState.any() : The operation will be executed as soon as possible regardless of modal dialogs. Please note that modifying PSI, VFS, or project model is prohibited from such runnables. If a UI thread activity needs to access file-based index (e.g., it's doing any project-wide PSI analysis, resolves references, etc.), please use DumbService.smartInvokeLater() . That way, it is run after all possible indexing processes have been completed. Background processes and ProcessCanceledException Background progresses are managed by ProgressManager class, which has plenty of methods to execute the given code with a modal (dialog), non-modal (visible in the status bar), or invisible progress. In all cases, the code is executed on a background thread, which is associated with a ProgressIndicator object. The current thread's indicator can be retrieved any time via ProgressIndicatorProvider.getGlobalProgressIndicator() . For visible progresses, threads can use ProgressIndicator to notify the user about current status: e.g., set text or visual fraction of the work done. Progress indicators also provide means to handle cancellation of background processes, either by the user (pressing the Cancel button) or from code (e.g., when the current operation becomes obsolete due to some changes in the project). The progress can be marked as canceled by calling ProgressIndicator.cancel() . The process reacts to this by calling ProgressIndicator.checkCanceled() (or ProgressManager.checkCanceled() if no indicator instance at hand). This call throws a special unchecked ProcessCanceledException if the background process has been canceled. All code working with PSI, or in other kinds of background processes, must be prepared for ProcessCanceledException being thrown from any point. This exception should never be logged but rethrown, and it'll be handled in the infrastructure that started the process. The checkCanceled() should be called often enough to guarantee the process's smooth cancellation. PSI internals have a lot of checkCanceled() calls inside. If a process does lengthy non-PSI activity, insert explicit checkCanceled() calls so that it happens frequently, e.g., on each Nth loop iteration. Read Action Cancellability Background threads shouldn't take plain read actions for a long time. The reason is that if the UI thread needs a write action (e.g., the user types something), it must be acquired as soon as possible. Otherwise, the UI will freeze until all background threads have released their read actions. The best-known approach is to cancel background read actions whenever there's a write action about to occur, and restart that background read action later from scratch. Editor highlighting, code completion, Goto Class/File/... actions all work like this. To achieve that, the lengthy background operation is started with a ProgressIndicator , and a dedicated listener cancels that indicator when write action is initiated. The next time the background thread calls checkCanceled() , a ProcessCanceledException is thrown, and the thread should stop its operation (and finish the read action) as soon as possible. There are two recommended ways of doing this: If on UI thread, call ReadAction.nonBlocking() which returns NonBlockingReadAction If already in a background thread, use ProgressManager.getInstance().runInReadActionWithWriteActionPriority() in a loop, until it passes or the whole activity becomes obsolete. In both approaches, always check at the start of each read action, if the objects are still valid, and if the whole operation still makes sense (i.e., not canceled by the user, the project isn't closed, etc.). With ReadAction.nonBlocking() , use expireWith() or expireWhen() for that. If the activity has to access file-based index (e.g., it's doing any project-wide PSI analysis, resolves references, etc.), use ReadAction.nonBlocking(...).inSmartMode() .","title":"Overview"},{"location":"basics/architectural_overview/general_threading_rules/#readwrite-lock","text":"In general, code-related data structures in the Consulo are covered by a single reader/writer lock. You must not access the model outside a read or write action for the following subsystems: - Program Structure Interface (PSI) - Virtual File System (VFS) - Project root model . Reading data is allowed from any thread. Reading data from the UI thread does not require any special effort. However, read operations performed from any other thread need to be wrapped in a read action by using ApplicationManager.getApplication().runReadAction() or, shorter, ReadAction run() / compute() . The corresponding objects are not guaranteed to survive between several consecutive read actions. As a rule of thumb, whenever starting a read action, check if the PSI/VFS/project/module is still valid. Writing data is only allowed from the UI thread, and write operations always need to be wrapped in a write action with ApplicationManager.getApplication().runWriteAction() or, shorter, WriteAction run() / compute() . Modifying the model is only allowed from write-safe contexts, including user actions and invokeLater() calls from them (see the next section). You may not modify PSI, VFS, or project model from inside UI renderers or SwingUtilities.invokeLater() calls.","title":"Read/Write Lock"},{"location":"basics/architectural_overview/general_threading_rules/#modality-and-invokelater","text":"To pass control from a background thread to the Event Dispatch Thread (EDT), instead of the standard SwingUtilities.invokeLater() , plugins should use ApplicationManager.getApplication().invokeLater() . The latter API allows specifying the modality state ( ModalityState ) for the call, i.e., the stack of modal dialogs under which the call is allowed to execute: ModalityState.NON_MODAL : The operation will be executed after all modal dialogs are closed. If any of the open (unrelated) project displays a per-project modal dialog, the action will be performed after the dialog is closed. ModalityState.stateForComponent() : The operation can be executed when the topmost shown dialog is the one that contains the specified component or is one of its parent dialogs. None specified : ModalityState.defaultModalityState() will be used. This is the optimal choice in most cases that uses the current modality state when invoked from UI thread. It has special handling for background processes started with ProgressManager : invokeLater() from such a process may run in the same dialog that the process started. ModalityState.any() : The operation will be executed as soon as possible regardless of modal dialogs. Please note that modifying PSI, VFS, or project model is prohibited from such runnables. If a UI thread activity needs to access file-based index (e.g., it's doing any project-wide PSI analysis, resolves references, etc.), please use DumbService.smartInvokeLater() . That way, it is run after all possible indexing processes have been completed.","title":"Modality and invokeLater()"},{"location":"basics/architectural_overview/general_threading_rules/#background-processes-and-processcanceledexception","text":"Background progresses are managed by ProgressManager class, which has plenty of methods to execute the given code with a modal (dialog), non-modal (visible in the status bar), or invisible progress. In all cases, the code is executed on a background thread, which is associated with a ProgressIndicator object. The current thread's indicator can be retrieved any time via ProgressIndicatorProvider.getGlobalProgressIndicator() . For visible progresses, threads can use ProgressIndicator to notify the user about current status: e.g., set text or visual fraction of the work done. Progress indicators also provide means to handle cancellation of background processes, either by the user (pressing the Cancel button) or from code (e.g., when the current operation becomes obsolete due to some changes in the project). The progress can be marked as canceled by calling ProgressIndicator.cancel() . The process reacts to this by calling ProgressIndicator.checkCanceled() (or ProgressManager.checkCanceled() if no indicator instance at hand). This call throws a special unchecked ProcessCanceledException if the background process has been canceled. All code working with PSI, or in other kinds of background processes, must be prepared for ProcessCanceledException being thrown from any point. This exception should never be logged but rethrown, and it'll be handled in the infrastructure that started the process. The checkCanceled() should be called often enough to guarantee the process's smooth cancellation. PSI internals have a lot of checkCanceled() calls inside. If a process does lengthy non-PSI activity, insert explicit checkCanceled() calls so that it happens frequently, e.g., on each Nth loop iteration.","title":"Background processes and ProcessCanceledException"},{"location":"basics/architectural_overview/general_threading_rules/#read-action-cancellability","text":"Background threads shouldn't take plain read actions for a long time. The reason is that if the UI thread needs a write action (e.g., the user types something), it must be acquired as soon as possible. Otherwise, the UI will freeze until all background threads have released their read actions. The best-known approach is to cancel background read actions whenever there's a write action about to occur, and restart that background read action later from scratch. Editor highlighting, code completion, Goto Class/File/... actions all work like this. To achieve that, the lengthy background operation is started with a ProgressIndicator , and a dedicated listener cancels that indicator when write action is initiated. The next time the background thread calls checkCanceled() , a ProcessCanceledException is thrown, and the thread should stop its operation (and finish the read action) as soon as possible. There are two recommended ways of doing this: If on UI thread, call ReadAction.nonBlocking() which returns NonBlockingReadAction If already in a background thread, use ProgressManager.getInstance().runInReadActionWithWriteActionPriority() in a loop, until it passes or the whole activity becomes obsolete. In both approaches, always check at the start of each read action, if the objects are still valid, and if the whole operation still makes sense (i.e., not canceled by the user, the project isn't closed, etc.). With ReadAction.nonBlocking() , use expireWith() or expireWhen() for that. If the activity has to access file-based index (e.g., it's doing any project-wide PSI analysis, resolves references, etc.), use ReadAction.nonBlocking(...).inSmartMode() .","title":"Read Action Cancellability"},{"location":"basics/architectural_overview/modifying_psi/","text":"The PSI is a read-write representation of the source code as a tree of elements corresponding to a source file's structure. You can modify the PSI by adding , replacing , and deleting PSI elements. To perform these operations, you use methods such as PsiElement.add() , PsiElement.delete() , and PsiElement.replace() , as well as other methods defined in the PsiElement interface that let you process multiple elements in a single operation, or to specify the exact location in the tree where an element needs to be added. Like document operations, PSI modifications need to be wrapped in a write action and in command (and can only be performed in the event dispatch thread). See the Documents article for more information on commands and write actions. Creating the New PSI The PSI elements to add to the tree or replace existing PSI elements are usually created from text . In the most general case, you use the createFileFromText() method of PsiFileFactory to create a new file that contains the code construct which you need to add to the tree or to use as a replacement for an existing element, traverse the resulting tree to locate the specific part that you need, and then pass that element to add() or replace() . Most languages provide factory methods that let you create specific code constructs more easily. For example, the PsiJavaParserFacade class contains methods such as createMethodFromText() , which creates a Java method from the given text. When you're implementing refactorings, intentions, or inspection quickfixes that work with existing code, the text that you pass to the various createFromText() methods will combine hard-coded fragments and fragments of code taken from the existing file. For small code fragments (individual identifiers), you can simply append the text from the existing code to the text of the code fragment you're building. In that case, you need to make sure that the resulting text is syntactically correct. Otherwise the createFromText() method will throw an exception. For larger code fragments, it's best to perform the modification in several steps: create a replacement tree fragment from the text, leaving placeholders for the user code fragments; replace the placeholders with the user code fragments; replace the element in the original source file with the replacement tree. This ensures that the user code's formatting is preserved and that the modification doesn't introduce any unwanted whitespace changes. As an example of this approach, see the quickfix in the ComparingReferencesInspection example: // binaryExpression holds a PSI expression of the form \"x == y\", which needs to be replaced with \"x.equals(y)\" PsiBinaryExpression binaryExpression = ( PsiBinaryExpression ) descriptor . getPsiElement (); IElementType opSign = binaryExpression . getOperationTokenType (); PsiExpression lExpr = binaryExpression . getLOperand (); PsiExpression rExpr = binaryExpression . getROperand (); // Step 1: Create a replacement fragment from text, with \"a\" and \"b\" as placeholders PsiElementFactory factory = JavaPsiFacade . getInstance ( project ). getElementFactory (); PsiMethodCallExpression equalsCall = ( PsiMethodCallExpression ) factory . createExpressionFromText ( \"a.equals(b)\" , null ); // Step 2: replace \"a\" and \"b\" with elements from the original file equalsCall . getMethodExpression (). getQualifierExpression (). replace ( lExpr ); equalsCall . getArgumentList (). getExpressions () [ 0 ] . replace ( rExpr ); // Step 3: replace a larger element in the original file with the replacement tree PsiExpression result = ( PsiExpression ) binaryExpression . replace ( equalsCall ); Just as everywhere else in the Consulo API, the text passed to createFileFromText() and other createFromText() methods must use only \\n as line separators. Maintaining Tree Structure Consistency The PSI modification methods do not restrict you in the way you can build the resulting tree structure. For example, when working with a Java class, you can add a for statement as a direct child of a PsiMethod element, even though the Java parser will never produce such a structure (the for statement will always be a child of the PsiCodeBlock ) representing the method body). Modifications that produce incorrect tree structures may appear to work, but they will lead to problems and exceptions later. Therefore, you always need to ensure that the structure you built with PSI modification operations is the same as what the parser would produce when parsing the code that you've created. To make sure you're not introducing inconsistencies, you can call PsiTestUtil.checkFileStructure() in the tests for your action that modifies the PSI. This method ensures that the structure you've built is the same as what the parser produces. Whitespaces and Imports When working with PSI modification functions, you should never create individual whitespace nodes (spaces or line breaks) from the text. Instead, all whitespace modifications are performed by the formatter, which follows the code style settings selected by the user. Formatting is automatically performed at the end of every command, and if you need, you can also perform it manually using the reformat(PsiElement) method in the CodeStyleManager class. Also, when working with Java code (or with code in other languages with a similar import mechanism such as Groovy or Python), you should never create imports manually. Instead, you should insert fully-qualified names into the code you're generating, and then call the shortenClassReferences() method in the JavaCodeStyleManager (or the equivalent API for the language you're working with). This ensures that the imports are created according to the user's code style settings and inserted into the file's correct place. Combining PSI and Document Modifications In some cases, you need to perform a PSI modification and then to perform an operation on the document you've just modified through the PSI (for example, start a live template). In this case, you need to call a special method that completes the PSI-based post-processing (such as formatting) and commits the changes to the document. The method you need to call is called doPostponedOperationsAndUnblockDocument() , and it's defined in the PsiDocumentManager class.","title":"Modifying the PSI"},{"location":"basics/architectural_overview/modifying_psi/#creating-the-new-psi","text":"The PSI elements to add to the tree or replace existing PSI elements are usually created from text . In the most general case, you use the createFileFromText() method of PsiFileFactory to create a new file that contains the code construct which you need to add to the tree or to use as a replacement for an existing element, traverse the resulting tree to locate the specific part that you need, and then pass that element to add() or replace() . Most languages provide factory methods that let you create specific code constructs more easily. For example, the PsiJavaParserFacade class contains methods such as createMethodFromText() , which creates a Java method from the given text. When you're implementing refactorings, intentions, or inspection quickfixes that work with existing code, the text that you pass to the various createFromText() methods will combine hard-coded fragments and fragments of code taken from the existing file. For small code fragments (individual identifiers), you can simply append the text from the existing code to the text of the code fragment you're building. In that case, you need to make sure that the resulting text is syntactically correct. Otherwise the createFromText() method will throw an exception. For larger code fragments, it's best to perform the modification in several steps: create a replacement tree fragment from the text, leaving placeholders for the user code fragments; replace the placeholders with the user code fragments; replace the element in the original source file with the replacement tree. This ensures that the user code's formatting is preserved and that the modification doesn't introduce any unwanted whitespace changes. As an example of this approach, see the quickfix in the ComparingReferencesInspection example: // binaryExpression holds a PSI expression of the form \"x == y\", which needs to be replaced with \"x.equals(y)\" PsiBinaryExpression binaryExpression = ( PsiBinaryExpression ) descriptor . getPsiElement (); IElementType opSign = binaryExpression . getOperationTokenType (); PsiExpression lExpr = binaryExpression . getLOperand (); PsiExpression rExpr = binaryExpression . getROperand (); // Step 1: Create a replacement fragment from text, with \"a\" and \"b\" as placeholders PsiElementFactory factory = JavaPsiFacade . getInstance ( project ). getElementFactory (); PsiMethodCallExpression equalsCall = ( PsiMethodCallExpression ) factory . createExpressionFromText ( \"a.equals(b)\" , null ); // Step 2: replace \"a\" and \"b\" with elements from the original file equalsCall . getMethodExpression (). getQualifierExpression (). replace ( lExpr ); equalsCall . getArgumentList (). getExpressions () [ 0 ] . replace ( rExpr ); // Step 3: replace a larger element in the original file with the replacement tree PsiExpression result = ( PsiExpression ) binaryExpression . replace ( equalsCall ); Just as everywhere else in the Consulo API, the text passed to createFileFromText() and other createFromText() methods must use only \\n as line separators.","title":"Creating the New PSI"},{"location":"basics/architectural_overview/modifying_psi/#maintaining-tree-structure-consistency","text":"The PSI modification methods do not restrict you in the way you can build the resulting tree structure. For example, when working with a Java class, you can add a for statement as a direct child of a PsiMethod element, even though the Java parser will never produce such a structure (the for statement will always be a child of the PsiCodeBlock ) representing the method body). Modifications that produce incorrect tree structures may appear to work, but they will lead to problems and exceptions later. Therefore, you always need to ensure that the structure you built with PSI modification operations is the same as what the parser would produce when parsing the code that you've created. To make sure you're not introducing inconsistencies, you can call PsiTestUtil.checkFileStructure() in the tests for your action that modifies the PSI. This method ensures that the structure you've built is the same as what the parser produces.","title":"Maintaining Tree Structure Consistency"},{"location":"basics/architectural_overview/modifying_psi/#whitespaces-and-imports","text":"When working with PSI modification functions, you should never create individual whitespace nodes (spaces or line breaks) from the text. Instead, all whitespace modifications are performed by the formatter, which follows the code style settings selected by the user. Formatting is automatically performed at the end of every command, and if you need, you can also perform it manually using the reformat(PsiElement) method in the CodeStyleManager class. Also, when working with Java code (or with code in other languages with a similar import mechanism such as Groovy or Python), you should never create imports manually. Instead, you should insert fully-qualified names into the code you're generating, and then call the shortenClassReferences() method in the JavaCodeStyleManager (or the equivalent API for the language you're working with). This ensures that the imports are created according to the user's code style settings and inserted into the file's correct place.","title":"Whitespaces and Imports"},{"location":"basics/architectural_overview/modifying_psi/#combining-psi-and-document-modifications","text":"In some cases, you need to perform a PSI modification and then to perform an operation on the document you've just modified through the PSI (for example, start a live template). In this case, you need to call a special method that completes the PSI-based post-processing (such as formatting) and commits the changes to the document. The method you need to call is called doPostponedOperationsAndUnblockDocument() , and it's defined in the PsiDocumentManager class.","title":"Combining PSI and Document Modifications"},{"location":"basics/architectural_overview/navigating_psi/","text":"There are three main ways to navigate the PSI: top-down , bottom-up , and references . In the first scenario, you have a PSI file or another higher-level element (for example, a method). You need to find all elements that match a specified condition (for example, all variable declarations). In the second scenario, you have a specific point in the PSI tree (for example, the element at caret) and need to find out something about its context (for example, the element in which it has been declared). Finally, references allow you to navigate from the usages of an element (e.g., a method call) to the declaration (the method being called) and back. References are described in a separate topic . Top-Down Navigation The most common way to perform top-down navigation is to use a visitor . To use a visitor, you create a class (usually an anonymous inner class) that extends the base visitor class, overrides the methods that handle the elements you're interested in, and passes the visitor instance to PsiElement.accept() . The base classes for visitors are language-specific. For example, if you need to process elements in a Java file, you extend JavaRecursiveElementVisitor and override the methods corresponding to the Java element types you're interested in. The following snippet shows the use of a visitor to find all Java local variable declarations: file . accept ( new JavaRecursiveElementVisitor () { @Override public void visitLocalVariable ( PsiLocalVariable variable ) { super . visitLocalVariable ( variable ); System . out . println ( \"Found a variable at offset \" + variable . getTextRange (). getStartOffset ()); } }); In many cases, you can also use more specific APIs for top-down navigation. For example, if you need to get a list of all methods in a Java class, you can use a visitor, but a much easier way to do that is calling PsiClass.getMethods() . PsiTreeUtil contains a number of general-purpose, language-independent functions for PSI tree navigation, some of which (for example, findChildrenOfType() ) perform top-down navigation. Bottom-Up Navigation The starting point for bottom-up navigation is either a specific element in the PSI tree (for example, the result of resolving a reference) or an offset. If you have an offset, you can find the corresponding PSI element by calling PsiFile.findElementAt() . This method returns the element at the lowest level of the tree (for example, an identifier), and you need to navigate the tree up if you want to determine the broader context. In most cases, bottom-up navigation is performed by calling PsiTreeUtil.getParentOfType() . This method goes up the tree until it finds the element of the type you've specified. For example, to find the containing method, you call PsiTreeUtil.getParentOfType(element, PsiMethod.class) . In some cases, you can also use specific navigation methods. For example, to find the class where a method is contained, you call PsiMethod.getContainingClass() . The following snippet shows how these calls can be used together: PsiFile psiFile = anActionEvent . getData ( CommonDataKeys . PSI_FILE ); PsiElement element = psiFile . findElementAt ( offset ); PsiMethod containingMethod = PsiTreeUtil . getParentOfType ( element , PsiMethod . class ); PsiClass containingClass = containingMethod . getContainingClass (); To see how the navigation works in practice, please refer to the code sample .","title":"Navigating the PSI"},{"location":"basics/architectural_overview/navigating_psi/#top-down-navigation","text":"The most common way to perform top-down navigation is to use a visitor . To use a visitor, you create a class (usually an anonymous inner class) that extends the base visitor class, overrides the methods that handle the elements you're interested in, and passes the visitor instance to PsiElement.accept() . The base classes for visitors are language-specific. For example, if you need to process elements in a Java file, you extend JavaRecursiveElementVisitor and override the methods corresponding to the Java element types you're interested in. The following snippet shows the use of a visitor to find all Java local variable declarations: file . accept ( new JavaRecursiveElementVisitor () { @Override public void visitLocalVariable ( PsiLocalVariable variable ) { super . visitLocalVariable ( variable ); System . out . println ( \"Found a variable at offset \" + variable . getTextRange (). getStartOffset ()); } }); In many cases, you can also use more specific APIs for top-down navigation. For example, if you need to get a list of all methods in a Java class, you can use a visitor, but a much easier way to do that is calling PsiClass.getMethods() . PsiTreeUtil contains a number of general-purpose, language-independent functions for PSI tree navigation, some of which (for example, findChildrenOfType() ) perform top-down navigation.","title":"Top-Down Navigation"},{"location":"basics/architectural_overview/navigating_psi/#bottom-up-navigation","text":"The starting point for bottom-up navigation is either a specific element in the PSI tree (for example, the result of resolving a reference) or an offset. If you have an offset, you can find the corresponding PSI element by calling PsiFile.findElementAt() . This method returns the element at the lowest level of the tree (for example, an identifier), and you need to navigate the tree up if you want to determine the broader context. In most cases, bottom-up navigation is performed by calling PsiTreeUtil.getParentOfType() . This method goes up the tree until it finds the element of the type you've specified. For example, to find the containing method, you call PsiTreeUtil.getParentOfType(element, PsiMethod.class) . In some cases, you can also use specific navigation methods. For example, to find the class where a method is contained, you call PsiMethod.getContainingClass() . The following snippet shows how these calls can be used together: PsiFile psiFile = anActionEvent . getData ( CommonDataKeys . PSI_FILE ); PsiElement element = psiFile . findElementAt ( offset ); PsiMethod containingMethod = PsiTreeUtil . getParentOfType ( element , PsiMethod . class ); PsiClass containingClass = containingMethod . getContainingClass (); To see how the navigation works in practice, please refer to the code sample .","title":"Bottom-Up Navigation"},{"location":"basics/architectural_overview/psi/","text":"The Program Structure Interface, commonly referred to as just PSI, is the layer in the Consulo responsible for parsing files and creating the syntactic and semantic code model that powers so many of the platform's features. PSI Files File View Providers PSI Elements TIP A useful tool for debugging the PSI implementation is the PsiViewer plugin . It can show you the PSI tree structure, the properties of every PSI element, and highlight its text range.","title":"What Is the PSI?"},{"location":"basics/architectural_overview/psi_elements/","text":"A PSI (Program Structure Interface) file represents a hierarchy of PSI elements (so-called PSI trees ). A single PSI file (itself being a PSI element) may contain several PSI trees in specific programming languages. A PSI element, in its turn, can have child PSI elements. PSI elements and operations at the level of individual PSI elements are used to explore the source code's internal structure as it is interpreted by the Consulo . For example, you can use PSI elements to perform code analysis, such as code inspections or intention actions . The PsiElement class is the common base class for PSI elements. How do I get a PSI element? From an action: e.getData(LangDataKeys.PSI_ELEMENT) . Note: if an editor is currently open and the element under caret is a reference, this will return the result of resolving the reference. This may or may not be what you need. From a file by offset: PsiFile.findElementAt() . Note: this returns the lowest level element (\"leaf\") at the specified offset, normally a lexer token. Most likely, you should use PsiTreeUtil.getParentOfType() to find the element you really need. By iterating through a PSI file: using a PsiRecursiveElementWalkingVisitor . By resolving a reference: PsiReference.resolve() What can I do with PSI elements? See PSI Cook Book","title":"PSI Elements"},{"location":"basics/architectural_overview/psi_elements/#how-do-i-get-a-psi-element","text":"From an action: e.getData(LangDataKeys.PSI_ELEMENT) . Note: if an editor is currently open and the element under caret is a reference, this will return the result of resolving the reference. This may or may not be what you need. From a file by offset: PsiFile.findElementAt() . Note: this returns the lowest level element (\"leaf\") at the specified offset, normally a lexer token. Most likely, you should use PsiTreeUtil.getParentOfType() to find the element you really need. By iterating through a PSI file: using a PsiRecursiveElementWalkingVisitor . By resolving a reference: PsiReference.resolve()","title":"How do I get a PSI element?"},{"location":"basics/architectural_overview/psi_elements/#what-can-i-do-with-psi-elements","text":"See PSI Cook Book","title":"What can I do with PSI elements?"},{"location":"basics/architectural_overview/psi_files/","text":"A PSI (Program Structure Interface) file is the root of a structure representing a file's contents as a hierarchy of elements in a particular programming language. The PsiFile class is the common base class for all PSI files, while files in a specific language are usually represented by its subclasses. For example, the PsiJavaFile class represents a Java file, and the XmlFile class represents an XML file. Unlike VirtualFile and Document , which have application scope (even if multiple projects are open, each file is represented by the same VirtualFile instance). A PSI has project scope. The same file is represented by one PsiFile instance for each open project to which the file belongs. In contrast, VirtualFile and Document have application scope; files are represented by the same VirtualFile instance, even if multiple projects are open. How do I get a PSI file? From an action: e.getData(LangDataKeys.PSI_FILE) . From a VirtualFile: PsiManager.getInstance(project).findFile() From a Document: PsiDocumentManager.getInstance(project).getPsiFile() From an element inside the file: psiElement.getContainingFile() To find files with a specific name anywhere in the project, use FilenameIndex.getFilesByName(project, name, scope) What can I do with a PSI file? Most interesting modification operations are performed on the level of individual PSI elements, not files as a whole. To iterate over the elements in a file, use psiFile.accept(new PsiRecursiveElementWalkingVisitor()...); Where does a PSI file come from? As PSI is language-dependent, PSI files are created through the Language object, by using the LanguageParserDefinitions.INSTANCE.forLanguage(language).createFile(fileViewProvider) method. Like documents, PSI files are created on-demand when the PSI is accessed for a particular file. How long do PSI files persist? Like documents, PSI files are weakly referenced from the corresponding VirtualFile instances and can be garbage-collected if not referenced by anyone. How do I create a PSI file? The PsiFileFactory createFileFromText() method creates an in-memory PSI file with the specified contents. To save the PSI file to disk, use the PsiDirectory add() method. How do I get notified when PSI files change? PsiManager.getInstance(project).addPsiTreeChangeListener() allows you to receive notifications about all changes to the PSI tree of a project. How do I extend PSI? PSI can be extended to support additional languages through custom language plugins. For more details on developing custom language plugins, see the Custom Language Support reference guide. What are the rules for working with PSI? Any changes done to the content of PSI files are reflected in documents, so all rules for working with documents (read/write actions, commands, read-only status handling) are in effect.","title":"PSI Files"},{"location":"basics/architectural_overview/psi_files/#how-do-i-get-a-psi-file","text":"From an action: e.getData(LangDataKeys.PSI_FILE) . From a VirtualFile: PsiManager.getInstance(project).findFile() From a Document: PsiDocumentManager.getInstance(project).getPsiFile() From an element inside the file: psiElement.getContainingFile() To find files with a specific name anywhere in the project, use FilenameIndex.getFilesByName(project, name, scope)","title":"How do I get a PSI file?"},{"location":"basics/architectural_overview/psi_files/#what-can-i-do-with-a-psi-file","text":"Most interesting modification operations are performed on the level of individual PSI elements, not files as a whole. To iterate over the elements in a file, use psiFile.accept(new PsiRecursiveElementWalkingVisitor()...);","title":"What can I do with a PSI file?"},{"location":"basics/architectural_overview/psi_files/#where-does-a-psi-file-come-from","text":"As PSI is language-dependent, PSI files are created through the Language object, by using the LanguageParserDefinitions.INSTANCE.forLanguage(language).createFile(fileViewProvider) method. Like documents, PSI files are created on-demand when the PSI is accessed for a particular file.","title":"Where does a PSI file come from?"},{"location":"basics/architectural_overview/psi_files/#how-long-do-psi-files-persist","text":"Like documents, PSI files are weakly referenced from the corresponding VirtualFile instances and can be garbage-collected if not referenced by anyone.","title":"How long do PSI files persist?"},{"location":"basics/architectural_overview/psi_files/#how-do-i-create-a-psi-file","text":"The PsiFileFactory createFileFromText() method creates an in-memory PSI file with the specified contents. To save the PSI file to disk, use the PsiDirectory add() method.","title":"How do I create a PSI file?"},{"location":"basics/architectural_overview/psi_files/#how-do-i-get-notified-when-psi-files-change","text":"PsiManager.getInstance(project).addPsiTreeChangeListener() allows you to receive notifications about all changes to the PSI tree of a project.","title":"How do I get notified when PSI files change?"},{"location":"basics/architectural_overview/psi_files/#how-do-i-extend-psi","text":"PSI can be extended to support additional languages through custom language plugins. For more details on developing custom language plugins, see the Custom Language Support reference guide.","title":"How do I extend PSI?"},{"location":"basics/architectural_overview/psi_files/#what-are-the-rules-for-working-with-psi","text":"Any changes done to the content of PSI files are reflected in documents, so all rules for working with documents (read/write actions, commands, read-only status handling) are in effect.","title":"What are the rules for working with PSI?"},{"location":"basics/architectural_overview/psi_references/","text":"A reference in a PSI tree is an object that represents a link from a usage of a particular element in the code to the corresponding declaration . Resolving a reference means locating the declaration to which a specific usage refers. The most common type of reference is defined by language semantics. For example, consider a simple Java method: public void hello ( String message ) { System . out . println ( message ); } This simple code fragment contains five references. The references created by the identifiers String , System , out , and println can be resolved to the corresponding declarations in the JDK: the String and System classes, the out field, and the println method. The reference created by the second occurrence of the message identifier in println(message) can be resolved to the message parameter, declared by String message in the method header. Note that String message is not a reference and cannot be resolved. Instead, it's a declaration . It does not refer to any name defined elsewhere; instead, it defines a name by itself. A reference is an instance of a class implementing the PsiReference interface. Note that references are distinct from PSI elements. References created by a PSI element are returned from PsiElement.getReferences() , the underlying PSI element of a reference can be obtained from PsiReference.getElement() . To resolve the reference - to locate the declaration being referenced - call PsiReference.resolve() . It's very important to understand the difference between PsiReference.getElement() and PsiReference.resolve() . The former method returns the source of a reference, while the latter returns its target . In the example above, for the message reference, getElement() will return the message identifier on the second line of the snippet, and resolve() will return the message identifier on the first line (inside the parameter list). The process of resolving references is distinct from parsing and is not performed at the same time. Moreover, it is not always successful. If the code currently open in the IDE does not compile, or in other situations, it's normal for PsiReference.resolve() to return null - all code working with references must be prepared to handle that. TIP Please see also Cache results of heavy computations in Working with PSI efficiently . Contributed References In addition to references defined by the semantics of the programming language, the IDE recognizes many references determined by the semantics of the APIs and frameworks used in code. Consider the following example: File f = new File ( \"foo.txt\" ); Here, \"foo.txt\" has no special meaning from the point of view of the Java syntax - it's just a string literal. However, opening this example in IntelliJ IDEA and having a file called \"foo.txt\" in the same directory, one can Ctrl/Cmd -Click on \"foo.txt\" and navigate to the file. This works because the IDE recognizes the semantics of new File(...) and contributes a reference into the string literal passed as a parameter to the method. Typically, references can be contributed to elements that don't have their own references, such as string literals and comments. References are also often contributed to non-code files, such as XML or JSON. Contributing references is one of the most common ways to extend an existing language. For example, your plugin can contribute references to Java code, even though the Java PSI is part of the platform and not defined in your plugin. To contribute references, see the reference contributor tutorial . References with Optional or Multiple Resolve Results In the simplest case, a reference resolves to a single element, and if resolving fails, the code is incorrect, and the IDE needs to highlight it as an error. However, there are cases when the situation is different. The first case is soft references . Consider the new File(\"foo.txt\") example above. If the IDE can't find the file \"foo.txt\", it doesn't mean that an error needs to be highlighted - maybe the file is only available at runtime. Such references return true from the PsiReference.isSoft() method. The second case is polyvariant references . Consider the case of a JavaScript program. JavaScript is a dynamically typed language, so the IDE cannot always precisely determine which method is being called at a particular location. To handle this, it provides a reference that can be resolved to multiple possible elements. Such references implement the PsiPolyVariantReference interface. For resolving a PsiPolyVariantReference , you call its multiResolve() method. The call returns an array of ResolveResult objects. Each of the objects identifies a PSI element and also specifies whether the result is valid. For example, suppose you have multiple Java method overloads and a call with arguments not matching any of the overloads. In that case, you will get back ResolveResult objects for all of the overloads, and isValidResult() returns false for all of them. Searching for References As you already know, resolving a reference means going from usage to the corresponding declaration. To perform the navigation in the opposite direction - from a declaration to its usages - perform a references search . To perform a search using ReferencesSearch , specify the element to search for, and optionally other parameters such as the scope in which the reference needs to be searched. The created Query allows obtaining all results at once or iterating over the results one by one. The latter allows stopping processing as soon as the first (matching) result has been found. Implementing References Please refer to the guide and corresponding tutorial for more information.","title":"References"},{"location":"basics/architectural_overview/psi_references/#contributed-references","text":"In addition to references defined by the semantics of the programming language, the IDE recognizes many references determined by the semantics of the APIs and frameworks used in code. Consider the following example: File f = new File ( \"foo.txt\" ); Here, \"foo.txt\" has no special meaning from the point of view of the Java syntax - it's just a string literal. However, opening this example in IntelliJ IDEA and having a file called \"foo.txt\" in the same directory, one can Ctrl/Cmd -Click on \"foo.txt\" and navigate to the file. This works because the IDE recognizes the semantics of new File(...) and contributes a reference into the string literal passed as a parameter to the method. Typically, references can be contributed to elements that don't have their own references, such as string literals and comments. References are also often contributed to non-code files, such as XML or JSON. Contributing references is one of the most common ways to extend an existing language. For example, your plugin can contribute references to Java code, even though the Java PSI is part of the platform and not defined in your plugin. To contribute references, see the reference contributor tutorial .","title":"Contributed References"},{"location":"basics/architectural_overview/psi_references/#references-with-optional-or-multiple-resolve-results","text":"In the simplest case, a reference resolves to a single element, and if resolving fails, the code is incorrect, and the IDE needs to highlight it as an error. However, there are cases when the situation is different. The first case is soft references . Consider the new File(\"foo.txt\") example above. If the IDE can't find the file \"foo.txt\", it doesn't mean that an error needs to be highlighted - maybe the file is only available at runtime. Such references return true from the PsiReference.isSoft() method. The second case is polyvariant references . Consider the case of a JavaScript program. JavaScript is a dynamically typed language, so the IDE cannot always precisely determine which method is being called at a particular location. To handle this, it provides a reference that can be resolved to multiple possible elements. Such references implement the PsiPolyVariantReference interface. For resolving a PsiPolyVariantReference , you call its multiResolve() method. The call returns an array of ResolveResult objects. Each of the objects identifies a PSI element and also specifies whether the result is valid. For example, suppose you have multiple Java method overloads and a call with arguments not matching any of the overloads. In that case, you will get back ResolveResult objects for all of the overloads, and isValidResult() returns false for all of them.","title":"References with Optional or Multiple Resolve Results"},{"location":"basics/architectural_overview/psi_references/#searching-for-references","text":"As you already know, resolving a reference means going from usage to the corresponding declaration. To perform the navigation in the opposite direction - from a declaration to its usages - perform a references search . To perform a search using ReferencesSearch , specify the element to search for, and optionally other parameters such as the scope in which the reference needs to be searched. The created Query allows obtaining all results at once or iterating over the results one by one. The latter allows stopping processing as soon as the first (matching) result has been found.","title":"Searching for References"},{"location":"basics/architectural_overview/psi_references/#implementing-references","text":"Please refer to the guide and corresponding tutorial for more information.","title":"Implementing References"},{"location":"basics/architectural_overview/virtual_file/","text":"A VirtualFile (VF) is the Consulo's representation of a file in a Virtual File System (VFS) . Most commonly, a virtual file is a file in a local file system. However, the Consulo supports multiple pluggable file system implementations, so virtual files can also represent classes in a JAR file, old revisions of files loaded from a version control repository, and so on. The VFS level deals only with binary content. Contents of a VirtualFile are treated as a stream of bytes, but concepts like encodings and line separators are handled on higher system levels. How do I get a virtual file? From an action : e.getData(PlatformDataKeys.VIRTUAL_FILE) or e.getData(PlatformDataKeys.VIRTUAL_FILE_ARRAY) for multiple selection From a path in the local file system: : - LocalFileSystem.getInstance().findFileByIoFile() - VirtualFileManager.findFileByNioPath() / refreshAndFindFileByNioPath() (2020.2 and later) From a PSI file : psiFile.getVirtualFile() (may return null if the PSI file exists only in memory) From a document : FileDocumentManager.getInstance().getFile() What can I do with it? Typical file operations are available, such as traverse the file system, get file contents, rename, move, or delete. Recursive iteration should be performed using VfsUtilCore.iterateChildrenRecursively() to prevent endless loops caused by recursive symlinks. Where does it come from? The VFS is built incrementally by scanning the file system up and down, starting from the project root. VFS refreshes detect new files appearing in the file system. A refresh operation can be initiated programmatically using VirtualFileManager.syncRefresh() / asyncRefresh() or VirtualFile.refresh() . VFS refreshes are also triggered whenever file system watchers receive file system change notifications. Invoking a VFS refresh might be necessary for accessing a file that has just been created by an external tool through the Consulo APIs. How long does a virtual file persist? A particular file on disk is represented by equal VirtualFile instances for the IDE process's entire lifetime. There may be several instances corresponding to the same file, and they can be garbage-collected. The file is a UserDataHolder , and the user data is shared between those equal instances. If a file is deleted, its corresponding VirtualFile instance becomes invalid ( isValid() returns false ), and operations cause exceptions. How do I create a virtual file? Usually, you don't. As a general rule, files are created either through the PSI API or through the regular java.io.File API. If one needs to create a file through VFS, use VirtualFile.createChildData() to create a VirtualFile instance and VirtualFile.setBinaryContent() to write some data to the file. How do I get notified when VFS changes? NOTE See Virtual file system events for important details. Implement BulkFileListener and subscribe to the message bus topic VirtualFileManager.VFS_CHANGES . For example: project . getMessageBus (). connect (). subscribe ( VirtualFileManager . VFS_CHANGES , new BulkFileListener () { @Override public void after ( @NotNull List <? extends VFileEvent > events ) { // handle the events } }); See Message Infrastructure and Plugin Listeners for more details. For a non-blocking alternative, starting with version 2019.2 of the platform, see AsyncFileListener . Plugins targeting versions 2017.2 or older of the platform can use the now deprecated VirtualFileManager.addVirtualFileListener() method, which allows you to receive notifications about all changes in the VFS. Are there any utilities for analyzing and manipulating virtual files? VfsUtil and VfsUtilCore provide utility methods for analyzing files in the Virtual File System. Use ProjectLocator to find the projects that contain a given virtual file. How do I extend VFS? To provide an alternative file system implementation (for example, an FTP file system), implement the VirtualFileSystem class (most likely you'll also need to implement VirtualFile ), and register your implementation via com.intellij.virtualFileSystem extension point (2019.2 and later) or application component for earlier versions. To hook into operations performed in the local file system (for example, when developing a version control system integration that needs custom rename/move handling), implement LocalFileOperationsHandler and register it via LocalFileSystem.registerAuxiliaryFileOperationsHandler() . What are the rules for working with VFS? See Virtual File System for a detailed description of the VFS architecture and usage guidelines.","title":"Virtual Files"},{"location":"basics/architectural_overview/virtual_file/#how-do-i-get-a-virtual-file","text":"From an action : e.getData(PlatformDataKeys.VIRTUAL_FILE) or e.getData(PlatformDataKeys.VIRTUAL_FILE_ARRAY) for multiple selection From a path in the local file system: : - LocalFileSystem.getInstance().findFileByIoFile() - VirtualFileManager.findFileByNioPath() / refreshAndFindFileByNioPath() (2020.2 and later) From a PSI file : psiFile.getVirtualFile() (may return null if the PSI file exists only in memory) From a document : FileDocumentManager.getInstance().getFile()","title":"How do I get a virtual file?"},{"location":"basics/architectural_overview/virtual_file/#what-can-i-do-with-it","text":"Typical file operations are available, such as traverse the file system, get file contents, rename, move, or delete. Recursive iteration should be performed using VfsUtilCore.iterateChildrenRecursively() to prevent endless loops caused by recursive symlinks.","title":"What can I do with it?"},{"location":"basics/architectural_overview/virtual_file/#where-does-it-come-from","text":"The VFS is built incrementally by scanning the file system up and down, starting from the project root. VFS refreshes detect new files appearing in the file system. A refresh operation can be initiated programmatically using VirtualFileManager.syncRefresh() / asyncRefresh() or VirtualFile.refresh() . VFS refreshes are also triggered whenever file system watchers receive file system change notifications. Invoking a VFS refresh might be necessary for accessing a file that has just been created by an external tool through the Consulo APIs.","title":"Where does it come from?"},{"location":"basics/architectural_overview/virtual_file/#how-long-does-a-virtual-file-persist","text":"A particular file on disk is represented by equal VirtualFile instances for the IDE process's entire lifetime. There may be several instances corresponding to the same file, and they can be garbage-collected. The file is a UserDataHolder , and the user data is shared between those equal instances. If a file is deleted, its corresponding VirtualFile instance becomes invalid ( isValid() returns false ), and operations cause exceptions.","title":"How long does a virtual file persist?"},{"location":"basics/architectural_overview/virtual_file/#how-do-i-create-a-virtual-file","text":"Usually, you don't. As a general rule, files are created either through the PSI API or through the regular java.io.File API. If one needs to create a file through VFS, use VirtualFile.createChildData() to create a VirtualFile instance and VirtualFile.setBinaryContent() to write some data to the file.","title":"How do I create a virtual file?"},{"location":"basics/architectural_overview/virtual_file/#how-do-i-get-notified-when-vfs-changes","text":"NOTE See Virtual file system events for important details. Implement BulkFileListener and subscribe to the message bus topic VirtualFileManager.VFS_CHANGES . For example: project . getMessageBus (). connect (). subscribe ( VirtualFileManager . VFS_CHANGES , new BulkFileListener () { @Override public void after ( @NotNull List <? extends VFileEvent > events ) { // handle the events } }); See Message Infrastructure and Plugin Listeners for more details. For a non-blocking alternative, starting with version 2019.2 of the platform, see AsyncFileListener . Plugins targeting versions 2017.2 or older of the platform can use the now deprecated VirtualFileManager.addVirtualFileListener() method, which allows you to receive notifications about all changes in the VFS.","title":"How do I get notified when VFS changes?"},{"location":"basics/architectural_overview/virtual_file/#are-there-any-utilities-for-analyzing-and-manipulating-virtual-files","text":"VfsUtil and VfsUtilCore provide utility methods for analyzing files in the Virtual File System. Use ProjectLocator to find the projects that contain a given virtual file.","title":"Are there any utilities for analyzing and manipulating virtual files?"},{"location":"basics/architectural_overview/virtual_file/#how-do-i-extend-vfs","text":"To provide an alternative file system implementation (for example, an FTP file system), implement the VirtualFileSystem class (most likely you'll also need to implement VirtualFile ), and register your implementation via com.intellij.virtualFileSystem extension point (2019.2 and later) or application component for earlier versions. To hook into operations performed in the local file system (for example, when developing a version control system integration that needs custom rename/move handling), implement LocalFileOperationsHandler and register it via LocalFileSystem.registerAuxiliaryFileOperationsHandler() .","title":"How do I extend VFS?"},{"location":"basics/architectural_overview/virtual_file/#what-are-the-rules-for-working-with-vfs","text":"See Virtual File System for a detailed description of the VFS architecture and usage guidelines.","title":"What are the rules for working with VFS?"},{"location":"basics/boot/boot.directories/","text":"Windows Windows Vista, 7, 8, 8.1, 10: ${system-drive}/Users/${user-name}/AppData/Roaming/Consulo - configuration directory ${system-drive}/Users/${user-name}/AppData/Roaming/Consulo Platorm - platform directory ${system-drive}/Users/${user-name}/AppData/Roaming/Consulo/plugins - plugin directory ${system-drive}/Users/${user-name}/AppData/Local/Consulo/log - log directory Windows XP: ${system-drive}/Users/${user-name}/Application Data/Consulo/ - configuration directory ${system-drive}/Users/${user-name}/Application Data/Consulo Platform - platform directory ${system-drive}/Users/${user-name}/Application Data/Consulo/plugins - plugin directory ${system-drive}/Users/${user-name}/Local Settings/Application Data/Consulo/log - log directory Linux Any: ${home-directory}/.consulo_settings config - configuration directory config/plugins - plugin directory system/log - log directory Mac OS Any ~/Library/Preferences/Consulo - configuration directory ~/Library/Application Support/Consulo Platform - platform directory ~/Library/Application Support/Consulo - plugin directory ~/Library/Logs/Consulo - log directory","title":"Boot Directories"},{"location":"basics/boot/boot.directories/#windows","text":"Windows Vista, 7, 8, 8.1, 10: ${system-drive}/Users/${user-name}/AppData/Roaming/Consulo - configuration directory ${system-drive}/Users/${user-name}/AppData/Roaming/Consulo Platorm - platform directory ${system-drive}/Users/${user-name}/AppData/Roaming/Consulo/plugins - plugin directory ${system-drive}/Users/${user-name}/AppData/Local/Consulo/log - log directory Windows XP: ${system-drive}/Users/${user-name}/Application Data/Consulo/ - configuration directory ${system-drive}/Users/${user-name}/Application Data/Consulo Platform - platform directory ${system-drive}/Users/${user-name}/Application Data/Consulo/plugins - plugin directory ${system-drive}/Users/${user-name}/Local Settings/Application Data/Consulo/log - log directory","title":"Windows"},{"location":"basics/boot/boot.directories/#linux","text":"Any: ${home-directory}/.consulo_settings config - configuration directory config/plugins - plugin directory system/log - log directory","title":"Linux"},{"location":"basics/boot/boot.directories/#mac-os","text":"Any ~/Library/Preferences/Consulo - configuration directory ~/Library/Application Support/Consulo Platform - platform directory ~/Library/Application Support/Consulo - plugin directory ~/Library/Logs/Consulo - log directory","title":"Mac OS"},{"location":"basics/boot/overview/","text":"Consulo Boot Information Boot Directories - Paths to system directories Major boot changes Consulo consists of two parts: * boot part (not updatable) * .exe files on windows * macOS launcher * sh script on linux * platform part (updatable) Sometimes (not often) major issues reported, which required changes in boot part . For update boot part - need only re-download Consulo, and replace it by new build . All settings will be not changed. List of major boot issues: * Platform not updated without admin rights, when Consulo placed under Program Files directory * After update consulo can't start happen second time","title":"Overview"},{"location":"basics/boot/overview/#consulo-boot-information","text":"Boot Directories - Paths to system directories","title":"Consulo Boot Information"},{"location":"basics/boot/overview/#major-boot-changes","text":"Consulo consists of two parts: * boot part (not updatable) * .exe files on windows * macOS launcher * sh script on linux * platform part (updatable) Sometimes (not often) major issues reported, which required changes in boot part . For update boot part - need only re-download Consulo, and replace it by new build . All settings will be not changed. List of major boot issues: * Platform not updated without admin rights, when Consulo placed under Program Files directory * After update consulo can't start happen second time","title":"Major boot changes"},{"location":"basics/getting_started/build_number_ranges/","text":"table { width:100%; } th:first-child, td:first-child { width: 10%; } Use this reference of build number ranges to specify the correct since-build and until-build values in your plugin descriptor. When using Gradle, setting the actual values in plugin.xml is usually managed by the patchPluginXml task, see Patching the Plugin Configuration File for details. NOTE Compatibility with specified version range (and compatible products) should always be verified using Plugin Verifier to ensure binary compatibility. Starting with IntelliJ IDEA 9 beta, a multi-part build number is used, such as IU-162.94 . The number consists of the following parts: Product ID ( IC for IDEA Community, IU for IDEA Ultimate, RM for RubyMine, PY for PyCharm, etc.) Branch number ( 162 ) Build number in the branch ( 94 ) Since version 2016.2 of the Consulo , branch numbers are based on the YYYY.R IDE release version numbers . The branch number takes the last two digits of the year and the R release number. For example, 162 for 2016.2, 163 for 2016.3, 171 for 2017.1. In this scheme, IU-162.94 corresponds to the 2016.2 release. Starting with 2016.2, the build number may also have multiple components: IU-162.94 , IU-162.94.11 , IU-162.94.11.256.42 . This gives more flexibility for third-party plugins and IDE developers. Plugins may specify compatibility versions more precisely; IDE vendors may have build numbers based on a specific Consulo version and specify additional internal version (e.g. 256.42 in XX-162.94.11.256.42 ) to allow plugin developers for their IDE to specify compatibility. Multi-part build numbers can also be used in the since-build and until-build attributes of idea-version . Usually you should omit the product ID and use only the branch number and build number, for example: <idea-version since-build= \"94.539\" /> <idea-version since-build= \"162.539.11\" /> <idea-version until-build= \"162\" /> <!-- any build until 162, not inclusive!--> <idea-version since-build= \"162\" until-build= \"162.*\" /> <!-- any 162-based version, 162.94, 162.94.11, etc.--> NOTE Specific build numbers and their corresponding release version are available via Previous Releases on the corresponding product's download page, e.g. Previous IntelliJ IDEA Releases . Consulo Based Products of Recent IDE Versions TIP Which versions should your plugin support? We've collected some insights based on download statistics in Statistics: Product Versions in Use . Branch number Consulo version 203 2020.3 NOTE Java 11 is now required ( blog post ) 202 2020.2 201 2020.1 193 2019.3 192 2019.2 191 2019.1 183 2018.3 182 2018.2 181 2018.1 173 2017.3 172 2017.2 171 2017.1 163 2016.3 162 2016.2 Note that there is no 170 . In the YYYY.R versioning scheme, the R part starts at 1. Consulo Based Products of Pre-2016.2 IDE Versions Branch number Product version 145 IntelliJ IDEA 2016.1, AppCode 2016.1, CLion 2016.1, DataGrip 2016.1, PhpStorm 2016.1, PyCharm 2016.1, RubyMine 2016.1, WebStorm 2016.1 143 IntelliJ IDEA 15, AppCode 3.3, CLion 1.2, DataGrip 1.0, PhpStorm 10, PyCharm 5, RubyMine 8, WebStorm 11 141 IntelliJ IDEA 14.1, Android Studio 1.3, PyCharm 4.1, WebStorm 10 139 IntelliJ IDEA 14, PhpStorm 8, PyCharm 4, RubyMine 7, WebStorm 9 135 IntelliJ IDEA 13.1, WebStorm 8 133 IntelliJ IDEA 13, PhpStorm 7, PyCharm 3.1, WebStorm 7 131 PhpStorm 7, PyCharm 3.0, WebStorm 7 129 IntelliJ IDEA 12.1, bug-fix updates for PyCharm 2.7 and PhpStorm/WebStorm 6.0 127 AppCode 2.0, PhpStorm/WebStorm 6.0 125 PyCharm 2.7, RubyMine 5.0 123 IntelliJ IDEA 12 121 AppCode 1.6, PyCharm 2.6, PhpStorm/WebStorm 5.0 119 RubyMine 4.5 117 IntelliJ IDEA 11.1, AppCode 1.5, PyCharm 2.5, RubyMine 4.0.x, PhpStorm/WebStorm 4.0 111 IntelliJ IDEA 11.0 107 IntelliJ IDEA 10.5 103 IntelliJ IDEA 10.0.2+ 99 IntelliJ IDEA 10.0+ 95 IntelliJ IDEA 9.0.2+ 93 IntelliJ IDEA 9.0 History Build Numbers for IntelliJ IDEA Versions IntelliJ IDEA version Build number 12.0 123.72 11.1.3 117.798 11.1.2 117.418 11.1.1 117.117 11.1 117.105 11.0.2 111.277 11.0.1 111.167 11.0 111.69 10.5.2 107.587 10.5.1 107.322 10.5 107.105 10.0.3 103.255 10.0.2 103.72 10.0.1 99.32 10.0 99.18 9.0.4 95.627 9.0.3 95.429 9.0.2 95.66 9.0.1 93.94 9.0 93.13 Build Numbers for IntelliJ IDEA Pre-9.0 Before IntelliJ IDEA 9.0, linear build numbers were used, with the following ranges: IntelliJ IDEA version Build number range 8.1.x 9500-9999 8.0.x 9100-9499 8.0 8000-9099 7.0.2+ 7500-7999 7.0 final 7200-7499 7.0 pre-M2 6900-7199 7.0 pre-M1 6500-6899 6.0.2 branch 6000-6499 6.0 branch 5000-5999 5.1 branch 4000-4999 The build number for each release: IntelliJ IDEA version Build number 8.1 9732 8.0.1 9164 8.0 9013 8.0M1 8664 7.0.5 7971 7.0.3 7757 7.0.2 7590 7.0 final 7361 7.0 M2 7126 7.0 M1 6813 6.0.6 6197 6.0.5 6180 6.0.1 5784 5.1.2 4267","title":"Build Number Ranges"},{"location":"basics/getting_started/build_number_ranges/#consulo-based-products-of-recent-ide-versions","text":"TIP Which versions should your plugin support? We've collected some insights based on download statistics in Statistics: Product Versions in Use . Branch number Consulo version 203 2020.3 NOTE Java 11 is now required ( blog post ) 202 2020.2 201 2020.1 193 2019.3 192 2019.2 191 2019.1 183 2018.3 182 2018.2 181 2018.1 173 2017.3 172 2017.2 171 2017.1 163 2016.3 162 2016.2 Note that there is no 170 . In the YYYY.R versioning scheme, the R part starts at 1.","title":"Consulo Based Products of Recent IDE Versions"},{"location":"basics/getting_started/build_number_ranges/#consulo-based-products-of-pre-20162-ide-versions","text":"Branch number Product version 145 IntelliJ IDEA 2016.1, AppCode 2016.1, CLion 2016.1, DataGrip 2016.1, PhpStorm 2016.1, PyCharm 2016.1, RubyMine 2016.1, WebStorm 2016.1 143 IntelliJ IDEA 15, AppCode 3.3, CLion 1.2, DataGrip 1.0, PhpStorm 10, PyCharm 5, RubyMine 8, WebStorm 11 141 IntelliJ IDEA 14.1, Android Studio 1.3, PyCharm 4.1, WebStorm 10 139 IntelliJ IDEA 14, PhpStorm 8, PyCharm 4, RubyMine 7, WebStorm 9 135 IntelliJ IDEA 13.1, WebStorm 8 133 IntelliJ IDEA 13, PhpStorm 7, PyCharm 3.1, WebStorm 7 131 PhpStorm 7, PyCharm 3.0, WebStorm 7 129 IntelliJ IDEA 12.1, bug-fix updates for PyCharm 2.7 and PhpStorm/WebStorm 6.0 127 AppCode 2.0, PhpStorm/WebStorm 6.0 125 PyCharm 2.7, RubyMine 5.0 123 IntelliJ IDEA 12 121 AppCode 1.6, PyCharm 2.6, PhpStorm/WebStorm 5.0 119 RubyMine 4.5 117 IntelliJ IDEA 11.1, AppCode 1.5, PyCharm 2.5, RubyMine 4.0.x, PhpStorm/WebStorm 4.0 111 IntelliJ IDEA 11.0 107 IntelliJ IDEA 10.5 103 IntelliJ IDEA 10.0.2+ 99 IntelliJ IDEA 10.0+ 95 IntelliJ IDEA 9.0.2+ 93 IntelliJ IDEA 9.0","title":"Consulo Based Products of Pre-2016.2 IDE Versions"},{"location":"basics/getting_started/build_number_ranges/#history","text":"","title":"History"},{"location":"basics/getting_started/build_number_ranges/#build-numbers-for-intellij-idea-versions","text":"IntelliJ IDEA version Build number 12.0 123.72 11.1.3 117.798 11.1.2 117.418 11.1.1 117.117 11.1 117.105 11.0.2 111.277 11.0.1 111.167 11.0 111.69 10.5.2 107.587 10.5.1 107.322 10.5 107.105 10.0.3 103.255 10.0.2 103.72 10.0.1 99.32 10.0 99.18 9.0.4 95.627 9.0.3 95.429 9.0.2 95.66 9.0.1 93.94 9.0 93.13","title":"Build Numbers for IntelliJ IDEA Versions"},{"location":"basics/getting_started/build_number_ranges/#build-numbers-for-intellij-idea-pre-90","text":"Before IntelliJ IDEA 9.0, linear build numbers were used, with the following ranges: IntelliJ IDEA version Build number range 8.1.x 9500-9999 8.0.x 9100-9499 8.0 8000-9099 7.0.2+ 7500-7999 7.0 final 7200-7499 7.0 pre-M2 6900-7199 7.0 pre-M1 6500-6899 6.0.2 branch 6000-6499 6.0 branch 5000-5999 5.1 branch 4000-4999 The build number for each release: IntelliJ IDEA version Build number 8.1 9732 8.0.1 9164 8.0 9013 8.0M1 8664 7.0.5 7971 7.0.3 7757 7.0.2 7590 7.0 final 7361 7.0 M2 7126 7.0 M1 6813 6.0.6 6197 6.0.5 6180 6.0.1 5784 5.1.2 4267","title":"Build Numbers for IntelliJ IDEA Pre-9.0"},{"location":"basics/getting_started/creating_plugin_project/","text":"NOTE For new projects, it is highly recommended to use Gradle . This section explains how you can create a new plugin project from scratch using the New Project wizard. Optionally, you can import an existing project or import a project from external models. You can also add a new plugin module to a current Consulo project. For more information, refer to the IntelliJ IDEA Web Help . To Create an Consulo Plugin Project: On the main menu, choose File | New | Project . The New Project wizard starts. Set Consulo Plugin project type. Click Next . Set the desired project name. Click Finish to generate project structure files. Go to File | Project Structure to customize project settings if required. To Create an Consulo Plugin Module Select File | New | Module and choose the Consulo Plugin module type Enter your desired plugin name. Go to File | Project Structure and select the newly created Consulo SDK as the default SDK for the plugin module: Adding Code to the Project Before running the new project, add some code to provide simple functionality. See the Creating Actions tutorial for step-by-step instructions for adding a menu action.","title":"Creating a Plugin Project"},{"location":"basics/getting_started/creating_plugin_project/#to-create-an-consulo-plugin-project","text":"On the main menu, choose File | New | Project . The New Project wizard starts. Set Consulo Plugin project type. Click Next . Set the desired project name. Click Finish to generate project structure files. Go to File | Project Structure to customize project settings if required.","title":"To Create an Consulo Plugin Project:"},{"location":"basics/getting_started/creating_plugin_project/#to-create-an-consulo-plugin-module","text":"Select File | New | Module and choose the Consulo Plugin module type Enter your desired plugin name. Go to File | Project Structure and select the newly created Consulo SDK as the default SDK for the plugin module:","title":"To Create an Consulo Plugin Module"},{"location":"basics/getting_started/creating_plugin_project/#adding-code-to-the-project","text":"Before running the new project, add some code to provide simple functionality. See the Creating Actions tutorial for step-by-step instructions for adding a menu action.","title":"Adding Code to the Project"},{"location":"basics/getting_started/deploying_plugin/","text":"Before your custom plugin can be used, it must be deployed: built, installed, and then enabled using Plugin Manager. To deploy a plugin: Make your project by invoking Build | Build Project or Build | Build Module \\<module name> . Prepare your plugin for deployment. In the main menu, select Build | Prepare Plugin Module \\<module name> for Deployment . If the plugin module does not depend on any libraries, a .jar archive will be created. Otherwise, a .zip archive will be created, including all the plugin libraries specified in the project settings. Install the newly created archive/jar file from disk. The editor_basics code sample builds the plugin archive/jar into the editor_basics project folder: Restart your IDE so the changes will take effect.","title":"Deploying a Plugin"},{"location":"basics/getting_started/plugin_compatibility/","text":"table { width:100%; } th:first-child, td:first-child { width: 32%; } Introduction All products based on the Consulo are built on the same underlying API. Some of these products share features built on top of the platform, such as Java support in IntelliJ IDEA and Android Studio. Underlying those shared features are shared components. When authoring a plugin for the Consulo, it is important to understand and declare dependencies on these components. Otherwise, it may not be possible to load or run the plugin in a product because the components on which it depends aren't available. TIP Qualifying Open Source projects can apply for free licenses of JetBrains products. bullet list {:toc} Declaring Plugin Dependencies For the purposes of dependencies, a module can be thought of like a built-in plugin that ships as a non-removable part of a product. A working definition of a dependency is that a plugin project cannot be run without the module present in an Consulo-based product. Declaring a dependency on a module also expresses a plugin's compatibility with a product in that the Consulo determines whether a product contains the correct modules to support a plugin before loading it. Part I of this document describes the syntax for declaring plugin dependencies and optional plugin dependencies. Part II of this document (below) describes the Consulo modules' functionality to aid in determining the dependencies of a plugin. The way dependency declarations are handled by the Consulo is determined by the contents of the plugin.xml file: * If a plugin does not declare any dependencies in its plugin.xml file, or if it declares dependencies only on other plugins but not modules, it's assumed to be a legacy plugin and is loaded only in IntelliJ IDEA. This configuration of the dependency declaration is deprecated; do not use it for new plugin projects. * If a plugin declares at least one module dependency in its plugin.xml file, the plugin is loaded if an Consulo-based product contains all the modules and plugins on which the plugin has declared a dependency. Modules A module represents a built-in plugin that is a non-removable part of a product. Some modules are available in all products, and some modules are available only in some, or even just one product. This section identifies and discusses modules of both types. Declaring Incompatibility with Module Starting in 2020.2, a plugin can declare incompatibility with an arbitrary module by specifying <incompatible-with> containing module ID in its plugin.xml . Modules Available in All Products A core set of modules are available in all products based on the Consulo. These modules provide a set of shared functionality. The following table lists modules that are currently available in all products. NOTE All plugins should declare a dependency on com.intellij.modules.platform to indicate dependence on shared functionality. Module for <depends> Element Declaration in plugin.xml File Functionality com.intellij.modules.platform Messaging, UI Themes, UI Components, Files, Documents, Actions, Components, Services, Extensions, Editors com.intellij.modules.lang File Type, Lexer, Parser, Highlighting, References, Code Completion, Find, Rename, Formatter, Code Navigation com.intellij.modules.xml XML, XML DOM, XSD/DTD, DOM Model com.intellij.modules.vcs VCS Revision Numbers, File Status, Change Lists, File History, Annotations com.intellij.modules.xdebugger Debug Session, Stack Frames, Break Points, Source Positions, Memory Views, Tracked Instances As of this writing, if a plugin: A) is dependent only on one or more of the modules in the table above, and B) declares those module dependencies in plugin.xml , then any product developed by JetBrains based on the Consulo will load it. Modules Specific to Functionality More specialized functionality is also delivered via modules and plugins in Consulo-based products. For example, the com.intellij.modules.python module supports the Python language-specific functionality. If a plugin uses this module's functionality, such as Python-specific inspections and refactoring, it must declare a dependency on this module. Note that not all products define and declare modules. For example, PhpStorm does not have its own module, but the product itself depends on (and ships with) the PHP language plugin. A plugin project is compatible with PHP functionality if it declares a dependency on this PHP language plugin. The following table lists (1) modules or built-in plugins that provide specific functionality, and the products currently shipping with them. Module or Plugin for <depends> Element Declaration in plugin.xml File Functionality Consulo-Based Product Compatibility com.intellij.modules.java See (2) below. com.intellij.java Java language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework IntelliJ IDEA, Android Studio com.intellij.modules.androidstudio Android SDK Platform, Build Tools, Platform Tools, SDK Tools Android Studio com.intellij.modules.appcode CocoaPods, Core Data Objects, Device & Simulator Support AppCode com.intellij.modules.cidr.lang C, C++, Objective-C/C++ language PSI Model, Swift/Objective-C Interaction, Inspections, Intentions, Completion, Refactoring, Test Framework AppCode, CLion com.intellij.modules.cidr.debugger Debugger Watches, Evaluations, Breakpoints, Inline Debugging AppCode, CLion, RubyMine com.intellij.modules.clion CMake, Profiler, Embedded Development, Remote Development, Remote Debug, Disassembly CLion com.intellij.database Database Tools and SQL language PSI Model, Inspections, Completion, Refactoring, Queries DataGrip, IntelliJ IDEA Ultimate, AppCode, PhpStorm, PyCharm Professional, RubyMine, CLion, GoLand, Rider, and WebStorm if the Database Tools and SQL plugin is installed. com.intellij.modules.go Go language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework GoLand com.intellij.modules.python Python language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework PyCharm, and other products if the Python plugin is installed. com.intellij.modules.rider Connection to ReSharper Process in Background Rider com.intellij.modules.ruby Ruby language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework RubyMine, and IntelliJ IDEA Ultimate if the Ruby plugin is installed. com.intellij.modules.ultimate Licensing All commercial IDEs (IntelliJ IDEA Ultimate, PhpStorm, DataGrip, ...) com.jetbrains.php PHP language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework PhpStorm, and other products if the PHP plugin is installed. JavaScript JavaScript language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework WebStorm, and other products if the JavaScript plugin is installed. Notes about Module and Plugin Dependency: (1) This table is not exhaustive; other modules are currently available in JetBrains' Consulo-based IDEs. To see a list of modules, invoke the code completion feature for the <depends> element contents while editing the plugin.xml file. (2) The Java language functionality was extracted as a plugin in version 2019.2 of the Consulo. This refactoring separated the Java implementation from the other, non-language portions of the platform. Consequently, dependencies on Java functionality are expressed differently in plugin.xml depending on the version of the Consulo being targeted: Syntax for 2019.2 and later releases: plugin.xml allowable alternative add <depends>com.intellij.java</depends> build.gradle required define dependency on Java plugin intellij { plugins = ['com.intellij.java'] } Syntax required for releases prior to 2019.2, allowable in all releases: plugin.xml add <depends>com.intellij.modules.java</depends> Exploring Module and Plugin APIs Once the dependency on a module or plugin is declared in plugin.xml , it's useful to explore the packages and classes available in that dependency. The section below gives some recommended procedures for discovering what's available in a module or plugin on which a project depends. These procedures assume a project has the build.gradle and plugin.xml dependencies configured correctly. Exploring APIs as a Consumer Exploring the available packages and classes in a plugin or module utilizes features in the IntelliJ IDEA IDE. If the project is not up to date, Reimport the Gradle project as a first step. Reimporting the project will automatically update the dependencies. In the Project Window, select Project View and scroll to the bottom to see External Libraries . Look for the library Gradle:unzipped.com.jetbrains.plugins:foo: , where \"foo\" matches, or is similar to the contents of the <depends> tags in plugin.xml or the intellij.plugins declaration in build.gradle . The image below shows the External Libraries for the example plugin project configuration explained in Configuring build.gradle and Configuring plugin.xml . {:width=\"700px\"} Expand the External Library (as shown) to reveal the JAR files contained in the library. Drill down into the JAR files to expose the packages and (decompiled) classes. Exploring APIs as an Extender If a project is dependent on a plugin or module, in some cases, the project can also extend the functionality available from the plugin or module. To browse the opportunities for extension, start by placing the cursor on the contents of the <depends> elements in the project's plugin.xml file. Use the Go to Declaration IDE feature to navigate to the plugin.xml file for the plugin on which the project depends. For example, performing this procedure on the <depends>com.jetbrains.php</depends> declaration in a project's plugin.xml file will navigate to the plugin.xml file for the com.jetbrains.php (PHP) project. A common, but not universal, pattern in the Consulo is for a plugin (like PHP) to declare <extensionPoints> and then implement each one as <extensions> . Continuing the example, search the PHP plugin's plugin.xml file for: * <extensionPoints> to find the opportunities for extending the PHP plugin's functionality. * <extensions defaultExtensionNs=\"com.jetbrains.php\"> to find where the PHP plugin extends functionality. The extension namespace (in this example com.jetbrains.php ) will match the <id> defined in the plugin.xml file. Verifying Dependency Before marking a plugin project as dependent only on modules in a target product in addition to com.intellij.modules.platform , verify the plugin isn't implicitly dependent on any APIs that are specific to IntelliJ IDEA. For Gradle-based projects, Plugin Verifier can be used to ensure compatibility with all specified target IDEs. For DevKit-based projects, create an SDK pointing to an installation of the intended target Consulo-based product, e.g., PhpStorm, rather than IntelliJ IDEA. Use the same development version of the Consulo as the targeted product. Based on the tables above, the JetBrains Plugins Repository automatically detects the JetBrains products with which a plugin is compatible, and makes the compatibility information available to plugin authors. The compatibility information determines if plugins are available at the plugin repository to users of a particular JetBrains product. Platform API Version Compatibility The API of Consulo and bundled plugins may change between releases. The significant changes that may break plugins are listed on Incompatible Changes in Consulo and Plugins API page.","title":"Plugin Compatibility with Consulo Products"},{"location":"basics/getting_started/plugin_compatibility/#introduction","text":"All products based on the Consulo are built on the same underlying API. Some of these products share features built on top of the platform, such as Java support in IntelliJ IDEA and Android Studio. Underlying those shared features are shared components. When authoring a plugin for the Consulo, it is important to understand and declare dependencies on these components. Otherwise, it may not be possible to load or run the plugin in a product because the components on which it depends aren't available. TIP Qualifying Open Source projects can apply for free licenses of JetBrains products. bullet list {:toc}","title":"Introduction"},{"location":"basics/getting_started/plugin_compatibility/#declaring-plugin-dependencies","text":"For the purposes of dependencies, a module can be thought of like a built-in plugin that ships as a non-removable part of a product. A working definition of a dependency is that a plugin project cannot be run without the module present in an Consulo-based product. Declaring a dependency on a module also expresses a plugin's compatibility with a product in that the Consulo determines whether a product contains the correct modules to support a plugin before loading it. Part I of this document describes the syntax for declaring plugin dependencies and optional plugin dependencies. Part II of this document (below) describes the Consulo modules' functionality to aid in determining the dependencies of a plugin. The way dependency declarations are handled by the Consulo is determined by the contents of the plugin.xml file: * If a plugin does not declare any dependencies in its plugin.xml file, or if it declares dependencies only on other plugins but not modules, it's assumed to be a legacy plugin and is loaded only in IntelliJ IDEA. This configuration of the dependency declaration is deprecated; do not use it for new plugin projects. * If a plugin declares at least one module dependency in its plugin.xml file, the plugin is loaded if an Consulo-based product contains all the modules and plugins on which the plugin has declared a dependency.","title":"Declaring Plugin Dependencies"},{"location":"basics/getting_started/plugin_compatibility/#modules","text":"A module represents a built-in plugin that is a non-removable part of a product. Some modules are available in all products, and some modules are available only in some, or even just one product. This section identifies and discusses modules of both types.","title":"Modules"},{"location":"basics/getting_started/plugin_compatibility/#declaring-incompatibility-with-module","text":"Starting in 2020.2, a plugin can declare incompatibility with an arbitrary module by specifying <incompatible-with> containing module ID in its plugin.xml .","title":"Declaring Incompatibility with Module"},{"location":"basics/getting_started/plugin_compatibility/#modules-available-in-all-products","text":"A core set of modules are available in all products based on the Consulo. These modules provide a set of shared functionality. The following table lists modules that are currently available in all products. NOTE All plugins should declare a dependency on com.intellij.modules.platform to indicate dependence on shared functionality. Module for <depends> Element Declaration in plugin.xml File Functionality com.intellij.modules.platform Messaging, UI Themes, UI Components, Files, Documents, Actions, Components, Services, Extensions, Editors com.intellij.modules.lang File Type, Lexer, Parser, Highlighting, References, Code Completion, Find, Rename, Formatter, Code Navigation com.intellij.modules.xml XML, XML DOM, XSD/DTD, DOM Model com.intellij.modules.vcs VCS Revision Numbers, File Status, Change Lists, File History, Annotations com.intellij.modules.xdebugger Debug Session, Stack Frames, Break Points, Source Positions, Memory Views, Tracked Instances As of this writing, if a plugin: A) is dependent only on one or more of the modules in the table above, and B) declares those module dependencies in plugin.xml , then any product developed by JetBrains based on the Consulo will load it.","title":"Modules Available in All Products"},{"location":"basics/getting_started/plugin_compatibility/#modules-specific-to-functionality","text":"More specialized functionality is also delivered via modules and plugins in Consulo-based products. For example, the com.intellij.modules.python module supports the Python language-specific functionality. If a plugin uses this module's functionality, such as Python-specific inspections and refactoring, it must declare a dependency on this module. Note that not all products define and declare modules. For example, PhpStorm does not have its own module, but the product itself depends on (and ships with) the PHP language plugin. A plugin project is compatible with PHP functionality if it declares a dependency on this PHP language plugin. The following table lists (1) modules or built-in plugins that provide specific functionality, and the products currently shipping with them. Module or Plugin for <depends> Element Declaration in plugin.xml File Functionality Consulo-Based Product Compatibility com.intellij.modules.java See (2) below. com.intellij.java Java language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework IntelliJ IDEA, Android Studio com.intellij.modules.androidstudio Android SDK Platform, Build Tools, Platform Tools, SDK Tools Android Studio com.intellij.modules.appcode CocoaPods, Core Data Objects, Device & Simulator Support AppCode com.intellij.modules.cidr.lang C, C++, Objective-C/C++ language PSI Model, Swift/Objective-C Interaction, Inspections, Intentions, Completion, Refactoring, Test Framework AppCode, CLion com.intellij.modules.cidr.debugger Debugger Watches, Evaluations, Breakpoints, Inline Debugging AppCode, CLion, RubyMine com.intellij.modules.clion CMake, Profiler, Embedded Development, Remote Development, Remote Debug, Disassembly CLion com.intellij.database Database Tools and SQL language PSI Model, Inspections, Completion, Refactoring, Queries DataGrip, IntelliJ IDEA Ultimate, AppCode, PhpStorm, PyCharm Professional, RubyMine, CLion, GoLand, Rider, and WebStorm if the Database Tools and SQL plugin is installed. com.intellij.modules.go Go language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework GoLand com.intellij.modules.python Python language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework PyCharm, and other products if the Python plugin is installed. com.intellij.modules.rider Connection to ReSharper Process in Background Rider com.intellij.modules.ruby Ruby language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework RubyMine, and IntelliJ IDEA Ultimate if the Ruby plugin is installed. com.intellij.modules.ultimate Licensing All commercial IDEs (IntelliJ IDEA Ultimate, PhpStorm, DataGrip, ...) com.jetbrains.php PHP language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework PhpStorm, and other products if the PHP plugin is installed. JavaScript JavaScript language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework WebStorm, and other products if the JavaScript plugin is installed. Notes about Module and Plugin Dependency: (1) This table is not exhaustive; other modules are currently available in JetBrains' Consulo-based IDEs. To see a list of modules, invoke the code completion feature for the <depends> element contents while editing the plugin.xml file. (2) The Java language functionality was extracted as a plugin in version 2019.2 of the Consulo. This refactoring separated the Java implementation from the other, non-language portions of the platform. Consequently, dependencies on Java functionality are expressed differently in plugin.xml depending on the version of the Consulo being targeted: Syntax for 2019.2 and later releases: plugin.xml allowable alternative add <depends>com.intellij.java</depends> build.gradle required define dependency on Java plugin intellij { plugins = ['com.intellij.java'] } Syntax required for releases prior to 2019.2, allowable in all releases: plugin.xml add <depends>com.intellij.modules.java</depends>","title":"Modules Specific to Functionality"},{"location":"basics/getting_started/plugin_compatibility/#exploring-module-and-plugin-apis","text":"Once the dependency on a module or plugin is declared in plugin.xml , it's useful to explore the packages and classes available in that dependency. The section below gives some recommended procedures for discovering what's available in a module or plugin on which a project depends. These procedures assume a project has the build.gradle and plugin.xml dependencies configured correctly.","title":"Exploring Module and Plugin APIs"},{"location":"basics/getting_started/plugin_compatibility/#exploring-apis-as-a-consumer","text":"Exploring the available packages and classes in a plugin or module utilizes features in the IntelliJ IDEA IDE. If the project is not up to date, Reimport the Gradle project as a first step. Reimporting the project will automatically update the dependencies. In the Project Window, select Project View and scroll to the bottom to see External Libraries . Look for the library Gradle:unzipped.com.jetbrains.plugins:foo: , where \"foo\" matches, or is similar to the contents of the <depends> tags in plugin.xml or the intellij.plugins declaration in build.gradle . The image below shows the External Libraries for the example plugin project configuration explained in Configuring build.gradle and Configuring plugin.xml . {:width=\"700px\"} Expand the External Library (as shown) to reveal the JAR files contained in the library. Drill down into the JAR files to expose the packages and (decompiled) classes.","title":"Exploring APIs as a Consumer"},{"location":"basics/getting_started/plugin_compatibility/#exploring-apis-as-an-extender","text":"If a project is dependent on a plugin or module, in some cases, the project can also extend the functionality available from the plugin or module. To browse the opportunities for extension, start by placing the cursor on the contents of the <depends> elements in the project's plugin.xml file. Use the Go to Declaration IDE feature to navigate to the plugin.xml file for the plugin on which the project depends. For example, performing this procedure on the <depends>com.jetbrains.php</depends> declaration in a project's plugin.xml file will navigate to the plugin.xml file for the com.jetbrains.php (PHP) project. A common, but not universal, pattern in the Consulo is for a plugin (like PHP) to declare <extensionPoints> and then implement each one as <extensions> . Continuing the example, search the PHP plugin's plugin.xml file for: * <extensionPoints> to find the opportunities for extending the PHP plugin's functionality. * <extensions defaultExtensionNs=\"com.jetbrains.php\"> to find where the PHP plugin extends functionality. The extension namespace (in this example com.jetbrains.php ) will match the <id> defined in the plugin.xml file.","title":"Exploring APIs as an Extender"},{"location":"basics/getting_started/plugin_compatibility/#verifying-dependency","text":"Before marking a plugin project as dependent only on modules in a target product in addition to com.intellij.modules.platform , verify the plugin isn't implicitly dependent on any APIs that are specific to IntelliJ IDEA. For Gradle-based projects, Plugin Verifier can be used to ensure compatibility with all specified target IDEs. For DevKit-based projects, create an SDK pointing to an installation of the intended target Consulo-based product, e.g., PhpStorm, rather than IntelliJ IDEA. Use the same development version of the Consulo as the targeted product. Based on the tables above, the JetBrains Plugins Repository automatically detects the JetBrains products with which a plugin is compatible, and makes the compatibility information available to plugin authors. The compatibility information determines if plugins are available at the plugin repository to users of a particular JetBrains product.","title":"Verifying Dependency"},{"location":"basics/getting_started/plugin_compatibility/#platform-api-version-compatibility","text":"The API of Consulo and bundled plugins may change between releases. The significant changes that may break plugins are listed on Incompatible Changes in Consulo and Plugins API page.","title":"Platform API Version Compatibility"},{"location":"basics/getting_started/publishing_plugin/","text":"When your plugin is ready, you can publish it to a plugin repository so that other users can install it. You can choose to publish it on the JetBrains Plugins Repository or a custom plugin repository . TIP Please see Marketing for remarks on how to prepare your plugin for optimal presentation. Publishing to the JetBrains Plugins Repository To upload your plugin to the JetBrains Plugins Repository , you must log in with your personal JetBrains Account. To get your JetBrains account: Open the JetBrains Account Center and click Create Account . Fill in all fields in the Create JetBrains Account form that opens and click Register . To upload your plugin to JetBrains Plugins Repository: Log in to JetBrains Plugins Repository with your personal JetBrains account. On your Profile page that opens, click Add new plugin . Fill in the Add new plugin form that opens and click the Add the plugin button to upload your plugin. Publishing a Plugin to a Custom Plugin Repository If you plan to publish your plugin to a repository other than the JetBrains Plugins Repository , please refer to the Publishing to Custom Plugin Repositories documentation.","title":"Publishing a Plugin"},{"location":"basics/getting_started/publishing_plugin/#publishing-to-the-jetbrains-plugins-repository","text":"To upload your plugin to the JetBrains Plugins Repository , you must log in with your personal JetBrains Account. To get your JetBrains account: Open the JetBrains Account Center and click Create Account . Fill in all fields in the Create JetBrains Account form that opens and click Register . To upload your plugin to JetBrains Plugins Repository: Log in to JetBrains Plugins Repository with your personal JetBrains account. On your Profile page that opens, click Add new plugin . Fill in the Add new plugin form that opens and click the Add the plugin button to upload your plugin.","title":"Publishing to the JetBrains Plugins Repository"},{"location":"basics/getting_started/publishing_plugin/#publishing-a-plugin-to-a-custom-plugin-repository","text":"If you plan to publish your plugin to a repository other than the JetBrains Plugins Repository , please refer to the Publishing to Custom Plugin Repositories documentation.","title":"Publishing a Plugin to a Custom Plugin Repository"},{"location":"basics/getting_started/running_and_debugging_a_plugin/","text":"It's possible to run and debug a plugin directly from the IntelliJ IDEA . You need a configured special profile (a Plugin Run/Debug configuration) that specifies the plugin module, VM parameters, and other specific options. When you run such a profile, it launches the IDE with your plugin installed. See IDE Development Instances for more information about configuration and advanced settings. For information on how to change the Run/Debug configuration profile, refer to Run/Debug Configuration and Run/Debug Configuration: Plugin in IntelliJ IDEA Web Help. Using IntelliJ IDEA 's debugger, you can find out the origin of the run-time errors and exceptions. To debug a plugin Select Run | Debug in the main menu, or press Shift + F9 . To run a plugin Select Run | Run in the main menu, or press Shift + F10 .","title":"Running and Debugging a Plugin"},{"location":"basics/getting_started/setting_up_environment/","text":"NOTE For new projects, it is highly recommended to use Gradle . Preliminary Steps Use the following checklist to ensure that you are ready to develop your custom plugins. Get IntelliJ IDEA CE source code on your local computer. Getting IntelliJ IDEA CE source code is not a requirement for plugin development, but having it makes debugging your plugins much more straightforward. For detailed instructions, refer to the Getting IntelliJ IDEA Community Edition Source Code section of Check Out And Build Community Edition . Note that building IntelliJ IDEA CE from source code is not required for plugin development. Plugin DevKit plugin must be enabled in IntelliJ IDEA . Consulo SDK must be configured for your IDEA project. For more information, see below. Configuring Consulo SDK To set up your plugin development environment: Create a new Consulo SDK under File | Project Structure : Specify the installation folder of the IntelliJ IDEA Community Edition as the home directory. WARNING You may use IntelliJ IDEA Ultimate as an alternative, but debugging the core code will only work with the Community Edition . Select 1.8 as the default Java SDK. See the IntelliJ Build Configuration section of Check Out And Build Community Edition for instructions about creating 1.8 Java SDK. In the Sourcepath tab of the SDK settings, click the Add button: Specify the source code directory for the IntelliJ IDEA Community Edition : Specify the Sandbox Home directory. The Sandbox Home directory stores the settings of the IDE development instance launched from a Plugin Project's Run configuration. Shown below is the default Sandbox Home directory for a user on Mac OS X. Any directory can be chosen as the Sandbox Home location. Use the ellipsis button (shown below) to define a custom location. See the IDE Development Instances page for more information about default Sandbox Home directory locations and contents.","title":"Setting Up a Development Environment"},{"location":"basics/getting_started/setting_up_environment/#preliminary-steps","text":"Use the following checklist to ensure that you are ready to develop your custom plugins. Get IntelliJ IDEA CE source code on your local computer. Getting IntelliJ IDEA CE source code is not a requirement for plugin development, but having it makes debugging your plugins much more straightforward. For detailed instructions, refer to the Getting IntelliJ IDEA Community Edition Source Code section of Check Out And Build Community Edition . Note that building IntelliJ IDEA CE from source code is not required for plugin development. Plugin DevKit plugin must be enabled in IntelliJ IDEA . Consulo SDK must be configured for your IDEA project. For more information, see below.","title":"Preliminary Steps"},{"location":"basics/getting_started/setting_up_environment/#configuring-consulo-sdk","text":"To set up your plugin development environment: Create a new Consulo SDK under File | Project Structure : Specify the installation folder of the IntelliJ IDEA Community Edition as the home directory. WARNING You may use IntelliJ IDEA Ultimate as an alternative, but debugging the core code will only work with the Community Edition . Select 1.8 as the default Java SDK. See the IntelliJ Build Configuration section of Check Out And Build Community Edition for instructions about creating 1.8 Java SDK. In the Sourcepath tab of the SDK settings, click the Add button: Specify the source code directory for the IntelliJ IDEA Community Edition : Specify the Sandbox Home directory. The Sandbox Home directory stores the settings of the IDE development instance launched from a Plugin Project's Run configuration. Shown below is the default Sandbox Home directory for a user on Mac OS X. Any directory can be chosen as the Sandbox Home location. Use the ellipsis button (shown below) to define a custom location. See the IDE Development Instances page for more information about default Sandbox Home directory locations and contents.","title":"Configuring Consulo SDK"},{"location":"basics/getting_started/update_plugins_format/","text":"If you intend to use a plugin repository other than the JetBrains Plugins Repository , you will need to: * Create and maintain an updatePlugins.xml file on the HTTPS web server you are using for your custom repository. This file describes all the plugins available in your custom repository and each plugin's download URL. * Upload your plugin JAR/ZIP file to an HTTPS web server. This can be the same web server you are using for the custom repository or a different HTTPS web server. * Add the URL for the custom repository to the JetBrains IDE Repository Settings/Preferences . TIP Gradle plugin IntelliJ plugin uploader can be used to automate deployment. Describing Your Plugins in updatePlugins.xml File Every custom plugin repository must have at least one updatePlugins.xml file to describe every hosted plugin's latest available version. The description in updatePlugins.xml is used by JetBrains IDEs to locate plugins by attributes such as id, IDE version, and plugin version. These attributes are displayed by JetBrains IDEs to help users select or upgrade plugins. The description also tells the JetBrains IDE where to download the plugin itself. A custom plugin repository's updatePlugins.xml file is constructed and maintained by the repository administrator. More than one updatePlugins.xml file may be required if the custom repository consumers are using more than one version of a JetBrains IDE. For example, updatePlugins-182.xml , updatePlugins-183.xml for IntelliJ IDEA 2018.2 and 2018.3, respectively. Each updatePlugins-*.xml file will have a unique URL that is added to the JetBrains IDE Repository Settings/Preferences . Format of updatePlugins.xml File The format of an updatePlugins.xml file is simply a list of sequential elements that describe each plugin: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!-- The <plugins> element contains the description of the plugins available at this repository. Required. --> <plugins> <!-- Each <plugin> element describes one plugin in the repository. Required. id - used by JetBrains IDEs to uniquely identify a plugin. Required. Must match <id> in plugin.xml url - path to download the plugin JAR/ZIP file. Required. Must be HTTPS version - version of this plugin. Required. Must match <version> in plugin.xml --> <plugin id= \"fully.qualified.id.of.this.plugin\" url= \"https://www.mycompany.com/my_repository/mypluginname.jar\" version= \"major.minor.update\" > <!-- The <idea-version> element must match the same element in plugin.xml. Required. --> <idea-version since-build= \"181.3\" until-build= \"191.*\" /> </plugin> <plugin id= \"id.of.different.plugin\" url= \"https://www.otherserver.com/other_repository/differentplugin.jar\" version= \"major.minor\" > <idea-version since-build= \"181.3\" until-build= \"191.*\" /> </plugin> <plugin> <!-- And so on for other plugins... --> </plugin> </plugins> Note: * An updatePlugins.xml file must contain at least one set of <plugin></plugin> elements. * A plugin id may be listed only once in an updatePlugins.xml file. * Multiple plugins with the same id but different idea-version attributes must be split into separate updatePlugins-*.xml files. The requesting IDE's version is passed as build parameter and can be used for server-side filtering. Optional updatePlugin.xml Elements Can additional elements be added to updatePlugins.xml ? Yes, but it's advisable only if needed. The additional elements will have to be synchronized with each plugin's plugin.xml file. During plugin installation the IDE reads the plugin JAR/ZIP file, and thereafter displays more information about the plugin. What additional information might help a user select a plugin when browsing the custom plugin repository before installation? The answer depends on the plugins and repository consumers. Here are the candidate elements: Element Effects & Requirements <name> My Plugin Name </name> By default the name of the plugin JAR/ZIP file is displayed before installation. Using the <name> element displays the name of the plugin. Contents should match the <name> element contents in the plugins's plugin.xml file to avoid confusion. <description> My plugin is awesome </description> By default no description for the plugin is displayed before installation. Using the <description> element will cause a description to be displayed before installation. Contents should match the <description> element contents in the plugins's plugin.xml file to avoid confusion. Optionally, an enclosing <![CDATA[ ]]> element can be used if the description needs to contain HTML tags. <change-notes> Added cool feature </change-notes> By default no change notes for the plugin are displayed before installation. Using the <change-notes> element will cause a description of changes to be displayed before installation. Contents should match the <change-notes> element contents in the plugin's plugin.xml file to avoid confusion. Optionally, an enclosing <![CDATA[ ]]> element can be used if the change notes need to contain HTML tags.","title":"Publishing a Plugin to a Custom Plugin Repository"},{"location":"basics/getting_started/update_plugins_format/#describing-your-plugins-in-updatepluginsxml-file","text":"Every custom plugin repository must have at least one updatePlugins.xml file to describe every hosted plugin's latest available version. The description in updatePlugins.xml is used by JetBrains IDEs to locate plugins by attributes such as id, IDE version, and plugin version. These attributes are displayed by JetBrains IDEs to help users select or upgrade plugins. The description also tells the JetBrains IDE where to download the plugin itself. A custom plugin repository's updatePlugins.xml file is constructed and maintained by the repository administrator. More than one updatePlugins.xml file may be required if the custom repository consumers are using more than one version of a JetBrains IDE. For example, updatePlugins-182.xml , updatePlugins-183.xml for IntelliJ IDEA 2018.2 and 2018.3, respectively. Each updatePlugins-*.xml file will have a unique URL that is added to the JetBrains IDE Repository Settings/Preferences .","title":"Describing Your Plugins in updatePlugins.xml File"},{"location":"basics/getting_started/update_plugins_format/#format-of-updatepluginsxml-file","text":"The format of an updatePlugins.xml file is simply a list of sequential elements that describe each plugin: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!-- The <plugins> element contains the description of the plugins available at this repository. Required. --> <plugins> <!-- Each <plugin> element describes one plugin in the repository. Required. id - used by JetBrains IDEs to uniquely identify a plugin. Required. Must match <id> in plugin.xml url - path to download the plugin JAR/ZIP file. Required. Must be HTTPS version - version of this plugin. Required. Must match <version> in plugin.xml --> <plugin id= \"fully.qualified.id.of.this.plugin\" url= \"https://www.mycompany.com/my_repository/mypluginname.jar\" version= \"major.minor.update\" > <!-- The <idea-version> element must match the same element in plugin.xml. Required. --> <idea-version since-build= \"181.3\" until-build= \"191.*\" /> </plugin> <plugin id= \"id.of.different.plugin\" url= \"https://www.otherserver.com/other_repository/differentplugin.jar\" version= \"major.minor\" > <idea-version since-build= \"181.3\" until-build= \"191.*\" /> </plugin> <plugin> <!-- And so on for other plugins... --> </plugin> </plugins> Note: * An updatePlugins.xml file must contain at least one set of <plugin></plugin> elements. * A plugin id may be listed only once in an updatePlugins.xml file. * Multiple plugins with the same id but different idea-version attributes must be split into separate updatePlugins-*.xml files. The requesting IDE's version is passed as build parameter and can be used for server-side filtering.","title":"Format of updatePlugins.xml File"},{"location":"basics/getting_started/update_plugins_format/#optional-updatepluginxml-elements","text":"Can additional elements be added to updatePlugins.xml ? Yes, but it's advisable only if needed. The additional elements will have to be synchronized with each plugin's plugin.xml file. During plugin installation the IDE reads the plugin JAR/ZIP file, and thereafter displays more information about the plugin. What additional information might help a user select a plugin when browsing the custom plugin repository before installation? The answer depends on the plugins and repository consumers. Here are the candidate elements: Element Effects & Requirements <name> My Plugin Name </name> By default the name of the plugin JAR/ZIP file is displayed before installation. Using the <name> element displays the name of the plugin. Contents should match the <name> element contents in the plugins's plugin.xml file to avoid confusion. <description> My plugin is awesome </description> By default no description for the plugin is displayed before installation. Using the <description> element will cause a description to be displayed before installation. Contents should match the <description> element contents in the plugins's plugin.xml file to avoid confusion. Optionally, an enclosing <![CDATA[ ]]> element can be used if the description needs to contain HTML tags. <change-notes> Added cool feature </change-notes> By default no change notes for the plugin are displayed before installation. Using the <change-notes> element will cause a description of changes to be displayed before installation. Contents should match the <change-notes> element contents in the plugin's plugin.xml file to avoid confusion. Optionally, an enclosing <![CDATA[ ]]> element can be used if the change notes need to contain HTML tags.","title":"Optional updatePlugin.xml Elements"},{"location":"basics/getting_started/using_dev_kit/","text":"NOTE For new projects, it is highly recommended to use Gradle . Plugin DevKit is a bundled IntelliJ IDEA plugin for developing plugins for the Consulo using IntelliJ IDEA's build system. It provides its custom SDK type and a set of actions for building plugins within the IDE. In this section: Setting Up a Development Environment Creating a Plugin Project Creating Actions Running and Debugging a Plugin Deploying a Plugin Publishing a Plugin","title":"Using DevKit"},{"location":"basics/indexing_and_psi_stubs/file_based_indexes/","text":"File-based indexes are based on a Map/Reduce architecture. Each index has a specific type of key and a particular type of value. The key is what's later used to retrieve data from the index. Example: in the word index, the key is the word itself. The value is arbitrary data, which is associated with the key in the index. Example: in the word index, the value is a mask indicating in which context the word occurs (code, string literal, or comment). In the simplest case, when we only need to know in what files some data is present, the value has type Void and is not stored in the index. When the index implementation indexes a file, it receives a file's content and returns a map from the keys found in the file to the associated values. When you access the index, you specify the key you're interested in and get back the list of files in which the key occurs, and the value associated with each file. Implementing a File-Based Index A relatively simple file-based index implementation is the UI Designer bound forms index . Refer to it as an example to understand this topic better. Each specific index implementation is a class extending FileBasedIndexExtension . A file-based index should be registered in the com.intellij.fileBasedIndex extension point. An implementation of a file-based index consists of the following main parts: getIndexer() returns the indexer class actually responsible for building a set of key/value pairs based on file content. getKeyDescriptor() returns the key descriptor responsible for comparing keys and storing them in a serialized binary format. Probably the most commonly used KeyDescriptor implementation is EnumeratorStringDescriptor , which is designed for storing efficiently storing identifiers. * getValueExternalizer() returns the value serializer responsible for storing values in a serialized binary format. * getInputFilter() allows restricting the indexing only to a certain set of files. * getVersion() returns the version of the index implementation. The index is automatically rebuilt if the current version differs from the version of the index implementation used to build it. If you don't need to associate any value with the files (i.e., your value type is Void ), you can simplify the implementation by using ScalarIndexExtension as the base class. WARNING The data returned by DataIndexer.map() must depend only on input data passed to the method, and must not depend on any external files. Otherwise, your index will not be correctly updated when the external data changes, and you will have stale data in your index. NOTE Please see com.intellij.util.indexing.DebugAssertions on how to enable additional debugging assertions during development to assert correct index implementation. Accessing a File-Based Index Access to file-based indexes is performed through the FileBasedIndex class. The following primary operations are supported: getAllKeys() and processAllKeys() allow obtaining the list of all keys found in files, which are a part of the specified project. NOTE The returned data is guaranteed to contain all keys found in up-to-date project content, but may also include additional keys not currently found in the project. getValues() allows to get all values associated with a specific key but not the files in which they were found. getContainingFiles() allows collecting all files in which a particular key was encountered. processValues() allows iterating through all files in which a specific key was encountered and accessing the associated values simultaneously. WARNING Nested index access is forbidden as it might lead to a deadlock. Collect all necessary data from index A first, then process results while accessing index B. Standard Indexes The Consulo contains several standard file-based indexes. The most useful indexes for plugin developers are: Word Index Generally, the word index should be accessed indirectly by using helper methods of the PsiSearchHelper class. File Name Index FilenameIndex provides a quick way to find all files matching a specific file name. File Type Index FileTypeIndex serves a similar goal: it allows to find all files of a particular FileType quickly.","title":"File-Based Indexes"},{"location":"basics/indexing_and_psi_stubs/file_based_indexes/#implementing-a-file-based-index","text":"A relatively simple file-based index implementation is the UI Designer bound forms index . Refer to it as an example to understand this topic better. Each specific index implementation is a class extending FileBasedIndexExtension . A file-based index should be registered in the com.intellij.fileBasedIndex extension point. An implementation of a file-based index consists of the following main parts: getIndexer() returns the indexer class actually responsible for building a set of key/value pairs based on file content. getKeyDescriptor() returns the key descriptor responsible for comparing keys and storing them in a serialized binary format. Probably the most commonly used KeyDescriptor implementation is EnumeratorStringDescriptor , which is designed for storing efficiently storing identifiers. * getValueExternalizer() returns the value serializer responsible for storing values in a serialized binary format. * getInputFilter() allows restricting the indexing only to a certain set of files. * getVersion() returns the version of the index implementation. The index is automatically rebuilt if the current version differs from the version of the index implementation used to build it. If you don't need to associate any value with the files (i.e., your value type is Void ), you can simplify the implementation by using ScalarIndexExtension as the base class. WARNING The data returned by DataIndexer.map() must depend only on input data passed to the method, and must not depend on any external files. Otherwise, your index will not be correctly updated when the external data changes, and you will have stale data in your index. NOTE Please see com.intellij.util.indexing.DebugAssertions on how to enable additional debugging assertions during development to assert correct index implementation.","title":"Implementing a File-Based Index"},{"location":"basics/indexing_and_psi_stubs/file_based_indexes/#accessing-a-file-based-index","text":"Access to file-based indexes is performed through the FileBasedIndex class. The following primary operations are supported: getAllKeys() and processAllKeys() allow obtaining the list of all keys found in files, which are a part of the specified project. NOTE The returned data is guaranteed to contain all keys found in up-to-date project content, but may also include additional keys not currently found in the project. getValues() allows to get all values associated with a specific key but not the files in which they were found. getContainingFiles() allows collecting all files in which a particular key was encountered. processValues() allows iterating through all files in which a specific key was encountered and accessing the associated values simultaneously. WARNING Nested index access is forbidden as it might lead to a deadlock. Collect all necessary data from index A first, then process results while accessing index B.","title":"Accessing a File-Based Index"},{"location":"basics/indexing_and_psi_stubs/file_based_indexes/#standard-indexes","text":"The Consulo contains several standard file-based indexes. The most useful indexes for plugin developers are:","title":"Standard Indexes"},{"location":"basics/indexing_and_psi_stubs/file_based_indexes/#word-index","text":"Generally, the word index should be accessed indirectly by using helper methods of the PsiSearchHelper class.","title":"Word Index"},{"location":"basics/indexing_and_psi_stubs/file_based_indexes/#file-name-index","text":"FilenameIndex provides a quick way to find all files matching a specific file name.","title":"File Name Index"},{"location":"basics/indexing_and_psi_stubs/file_based_indexes/#file-type-index","text":"FileTypeIndex serves a similar goal: it allows to find all files of a particular FileType quickly.","title":"File Type Index"},{"location":"basics/indexing_and_psi_stubs/stub_indexes/","text":"Stub Trees A stub tree is a subset of the PSI tree for a file; it is stored in a compact serialized binary format. The PSI tree for a file can be backed either by the AST (built by parsing the file) or by the stub tree deserialized from disk. Switching between the two is transparent. The stub tree contains only a subset of the nodes. Typically, it contains only the nodes needed to resolve the declarations contained in this file from external files. Trying to access any node that is not part of the stub tree or perform any operation that cannot be satisfied by the stub tree, e.g., accessing the text of a PSI element, causes file parsing to switch from the PSI to AST backing. Each stub in the stub tree is simply a bean class with no behavior. A stub stores a subset of the corresponding PSI element's state, like the element's name, modifier flags like public or final, etc. The stub also holds a pointer to its parent in the tree and a list of its children's stubs. To support stubs for your custom language, you first need to decide which of your PSI tree elements should be stored as stubs. Typically, you need to have stubs for things like methods or fields visible from other files. You usually don't need to have stubs for things like statements or local variables, which are not visible externally. For each element type that you want to store in the stub tree, you need to perform the following steps: Define an interface for the stub, derived from the StubElement interface ( example ). Provide an implementation for the interface ( example ). Make sure the interface for the PSI element extends StubBasedPsiElement parameterized by the type of the stub interface ( example ). Make sure the implementation class for the PSI element extends StubBasedPsiElementBase parameterized by the type of the stub interface ( example ). Provide both a constructor that accepts an ASTNode and a constructor that accepts a stub. Create a class that implements IStubElementType and is parameterized with the stub interface and the actual PSI element interface ( example ). Implement the createPsi() and createStub() methods for creating PSI from a stub and vice versa. Implement the serialize() and deserialize() methods for storing the data in a binary stream. Use the class implementing IStubElementType as the element type constant when parsing ( example ). Make sure all methods in the PSI element interface access the stub data rather than the PSI tree when appropriate ( example: Property.getKey() implementation ). The following steps need to be performed only once for each language that supports stubs: Change the file element type for your language (the element type that you return from ParserDefinition.getFileNodeType() ) to a class that extends IStubFileElementType . In your plugin.xml , define the com.intellij.stubElementTypeHolder extension and specify the interface which contains the IElementType constants used by your language's parser as well as externalIdPrefix if possible ( example ). For serializing string data, e.g. element names, in stubs, we recommend to use StubOutputStream.writeName() and StubInputStream.readName() methods. These methods ensure that each unique identifier is stored only once in the data stream. This reduces the size of the serialized stub tree data. If you need to change the stored binary format for the stubs (for example, if you want to store some additional data or some new elements), make sure you advance the stub version returned from IStubFileElementType.getStubVersion() for your language. This will cause the stubs and stub indices to be rebuilt, and will avoid mismatches between the stored data format, and the code trying to load it. By default, if a PSI element extends StubBasedPsiElement , all elements of that type will be stored in the stub tree. If you need more precise control over which elements are stored, override IStubElementType.shouldCreateStub() and return false for elements that should not be included in the stub tree. NOTE The exclusion is not recursive: if some elements of the element for which you returned false are also stub-based PSI elements, they will be included in the stub tree. It's essential to ensure that all information stored in the stub tree depends only on the contents of the file for which stubs are being built, and does not depend on any external files. Otherwise, the stub tree will not be rebuilt when external dependency changes, and you will have stale and incorrect data in the stub tree. TIP Please see also Improving indexing performance . Stub Indexes When building the stub tree, you can, at the same time, put some data about the stub elements into a number of indexes, which then can be used to find the PSI elements by the corresponding key. Unlike file-based indexes, stub indexes do not support storing custom data as values; the value is always a PSI element. Keys in stub indexes are typically strings (such as class names); other data types are also supported if desired. A stub index is a class which extends AbstractStubIndex . In the most common case, when the key type is String , you use a more specific base class, namely StringStubIndexExtension . Stub index implementation classes are registered in the com.intellij.stubIndex extension point. To put data into an index, you implement the method IStubElementType.indexStub() ( example: JavaClassElementType.indexStub() ). This method accepts an IndexSink as a parameter and puts in the index ID and the key for each index in which the element should be stored. To access the data from an index, the following two methods are used: AbstractStubIndex.getAllKeys() returns the list of all keys in the specified index for the specified project (for example, the list of all class names found in the project). AbstractStubIndex.get() returns the collection of PSI elements corresponding to a certain key (for example, classes with the specified short name) in the specified scope. Related Forum Discussions Lifecycle of stub creation","title":"Stub Indexes"},{"location":"basics/indexing_and_psi_stubs/stub_indexes/#stub-trees","text":"A stub tree is a subset of the PSI tree for a file; it is stored in a compact serialized binary format. The PSI tree for a file can be backed either by the AST (built by parsing the file) or by the stub tree deserialized from disk. Switching between the two is transparent. The stub tree contains only a subset of the nodes. Typically, it contains only the nodes needed to resolve the declarations contained in this file from external files. Trying to access any node that is not part of the stub tree or perform any operation that cannot be satisfied by the stub tree, e.g., accessing the text of a PSI element, causes file parsing to switch from the PSI to AST backing. Each stub in the stub tree is simply a bean class with no behavior. A stub stores a subset of the corresponding PSI element's state, like the element's name, modifier flags like public or final, etc. The stub also holds a pointer to its parent in the tree and a list of its children's stubs. To support stubs for your custom language, you first need to decide which of your PSI tree elements should be stored as stubs. Typically, you need to have stubs for things like methods or fields visible from other files. You usually don't need to have stubs for things like statements or local variables, which are not visible externally. For each element type that you want to store in the stub tree, you need to perform the following steps: Define an interface for the stub, derived from the StubElement interface ( example ). Provide an implementation for the interface ( example ). Make sure the interface for the PSI element extends StubBasedPsiElement parameterized by the type of the stub interface ( example ). Make sure the implementation class for the PSI element extends StubBasedPsiElementBase parameterized by the type of the stub interface ( example ). Provide both a constructor that accepts an ASTNode and a constructor that accepts a stub. Create a class that implements IStubElementType and is parameterized with the stub interface and the actual PSI element interface ( example ). Implement the createPsi() and createStub() methods for creating PSI from a stub and vice versa. Implement the serialize() and deserialize() methods for storing the data in a binary stream. Use the class implementing IStubElementType as the element type constant when parsing ( example ). Make sure all methods in the PSI element interface access the stub data rather than the PSI tree when appropriate ( example: Property.getKey() implementation ). The following steps need to be performed only once for each language that supports stubs: Change the file element type for your language (the element type that you return from ParserDefinition.getFileNodeType() ) to a class that extends IStubFileElementType . In your plugin.xml , define the com.intellij.stubElementTypeHolder extension and specify the interface which contains the IElementType constants used by your language's parser as well as externalIdPrefix if possible ( example ). For serializing string data, e.g. element names, in stubs, we recommend to use StubOutputStream.writeName() and StubInputStream.readName() methods. These methods ensure that each unique identifier is stored only once in the data stream. This reduces the size of the serialized stub tree data. If you need to change the stored binary format for the stubs (for example, if you want to store some additional data or some new elements), make sure you advance the stub version returned from IStubFileElementType.getStubVersion() for your language. This will cause the stubs and stub indices to be rebuilt, and will avoid mismatches between the stored data format, and the code trying to load it. By default, if a PSI element extends StubBasedPsiElement , all elements of that type will be stored in the stub tree. If you need more precise control over which elements are stored, override IStubElementType.shouldCreateStub() and return false for elements that should not be included in the stub tree. NOTE The exclusion is not recursive: if some elements of the element for which you returned false are also stub-based PSI elements, they will be included in the stub tree. It's essential to ensure that all information stored in the stub tree depends only on the contents of the file for which stubs are being built, and does not depend on any external files. Otherwise, the stub tree will not be rebuilt when external dependency changes, and you will have stale and incorrect data in the stub tree. TIP Please see also Improving indexing performance .","title":"Stub Trees"},{"location":"basics/indexing_and_psi_stubs/stub_indexes/#stub-indexes","text":"When building the stub tree, you can, at the same time, put some data about the stub elements into a number of indexes, which then can be used to find the PSI elements by the corresponding key. Unlike file-based indexes, stub indexes do not support storing custom data as values; the value is always a PSI element. Keys in stub indexes are typically strings (such as class names); other data types are also supported if desired. A stub index is a class which extends AbstractStubIndex . In the most common case, when the key type is String , you use a more specific base class, namely StringStubIndexExtension . Stub index implementation classes are registered in the com.intellij.stubIndex extension point. To put data into an index, you implement the method IStubElementType.indexStub() ( example: JavaClassElementType.indexStub() ). This method accepts an IndexSink as a parameter and puts in the index ID and the key for each index in which the element should be stored. To access the data from an index, the following two methods are used: AbstractStubIndex.getAllKeys() returns the list of all keys in the specified index for the specified project (for example, the list of all class names found in the project). AbstractStubIndex.get() returns the collection of PSI elements corresponding to a certain key (for example, classes with the specified short name) in the specified scope.","title":"Stub Indexes"},{"location":"basics/indexing_and_psi_stubs/stub_indexes/#related-forum-discussions","text":"Lifecycle of stub creation","title":"Related Forum Discussions"},{"location":"basics/plugin_structure/plugin_actions/","text":"The Consulo provides the concept of actions . An action is a class derived from AnAction , whose actionPerformed() method is called when its menu item or toolbar button is selected. Actions are the most common way for a user to invoke the functionality of your plugin. An action can be invoked from a menu or a toolbar, using a keyboard shortcut or the Help | Find Action... lookup. Actions are organized into groups, which, in turn, can contain other groups. A group of actions can form a toolbar or a menu. Subgroups of the group can form submenus of a menu. The user can customize all registered actions via Menus and Toolbars settings. Please see Action System on how to create and register actions in the IDE.","title":"Actions"},{"location":"basics/plugin_structure/plugin_class_loaders/","text":"A separate class loader is used to load the classes of each plugin. This allows each plugin to use a different library version, even if the same library is used by the IDE itself or by another plugin. By default, the main IDE class loader loads classes that are not found in the plugin class loader. However, in the plugin.xml file, you may use the <depends> element to specify that a plugin depends on one or more other plugins. In this case, the class loaders of those plugins will be used for classes not found in the current plugin. This allows a plugin to reference classes from other plugins. Using ServiceLoader Some libraries use ServiceLoader to detect and load implementations. For this to work in a plugin, the context class loader must be set to the plugin's classloader and restored afterwards with original one around initialization code: ClassLoader current = Thread . currentThread (). getContextClassLoader (); try { Thread . currentThread (). setContextClassLoader ( this . getClass (). getClassLoader ()); // code working with ServiceLoader here } finally { Thread . currentThread (). setContextClassLoader ( current ); }","title":"ClassLoaders"},{"location":"basics/plugin_structure/plugin_class_loaders/#using-serviceloader","text":"Some libraries use ServiceLoader to detect and load implementations. For this to work in a plugin, the context class loader must be set to the plugin's classloader and restored afterwards with original one around initialization code: ClassLoader current = Thread . currentThread (). getContextClassLoader (); try { Thread . currentThread (). setContextClassLoader ( this . getClass (). getClassLoader ()); // code working with ServiceLoader here } finally { Thread . currentThread (). setContextClassLoader ( current ); }","title":"Using ServiceLoader"},{"location":"basics/plugin_structure/plugin_components/","text":"WARNING When writing new plugins, creating Components should be avoided. Any existing Components should be migrated to services, extensions, or listeners (see below). Plugin Components are a legacy feature supported for compatibility with plugins created for older versions of the Consulo. Plugin Components are defined in the <application-components> , <project-components> , and <module-components> sections in a Plugin Configuration File . Migration To migrate existing code from Components to more modern APIs, please see the following guidelines. Manage State To manage some state or logic that is only needed when the user performs a specific operation, use a Service . Persisting State To store the state of your plugin at the application or project level, use a Service , and implement the PersistentStateComponent interface. See Persisting State of Components for details. Subscribing to Events To subscribe to events, use a listener or create an extension for a dedicated extension point (for example, com.intellij.editorFactoryListener ) if one exists for the event to subscribe to. Application Startup Executing code on application startup should be avoided whenever possible because it slows down startup. Plugin code should only be executed when projects are opened (see Project Open ) or when the user invokes an action of a plugin. If this cannot be avoided, add a listener subscribing to the AppLifecycleListener topic. To execute an activity in background on IDE startup (e.g., to warm up caches), use PreloadingActivity . Project Open To execute code when a project is being opened, use one of these two extensions : com.intellij.postStartupActivity : StartupActivity for immediate execution on EDT. Implement DumbAware to indicate activity can run in background thread (in parallel with other such tasks). com.intellij.backgroundPostStartupActivity : StartupActivity.Background for execution with 5 seconds delay in background thread (2019.3 or later). Any long-running or CPU intensive tasks should be made visible to users by using ProgressManager.run(Task.Backgroundable) . Access to indices must be wrapped with DumbService , see also General Threading Rules . Application/Project Close To execute code on project closing or application shutdown, implement the Disposable interface in a Service and place the code in the dispose() method. Alternatively, use Disposer.register() passing a Project or Application service instance as the parent argument (see Choosing a Disposable Parent ).","title":"Components"},{"location":"basics/plugin_structure/plugin_components/#migration","text":"To migrate existing code from Components to more modern APIs, please see the following guidelines.","title":"Migration"},{"location":"basics/plugin_structure/plugin_components/#manage-state","text":"To manage some state or logic that is only needed when the user performs a specific operation, use a Service .","title":"Manage State"},{"location":"basics/plugin_structure/plugin_components/#persisting-state","text":"To store the state of your plugin at the application or project level, use a Service , and implement the PersistentStateComponent interface. See Persisting State of Components for details.","title":"Persisting State"},{"location":"basics/plugin_structure/plugin_components/#subscribing-to-events","text":"To subscribe to events, use a listener or create an extension for a dedicated extension point (for example, com.intellij.editorFactoryListener ) if one exists for the event to subscribe to.","title":"Subscribing to Events"},{"location":"basics/plugin_structure/plugin_components/#application-startup","text":"Executing code on application startup should be avoided whenever possible because it slows down startup. Plugin code should only be executed when projects are opened (see Project Open ) or when the user invokes an action of a plugin. If this cannot be avoided, add a listener subscribing to the AppLifecycleListener topic. To execute an activity in background on IDE startup (e.g., to warm up caches), use PreloadingActivity .","title":"Application Startup"},{"location":"basics/plugin_structure/plugin_components/#project-open","text":"To execute code when a project is being opened, use one of these two extensions : com.intellij.postStartupActivity : StartupActivity for immediate execution on EDT. Implement DumbAware to indicate activity can run in background thread (in parallel with other such tasks). com.intellij.backgroundPostStartupActivity : StartupActivity.Background for execution with 5 seconds delay in background thread (2019.3 or later). Any long-running or CPU intensive tasks should be made visible to users by using ProgressManager.run(Task.Backgroundable) . Access to indices must be wrapped with DumbService , see also General Threading Rules .","title":"Project Open"},{"location":"basics/plugin_structure/plugin_components/#applicationproject-close","text":"To execute code on project closing or application shutdown, implement the Disposable interface in a Service and place the code in the dispose() method. Alternatively, use Disposer.register() passing a Project or Application service instance as the parent argument (see Choosing a Disposable Parent ).","title":"Application/Project Close"},{"location":"basics/plugin_structure/plugin_configuration_file/","text":"The following is a sample plugin configuration file. This sample showcases and describes all elements that can be used in the plugin.xml file. Additional information about configuring <actions> is available in the Actions section in Part II. Limited HTML elements are allowed within <description> and <change-notes> elements. However, content containing HTML elements must be surrounded by <![CDATA[ ]]> tags. Allowed HTML elements include text formatting, paragraphs, and lists. When using Gradle, a number of metadata elements will be provided at build time by patchPluginXml task . <!-- `url` specifies the URL of the plugin homepage (can be opened from \"Plugins\" settings dialog) --> <idea-plugin url= \"https://www.jetbrains.com/idea\" > <!-- Plugin name. It should be short and descriptive and in Title Case. Displayed in the \"Plugins\" settings dialog and the plugin repository Web interface. --> <name> Vss Integration </name> <!-- Unique identifier of the plugin. It should be FQN. It cannot be changed between the plugin versions. If not specified, <name> will be used (not recommended). --> <id> com.jetbrains.vssintegration </id> <!-- Description of the plugin. Should be short and to the point. Start the description with a verb in a present simple form such as \"integrates\", \"synchronizes\", \"adds support for\" or \"lets you view\". Don't use marketing adjectives like \"simple\", \"lightweight\", or \"professional\". Don't repeat the name of the plugin. For plugins that add language/platform/framework support, the description MUST specify the version of the corresponding language/platform/framework. Don't mention the IDE compatibility. E.g., don't say \"Adds support to IntelliJ IDEA for...\" Displayed in the \"Plugins\" settings dialog and the plugin repository Web interface. Simple HTML elements can be included between <![CDATA[ ]]> tags. --> <description> Integrates Volume Snapshot Service W10 </description> <!-- Description of changes in the latest version of the plugin. Displayed in the \"Plugins\" settings dialog and the plugin repository Web interface. Simple HTML elements can be included between <![CDATA[ ]]> tags. --> <change-notes> Initial release of the plugin. </change-notes> <!-- Plugin version Recommended format is BRANCH.BUILD.FIX (MAJOR.MINOR.FIX) Displayed in the \"Plugins\" settings dialog and the plugin repository Web interface. --> <version> 1.0.0 </version> <!-- The vendor of the plugin. The optional \"url\" attribute specifies the URL of the vendor homepage. The optional \"email\" attribute specifies the e-mail address of the vendor. Displayed in the \"Plugins\" settings dialog and the plugin repository Web interface. --> <vendor url= \"https://www.company.com\" email= \"support@company.com\" > A Company Inc. </vendor> <!-- Mandatory dependencies on plugins or modules. The FQN module names in <depends> elements are used to determine IDE compatibility for the plugin. Include at least the module shown below to indicate compatibility with Consulo-based products. Also, include dependencies on other plugins as needed. See \"Compatibility with Multiple Products\" and \"Plugin Dependencies\" for more information. --> <depends> com.intellij.modules.platform </depends> <depends> com.third.party.plugin </depends> <!-- Optional dependency on another plugin. If the plugin with the \"com.MySecondPlugin\" ID is installed, the contents of mysecondplugin.xml (the format of this file conforms to the format of plugin.xml) will be loaded. --> <depends optional= \"true\" config-file= \"mysecondplugin.xml\" > com.MySecondPlugin </depends> <!-- Minimum and maximum build of IDE compatible with the plugin --> <idea-version since-build= \"193\" until-build= \"193.*\" /> <!-- Resource bundle (/messages/MyPluginBundle.properties) to be used with `key` attributes in extension points and implicit keys like `action.[ActionID].text|description` --> <resource-bundle> messages.MyPluginBundle </resource-bundle> <!-- Plugin's application components / DEPRECATED - do not use in new plugins See https://www.jetbrains.org/intellij/sdk/docs/basics/plugin_structure/plugin_components.html for migration steps --> <application-components> <component> <!-- Component's interface class --> <interface-class> com.foo.Component1Interface </interface-class> <!-- Component's implementation class --> <implementation-class> com.foo.impl.Component1Impl </implementation-class> </component> </application-components> <!-- Plugin's project components / DEPRECATED - do not use in new plugins See https://www.jetbrains.org/intellij/sdk/docs/basics/plugin_structure/plugin_components.html for migration steps --> <project-components> <component> <!-- Interface and implementation classes are the same --> <implementation-class> com.foo.Component2 </implementation-class> <!-- If the \"workspace\" option is set \"true\", the component saves its state to the .iws file instead of the .ipr file. Note that the <option> element is used only if the component implements the JDOMExternalizable interface. Otherwise, the use of the <option> element takes no effect. --> <option name= \"workspace\" value= \"true\" /> <!-- If the \"loadForDefaultProject\" tag is present, the project component is instantiated also for the default project. --> <loadForDefaultProject/> </component> </project-components> <!-- Plugin's module components / DEPRECATED - do not use in new plugins See https://www.jetbrains.org/intellij/sdk/docs/basics/plugin_structure/plugin_components.html for migration steps --> <module-components> <component> <implementation-class> com.foo.Component3 </implementation-class> </component> </module-components> <!-- Actions --> <actions> <action id= \"VssIntegration.GarbageCollection\" class= \"com.foo.impl.CollectGarbage\" text= \"Collect _Garbage\" description= \"Run garbage collector\" > <keyboard-shortcut first-keystroke= \"control alt G\" second-keystroke= \"C\" keymap= \"$default\" /> </action> </actions> <!-- Extension points defined by the plugin. Extension points are registered by a plugin so that other plugins can provide this plugin with certain data. --> <extensionPoints> <extensionPoint name= \"testExtensionPoint\" beanClass= \"com.foo.impl.MyExtensionBean\" /> </extensionPoints> <!-- Extensions which the plugin adds to extension points defined by the Consulo or by other plugins. The \"defaultExtensionNs\" attribute must be set to the ID of the plugin defining the extension point, or to \"com.intellij\" if the extension point is defined by the Consulo. The name of the tag within the <extensions> tag matches the name of the extension point, and the \"implementation\" class specifies the name of the class added to the extension point. --> <extensions defaultExtensionNs= \"VssIntegration\" > <testExtensionPoint implementation= \"com.foo.impl.MyExtensionImpl\" /> </extensions> <!-- Application-level listeners --> <applicationListeners> <listener class= \"com.foo.impl.MyListener\" topic= \"com.intellij.openapi.vfs.newvfs.BulkFileListener\" /> </applicationListeners> <!-- Project-level listeners --> <projectListeners> <listener class= \"com.foo.impl.MyToolwindowListener\" topic= \"com.intellij.openapi.wm.ex.ToolWindowManagerListener\" /> </projectListeners> </idea-plugin>","title":"Configuration File"},{"location":"basics/plugin_structure/plugin_content/","text":"The plugin jar file must contain: - the configuration file ( META-INF/plugin.xml ) ( Plugin Configuration File ) - the classes that implement the plugin functionality - recommended: plugin logo file(s) ( META-INF/pluginIcon*.svg ) ( Plugin Logo ) Plugin Without Dependencies A plugin consisting of a single .jar file is placed in the /plugins directory. .IntelliJIDEAx0/ \u2514\u2500\u2500 plugins \u2514\u2500\u2500 sample.jar \u251c\u2500\u2500 com/foo/... \u2502 ... \u2502 ... \u2514\u2500\u2500 META-INF \u251c\u2500\u2500 plugin.xml \u251c\u2500\u2500 pluginIcon.svg \u2514\u2500\u2500 pluginIcon_dark.svg Plugin With Dependencies The plugin .jar file is placed in the /lib folder under the plugin's \"root\" folder, together with all required bundled libraries. All jars from the /lib folder are automatically added to the classpath (see also Plugin Class Loaders ). .IntelliJIDEAx0/ \u2514\u2500\u2500 plugins \u2514\u2500\u2500 sample \u2514\u2500\u2500 lib \u251c\u2500\u2500 lib_foo.jar \u251c\u2500\u2500 lib_bar.jar \u2502 ... \u2502 ... \u2514\u2500\u2500 sample.jar \u251c\u2500\u2500 com/foo/... \u2502 ... \u2502 ... \u2514\u2500\u2500 META-INF \u251c\u2500\u2500 plugin.xml \u251c\u2500\u2500 pluginIcon.svg \u2514\u2500\u2500 pluginIcon_dark.svg","title":"Content"},{"location":"basics/plugin_structure/plugin_content/#plugin-without-dependencies","text":"A plugin consisting of a single .jar file is placed in the /plugins directory. .IntelliJIDEAx0/ \u2514\u2500\u2500 plugins \u2514\u2500\u2500 sample.jar \u251c\u2500\u2500 com/foo/... \u2502 ... \u2502 ... \u2514\u2500\u2500 META-INF \u251c\u2500\u2500 plugin.xml \u251c\u2500\u2500 pluginIcon.svg \u2514\u2500\u2500 pluginIcon_dark.svg","title":"Plugin Without Dependencies"},{"location":"basics/plugin_structure/plugin_content/#plugin-with-dependencies","text":"The plugin .jar file is placed in the /lib folder under the plugin's \"root\" folder, together with all required bundled libraries. All jars from the /lib folder are automatically added to the classpath (see also Plugin Class Loaders ). .IntelliJIDEAx0/ \u2514\u2500\u2500 plugins \u2514\u2500\u2500 sample \u2514\u2500\u2500 lib \u251c\u2500\u2500 lib_foo.jar \u251c\u2500\u2500 lib_bar.jar \u2502 ... \u2502 ... \u2514\u2500\u2500 sample.jar \u251c\u2500\u2500 com/foo/... \u2502 ... \u2502 ... \u2514\u2500\u2500 META-INF \u251c\u2500\u2500 plugin.xml \u251c\u2500\u2500 pluginIcon.svg \u2514\u2500\u2500 pluginIcon_dark.svg","title":"Plugin With Dependencies"},{"location":"basics/plugin_structure/plugin_dependencies/","text":"A plugin may depend on classes from other plugins, either bundled, third-party, or by the same author. This document describes the syntax for declaring plugin dependencies and optional plugin dependencies. For more information about dependencies on the Consulo modules, see Part II of this document: Plugin Compatibility with Consulo Products . NOTE It is impossible to specify the minimum/maximum version for the dependent plugin. ( Issue ) To express dependencies on classes from other plugins or modules, perform the following three required steps: 1. Locating Plugin ID and Preparing Sandbox A compatible version must be chosen carefully according to the plugin's compatibility . For plugins published on JetBrains Plugins Repository - open plugin's detail page - select Versions tab - open detail page for the desired version, displaying the Compatibility Range and Plugin ID For bundled and non-public plugins, locate the plugin's main JAR file containing META-INF/plugin.xml descriptor with <id> tag (or <name> if not specified). If the plugin is not bundled with the target IDE, run the (sandbox) IDE Development Instance of your target IDE and install the plugin there. 2. Project Setup Depending on the chosen development workflow (Gradle or DevKit), one of the two following steps is necessary. 2.1 Gradle NOTE Please see the plugins attribute gradle-intellij-plugin: Configuration for acceptable values. If the project uses Gradle with a Groovy build script to build the plugin, add the dependency to the plugins parameter of the intellij block in your build.gradle , for example: intellij { plugins 'org.another.plugin:1.0' } When using Kotlin build script, use setPlugins() within the intellij block, for example: intellij { setPlugins ( \"org.another.plugin:1.0\" ) } NOTE Transitive dependencies required for tests must currently be specified explicitly . 2.2 DevKit TIP Existing DevKit-based projects can be converted to use Gradle setup where managing dependencies is fully automated. If the project uses DevKit , add the JARs of the plugin on which the project depends to the classpath of the Consulo SDK . WARNING Do not add the plugin JARs as a library: this will fail at runtime because the Consulo will load two separate copies of the dependency plugin classes. To do that, open the Project Structure dialog, select the SDK used in the project, press the + button in the Classpath tab, and select the plugin JAR file or files: * For bundled plugins, the plugin JAR files are located in plugins/<pluginname> or plugins/<pluginname>/lib under the main installation directory. If you're not sure which JAR to add, you can add all of them. * For non-bundled plugins, the plugin JAR files are located in config/plugins/<pluginname> or config/plugins/<pluginname>/lib under the directory specified as \"Sandbox Home\" in the Consulo Plugin SDK settings. 3. Dependency Declaration in plugin.xml Regardless of whether a plugin project uses Modules Available in All Products , or Modules Specific to Functionality , the correct module must be listed as a dependency in plugin.xml . If a project depends on another plugin, the dependency must be declared like a module. If only general Consulo features (APIs) are used, then a default dependency on com.intellij.modules.platform must be declared. To display a list of available Consulo modules, invoke the code completion feature for the <depends> element contents while editing the plugin project's plugin.xml file. 3.1 Configuring plugin.xml In the plugin.xml , add a <depends> tag with the dependency plugin's ID as its content. Continuing with the example from Section 2 above, the dependency declaration in plugin.xml would be: <depends> org.another.plugin </depends> Optional Plugin Dependencies A project can also specify an optional plugin dependency. In this case, the plugin will load even if the plugin it depends on is not installed or enabled, but part of the plugin's functionality will not be available. Declare additional optional=\"true\" and config-file attribute pointing to optional plugin descriptor file: <depends optional= \"true\" config-file= \"myPluginId-optionalPluginName.xml\" > dependency.plugin.id </depends> NOTE Additional plugin descriptor files must follow the naming pattern myPluginId-$NAME$.xml resulting in unique filenames to prevent problems with classloaders in tests ( Details ). For example, if a plugin adds additional highlighting for Java and Kotlin files, use the following setup. The main plugin.xml will define an annotator for Java and specify an optional dependency on the Kotlin plugin ( org.jetbrains.kotlin ): plugin.xml <idea-plugin> ... <depends optional= \"true\" config-file= \"myPluginId-withKotlin.xml\" > org.jetbrains.kotlin </depends> <extensions defaultExtensionNs= \"com.intellij\" > <annotator language= \"JAVA\" implementationClass= \"com.example.MyJavaAnnotator\" /> </extensions> </idea-plugin> Then create a file called myPluginId-withKotlin.xml , in the same directory as the main plugin.xml file. In that file, define an annotator for Kotlin: myPluginId-withKotlin.xml <idea-plugin> <extensions defaultExtensionNs= \"com.intellij\" > <annotator language= \"kotlin\" implementationClass= \"com.example.MyKotlinAnnotator\" /> </extensions> </idea-plugin>","title":"Dependencies"},{"location":"basics/plugin_structure/plugin_dependencies/#1-locating-plugin-id-and-preparing-sandbox","text":"A compatible version must be chosen carefully according to the plugin's compatibility . For plugins published on JetBrains Plugins Repository - open plugin's detail page - select Versions tab - open detail page for the desired version, displaying the Compatibility Range and Plugin ID For bundled and non-public plugins, locate the plugin's main JAR file containing META-INF/plugin.xml descriptor with <id> tag (or <name> if not specified). If the plugin is not bundled with the target IDE, run the (sandbox) IDE Development Instance of your target IDE and install the plugin there.","title":"1. Locating Plugin ID and Preparing Sandbox"},{"location":"basics/plugin_structure/plugin_dependencies/#2-project-setup","text":"Depending on the chosen development workflow (Gradle or DevKit), one of the two following steps is necessary.","title":"2. Project Setup"},{"location":"basics/plugin_structure/plugin_dependencies/#21-gradle","text":"NOTE Please see the plugins attribute gradle-intellij-plugin: Configuration for acceptable values. If the project uses Gradle with a Groovy build script to build the plugin, add the dependency to the plugins parameter of the intellij block in your build.gradle , for example: intellij { plugins 'org.another.plugin:1.0' } When using Kotlin build script, use setPlugins() within the intellij block, for example: intellij { setPlugins ( \"org.another.plugin:1.0\" ) } NOTE Transitive dependencies required for tests must currently be specified explicitly .","title":"2.1 Gradle"},{"location":"basics/plugin_structure/plugin_dependencies/#22-devkit","text":"TIP Existing DevKit-based projects can be converted to use Gradle setup where managing dependencies is fully automated. If the project uses DevKit , add the JARs of the plugin on which the project depends to the classpath of the Consulo SDK . WARNING Do not add the plugin JARs as a library: this will fail at runtime because the Consulo will load two separate copies of the dependency plugin classes. To do that, open the Project Structure dialog, select the SDK used in the project, press the + button in the Classpath tab, and select the plugin JAR file or files: * For bundled plugins, the plugin JAR files are located in plugins/<pluginname> or plugins/<pluginname>/lib under the main installation directory. If you're not sure which JAR to add, you can add all of them. * For non-bundled plugins, the plugin JAR files are located in config/plugins/<pluginname> or config/plugins/<pluginname>/lib under the directory specified as \"Sandbox Home\" in the Consulo Plugin SDK settings.","title":"2.2 DevKit"},{"location":"basics/plugin_structure/plugin_dependencies/#3-dependency-declaration-in-pluginxml","text":"Regardless of whether a plugin project uses Modules Available in All Products , or Modules Specific to Functionality , the correct module must be listed as a dependency in plugin.xml . If a project depends on another plugin, the dependency must be declared like a module. If only general Consulo features (APIs) are used, then a default dependency on com.intellij.modules.platform must be declared. To display a list of available Consulo modules, invoke the code completion feature for the <depends> element contents while editing the plugin project's plugin.xml file.","title":"3. Dependency Declaration in plugin.xml"},{"location":"basics/plugin_structure/plugin_dependencies/#31-configuring-pluginxml","text":"In the plugin.xml , add a <depends> tag with the dependency plugin's ID as its content. Continuing with the example from Section 2 above, the dependency declaration in plugin.xml would be: <depends> org.another.plugin </depends>","title":"3.1 Configuring plugin.xml"},{"location":"basics/plugin_structure/plugin_dependencies/#optional-plugin-dependencies","text":"A project can also specify an optional plugin dependency. In this case, the plugin will load even if the plugin it depends on is not installed or enabled, but part of the plugin's functionality will not be available. Declare additional optional=\"true\" and config-file attribute pointing to optional plugin descriptor file: <depends optional= \"true\" config-file= \"myPluginId-optionalPluginName.xml\" > dependency.plugin.id </depends> NOTE Additional plugin descriptor files must follow the naming pattern myPluginId-$NAME$.xml resulting in unique filenames to prevent problems with classloaders in tests ( Details ). For example, if a plugin adds additional highlighting for Java and Kotlin files, use the following setup. The main plugin.xml will define an annotator for Java and specify an optional dependency on the Kotlin plugin ( org.jetbrains.kotlin ): plugin.xml <idea-plugin> ... <depends optional= \"true\" config-file= \"myPluginId-withKotlin.xml\" > org.jetbrains.kotlin </depends> <extensions defaultExtensionNs= \"com.intellij\" > <annotator language= \"JAVA\" implementationClass= \"com.example.MyJavaAnnotator\" /> </extensions> </idea-plugin> Then create a file called myPluginId-withKotlin.xml , in the same directory as the main plugin.xml file. In that file, define an annotator for Kotlin: myPluginId-withKotlin.xml <idea-plugin> <extensions defaultExtensionNs= \"com.intellij\" > <annotator language= \"kotlin\" implementationClass= \"com.example.MyKotlinAnnotator\" /> </extensions> </idea-plugin>","title":"Optional Plugin Dependencies"},{"location":"basics/plugin_structure/plugin_extension_points/","text":"NOTE See Plugin Extensions for using extension points in your plugin. By defining extension points in your plugin, you can allow other plugins to extend your plugin's functionality. There are two types of extension points: Interface extension points allow other plugins to extend your plugins with code . When you define an interface extension point, you specify an interface, and other plugins will provide classes implementing that interface. You'll then be able to invoke methods on those interfaces. Bean extension points allow other plugins to extend your plugins with data . You specify the fully qualified name of an extension class, and other plugins will provide data that will be turned into instances of that class. Declaring Extension Points You can declare extensions and extension points in the plugin configuration file plugin.xml , within the <extensions> and <extensionPoints> sections. To declare extension points in your plugin, add an <extensionPoints> section to your plugin.xml . Then insert a child element <extensionPoint> that defines the extension point name and the name of a bean class or an interface that is allowed to extend the plugin functionality in the name , beanClass and interface attributes, respectively. myPlugin/META-INF/plugin.xml <idea-plugin> <id> my.plugin </id> <extensionPoints> <extensionPoint name= \"myExtensionPoint1\" beanClass= \"com.myplugin.MyBeanClass\" /> <extensionPoint name= \"myExtensionPoint2\" interface= \"com.myplugin.MyInterface\" /> </extensionPoints> </idea-plugin> The name attribute assigns a unique name for this extension point. It will be prefixed with the plugin's <id> automatically. The beanClass attribute sets a bean class that specifies one or several properties annotated with the @Attribute annotation. The interface attribute sets an interface the plugin that contributes to the extension point must implement. The area attribute determines the scope in which the extension will be instantiated. As extensions should be stateless, it is not recommended to use non-default. Must be one of IDEA_APPLICATION for Application (default), IDEA_PROJECT for Project, or IDEA_MODULE for Module scope. The plugin that contributes to the extension point will read those properties from the plugin.xml file. Sample To clarify this, consider the following sample MyBeanClass bean class used in the above plugin.xml file: myPlugin/src/com/myplugin/MyBeanClass.java public class MyBeanClass extends AbstractExtensionPointBean { @Attribute ( \"key\" ) public String key ; @Attribute ( \"implementationClass\" ) public String implementationClass ; public String getKey () { return key ; } public String getClass () { return implementationClass ; } } TIP See Extension properties code insight on how to provide smart completion/validation. For above extension points usage in anotherPlugin would look like this (see also Declaring Extensions ): anotherPlugin/META-INF/plugin.xml <idea-plugin> <id> another.plugin </id> <!-- declare dependency on plugin defining extension point --> <depends> my.plugin </depends> <!-- use \"my.plugin\" namespace --> <extensions defaultExtensionNs= \"my.plugin\" > <myExtensionPoint1 key= \"someKey\" implementationClass= \"another.some.implementation.class\" /> <myExtensionPoint2 implementation= \"another.MyInterfaceImpl\" /> </extension> </idea-plugin> Using Extension Points To refer to all registered extension instances at runtime, declare an ExtensionPointName passing in the fully-qualified name matching its declaration in plugin.xml . myPlugin/src/com/myplugin/MyExtensionUsingService.java public class MyExtensionUsingService { private static final ExtensionPointName < MyBeanClass > EP_NAME = ExtensionPointName . create ( \"my.plugin.myExtensionPoint1\" ); public void useExtensions () { for ( MyBeanClass extension : EP_NAME . getExtensionList ()) { String key = extension . getKey (); String clazz = extension . getClass (); // ... } } } A gutter icon for the ExtensionPointName declaration allows navigating to the corresponding <extensionPoint> declaration in plugin.xml .","title":"Extension Points"},{"location":"basics/plugin_structure/plugin_extension_points/#declaring-extension-points","text":"You can declare extensions and extension points in the plugin configuration file plugin.xml , within the <extensions> and <extensionPoints> sections. To declare extension points in your plugin, add an <extensionPoints> section to your plugin.xml . Then insert a child element <extensionPoint> that defines the extension point name and the name of a bean class or an interface that is allowed to extend the plugin functionality in the name , beanClass and interface attributes, respectively. myPlugin/META-INF/plugin.xml <idea-plugin> <id> my.plugin </id> <extensionPoints> <extensionPoint name= \"myExtensionPoint1\" beanClass= \"com.myplugin.MyBeanClass\" /> <extensionPoint name= \"myExtensionPoint2\" interface= \"com.myplugin.MyInterface\" /> </extensionPoints> </idea-plugin> The name attribute assigns a unique name for this extension point. It will be prefixed with the plugin's <id> automatically. The beanClass attribute sets a bean class that specifies one or several properties annotated with the @Attribute annotation. The interface attribute sets an interface the plugin that contributes to the extension point must implement. The area attribute determines the scope in which the extension will be instantiated. As extensions should be stateless, it is not recommended to use non-default. Must be one of IDEA_APPLICATION for Application (default), IDEA_PROJECT for Project, or IDEA_MODULE for Module scope. The plugin that contributes to the extension point will read those properties from the plugin.xml file.","title":"Declaring Extension Points"},{"location":"basics/plugin_structure/plugin_extension_points/#sample","text":"To clarify this, consider the following sample MyBeanClass bean class used in the above plugin.xml file: myPlugin/src/com/myplugin/MyBeanClass.java public class MyBeanClass extends AbstractExtensionPointBean { @Attribute ( \"key\" ) public String key ; @Attribute ( \"implementationClass\" ) public String implementationClass ; public String getKey () { return key ; } public String getClass () { return implementationClass ; } } TIP See Extension properties code insight on how to provide smart completion/validation. For above extension points usage in anotherPlugin would look like this (see also Declaring Extensions ): anotherPlugin/META-INF/plugin.xml <idea-plugin> <id> another.plugin </id> <!-- declare dependency on plugin defining extension point --> <depends> my.plugin </depends> <!-- use \"my.plugin\" namespace --> <extensions defaultExtensionNs= \"my.plugin\" > <myExtensionPoint1 key= \"someKey\" implementationClass= \"another.some.implementation.class\" /> <myExtensionPoint2 implementation= \"another.MyInterfaceImpl\" /> </extension> </idea-plugin>","title":"Sample"},{"location":"basics/plugin_structure/plugin_extension_points/#using-extension-points","text":"To refer to all registered extension instances at runtime, declare an ExtensionPointName passing in the fully-qualified name matching its declaration in plugin.xml . myPlugin/src/com/myplugin/MyExtensionUsingService.java public class MyExtensionUsingService { private static final ExtensionPointName < MyBeanClass > EP_NAME = ExtensionPointName . create ( \"my.plugin.myExtensionPoint1\" ); public void useExtensions () { for ( MyBeanClass extension : EP_NAME . getExtensionList ()) { String key = extension . getKey (); String clazz = extension . getClass (); // ... } } } A gutter icon for the ExtensionPointName declaration allows navigating to the corresponding <extensionPoint> declaration in plugin.xml .","title":"Using Extension Points"},{"location":"basics/plugin_structure/plugin_extensions/","text":"Extensions are the most common way for a plugin to extend the Consulo's functionality in a way that is not as straightforward as adding an action to a menu or toolbar. The following are some of the most common tasks accomplished using extensions: The com.intellij.toolWindow extension point allows plugins to add tool windows (panels displayed at the sides of the IDE user interface); The com.intellij.applicationConfigurable and com.intellij.projectConfigurable extension points allow plugins to add pages to the Settings/Preferences dialog ; Custom language plugins use many extension points to extend various language support features in the IDE. There are more than 1000 extension points available in the platform and the bundled plugins, allowing to customize different parts of the IDE behavior. Declaring Extensions TIP Auto-completion, Quick Documentation, and other code insight features are available on extension point tags and attributes. Add an <extensions> element to your plugin.xml if it's not yet present there. Set the defaultExtensionNs attribute to one of the following values: com.intellij , if your plugin extends the Consulo core functionality. {ID of a plugin} , if your plugin extends the functionality of another plugin (must configure Plugin Dependencies ). Add a new child element to the <extensions> element. The child element name must match the name of the extension point you want the extension to access. Depending on the type of the extension point, do one of the following: If the extension point was declared using the interface attribute, for newly added child element, set the implementation attribute to the name of the class that implements the specified interface. If the extension point was declared using the beanClass attribute, for newly added child element, set all attributes annotated with the @Attribute annotations in the specified bean class. To clarify this procedure, consider the following sample section of the plugin.xml file that defines two extensions designed to access the com.intellij.appStarter and com.intellij.projectTemplatesFactory extension points in the Consulo and one extension to access the another.plugin.myExtensionPoint extension point in another plugin another.plugin : <!-- Declare extensions to access extension points in the Consulo. These extension points have been declared using \"interface\". --> <extensions defaultExtensionNs= \"com.intellij\" > <appStarter implementation= \"com.myplugin.MyAppStarter\" /> <projectTemplatesFactory implementation= \"com.myplugin.MyProjectTemplatesFactory\" /> </extensions> <!-- Declare extensions to access extension points in a custom plugin \"another.plugin\" The \"myExtensionPoint\" extension point has been declared using \"beanClass\" and exposes custom properties \"key\" and \"implementationClass\". --> <extensions defaultExtensionNs= \"another.plugin\" > <myExtensionPoint key= \"keyValue\" implementationClass= \"com.myplugin.MyExtensionPointImpl\" /> </extensions> Extension Default Properties The following properties are available always: id - unique ID order - allows to order all defined extensions using first , last or before|after [id] respectively os - allows restricting extension to given OS, e.g., os=\"windows\" registers the extension on Windows only If an extension instance needs to \"opt out\" in certain scenarios, it can throw ExtensionNotApplicableException in its constructor. Extension Properties Code Insight Several tooling features are available to help configure bean class extension points in plugin.xml . Properties annotated with @RequiredElement are inserted automatically and validated (2019.3 and later). If the given property is allowed to have an explicit empty value, set allowEmpty to true (2020.3 and later). Property names matching the following list will resolve to FQN: - implementation - className - serviceInterface / serviceImplementation - ending with Class (case-sensitive) A required parent type can be specified in the extension point declaration via nested <with> : <extensionPoint name= \"myExtension\" beanClass= \"MyExtensionBean\" > <with attribute= \"psiElementClass\" implements= \"com.intellij.psi.PsiElement\" /> </extensionPoint> Property name language (or ending in *Language , 2020.2+) resolves to all present Language IDs. Similarly, action resolves to all registered <action> IDs. Specifying @org.jetbrains.annotations.Nls validates a UI String capitalization according to the text property Capitalization enum value (2019.2 and later). Attributes with Enum type support code insight with lowerSnakeCased notation (2020.1 and later). How to get the extension points list? Extension Point List contains all available in Consulo and from bundled plugins in IntelliJ IDEA. Alternatively (or when using 3rd party extension points), all available extension points for the specified namespace can be listed using auto-completion inside the <extensions> block. Use View | Quick Documentation in the lookup list to access more information about the extension point and implementation (if applicable).","title":"Extensions"},{"location":"basics/plugin_structure/plugin_extensions/#declaring-extensions","text":"TIP Auto-completion, Quick Documentation, and other code insight features are available on extension point tags and attributes. Add an <extensions> element to your plugin.xml if it's not yet present there. Set the defaultExtensionNs attribute to one of the following values: com.intellij , if your plugin extends the Consulo core functionality. {ID of a plugin} , if your plugin extends the functionality of another plugin (must configure Plugin Dependencies ). Add a new child element to the <extensions> element. The child element name must match the name of the extension point you want the extension to access. Depending on the type of the extension point, do one of the following: If the extension point was declared using the interface attribute, for newly added child element, set the implementation attribute to the name of the class that implements the specified interface. If the extension point was declared using the beanClass attribute, for newly added child element, set all attributes annotated with the @Attribute annotations in the specified bean class. To clarify this procedure, consider the following sample section of the plugin.xml file that defines two extensions designed to access the com.intellij.appStarter and com.intellij.projectTemplatesFactory extension points in the Consulo and one extension to access the another.plugin.myExtensionPoint extension point in another plugin another.plugin : <!-- Declare extensions to access extension points in the Consulo. These extension points have been declared using \"interface\". --> <extensions defaultExtensionNs= \"com.intellij\" > <appStarter implementation= \"com.myplugin.MyAppStarter\" /> <projectTemplatesFactory implementation= \"com.myplugin.MyProjectTemplatesFactory\" /> </extensions> <!-- Declare extensions to access extension points in a custom plugin \"another.plugin\" The \"myExtensionPoint\" extension point has been declared using \"beanClass\" and exposes custom properties \"key\" and \"implementationClass\". --> <extensions defaultExtensionNs= \"another.plugin\" > <myExtensionPoint key= \"keyValue\" implementationClass= \"com.myplugin.MyExtensionPointImpl\" /> </extensions>","title":"Declaring Extensions"},{"location":"basics/plugin_structure/plugin_extensions/#extension-default-properties","text":"The following properties are available always: id - unique ID order - allows to order all defined extensions using first , last or before|after [id] respectively os - allows restricting extension to given OS, e.g., os=\"windows\" registers the extension on Windows only If an extension instance needs to \"opt out\" in certain scenarios, it can throw ExtensionNotApplicableException in its constructor.","title":"Extension Default Properties"},{"location":"basics/plugin_structure/plugin_extensions/#extension-properties-code-insight","text":"Several tooling features are available to help configure bean class extension points in plugin.xml . Properties annotated with @RequiredElement are inserted automatically and validated (2019.3 and later). If the given property is allowed to have an explicit empty value, set allowEmpty to true (2020.3 and later). Property names matching the following list will resolve to FQN: - implementation - className - serviceInterface / serviceImplementation - ending with Class (case-sensitive) A required parent type can be specified in the extension point declaration via nested <with> : <extensionPoint name= \"myExtension\" beanClass= \"MyExtensionBean\" > <with attribute= \"psiElementClass\" implements= \"com.intellij.psi.PsiElement\" /> </extensionPoint> Property name language (or ending in *Language , 2020.2+) resolves to all present Language IDs. Similarly, action resolves to all registered <action> IDs. Specifying @org.jetbrains.annotations.Nls validates a UI String capitalization according to the text property Capitalization enum value (2019.2 and later). Attributes with Enum type support code insight with lowerSnakeCased notation (2020.1 and later).","title":"Extension Properties Code Insight"},{"location":"basics/plugin_structure/plugin_extensions/#how-to-get-the-extension-points-list","text":"Extension Point List contains all available in Consulo and from bundled plugins in IntelliJ IDEA. Alternatively (or when using 3rd party extension points), all available extension points for the specified namespace can be listed using auto-completion inside the <extensions> block. Use View | Quick Documentation in the lookup list to access more information about the extension point and implementation (if applicable).","title":"How to get the extension points list?"},{"location":"basics/plugin_structure/plugin_icon_file/","text":"Beginning in version 2019.1, the Consulo supports representing a plugin with a logo. A Plugin Logo is intended to be a unique representation of a plugin's functionality, technology, or company. Previously this page referred to Plugin Logos as Plugin Icons . Note: icons and images used within a plugin have different requirements. See Working with Icons and Images for more information. bullet list {:toc} Introduction Plugin Logos are shown in the JetBrains Plugins Repository . They also appear in the Settings/Preferences Plugin Manager UI in Consulo-based IDEs. Whether online or in the product UI, a Plugin Logo helps users to identify a plugin more quickly in a list, as shown below: {:width=\"800px\"} NOTE When browsing custom plugin repositories , there is no support for showing logos for plugins hosted there but not yet installed. Plugin Logo Requirements For a Plugin Logo to be displayed correctly within an Consulo-based IDE, it must: * Follow the best practices design guidelines, * Be in the correct file format, * Conform to file name conventions, * Be in the META-INF folder of the plugin distribution file. Plugin Logo Size The Plugin Logo should be provided in one size: 40px by 40px. A Plugin Logo is displayed in two sizes, and scales automatically in each context: * 40px by 40px in the plugins list in the Plugin Manager UI. * 80px by 80px in the plugin details screen in the Plugin Manager UI, on the plugin's page in the Plugins Repository, and on MarketPlace. Verify that Plugin Logo designs are effective in both sizes and all display contexts. Plugin Logo Shape Plugin Logo designs should leave at least 2px transparent padding around the perimeter, as shown below: {:width=\"225px\"} Make sure Plugin Logos have the same visual weight as the logos in the examples below. The more filled a Plugin Logo design is, the less actual space it needs. See more examples of visual weight compensation in the Consulo UI Guidelines for Icons. For basic shapes, use the following sizes. Note the different areas of transparent padding used for each shape: {:width=\"225px\"} {:width=\"225px\"} Square logo 32px by 32px Circular logo 36px in diameter {:width=\"225px\"} {:width=\"225px\"} Horizontal rectangular logo 36px by 26px Vertical rectangular logo 26px by 36px Plugin Logo Colors If the plugin's technology already has a logo, use its colors. Check the license terms before using the logo. If there is no existing logo, or its use is prohibited, create a custom logo based on the Action Colors Palette in the Consulo UI Guidelines for Icons. {:height=\"200px\" width=\"200px\"} {:height=\"200px\" width=\"200px\"} The YouTrack Plugin Logo uses the YouTrack product logo The Keymap Plugin Logo uses a color from the Action Colors Palette Ensure a Plugin Logo is visible on both light and dark backgrounds. If one Plugin Logo design does not work on both light and dark backgrounds, create separate light and dark versions of the Plugin Logo. The examples below illustrate how a Plugin Logo design may work well for a light background but not for a dark background. Consequently, a separate Plugin Logo for dark backgrounds is needed. {:width=\"225px\"} {:width=\"225px\"} {:width=\"225px\"} The light Plugin Logo design works well on light UI Theme The light Plugin Logo design does not work well on a dark UI Theme A separate, dark Plugin Logo design works well on dark UI Theme Plugin Logo File Format All Plugin Logo images must be SVG format. This vector image format is required because the Plugin Logo file must be small, and the image must scale without any loss of quality. Plugin Logo File Naming Convention Name the Plugin Logo files according to the following conventions: * pluginIcon.svg is the default Plugin Logo. If a separate Logo file for dark UI Themes exists in the plugin, then this file is used solely for light UI Themes, * pluginIcon_dark.svg is an optional, alternative Plugin Logo for use solely with dark IDE UI Themes. Adding Plugin Logo Files to a Plugin Project The Plugin Logo files must be in the META-INF folder of the plugin distribution file, i.e., the *.jar or *.zip file you upload to the plugin repository and install into a JetBrains IDE. To include Plugin Logo files in your distribution file, place the Plugin Logo files into a plugin project's resources/META-INF folder. Note that this requirement is the same regardless of using DevKit or Gradle for developing a plugin. For example: {:width=\"450px\"}","title":"Icon File"},{"location":"basics/plugin_structure/plugin_icon_file/#introduction","text":"Plugin Logos are shown in the JetBrains Plugins Repository . They also appear in the Settings/Preferences Plugin Manager UI in Consulo-based IDEs. Whether online or in the product UI, a Plugin Logo helps users to identify a plugin more quickly in a list, as shown below: {:width=\"800px\"} NOTE When browsing custom plugin repositories , there is no support for showing logos for plugins hosted there but not yet installed.","title":"Introduction"},{"location":"basics/plugin_structure/plugin_icon_file/#plugin-logo-requirements","text":"For a Plugin Logo to be displayed correctly within an Consulo-based IDE, it must: * Follow the best practices design guidelines, * Be in the correct file format, * Conform to file name conventions, * Be in the META-INF folder of the plugin distribution file.","title":"Plugin Logo Requirements"},{"location":"basics/plugin_structure/plugin_icon_file/#plugin-logo-size","text":"The Plugin Logo should be provided in one size: 40px by 40px. A Plugin Logo is displayed in two sizes, and scales automatically in each context: * 40px by 40px in the plugins list in the Plugin Manager UI. * 80px by 80px in the plugin details screen in the Plugin Manager UI, on the plugin's page in the Plugins Repository, and on MarketPlace. Verify that Plugin Logo designs are effective in both sizes and all display contexts.","title":"Plugin Logo Size"},{"location":"basics/plugin_structure/plugin_icon_file/#plugin-logo-shape","text":"Plugin Logo designs should leave at least 2px transparent padding around the perimeter, as shown below: {:width=\"225px\"} Make sure Plugin Logos have the same visual weight as the logos in the examples below. The more filled a Plugin Logo design is, the less actual space it needs. See more examples of visual weight compensation in the Consulo UI Guidelines for Icons. For basic shapes, use the following sizes. Note the different areas of transparent padding used for each shape: {:width=\"225px\"} {:width=\"225px\"} Square logo 32px by 32px Circular logo 36px in diameter {:width=\"225px\"} {:width=\"225px\"} Horizontal rectangular logo 36px by 26px Vertical rectangular logo 26px by 36px","title":"Plugin Logo Shape"},{"location":"basics/plugin_structure/plugin_icon_file/#plugin-logo-colors","text":"If the plugin's technology already has a logo, use its colors. Check the license terms before using the logo. If there is no existing logo, or its use is prohibited, create a custom logo based on the Action Colors Palette in the Consulo UI Guidelines for Icons. {:height=\"200px\" width=\"200px\"} {:height=\"200px\" width=\"200px\"} The YouTrack Plugin Logo uses the YouTrack product logo The Keymap Plugin Logo uses a color from the Action Colors Palette Ensure a Plugin Logo is visible on both light and dark backgrounds. If one Plugin Logo design does not work on both light and dark backgrounds, create separate light and dark versions of the Plugin Logo. The examples below illustrate how a Plugin Logo design may work well for a light background but not for a dark background. Consequently, a separate Plugin Logo for dark backgrounds is needed. {:width=\"225px\"} {:width=\"225px\"} {:width=\"225px\"} The light Plugin Logo design works well on light UI Theme The light Plugin Logo design does not work well on a dark UI Theme A separate, dark Plugin Logo design works well on dark UI Theme","title":"Plugin Logo Colors"},{"location":"basics/plugin_structure/plugin_icon_file/#plugin-logo-file-format","text":"All Plugin Logo images must be SVG format. This vector image format is required because the Plugin Logo file must be small, and the image must scale without any loss of quality.","title":"Plugin Logo File Format"},{"location":"basics/plugin_structure/plugin_icon_file/#plugin-logo-file-naming-convention","text":"Name the Plugin Logo files according to the following conventions: * pluginIcon.svg is the default Plugin Logo. If a separate Logo file for dark UI Themes exists in the plugin, then this file is used solely for light UI Themes, * pluginIcon_dark.svg is an optional, alternative Plugin Logo for use solely with dark IDE UI Themes.","title":"Plugin Logo File Naming Convention"},{"location":"basics/plugin_structure/plugin_icon_file/#adding-plugin-logo-files-to-a-plugin-project","text":"The Plugin Logo files must be in the META-INF folder of the plugin distribution file, i.e., the *.jar or *.zip file you upload to the plugin repository and install into a JetBrains IDE. To include Plugin Logo files in your distribution file, place the Plugin Logo files into a plugin project's resources/META-INF folder. Note that this requirement is the same regardless of using DevKit or Gradle for developing a plugin. For example: {:width=\"450px\"}","title":"Adding Plugin Logo Files to a Plugin Project"},{"location":"basics/plugin_structure/plugin_listeners/","text":"NOTE Defining listeners in plugin.xml is supported starting with version 2019.3 of the platform. NOTE Listener implementations must be stateless and may not implement life-cycle (e.g., Disposable ). Listeners allow plugins to declaratively subscribe to events delivered through the message bus (see Messaging infrastructure for details). You can define both application- and project-level listeners. Declarative registration of listeners allows you to achieve better performance than registering listeners from code. The advantage is because listener instances get created lazily - the first time an event is sent to the topic - and not during application startup or project opening. Defining Application-Level Listeners To define an application-level listener, add the following section to your plugin.xml : <applicationListeners> <listener class= \"myPlugin.MyListenerClass\" topic= \"BaseListenerInterface\" /> </applicationListeners> The topic attribute specifies the listener interface corresponding to the type of events you want to receive. Usually, this is the interface used as the type parameter of the Topic instance for the type of events. The class attribute specifies the class in your plugin that implements the listener interface and receives the events. As a specific example, if you want to receive events about all virtual file system changes, you need to implement the BulkFileListener interface, corresponding to the topic VirtualFileManager.VFS_CHANGES . To subscribe to this topic from code, you could use something like the following snippet: messageBus . connect (). subscribe ( VirtualFileManager . VFS_CHANGES , new BulkFileListener () { @Override public void after ( @NotNull List <? extends VFileEvent > events ) { // handle the events } }); To use declarative registration, you no longer need to reference the Topic instance. Instead, you refer directly to the listener interface class: <applicationListeners> <listener class= \"myPlugin.MyVfsListener\" topic= \"com.intellij.openapi.vfs.newvfs.BulkFileListener\" /> </applicationListeners> Then you provide the listener implementation as a top-level class: public class MyVfsListener implements BulkFileListener { @Override public void after ( @NotNull List <? extends VFileEvent > events ) { // handle the events } } Defining Project-Level Listeners Project-level listeners are registered in the same way, except that the top-level tag is <projectListeners> . They can be used to listen to project-level events, for example, tool window operations: <projectListeners> <listener class= \"MyToolwindowListener\" topic= \"com.intellij.openapi.wm.ex.ToolWindowManagerListener\" /> </projectListeners> The class implementing the listener interface can define a one-argument constructor accepting a Project , and it will receive the instance of the project for which the listener is created: public class MyToolwindowListener implements ToolWindowManagerListener { private final Project project ; public MyToolwindowListener ( Project project ) { this . project = project ; } @Override public void stateChanged () { // handle the state change } } Additional Attributes Registration of listeners can be restricted using the following attributes: os - allows to restrict listener to given OS, e.g., os=\"windows\" for Windows only (2020.1 and later) activeInTestMode - set to false to disable listener if com.intellij.openapi.application.Application.isUnitTestMode() == true activeInHeadlessMode - set to false to disable listener if com.intellij.openapi.application.Application.isHeadlessEnvironment() == true . Also, covers activeInTestMode as test mode implies headless mode.","title":"Listeners"},{"location":"basics/plugin_structure/plugin_listeners/#defining-application-level-listeners","text":"To define an application-level listener, add the following section to your plugin.xml : <applicationListeners> <listener class= \"myPlugin.MyListenerClass\" topic= \"BaseListenerInterface\" /> </applicationListeners> The topic attribute specifies the listener interface corresponding to the type of events you want to receive. Usually, this is the interface used as the type parameter of the Topic instance for the type of events. The class attribute specifies the class in your plugin that implements the listener interface and receives the events. As a specific example, if you want to receive events about all virtual file system changes, you need to implement the BulkFileListener interface, corresponding to the topic VirtualFileManager.VFS_CHANGES . To subscribe to this topic from code, you could use something like the following snippet: messageBus . connect (). subscribe ( VirtualFileManager . VFS_CHANGES , new BulkFileListener () { @Override public void after ( @NotNull List <? extends VFileEvent > events ) { // handle the events } }); To use declarative registration, you no longer need to reference the Topic instance. Instead, you refer directly to the listener interface class: <applicationListeners> <listener class= \"myPlugin.MyVfsListener\" topic= \"com.intellij.openapi.vfs.newvfs.BulkFileListener\" /> </applicationListeners> Then you provide the listener implementation as a top-level class: public class MyVfsListener implements BulkFileListener { @Override public void after ( @NotNull List <? extends VFileEvent > events ) { // handle the events } }","title":"Defining Application-Level Listeners"},{"location":"basics/plugin_structure/plugin_listeners/#defining-project-level-listeners","text":"Project-level listeners are registered in the same way, except that the top-level tag is <projectListeners> . They can be used to listen to project-level events, for example, tool window operations: <projectListeners> <listener class= \"MyToolwindowListener\" topic= \"com.intellij.openapi.wm.ex.ToolWindowManagerListener\" /> </projectListeners> The class implementing the listener interface can define a one-argument constructor accepting a Project , and it will receive the instance of the project for which the listener is created: public class MyToolwindowListener implements ToolWindowManagerListener { private final Project project ; public MyToolwindowListener ( Project project ) { this . project = project ; } @Override public void stateChanged () { // handle the state change } }","title":"Defining Project-Level Listeners"},{"location":"basics/plugin_structure/plugin_listeners/#additional-attributes","text":"Registration of listeners can be restricted using the following attributes: os - allows to restrict listener to given OS, e.g., os=\"windows\" for Windows only (2020.1 and later) activeInTestMode - set to false to disable listener if com.intellij.openapi.application.Application.isUnitTestMode() == true activeInHeadlessMode - set to false to disable listener if com.intellij.openapi.application.Application.isHeadlessEnvironment() == true . Also, covers activeInTestMode as test mode implies headless mode.","title":"Additional Attributes"},{"location":"basics/plugin_structure/plugin_services/","text":"A service is a plugin component loaded on demand when your plugin calls the getService() method of ServiceManager . The Consulo ensures that only one instance of a service is loaded even though it is called several times. A service must have an implementation class that is used for service instantiation. A service may also have an interface class used to obtain the service instance and provide the service's API. A service needing a shutdown hook/cleanup routine can implement Disposable and perform necessary work in dispose() (see Automatically Disposed Objects ). Types The Consulo offers three types of services: application level services (global singleton), project level services, and module level services. For the latter two, a separate instance of the service is created for each instance of its corresponding scope, see Project Model Introduction . NOTE Please consider not using module-level services because it can increase memory usage for projects with many modules. Constructor Project/Module level service constructors can have a Project / Module argument. To improve startup performance, avoid any heavy initializations in the constructor. NOTE Please note that using constructor injection is deprecated (and not supported in Light Services ) for performance reasons. Other dependencies should be acquired only when needed in all corresponding methods (see someServiceMethod() in Project Service Sample ). Light Services NOTE Light Services are available since Consulo 2019.3. A service not going to be overridden does not need to be registered in plugin.xml (see Declaring a Service ). Instead, annotate service class with @Service . The service instance will be created in scope according to the caller (see Retrieving a Service ). Restrictions: Service class must be final . Constructor injection is not supported (since it is deprecated). If service is a PersistentStateComponent , roaming must be disabled ( roamingType = RoamingType.DISABLED ). See Project Level Service below for a sample. Declaring a Service To register a non- Light Service , distinct extension points are provided for each type: com.intellij.applicationService - application level service com.intellij.projectService - project level service com.intellij.moduleService - module level service (not recommended, see Note above) To expose service API, create separate class for serviceInterface and extend it in corresponding class registered in serviceImplementation . If serviceInterface isn't specified, it's supposed to have the same value as serviceImplementation . To provide custom implementation for test/headless environment, specify testServiceImplementation / headlessImplementation additionally. plugin.xml <extensions defaultExtensionNs= \"com.intellij\" > <!-- Declare the application level service --> <applicationService serviceInterface= \"mypackage.MyApplicationService\" serviceImplementation= \"mypackage.MyApplicationServiceImpl\" /> <!-- Declare the project level service --> <projectService serviceInterface= \"mypackage.MyProjectService\" serviceImplementation= \"mypackage.MyProjectServiceImpl\" /> </extensions> Retrieving a Service Getting service doesn't need a read action and can be performed from any thread. If service is requested from several threads, it will be initialized in the first thread, and other threads will be blocked until service is fully initialized. To retrieve a service in Java code: MyApplicationService applicationService = ServiceManager . getService ( MyApplicationService . class ); MyProjectService projectService = project . getService ( MyProjectService . class ) In Kotlin code, use convenience methods: val applicationService = service < MyApplicationService > () val projectService = project . service < MyProjectService > () Project Service Sample This minimal sample shows Light Service ProjectService interacting with another project level service AnotherService (not shown here). ProjectService.java @Service public final class ProjectService { private final Project myProject ; public ProjectService ( Project project ) { myProject = project ; } public void someServiceMethod ( String parameter ) { AnotherService anotherService = myProject . getService ( AnotherService . class ); String result = anotherService . anotherServiceMethod ( parameter , false ); // do some more stuff } } Sample Plugin This sample plugin illustrates how to create and use a plugin service. This plugin has an application service counting the number of currently opened projects in the IDE. If this number exceeds the maximum number of simultaneously opened projects allowed by the plugin, it displays a warning message. To install and run the sample plugin Download the included sample plugin project located here . Start IntelliJ IDEA , on the starting page, click Open Project , and then use the Open Project dialog box to open the project. On the main menu, choose Run | Run or press Shift + F10 . If necessary, change the Run/Debug Configurations .","title":"Services"},{"location":"basics/plugin_structure/plugin_services/#types","text":"The Consulo offers three types of services: application level services (global singleton), project level services, and module level services. For the latter two, a separate instance of the service is created for each instance of its corresponding scope, see Project Model Introduction . NOTE Please consider not using module-level services because it can increase memory usage for projects with many modules.","title":"Types"},{"location":"basics/plugin_structure/plugin_services/#constructor","text":"Project/Module level service constructors can have a Project / Module argument. To improve startup performance, avoid any heavy initializations in the constructor. NOTE Please note that using constructor injection is deprecated (and not supported in Light Services ) for performance reasons. Other dependencies should be acquired only when needed in all corresponding methods (see someServiceMethod() in Project Service Sample ).","title":"Constructor"},{"location":"basics/plugin_structure/plugin_services/#light-services","text":"NOTE Light Services are available since Consulo 2019.3. A service not going to be overridden does not need to be registered in plugin.xml (see Declaring a Service ). Instead, annotate service class with @Service . The service instance will be created in scope according to the caller (see Retrieving a Service ). Restrictions: Service class must be final . Constructor injection is not supported (since it is deprecated). If service is a PersistentStateComponent , roaming must be disabled ( roamingType = RoamingType.DISABLED ). See Project Level Service below for a sample.","title":"Light Services"},{"location":"basics/plugin_structure/plugin_services/#declaring-a-service","text":"To register a non- Light Service , distinct extension points are provided for each type: com.intellij.applicationService - application level service com.intellij.projectService - project level service com.intellij.moduleService - module level service (not recommended, see Note above) To expose service API, create separate class for serviceInterface and extend it in corresponding class registered in serviceImplementation . If serviceInterface isn't specified, it's supposed to have the same value as serviceImplementation . To provide custom implementation for test/headless environment, specify testServiceImplementation / headlessImplementation additionally. plugin.xml <extensions defaultExtensionNs= \"com.intellij\" > <!-- Declare the application level service --> <applicationService serviceInterface= \"mypackage.MyApplicationService\" serviceImplementation= \"mypackage.MyApplicationServiceImpl\" /> <!-- Declare the project level service --> <projectService serviceInterface= \"mypackage.MyProjectService\" serviceImplementation= \"mypackage.MyProjectServiceImpl\" /> </extensions>","title":"Declaring a Service"},{"location":"basics/plugin_structure/plugin_services/#retrieving-a-service","text":"Getting service doesn't need a read action and can be performed from any thread. If service is requested from several threads, it will be initialized in the first thread, and other threads will be blocked until service is fully initialized. To retrieve a service in Java code: MyApplicationService applicationService = ServiceManager . getService ( MyApplicationService . class ); MyProjectService projectService = project . getService ( MyProjectService . class ) In Kotlin code, use convenience methods: val applicationService = service < MyApplicationService > () val projectService = project . service < MyProjectService > ()","title":"Retrieving a Service"},{"location":"basics/plugin_structure/plugin_services/#project-service-sample","text":"This minimal sample shows Light Service ProjectService interacting with another project level service AnotherService (not shown here). ProjectService.java @Service public final class ProjectService { private final Project myProject ; public ProjectService ( Project project ) { myProject = project ; } public void someServiceMethod ( String parameter ) { AnotherService anotherService = myProject . getService ( AnotherService . class ); String result = anotherService . anotherServiceMethod ( parameter , false ); // do some more stuff } }","title":"Project Service Sample"},{"location":"basics/plugin_structure/plugin_services/#sample-plugin","text":"This sample plugin illustrates how to create and use a plugin service. This plugin has an application service counting the number of currently opened projects in the IDE. If this number exceeds the maximum number of simultaneously opened projects allowed by the plugin, it displays a warning message. To install and run the sample plugin Download the included sample plugin project located here . Start IntelliJ IDEA , on the starting page, click Open Project , and then use the Open Project dialog box to open the project. On the main menu, choose Run | Run or press Shift + F10 . If necessary, change the Run/Debug Configurations .","title":"Sample Plugin"},{"location":"basics/run_configurations/run_configuration_execution/","text":"The standard execution of a run action goes through the following steps: The user selects a run configuration (for example, by choosing one from the run configurations combobox) and an executor (for example, by pressing a toolbar button created by the executor). The program runner that will actually execute the process is selected by polling all registered program runners and asking whether they can run the specified run profile with the specified executor ID. The ExecutionEnvironment object is created. This object aggregates all the settings required to execute the process and the selected ProgramRunner . ProgramRunner.execute() is called, receiving the executor and the execution environment. Implementations of ProgramRunner.execute() go through the following steps to execute the process: RunProfile.getState() method is called to create a RunProfileState object, describing a process about to be started. At this stage, the command line parameters, environment variables, and other information required to start the process are initialized. RunProfileState.execute() is called. It starts the process, attaches a ProcessHandler to its input and output streams, creates a console to display the process output, and returns an ExecutionResult object aggregating the console and the process handler. The RunContentBuilder object is created and invoked to display the execution console in a tab of the Run or Debug tool window. Executor The Executor interface describes a specific way of executing any possible run configuration. The three default executors provided by the Consulo by default are Run , Debug , and Run with Coverage . Each executor gets its own toolbar button, which starts the selected run configuration using this executor, and its own context menu item for starting a configuration using this executor. As a plugin developer, you usually don't need to implement the Executor interface. However, it can be useful, for example, if you're implementing a profiler integration and want to provide the possibility to execute any configuration with profiling. Running a Process The RunProfileState interface comes up in every run configuration implementation as the return value RunProfile.getState() . It describes a process that is ready to be started and holds information like the command line, current working directory, and environment variables for the process to be started. (The existence of RunProfileState as a separate step in the execution flow allows run configuration extensions and other components to patch the configuration and modify the parameters before it gets executed.) The standard base class used as implementation of RunProfileState is CommandLineState . It contains the logic for putting together a running process and a console into an ExecutionResult , but doesn't know anything how the process is actually started. For starting the process, it's best to use the GeneralCommandLine class, which takes care of setting up the command line parameters and executing the process. Alternatively, if the process you need to run is a JVM-based one, you can use the JavaCommandLineState base class. It knows about the JVM command line parameters and can take care of details like calculating the classpath for the JVM. To monitor the execution of a process and capture its output, the OSProcessHandler class is usually used. Once you've created an instance of OSProcessHandler from either a command line or a Process object, you need to call the startNotify() method to capture its output. You may also want to attach a ProcessTerminatedListener to the OSProcessHandler so that the exit status of the process will be displayed in the console. Displaying Process Output If you're using CommandLineState , a console view will be automatically created and attached to the process's output. Alternatively, you can arrange this yourself: TextConsoleBuilderFactory.createBuilder(project).getConsole() creates a ConsoleView instance ConsoleView.attachToProcess() attaches it to the output of a process. If the running process uses ANSI escape codes to color its output, the ColoredProcessHandler class will parse it and display the colors in the IntelliJ console. Console filters allow you to convert certain strings found in the process output to clickable hyperlinks. To attach a filter to the console, use CommandLineState.addConsoleFilters() or, if you're creating a console manually, TextConsoleBuilder.addFilter() . Two common filter implementations you may want to reuse are RegexpFilter and UrlFilter . Starting a Run Configuration from Code If you have an existing run configuration that you need to execute, the easiest way to do so is to use ProgramRunnerUtil.executeConfiguration() . The method takes a Project , a RunnerAndConfigurationSettings , as well as an Executor . To get the RunnerAndConfigurationSettings for an existing configuration, you can use, for example, RunManager.getConfigurationSettings(ConfigurationType) . As the last parameter, you normally pass either DefaultRunExecutor.getRunExecutorInstance() or DefaultDebugExecutor.getDebugExecutorInstance() .","title":"Execution"},{"location":"basics/run_configurations/run_configuration_execution/#executor","text":"The Executor interface describes a specific way of executing any possible run configuration. The three default executors provided by the Consulo by default are Run , Debug , and Run with Coverage . Each executor gets its own toolbar button, which starts the selected run configuration using this executor, and its own context menu item for starting a configuration using this executor. As a plugin developer, you usually don't need to implement the Executor interface. However, it can be useful, for example, if you're implementing a profiler integration and want to provide the possibility to execute any configuration with profiling.","title":"Executor"},{"location":"basics/run_configurations/run_configuration_execution/#running-a-process","text":"The RunProfileState interface comes up in every run configuration implementation as the return value RunProfile.getState() . It describes a process that is ready to be started and holds information like the command line, current working directory, and environment variables for the process to be started. (The existence of RunProfileState as a separate step in the execution flow allows run configuration extensions and other components to patch the configuration and modify the parameters before it gets executed.) The standard base class used as implementation of RunProfileState is CommandLineState . It contains the logic for putting together a running process and a console into an ExecutionResult , but doesn't know anything how the process is actually started. For starting the process, it's best to use the GeneralCommandLine class, which takes care of setting up the command line parameters and executing the process. Alternatively, if the process you need to run is a JVM-based one, you can use the JavaCommandLineState base class. It knows about the JVM command line parameters and can take care of details like calculating the classpath for the JVM. To monitor the execution of a process and capture its output, the OSProcessHandler class is usually used. Once you've created an instance of OSProcessHandler from either a command line or a Process object, you need to call the startNotify() method to capture its output. You may also want to attach a ProcessTerminatedListener to the OSProcessHandler so that the exit status of the process will be displayed in the console.","title":"Running a Process"},{"location":"basics/run_configurations/run_configuration_execution/#displaying-process-output","text":"If you're using CommandLineState , a console view will be automatically created and attached to the process's output. Alternatively, you can arrange this yourself: TextConsoleBuilderFactory.createBuilder(project).getConsole() creates a ConsoleView instance ConsoleView.attachToProcess() attaches it to the output of a process. If the running process uses ANSI escape codes to color its output, the ColoredProcessHandler class will parse it and display the colors in the IntelliJ console. Console filters allow you to convert certain strings found in the process output to clickable hyperlinks. To attach a filter to the console, use CommandLineState.addConsoleFilters() or, if you're creating a console manually, TextConsoleBuilder.addFilter() . Two common filter implementations you may want to reuse are RegexpFilter and UrlFilter .","title":"Displaying Process Output"},{"location":"basics/run_configurations/run_configuration_execution/#starting-a-run-configuration-from-code","text":"If you have an existing run configuration that you need to execute, the easiest way to do so is to use ProgramRunnerUtil.executeConfiguration() . The method takes a Project , a RunnerAndConfigurationSettings , as well as an Executor . To get the RunnerAndConfigurationSettings for an existing configuration, you can use, for example, RunManager.getConfigurationSettings(ConfigurationType) . As the last parameter, you normally pass either DefaultRunExecutor.getRunExecutorInstance() or DefaultDebugExecutor.getDebugExecutorInstance() .","title":"Starting a Run Configuration from Code"},{"location":"basics/run_configurations/run_configuration_management/","text":"This document describes the primary classes to work with run configurations and everyday use cases. Dummy table of contents {:toc} Configuration Type The starting point for implementing any run configuration type is the ConfigurationType interface. The list of available configuration types is shown when a user opens the 'Edit run configurations' dialog and executes 'Add' action: Every type there is represented as an instance of ConfigurationType and registered like below: <configurationType implementation= \"org.jetbrains.plugins.gradle.service.execution.GradleExternalTaskConfigurationType\" /> The easiest way to implement this interface is to use the ConfigurationTypeBase base class. To use it, you need to inherit from it and to provide the configuration type parameters (ID, name, description, and icon) as constructor parameters. In addition to that, you need to call the addFactory() method to add a configuration factory. Configuration Factory All run configurations are created by the ConfigurationFactory registered for a particular ConfigurationType . It's possible that one ConfigurationType has more than one ConfigurationFactory : The key API of ConfigurationFactory , and the only method that you're required to implement, is the createTemplateConfiguration method. This method is called once per project to create the template run configuration. All real run configurations (loaded from the workspace or created by the user) are called by cloning the template through the createConfiguration method. You can customize additional aspects of your configuration factory by overriding the getIcon , getAddIcon , getName and the default settings methods. These additional overrides are optional. Run Configuration The run configuration itself is represented by the RunConfiguration interface. A 'run configuration' here is some named profile which can be executed, e.g., the application started via main() class, test, remote debug to particular machine/port, etc. Here is an example of a Java run configuration defined for a particular project: When implementing a run configuration, you may want to use one of the common base classes: RunConfigurationBase is a general-purpose superclass that contains the most basic implementation of a run configuration. LocatableConfigurationBase is a common base class that should be used for configurations that can be created from context by a RunConfigurationProducer . It supports automatically generating a name for a configuration from its settings and keeping track of whether the name was changed by the user. ModuleBasedConfiguration is a base class for a configuration that is associated with a specific module (for example, Java run configurations use the selected module to determine the run classpath). Settings Editor That common run configuration settings might be modified via: RunConfiguration -specific UI . That is handled by SettingsEditor : getComponent() method is called by the IDE and shows run configuration specific UI. resetFrom() is called to discard all non-confirmed user changes made via that UI. applyTo() is called to confirm the changes, i.e. copy current UI state into the target settings object. Persistence That run configuration settings are persistent, i.e., they are stored at the file system and loaded back on the IDE startup. That is performed via writeExternal() and readExternal() methods of RunConfiguration class correspondingly. The actual configurations stored by the Consulo are represented by instances of the RunnerAndConfigurationSettings class, which combines a run configuration with runner-specific settings, as well as keeping track of certain run configuration flags such as \"temporary\" or \"singleton\". Dealing with instances of this class becomes necessary when you need to create run configurations from code. This is accomplished with the following two steps: RunManager.createConfiguration() creates an instance of RunnerAndConfigurationSettings . RunManager.addConfiguration() makes it persistent by adding it to either the list of shared configurations stored in a project or to the list of local configurations stored in the workspace file. Refactoring Support Most run configurations contain references to classes, files, or directories in their settings, and these settings usually need to be updated when the corresponding element is renamed or moved. To support that, your run configuration needs to implement the RefactoringListenerProvider interface. In your implementation of getRefactoringElementListener() , you need to check whether the refactored element is the one that your run configuration refers to. If it is, you return a RefactoringElementListener that updates your configuration according to the new name and location of the element. Creating Configurations from Context Many plugins support automatic creation of run configurations from context so that the user can click, for example, on an application or test class and automatically run it using the correct run configuration type. To support that, you need to provide an implementation of the RunConfigurationProducer interface and to register it as <runConfigurationProducer> in your plugin.xml . This API was redesigned in IntelliJ IDEA 13; the previous RuntimeConfigurationProducer is a much more confusing version of the same API. The two main methods that you need to implement are: setupConfigurationFromContext() receives a blank configuration of your type and a ConfigurationContext containing information about a source code location (accessible by calling getLocation() or getPsiLocation() ). Your implementation needs to check whether the location is applicable for your configuration type (for example, if it's in a file of the language you're supporting). If not, you need to return false, and if it is, you need to put the correct context-specific settings into the run configuration and return true. isConfigurationFromContext() checks if your type's specified configuration was created from the specified context. Implementing this method allows you to reuse an existing run configuration, which applies to the current context instead of creating a new one and possibly ignoring the user's customizations in the existing one. Note that, to support the automatic naming of configurations created from context, your configuration should use LocatableConfigurationBase as the base class. Running from the Gutter Take a look at RunLineMarkerContributor and its implementations.","title":"Run Configuration Management"},{"location":"basics/run_configurations/run_configuration_management/#configuration-type","text":"The starting point for implementing any run configuration type is the ConfigurationType interface. The list of available configuration types is shown when a user opens the 'Edit run configurations' dialog and executes 'Add' action: Every type there is represented as an instance of ConfigurationType and registered like below: <configurationType implementation= \"org.jetbrains.plugins.gradle.service.execution.GradleExternalTaskConfigurationType\" /> The easiest way to implement this interface is to use the ConfigurationTypeBase base class. To use it, you need to inherit from it and to provide the configuration type parameters (ID, name, description, and icon) as constructor parameters. In addition to that, you need to call the addFactory() method to add a configuration factory.","title":"Configuration Type"},{"location":"basics/run_configurations/run_configuration_management/#configuration-factory","text":"All run configurations are created by the ConfigurationFactory registered for a particular ConfigurationType . It's possible that one ConfigurationType has more than one ConfigurationFactory : The key API of ConfigurationFactory , and the only method that you're required to implement, is the createTemplateConfiguration method. This method is called once per project to create the template run configuration. All real run configurations (loaded from the workspace or created by the user) are called by cloning the template through the createConfiguration method. You can customize additional aspects of your configuration factory by overriding the getIcon , getAddIcon , getName and the default settings methods. These additional overrides are optional.","title":"Configuration Factory"},{"location":"basics/run_configurations/run_configuration_management/#run-configuration","text":"The run configuration itself is represented by the RunConfiguration interface. A 'run configuration' here is some named profile which can be executed, e.g., the application started via main() class, test, remote debug to particular machine/port, etc. Here is an example of a Java run configuration defined for a particular project: When implementing a run configuration, you may want to use one of the common base classes: RunConfigurationBase is a general-purpose superclass that contains the most basic implementation of a run configuration. LocatableConfigurationBase is a common base class that should be used for configurations that can be created from context by a RunConfigurationProducer . It supports automatically generating a name for a configuration from its settings and keeping track of whether the name was changed by the user. ModuleBasedConfiguration is a base class for a configuration that is associated with a specific module (for example, Java run configurations use the selected module to determine the run classpath).","title":"Run Configuration"},{"location":"basics/run_configurations/run_configuration_management/#settings-editor","text":"That common run configuration settings might be modified via: RunConfiguration -specific UI . That is handled by SettingsEditor : getComponent() method is called by the IDE and shows run configuration specific UI. resetFrom() is called to discard all non-confirmed user changes made via that UI. applyTo() is called to confirm the changes, i.e. copy current UI state into the target settings object.","title":"Settings Editor"},{"location":"basics/run_configurations/run_configuration_management/#persistence","text":"That run configuration settings are persistent, i.e., they are stored at the file system and loaded back on the IDE startup. That is performed via writeExternal() and readExternal() methods of RunConfiguration class correspondingly. The actual configurations stored by the Consulo are represented by instances of the RunnerAndConfigurationSettings class, which combines a run configuration with runner-specific settings, as well as keeping track of certain run configuration flags such as \"temporary\" or \"singleton\". Dealing with instances of this class becomes necessary when you need to create run configurations from code. This is accomplished with the following two steps: RunManager.createConfiguration() creates an instance of RunnerAndConfigurationSettings . RunManager.addConfiguration() makes it persistent by adding it to either the list of shared configurations stored in a project or to the list of local configurations stored in the workspace file.","title":"Persistence"},{"location":"basics/run_configurations/run_configuration_management/#refactoring-support","text":"Most run configurations contain references to classes, files, or directories in their settings, and these settings usually need to be updated when the corresponding element is renamed or moved. To support that, your run configuration needs to implement the RefactoringListenerProvider interface. In your implementation of getRefactoringElementListener() , you need to check whether the refactored element is the one that your run configuration refers to. If it is, you return a RefactoringElementListener that updates your configuration according to the new name and location of the element.","title":"Refactoring Support"},{"location":"basics/run_configurations/run_configuration_management/#creating-configurations-from-context","text":"Many plugins support automatic creation of run configurations from context so that the user can click, for example, on an application or test class and automatically run it using the correct run configuration type. To support that, you need to provide an implementation of the RunConfigurationProducer interface and to register it as <runConfigurationProducer> in your plugin.xml . This API was redesigned in IntelliJ IDEA 13; the previous RuntimeConfigurationProducer is a much more confusing version of the same API. The two main methods that you need to implement are: setupConfigurationFromContext() receives a blank configuration of your type and a ConfigurationContext containing information about a source code location (accessible by calling getLocation() or getPsiLocation() ). Your implementation needs to check whether the location is applicable for your configuration type (for example, if it's in a file of the language you're supporting). If not, you need to return false, and if it is, you need to put the correct context-specific settings into the run configuration and return true. isConfigurationFromContext() checks if your type's specified configuration was created from the specified context. Implementing this method allows you to reuse an existing run configuration, which applies to the current context instead of creating a new one and possibly ignoring the user's customizations in the existing one. Note that, to support the automatic naming of configurations created from context, your configuration should use LocatableConfigurationBase as the base class.","title":"Creating Configurations from Context"},{"location":"basics/run_configurations/run_configuration_management/#running-from-the-gutter","text":"Take a look at RunLineMarkerContributor and its implementations.","title":"Running from the Gutter"},{"location":"organization/overview/","text":"Not documented yet","title":"Overview"},{"location":"organization/overview/#not-documented-yet","text":"","title":"Not documented yet"},{"location":"organization/repository_list/","text":"Repositiries by category Uncategoried consulo.github.io - contains consulo.io sources consulo-dev.github.io - contains consulo.dev sources consulo-app.github.io - contains consulo.app sources Core consulo - main repository of Consulo organization on github . It contains Consulo platform code without any language implementations . consulo-spellchecker - contains spellchecker implementation. consulo-images - contains image support. JVM Platform consulo-java - contains Java language implementation. Here you can report any problem with Java language, JVM debugger, etc. consulo-groovy - contains Groovy implementation. consulo-junit - contains JUnit implementation. consulo-testng - contains TestNG implementation. .NET Platform consulo-dotnet - contains base api implementation for .NET platform. Here you can report problems with MSIL language, debugger, etc. consulo-csharp - contains C# language implementation. Here you can report: any problem with C# language .NET debugger evaluation (but not problem with .NET debugger itself) consulo-unity - contains Unity framework implementation. Here you can report: any problem with Unity related functional UnityScript language UnityEditorConsuloPlugin - here you can found Consulo plugin for UnityEditor written in C# consulo-nunit - contains NUnit implementation. JavaScript Platform consulo-javascript - contains JavaScript , ECMAScript , JSON language implementation. Here you can report problems with JavaScript language, debugger, etc. consulo-nodejs - contains NodeJS , Mocha framework implementations. Python Platform consulo-python - contains Python language implementation, and Jython , IronPython frameworks. Here you can report problems with Python language, debugger, etc. Go Platform consulo-google-go - contains Go language implementation. Here you can report problems with Go language,debugger, etc.","title":"Repositories"},{"location":"organization/repository_list/#repositiries-by-category","text":"","title":"Repositiries by category"},{"location":"organization/repository_list/#uncategoried","text":"consulo.github.io - contains consulo.io sources consulo-dev.github.io - contains consulo.dev sources consulo-app.github.io - contains consulo.app sources","title":"Uncategoried"},{"location":"organization/repository_list/#core","text":"consulo - main repository of Consulo organization on github . It contains Consulo platform code without any language implementations . consulo-spellchecker - contains spellchecker implementation. consulo-images - contains image support.","title":"Core"},{"location":"organization/repository_list/#jvm-platform","text":"consulo-java - contains Java language implementation. Here you can report any problem with Java language, JVM debugger, etc. consulo-groovy - contains Groovy implementation. consulo-junit - contains JUnit implementation. consulo-testng - contains TestNG implementation.","title":"JVM Platform"},{"location":"organization/repository_list/#net-platform","text":"consulo-dotnet - contains base api implementation for .NET platform. Here you can report problems with MSIL language, debugger, etc. consulo-csharp - contains C# language implementation. Here you can report: any problem with C# language .NET debugger evaluation (but not problem with .NET debugger itself) consulo-unity - contains Unity framework implementation. Here you can report: any problem with Unity related functional UnityScript language UnityEditorConsuloPlugin - here you can found Consulo plugin for UnityEditor written in C# consulo-nunit - contains NUnit implementation.","title":".NET Platform"},{"location":"organization/repository_list/#javascript-platform","text":"consulo-javascript - contains JavaScript , ECMAScript , JSON language implementation. Here you can report problems with JavaScript language, debugger, etc. consulo-nodejs - contains NodeJS , Mocha framework implementations.","title":"JavaScript Platform"},{"location":"organization/repository_list/#python-platform","text":"consulo-python - contains Python language implementation, and Jython , IronPython frameworks. Here you can report problems with Python language, debugger, etc.","title":"Python Platform"},{"location":"organization/repository_list/#go-platform","text":"consulo-google-go - contains Go language implementation. Here you can report problems with Go language,debugger, etc.","title":"Go Platform"},{"location":"platform/fundamentals/","text":"This section describes the low-level fundamental building blocks of the Consulo : The component model - how the application is hosted and composed. Lifetime and dependency management. Disposers - managing object lifetimes and resource cleanup Threading models Messaging","title":"Overview"},{"location":"platform/internal_libraries/","text":"Java libraries dotnet-asm - library which read .dll/.netmodule files (compiled by .NET)","title":"Internal Libraries"},{"location":"platform/internal_libraries/#java-libraries","text":"dotnet-asm - library which read .dll/.netmodule files (compiled by .NET)","title":"Java libraries"},{"location":"platform/permissions/","text":"Overview For restricting illegal actions from 3rd-party plugins, permissions control some major access to system resources. Permission Types PROCESS_CREATE - running any process in OS (and destroy if need) PROCESS_MANAGE - list all processes in OS, and destroy them (protected by user space) NATIVE_LIBRARY - loading native libraries in Consulo process SOCKET_BIND - binding any TCP/UDP socket SOCKET_CONNECT - connecting to any TCP/UDP socket INTERNET_URL_ACCESS - permission for control access to internet by url(http, https), by plain implementation. Warning: some clients can implement own socket handling, and they will require #SOCKET_CONNECT permission, and don't checked it by this permission","title":"Permissions"},{"location":"platform/permissions/#overview","text":"For restricting illegal actions from 3rd-party plugins, permissions control some major access to system resources.","title":"Overview"},{"location":"platform/permissions/#permission-types","text":"PROCESS_CREATE - running any process in OS (and destroy if need) PROCESS_MANAGE - list all processes in OS, and destroy them (protected by user space) NATIVE_LIBRARY - loading native libraries in Consulo process SOCKET_BIND - binding any TCP/UDP socket SOCKET_CONNECT - connecting to any TCP/UDP socket INTERNET_URL_ACCESS - permission for control access to internet by url(http, https), by plain implementation. Warning: some clients can implement own socket handling, and they will require #SOCKET_CONNECT permission, and don't checked it by this permission","title":"Permission Types"},{"location":"platform/restriction/","text":"Code restrition While coding platform, there some rules, about code/library usage 'consulo.platform.base' module No usage of java.desktop module. It's mean you can't use classes from java.awt & javax.swing . Also since java.beans package in desktop module, you can't use it too (see kava.beans ). No usage of java.lang.System class, use \"consulo.platform.Platform#current()\" - system class, can return different values for each platform 'consulo.platform.desktop' AWT & Swing allowed - but preferer use consulo.ui , since AWT<>Consulo UI, conversion not allowed 'consulo.platform.web' AWT & Swing not allowed","title":"Code Restriction"},{"location":"platform/restriction/#code-restrition","text":"While coding platform, there some rules, about code/library usage","title":"Code restrition"},{"location":"platform/restriction/#consuloplatformbase-module","text":"No usage of java.desktop module. It's mean you can't use classes from java.awt & javax.swing . Also since java.beans package in desktop module, you can't use it too (see kava.beans ). No usage of java.lang.System class, use \"consulo.platform.Platform#current()\" - system class, can return different values for each platform","title":"'consulo.platform.base' module"},{"location":"platform/restriction/#consuloplatformdesktop","text":"AWT & Swing allowed - but preferer use consulo.ui , since AWT<>Consulo UI, conversion not allowed","title":"'consulo.platform.desktop'"},{"location":"platform/restriction/#consuloplatformweb","text":"AWT & Swing not allowed","title":"'consulo.platform.web'"},{"location":"platform/update_channels/","text":"Update Channels Consulo has four public update channels, and one internal (in parentheses iteration information): release (every monday new builds come at 00:00) beta (every day new builds come at 00:00) alpha (by hand on my own will (@VISTALL)) nightly (after each commit to platform or plugin) Channel settings You can always change channel in settings And then click About -> Check for updates WARNING In nightly / alpha channel sometimes plugins don't have builds for new platform (for example compilation failed) Keep calm - Consulo do not allow update, if some plugins missed, you will get warning about it.","title":"Update Channels"},{"location":"platform/update_channels/#update-channels","text":"Consulo has four public update channels, and one internal (in parentheses iteration information): release (every monday new builds come at 00:00) beta (every day new builds come at 00:00) alpha (by hand on my own will (@VISTALL)) nightly (after each commit to platform or plugin)","title":"Update Channels"},{"location":"platform/update_channels/#channel-settings","text":"You can always change channel in settings And then click About -> Check for updates","title":"Channel settings"},{"location":"platform/update_channels/#warning","text":"In nightly / alpha channel sometimes plugins don't have builds for new platform (for example compilation failed) Keep calm - Consulo do not allow update, if some plugins missed, you will get warning about it.","title":"WARNING"},{"location":"platform/desktop/spi.impl/","text":"Desktop SPI implementations Consulo provide some SPI implementations, for extending JRE Audio Stack Consulo have some forks of Sound libraries for extending javax.sound implementation via SPI JavaZoom JLayer JavaZoom Mp3 jvorbis jogg","title":"SPI Implementations"},{"location":"platform/desktop/spi.impl/#desktop-spi-implementations","text":"Consulo provide some SPI implementations, for extending JRE","title":"Desktop SPI implementations"},{"location":"platform/desktop/spi.impl/#audio-stack","text":"Consulo have some forks of Sound libraries for extending javax.sound implementation via SPI JavaZoom JLayer JavaZoom Mp3 jvorbis jogg","title":"Audio Stack"},{"location":"platform/project_model/project/startupactivity/","text":"Preloading Activity An activity to be executed in background on startup (regardless if some project was opened or not). See PreloadingActivity . To register: <extensions defaultExtensionNs= \"com.intellij\" > <preloadingActivity implementation= \"com.example.CatPreloadingActivity\" /> </extensions> Startup Activity An activity to be executed as part of project opening, under 'Loading Project' dialog. Can't be registered by plugins. To register: StartupManager.registerStartupActivity or <extensions defaultExtensionNs= \"com.intellij\" > <startupActivity implementation= \"com.example.CatStartupActivity\" /> </extensions> Post Startup Activity An activity to be executed after project opening. If activity implements DumbAware , it is executed after project is opened on a background thread with no visible progress indicator and regardless of the current indexing mode. Otherwise, it is executed on EDT and when indexes are ready. To register: StartupManager.registerPostStartupActivity or <extensions defaultExtensionNs= \"com.intellij\" > <postStartupActivity implementation= \"com.example.CatStartupActivity\" /> </extensions> See also backgroundPostStartupActivity that acts as postStartupActivity but is executed with 5 seconds delay after project opening. Use ProgressManager.run(Task.Backgroundable) to execute work that needs to be visible to users. Including work that consumes CPU over a noticeable period. Using of Application.executeOnPooledThread is not needed if you use the ProgressManager API. Use AppUiUtil.invokeLaterIfProjectAlive to execute work that needs to be performed in the UI thread. Use DumbService to execute work that requires access to indices.","title":"Startup Activity"},{"location":"platform/project_model/project/startupactivity/#preloading-activity","text":"An activity to be executed in background on startup (regardless if some project was opened or not). See PreloadingActivity . To register: <extensions defaultExtensionNs= \"com.intellij\" > <preloadingActivity implementation= \"com.example.CatPreloadingActivity\" /> </extensions>","title":"Preloading Activity"},{"location":"platform/project_model/project/startupactivity/#startup-activity","text":"An activity to be executed as part of project opening, under 'Loading Project' dialog. Can't be registered by plugins. To register: StartupManager.registerStartupActivity or <extensions defaultExtensionNs= \"com.intellij\" > <startupActivity implementation= \"com.example.CatStartupActivity\" /> </extensions>","title":"Startup Activity"},{"location":"platform/project_model/project/startupactivity/#post-startup-activity","text":"An activity to be executed after project opening. If activity implements DumbAware , it is executed after project is opened on a background thread with no visible progress indicator and regardless of the current indexing mode. Otherwise, it is executed on EDT and when indexes are ready. To register: StartupManager.registerPostStartupActivity or <extensions defaultExtensionNs= \"com.intellij\" > <postStartupActivity implementation= \"com.example.CatStartupActivity\" /> </extensions> See also backgroundPostStartupActivity that acts as postStartupActivity but is executed with 5 seconds delay after project opening. Use ProgressManager.run(Task.Backgroundable) to execute work that needs to be visible to users. Including work that consumes CPU over a noticeable period. Using of Application.executeOnPooledThread is not needed if you use the ProgressManager API. Use AppUiUtil.invokeLaterIfProjectAlive to execute work that needs to be performed in the UI thread. Use DumbService to execute work that requires access to indices.","title":"Post Startup Activity"},{"location":"platform/ui/image/","text":"File Tree icon icon/marker.txt icon/_light/ icon/_light/consulo.plugin.PluginIconGroup/ icon/_dark/ icon/_dark/consulo.plugin.PluginIconGroup/ Tree info marker.txt just marker - file must exists (text ignored) _light / _dark - is id for Image Library. _light and _dark is bundled image libraries consulo.plugin.PluginIconGroup - icon group. Directory must endsWith IconGroup Require maven plugin and configuration <build> <plugins> <plugin> <groupId> consulo.maven </groupId> <artifactId> maven-consulo-plugin </artifactId> <version> 2-SNAPSHOT </version> <extensions> true </extensions> <executions> <execution> <id> gen </id> <phase> generate-sources </phase> <goals> <goal> generate-icon </goal> </goals> </execution> </executions> </plugin> </plugins> </build>","title":"Image Library"},{"location":"platform/ui/image/#file-tree","text":"icon icon/marker.txt icon/_light/ icon/_light/consulo.plugin.PluginIconGroup/ icon/_dark/ icon/_dark/consulo.plugin.PluginIconGroup/","title":"File Tree"},{"location":"platform/ui/image/#tree-info","text":"marker.txt just marker - file must exists (text ignored) _light / _dark - is id for Image Library. _light and _dark is bundled image libraries consulo.plugin.PluginIconGroup - icon group. Directory must endsWith IconGroup","title":"Tree info"},{"location":"platform/ui/image/#require-maven-plugin-and-configuration","text":"<build> <plugins> <plugin> <groupId> consulo.maven </groupId> <artifactId> maven-consulo-plugin </artifactId> <version> 2-SNAPSHOT </version> <extensions> true </extensions> <executions> <execution> <id> gen </id> <phase> generate-sources </phase> <goals> <goal> generate-icon </goal> </goals> </execution> </executions> </plugin> </plugins> </build>","title":"Require maven plugin and configuration"},{"location":"platform/ui/localization/","text":"File Tree localize localize/id.txt package1/ package1/package2/ package1/package2/package3/ package1/package2/package3/PluginLocalize.yaml Text of 'id.txt' file Default value of english localize is en Require maven plugin and configuration <build> <plugins> <plugin> <groupId> consulo.maven </groupId> <artifactId> maven-consulo-plugin </artifactId> <version> 2-SNAPSHOT </version> <extensions> true </extensions> <executions> <execution> <id> gen </id> <phase> generate-sources </phase> <goals> <goal> generate-localize </goal> </goals> </execution> </executions> </plugin> </plugins> </build> Localization plugins Plugin must have yaml file an different locale. Like ru","title":"Localization"},{"location":"platform/ui/localization/#file-tree","text":"localize localize/id.txt package1/ package1/package2/ package1/package2/package3/ package1/package2/package3/PluginLocalize.yaml","title":"File Tree"},{"location":"platform/ui/localization/#text-of-idtxt-file","text":"Default value of english localize is en","title":"Text of 'id.txt' file"},{"location":"platform/ui/localization/#require-maven-plugin-and-configuration","text":"<build> <plugins> <plugin> <groupId> consulo.maven </groupId> <artifactId> maven-consulo-plugin </artifactId> <version> 2-SNAPSHOT </version> <extensions> true </extensions> <executions> <execution> <id> gen </id> <phase> generate-sources </phase> <goals> <goal> generate-localize </goal> </goals> </execution> </executions> </plugin> </plugins> </build>","title":"Require maven plugin and configuration"},{"location":"platform/ui/localization/#localization-plugins","text":"Plugin must have yaml file an different locale. Like ru","title":"Localization plugins"},{"location":"platform/ui/overview/","text":"Consulo Unified UI Consulo provide UI API - implementation will be work at Desktop & Web Browsers. Desktop implementation based on Swing , and Web on GWT (with Vaadin as transport + ui system) For default - any plugins don't known about Swing or GWT Classes: consulo.ui.UIAccess - class provide access to UI Thread, and allow get current thread status #isUIThread() - will return true if we inside UI Thread #give(Runnable) - run task inside UI Thread #get() - will return UIAccess instance if call inside UI thread, otherwise throw exception","title":"Overview"},{"location":"platform/ui/overview/#consulo-unified-ui","text":"Consulo provide UI API - implementation will be work at Desktop & Web Browsers. Desktop implementation based on Swing , and Web on GWT (with Vaadin as transport + ui system) For default - any plugins don't known about Swing or GWT Classes: consulo.ui.UIAccess - class provide access to UI Thread, and allow get current thread status #isUIThread() - will return true if we inside UI Thread #give(Runnable) - run task inside UI Thread #get() - will return UIAccess instance if call inside UI thread, otherwise throw exception","title":"Consulo Unified UI"},{"location":"reference_guide/api_changes_list/","text":"","title":"Api changes list"},{"location":"reference_guide/color_scheme_management/","text":"Preface Color scheme management in IntelliJ IDEA 12.1 was changed to ease scheme designers' work and make schemes look equally well for different programming languages even if not designed specifically for these languages. Previously language plug-ins were using fixed default colors incompatible, for example, with dark schemes. The new implementation allows specifying a dependency on a set of standard text attributes linked to a scheme but not to any specific language. Language-specific attributes still can be set by a scheme designer if needed, but it's optional. New color schemes have got a new .icls (Idea CoLor Scheme) extension to avoid confusion about compatibility problems with older platform versions: if only standard attributes are set, they will not be used by the version before 12.1, resulting in different highlighting colors. Plug-in Developers Text Attribute Key Dependency The easiest and the best way to specify highlighting text attributes is to specify a dependency on one of standard keys defined in DefaultLanguageHighlighterColors : static final TextAttributesKey MY_KEYWORD = TextAttributesKey . createTextAttributesKey ( \"MY_KEYWORD\" , DefaultLanguageHighlighterColors . KEYWORD ); The color scheme manager will search first for text attributes specified by the MY_KEYWORD key. If those are not defined explicitly or if all the attributes are empty (undefined), it will search them using the DEFAULT_KEYWORD key. If neither is defined, it will further fall back to a default scheme. Text attribute keys can be chained, for example you can define another key as: static final TextAttributesKey MY_PREDEFINED_SYMBOL = TextAttributesKey . createTextAttributesKey ( \"MY_PREDEFINED_SYMBOL\" , MY_KEYWORD ); The rule is the same: if text attributes can not be found by the MY_PREDEFINED_SYMBOL key or are empty, the color scheme manager will search for MY_KEYWORD and if not found (empty) will further look for DEFAULT_KEYWORD . NOTE A use of fixed default attributes is strongly discouraged . If you are unsure which base key to use, it's better to pick the most generic one, for example, DefaultLanguageHighlighterColors.IDENTIFIER . Remember that using fixed default attributes will force a scheme designer to explicitly set up a color for this element. Otherwise, its default colors may visually conflict with a color scheme. If the scheme designer doesn't have a language plug-in, he will not be able to fix this at all. Providing Attributes for Specific Schemes A language plug-in may provide default text attributes for \"Default\" and \"Darcula\" bundled schemes or basically for any other scheme if the scheme's name is known. This can be done in plugin.xml by adding an com.intellij.additionalTextAttributes extension providing the name of the file containing desired text attributes, for example: <extensions defaultExtensionNs= \"com.intellij\" > .. <additionalTextAttributes scheme= \"Default\" file= \"colorSchemes/MyLangDefault.xml\" /> .. </extensions> It tells the IDE that the file MyLangDefault.xml must be searched in resources under colorSchemes . Note that the path should not start with a backslash and its fully qualified name (in our case colorSchemes/MyLangDefault.xml ) MUST BE UNIQUE to avoid naming collisions between different providers. Thus adding a language prefix, for example, \"MyLang\", is highly recommended. The file itself is an extract from a color scheme with required attributes, for example: <?xml version='1.0'?> <list> <option name= \"MY_VAR\" > <value> <option name= \"FOREGROUND\" value= \"660000\" /> </value> </option> <option name= \"MY_SPECIAL_CHAR\" > <value> <option name= \"FOREGROUND\" value= \"008000\" /> <option name= \"BACKGROUND\" value= \"e3fcff\" /> <option name= \"FONT_TYPE\" value= \"1\" /> </value> </option> </list> Note: When the scheme is copied via \"Save as...\" all its attributes, including the ones defined in the extension, will be copied to the new scheme. A scheme designer may need to check that these copied attributes do not conflict with his/her color scheme, although in this case the plug-in is installed, and it should not cause any problems. Anyway, try to stick with a simple key dependency if possible (note that it works well for \"Darcula\") and provide explicit attributes only if necessary. Scheme Designers A Typical Workflow for a New Scheme Creation Choose a scheme which will be used as a base, for example, \"Default\" Click \"Save As..\" and give a name for the new scheme First set attributes in General section and proceed with Language Defaults Check all the languages and adjust language-specific text attributes if necessary. In most cases this may not be needed, but two cases may require an extra action: There is an obsolete plug-in which does not use the new color scheme management API and therefore does not utilize the attributes set in \"Language Defaults\". Ideally, a report must be created for the language plug-in so that its author will fix it eventually. A plug-in intentionally sets some default colors and, if the scheme was created from a default one, the colors are copied to the newly created scheme. This can be fixed either by resetting all the attributes to restore the inheritance from Language Defaults (see below) or by setting other colors suitable for the scheme. The first way is preferable since it will require less effort to change the color scheme later. Text Attributes Inheritance For many language text attributes that do not have any values, there will be a line indicating that the attributes are inherited from a specific section/attributes, such as \"Keyword (Language Defaults)\". If an element has any attributes set, only these attributes are used. All attributes from the base element are ignored. To restore the inheritance, unchecks all the boxes, and click Apply .","title":"Color Scheme Management"},{"location":"reference_guide/color_scheme_management/#preface","text":"Color scheme management in IntelliJ IDEA 12.1 was changed to ease scheme designers' work and make schemes look equally well for different programming languages even if not designed specifically for these languages. Previously language plug-ins were using fixed default colors incompatible, for example, with dark schemes. The new implementation allows specifying a dependency on a set of standard text attributes linked to a scheme but not to any specific language. Language-specific attributes still can be set by a scheme designer if needed, but it's optional. New color schemes have got a new .icls (Idea CoLor Scheme) extension to avoid confusion about compatibility problems with older platform versions: if only standard attributes are set, they will not be used by the version before 12.1, resulting in different highlighting colors.","title":"Preface"},{"location":"reference_guide/color_scheme_management/#plug-in-developers","text":"","title":"Plug-in Developers"},{"location":"reference_guide/color_scheme_management/#text-attribute-key-dependency","text":"The easiest and the best way to specify highlighting text attributes is to specify a dependency on one of standard keys defined in DefaultLanguageHighlighterColors : static final TextAttributesKey MY_KEYWORD = TextAttributesKey . createTextAttributesKey ( \"MY_KEYWORD\" , DefaultLanguageHighlighterColors . KEYWORD ); The color scheme manager will search first for text attributes specified by the MY_KEYWORD key. If those are not defined explicitly or if all the attributes are empty (undefined), it will search them using the DEFAULT_KEYWORD key. If neither is defined, it will further fall back to a default scheme. Text attribute keys can be chained, for example you can define another key as: static final TextAttributesKey MY_PREDEFINED_SYMBOL = TextAttributesKey . createTextAttributesKey ( \"MY_PREDEFINED_SYMBOL\" , MY_KEYWORD ); The rule is the same: if text attributes can not be found by the MY_PREDEFINED_SYMBOL key or are empty, the color scheme manager will search for MY_KEYWORD and if not found (empty) will further look for DEFAULT_KEYWORD . NOTE A use of fixed default attributes is strongly discouraged . If you are unsure which base key to use, it's better to pick the most generic one, for example, DefaultLanguageHighlighterColors.IDENTIFIER . Remember that using fixed default attributes will force a scheme designer to explicitly set up a color for this element. Otherwise, its default colors may visually conflict with a color scheme. If the scheme designer doesn't have a language plug-in, he will not be able to fix this at all.","title":"Text Attribute Key Dependency"},{"location":"reference_guide/color_scheme_management/#providing-attributes-for-specific-schemes","text":"A language plug-in may provide default text attributes for \"Default\" and \"Darcula\" bundled schemes or basically for any other scheme if the scheme's name is known. This can be done in plugin.xml by adding an com.intellij.additionalTextAttributes extension providing the name of the file containing desired text attributes, for example: <extensions defaultExtensionNs= \"com.intellij\" > .. <additionalTextAttributes scheme= \"Default\" file= \"colorSchemes/MyLangDefault.xml\" /> .. </extensions> It tells the IDE that the file MyLangDefault.xml must be searched in resources under colorSchemes . Note that the path should not start with a backslash and its fully qualified name (in our case colorSchemes/MyLangDefault.xml ) MUST BE UNIQUE to avoid naming collisions between different providers. Thus adding a language prefix, for example, \"MyLang\", is highly recommended. The file itself is an extract from a color scheme with required attributes, for example: <?xml version='1.0'?> <list> <option name= \"MY_VAR\" > <value> <option name= \"FOREGROUND\" value= \"660000\" /> </value> </option> <option name= \"MY_SPECIAL_CHAR\" > <value> <option name= \"FOREGROUND\" value= \"008000\" /> <option name= \"BACKGROUND\" value= \"e3fcff\" /> <option name= \"FONT_TYPE\" value= \"1\" /> </value> </option> </list> Note: When the scheme is copied via \"Save as...\" all its attributes, including the ones defined in the extension, will be copied to the new scheme. A scheme designer may need to check that these copied attributes do not conflict with his/her color scheme, although in this case the plug-in is installed, and it should not cause any problems. Anyway, try to stick with a simple key dependency if possible (note that it works well for \"Darcula\") and provide explicit attributes only if necessary.","title":"Providing Attributes for Specific Schemes"},{"location":"reference_guide/color_scheme_management/#scheme-designers","text":"","title":"Scheme Designers"},{"location":"reference_guide/color_scheme_management/#a-typical-workflow-for-a-new-scheme-creation","text":"Choose a scheme which will be used as a base, for example, \"Default\" Click \"Save As..\" and give a name for the new scheme First set attributes in General section and proceed with Language Defaults Check all the languages and adjust language-specific text attributes if necessary. In most cases this may not be needed, but two cases may require an extra action: There is an obsolete plug-in which does not use the new color scheme management API and therefore does not utilize the attributes set in \"Language Defaults\". Ideally, a report must be created for the language plug-in so that its author will fix it eventually. A plug-in intentionally sets some default colors and, if the scheme was created from a default one, the colors are copied to the newly created scheme. This can be fixed either by resetting all the attributes to restore the inheritance from Language Defaults (see below) or by setting other colors suitable for the scheme. The first way is preferable since it will require less effort to change the color scheme later.","title":"A Typical Workflow for a New Scheme Creation"},{"location":"reference_guide/color_scheme_management/#text-attributes-inheritance","text":"For many language text attributes that do not have any values, there will be a line indicating that the attributes are inherited from a specific section/attributes, such as \"Keyword (Language Defaults)\". If an element has any attributes set, only these attributes are used. All attributes from the base element are ignored. To restore the inheritance, unchecks all the boxes, and click Apply .","title":"Text Attributes Inheritance"},{"location":"reference_guide/custom_language_support/","text":"Consulo is a powerful platform for building development tools targeting any language. Most of the IDE features consist of language-independent (provided by the platform) and language-specific parts. Supporting a particular feature for a new language can be achieved with a small amount of effort: a plugin must implement only the language-specific part. This part of the documentation explains the main concepts of the Language API and guides you through the sequence of steps that are usually required to develop a custom language plugin. You can obtain additional information about the Language API from the JavaDoc comments for the Language API classes and from the Properties language support source code, which is part of the IntelliJ IDEA Community Edition source code. If you prefer a full example to the detailed descriptions offered in this section, please check out a step-by-step tutorial on how to create custom language support for Simple Language : Custom Language Support Tutorial . Corresponding steps from the tutorial are linked under the \"Examples\" section on each page of this reference. The webinar How We Built Comma, the Raku IDE, on the Consulo offers an excellent introduction as well. Providing custom language support includes the following major steps: Registering File Type Implementing Lexer Implementing Parser and PSI Syntax Highlighting and Error Highlighting References and Resolve Symbols Declarations and References Navigation Code Completion Find Usages Rename Refactoring Safe Delete Refactoring Code Formatter Code Inspections and Intentions Structure View Surround With Go to Class and Go to Symbol Documentation Additional Minor Features","title":"Overview"},{"location":"reference_guide/editors/","text":"This section covers working with text in the Consulo editor. It is presented in two major sections: * Editor basics tutorial * Using the action system to access a caret placed in a document open in an editor. * Accessing position information about a caret in an editor: coordinate systems and offsets. * Handling actions activated by keystroke events in the editor. * Multiple carets * Working with multiple, independent, carets in one editor. * How multiple carets affect core functionality, editor actions, typing actions, and code insight actions.","title":"Overview"},{"location":"reference_guide/intellij_artifacts/","text":"WARNING When using additional repositories, make sure to use HTTPS always. JetBrains maintains public repositories that host artifacts related to the Consulo, such as binaries and source code. These repositories make artifacts more accessible for plugin developers. The Consulo artifacts repositories are: * Releases repository for release versions by build number . * Snapshots repository for BRANCH#-EAP-SNAPSHOT , EAP-CANDIDATE-SNAPSHOT , LATEST-EAP-SNAPSHOT , and the EAP-SNAPSHOT . See the Maven coordinates section for details about specifying these artifacts. Both the Releases and Snapshots repositories have two types of content: * Binary and source code artifacts for cross-platform, ZIP distributions of Consulo-based IDEs, such as IntelliJ IDEA, CLion, Rider, and MPS. These artifacts are not intended to be accessed directly from a plugin project's build.gradle file. The gradle-intellij-plugin will access them as-needed for a plugin project. * Artifacts for individual modules from the Consulo. These may be downloaded, or accessed directly from a build.gradle file, as explained below. Artifacts for Consulo third-party dependencies are hosted at the Bintray repository . A link to this repository should be added to pom.xml / build.gradle files when individual modules from an Consulo artifacts repository are used. Using Consulo Module Artifacts Consulo module artifacts are utilized by adding information to a project's build.gradle file. More information about Gradle support is available in the IntelliJ IDEA Help documentation. To setup dependencies on a module there are two types of information needed: 1. Specify the corresponding repository URL for the artifact. 2. Specify the Maven coordinates for the artifact. Specify the Repository URL The URL for the desired artifact needs to be added to a Maven or Gradle script: * For release versions, use https://www.jetbrains.com/intellij-repository/releases * For EAP snapshots, use https://www.jetbrains.com/intellij-repository/snapshots * For dependencies on individual modules from the Consulo, also use https://jetbrains.bintray.com/intellij-third-party-dependencies Specify the Maven Coordinates for the Artifact Describing a desired Consulo module artifact is done with Maven coordinates: groupId , artifactId , and version . The Maven coordinates are based on the names of modules. The groupId for a module is the prefix com.jetbrains. concatenated with the first two parts of the module name. For example, the module intellij.xml would have the groupId com.jetbrains.intellij.xml . The artifactId is the second.. n parts of the module name separated by \"-\" characters. For example, the module intellij.xml would have the artifactId xml . There are some special cases to artifactId names. If the second part of the module name is a common group like platform , vcs , or cloud , the second part of the module name is dropped, and the artifactId becomes the third.. n parts of the module name, separated by \"-\" characters. Portions of the module name expressed in camelCase format are divided and used in the artifactId as (all lower case) camel-case . The table below shows some example module names and their corresponding groupId and artifactId. Module Name groupId artifactId intellij.java.compiler.antTasks com.jetbrains.intellij.java java-compiler-ant-tasks intellij.java.debugger com.jetbrains.intellij.java java-debugger intellij.platform.util com.jetbrains.intellij.platform util intellij.platform.vcs.log com.jetbrains.intellij.platform vcs-log intellij.spring com.jetbrains.intellij.spring spring intellij.xml.impl com.jetbrains.intellij.xml xml-impl The artifact version can be specified in one of several ways because each artifact at the Repository URLs has multiple versions available: * Specify release build versions as MAJOR[.MINOR][.FIX] . For example 14 , or 14.1 , or 14.1.1 * Snapshot versions are specified as: * The snapshot of the most recent branch build is specified as BRANCH-EAP-SNAPSHOT . For example, 193-EAP-SNAPSHOT . There is only one of this type of build for each branch of each product. * The snapshot of the branch from which the next EAP/release build might be produced is specified as BRANCH.BUILD-EAP-CANDIDATE-SNAPSHOT . For example 193.4386-EAP-CANDIDATE-SNAPSHOT . There are multiple builds of this type, one for each build in each branch of every product. * The latest snapshot of a product is always specified as LATEST-EAP-SNAPSHOT . There is only one build of this type per product, and it is always the same as the BRANCH-EAP-SNAPSHOT for the newest branch of the product. * A snapshot of a branch is specified as BRANCH.BUILD.FIX-EAP-SNAPSHOT . For example, 193.4386.10-EAP-SNAPSHOT . There are many builds of this type for each branch of each product. Example Artifact Specification For example, to specify the jps-model-serialization module: * groupId = com.jetbrains.intellij.platform * artifactId = jps-model-serialization * classifier = \"\" * packaging = jar Gradle Example for an Individual Module from the Consulo This section presents an example of using a Gradle script to incorporate an Consulo module and repository in a build.gradle file. The example illustrates declaring the artifact URL, Maven coordinates, and version for the jps-model-serialization module artifact. There are two parts to the example: the repository and the dependency sections. Repositories Section This code snippet selects the release repository with the first URL, and repository of Consulo dependencies with the second URL. The second URL is needed because this example selects individual modules. repositories { maven { url \"https://www.jetbrains.com/intellij-repository/releases\" } maven { url \"https://jetbrains.bintray.com/intellij-third-party-dependencies\" } } Dependencies Section This code snippet specifies the desired module artifacts. dependencies { compile \"com.jetbrains.intellij.platform:jps-model-serialization:182.2949.4\" compile \"com.jetbrains.intellij.platform:jps-model-impl:182.2949.4\" } Note: * The artifact version ( 182.2949.4 ) must match in both statements. * In this example jps-model-serialization declares the APIs and jps-model-impl provides the implementation, so both are required dependencies.","title":"Consulo Artifacts Repositories"},{"location":"reference_guide/intellij_artifacts/#using-consulo-module-artifacts","text":"Consulo module artifacts are utilized by adding information to a project's build.gradle file. More information about Gradle support is available in the IntelliJ IDEA Help documentation. To setup dependencies on a module there are two types of information needed: 1. Specify the corresponding repository URL for the artifact. 2. Specify the Maven coordinates for the artifact.","title":"Using Consulo Module Artifacts"},{"location":"reference_guide/intellij_artifacts/#specify-the-repository-url","text":"The URL for the desired artifact needs to be added to a Maven or Gradle script: * For release versions, use https://www.jetbrains.com/intellij-repository/releases * For EAP snapshots, use https://www.jetbrains.com/intellij-repository/snapshots * For dependencies on individual modules from the Consulo, also use https://jetbrains.bintray.com/intellij-third-party-dependencies","title":"Specify the Repository URL"},{"location":"reference_guide/intellij_artifacts/#specify-the-maven-coordinates-for-the-artifact","text":"Describing a desired Consulo module artifact is done with Maven coordinates: groupId , artifactId , and version . The Maven coordinates are based on the names of modules. The groupId for a module is the prefix com.jetbrains. concatenated with the first two parts of the module name. For example, the module intellij.xml would have the groupId com.jetbrains.intellij.xml . The artifactId is the second.. n parts of the module name separated by \"-\" characters. For example, the module intellij.xml would have the artifactId xml . There are some special cases to artifactId names. If the second part of the module name is a common group like platform , vcs , or cloud , the second part of the module name is dropped, and the artifactId becomes the third.. n parts of the module name, separated by \"-\" characters. Portions of the module name expressed in camelCase format are divided and used in the artifactId as (all lower case) camel-case . The table below shows some example module names and their corresponding groupId and artifactId. Module Name groupId artifactId intellij.java.compiler.antTasks com.jetbrains.intellij.java java-compiler-ant-tasks intellij.java.debugger com.jetbrains.intellij.java java-debugger intellij.platform.util com.jetbrains.intellij.platform util intellij.platform.vcs.log com.jetbrains.intellij.platform vcs-log intellij.spring com.jetbrains.intellij.spring spring intellij.xml.impl com.jetbrains.intellij.xml xml-impl The artifact version can be specified in one of several ways because each artifact at the Repository URLs has multiple versions available: * Specify release build versions as MAJOR[.MINOR][.FIX] . For example 14 , or 14.1 , or 14.1.1 * Snapshot versions are specified as: * The snapshot of the most recent branch build is specified as BRANCH-EAP-SNAPSHOT . For example, 193-EAP-SNAPSHOT . There is only one of this type of build for each branch of each product. * The snapshot of the branch from which the next EAP/release build might be produced is specified as BRANCH.BUILD-EAP-CANDIDATE-SNAPSHOT . For example 193.4386-EAP-CANDIDATE-SNAPSHOT . There are multiple builds of this type, one for each build in each branch of every product. * The latest snapshot of a product is always specified as LATEST-EAP-SNAPSHOT . There is only one build of this type per product, and it is always the same as the BRANCH-EAP-SNAPSHOT for the newest branch of the product. * A snapshot of a branch is specified as BRANCH.BUILD.FIX-EAP-SNAPSHOT . For example, 193.4386.10-EAP-SNAPSHOT . There are many builds of this type for each branch of each product.","title":"Specify the Maven Coordinates for the Artifact"},{"location":"reference_guide/intellij_artifacts/#example-artifact-specification","text":"For example, to specify the jps-model-serialization module: * groupId = com.jetbrains.intellij.platform * artifactId = jps-model-serialization * classifier = \"\" * packaging = jar","title":"Example Artifact Specification"},{"location":"reference_guide/intellij_artifacts/#gradle-example-for-an-individual-module-from-the-consulo","text":"This section presents an example of using a Gradle script to incorporate an Consulo module and repository in a build.gradle file. The example illustrates declaring the artifact URL, Maven coordinates, and version for the jps-model-serialization module artifact. There are two parts to the example: the repository and the dependency sections.","title":"Gradle Example for an Individual Module from the Consulo"},{"location":"reference_guide/intellij_artifacts/#repositories-section","text":"This code snippet selects the release repository with the first URL, and repository of Consulo dependencies with the second URL. The second URL is needed because this example selects individual modules. repositories { maven { url \"https://www.jetbrains.com/intellij-repository/releases\" } maven { url \"https://jetbrains.bintray.com/intellij-third-party-dependencies\" } }","title":"Repositories Section"},{"location":"reference_guide/intellij_artifacts/#dependencies-section","text":"This code snippet specifies the desired module artifacts. dependencies { compile \"com.jetbrains.intellij.platform:jps-model-serialization:182.2949.4\" compile \"com.jetbrains.intellij.platform:jps-model-impl:182.2949.4\" } Note: * The artifact version ( 182.2949.4 ) must match in both statements. * In this example jps-model-serialization declares the APIs and jps-model-impl provides the implementation, so both are required dependencies.","title":"Dependencies Section"},{"location":"reference_guide/messaging_infrastructure/","text":"Purpose The purpose of this document is to introduce the messaging infrastructure available in the Consulo to developers and plugin writers. It is intended to answer why, when and how to use it. Rationale So, what is messaging in the Consulo and why do we need it? Basically, its implementation of Observer pattern that provides additional features like broadcasting on hierarchy and special nested events processing ( nested event here is a situation when new event is fired (directly or indirectly) from the callback of another event). Design Here are the main components of the messaging API. Topic This class serves as an endpoint at the messaging infrastructure. I.e., clients are allowed to subscribe to a specific topic within a bus and send messages to that topic within that particular bus. display name just a human-readable name used for logging/monitoring purposes; broadcast direction will be explained in details at Broadcasting. Default value is TO_CHILDREN ; listener class that is a business interface for particular topic. Subscribers register an implementation of this interface at the messaging infrastructure. Publishers later retrieve objects that conform to the interface (IS-A) and call any methods defined on those implementations. The messaging infrastructure takes care of dispatching the message to all subscribers of the topic by calling the same method with the same arguments on the registered implementation callbacks; Message Bus Is the core of the messaging system. Is used at the following scenarios: Connection Manages all subscriptions for particular client within particular bus. keeps number of topic handler mappings (callbacks to invoke when message for the target topic is received) Note : not more than one handler per-topic within the same connection is allowed; it's possible to specify default handler and subscribe to the target topic without explicitly provided callback. Connection will use that default handler when storing (topic-handler) mapping; it's possible to explicitly release acquired resources ( disconnect() method). Also it can be plugged to standard semi-automatic disposing ( Disposable ); Putting Altogether Defining business interface and topic public interface ChangeActionNotifier { Topic < ChangeActionNotifier > CHANGE_ACTION_TOPIC = Topic . create ( \"custom name\" , ChangeActionNotifier . class ) void beforeAction ( Context context ); void afterAction ( Context context ); } Subscribing NOTE If targeting 2019.3 or later, use declarative registration if possible. public void init ( MessageBus bus ) { bus . connect (). subscribe ( ActionTopics . CHANGE_ACTION_TOPIC , new ChangeActionNotifier () { @Override public void beforeAction ( Context context ) { // Process 'before action' event. } @Override public void afterAction ( Context context ) { // Process 'after action' event. } }); } Publishing public void doChange ( Context context ) { ChangeActionNotifier publisher = myBus . syncPublisher ( ActionTopics . CHANGE_ACTION_TOPIC ); publisher . beforeAction ( context ); try { // Do action // ... } finally { publisher . afterAction ( context ) } } Existing resources MessageBus instances are available via ComponentManager.getMessageBus() Many standard interfaces implement a message bus, e.g., Application and Project . A number of public topics are used by the Consulo , e.g., AppTopics , ProjectTopics , etc. So, it's possible to subscribe to them in order to receive information about the processing; Broadcasting Message buses can be organised into hierarchies. Moreover, the Consulo has them already: That allows to notify subscribers registered in one message bus on messages sent to another message bus. Example: Here we have a simple hierarchy ( application bus is a parent of project bus ) with three subscribers for the same topic. We get the following if topic1 defines broadcast direction as TO_CHILDREN : 1. A message is sent to topic1 via application bus ; 2. handler1 is notified about the message; 3. The message is delivered to the subscribers of the same topic within project bus ( handler2 and handler3 ); Benefits We don't need to bother with memory management of subscribers that are bound to child buses but interested in parent bus-level events. Consider the example above we may want to have project-specific functionality that reacts to the application-level events. All we need to do is to subscribe to the target topic within the project bus . No hard reference to the project-level subscriber will be stored at application-level then, i.e., we just avoided memory leak on project re-opening. Options Broadcast configuration is defined per-topic. The following options are available: TO_CHILDREN_ (default); NONE ; TO_PARENT ; Nested Messages Nested message is a message sent (directly or indirectly) during another message processing. The Consulo's Messaging infrastructure guarantees that all messages sent to particular topic will be delivered at the sending order. Example: Suppose we have the following configuration: Let's see what happens if someone sends a message to the target topic: message1 is sent; handler1 receives message1 and sends message2 to the same topic; handler2 receives message1 ; handler2 receives message2 ; handler1 receives message2 ; Tips'n'tricks Relief Listeners Management Messaging infrastructure is very light-weight, so, it's possible to reuse it at local sub-systems in order to relieve Observers construction. Let's see what is necessary to do then: Define business interface to work with; Create shared message bus and topic that uses the interface above ( shared here means that either subject or observers know about them); Let's compare that with a manual implementation: Define listener interface (business interface); Provide reference to the subject to all interested listeners; Add listeners storage and listeners management methods (add/remove) to the subject ; Manually iterate all listeners and call target callback in all places where new event is fired; Avoid Shared Data Modification from Subscribers We had a problem in a situation when two subscribers tried to modify the same document ( IDEA-71701 ). The thing is that every document change is performed by the following scenario: before change event is sent to all document listeners and some of them publish new messages during that; actual change is performed; after change event is sent to all document listeners; We had the following then: message1 is sent to the topic with two subscribers; message1 is queued for both subscribers; message1 delivery starts; subscriber1 receives message1 ; subscriber1 issues document modification request at particular range (e.g. document.delete(startOffset, endOffset) ); before change notification is sent to the document listeners; message2 is sent by one of the standard document listeners to another topic within the same message bus during before change processing; the bus tries to deliver all pending messages before queuing message2 ; subscriber2 receives message1 and also modifies a document; the call stack is unwinded and actual change phase of document modification operation requested by subscriber1 begins; The problem is that document range used by subscriber1 for initial modification request is invalid if subscriber2 has changed document's range before it.","title":"Messaging Infrastructure"},{"location":"reference_guide/messaging_infrastructure/#purpose","text":"The purpose of this document is to introduce the messaging infrastructure available in the Consulo to developers and plugin writers. It is intended to answer why, when and how to use it.","title":"Purpose"},{"location":"reference_guide/messaging_infrastructure/#rationale","text":"So, what is messaging in the Consulo and why do we need it? Basically, its implementation of Observer pattern that provides additional features like broadcasting on hierarchy and special nested events processing ( nested event here is a situation when new event is fired (directly or indirectly) from the callback of another event).","title":"Rationale"},{"location":"reference_guide/messaging_infrastructure/#design","text":"Here are the main components of the messaging API.","title":"Design"},{"location":"reference_guide/messaging_infrastructure/#topic","text":"This class serves as an endpoint at the messaging infrastructure. I.e., clients are allowed to subscribe to a specific topic within a bus and send messages to that topic within that particular bus. display name just a human-readable name used for logging/monitoring purposes; broadcast direction will be explained in details at Broadcasting. Default value is TO_CHILDREN ; listener class that is a business interface for particular topic. Subscribers register an implementation of this interface at the messaging infrastructure. Publishers later retrieve objects that conform to the interface (IS-A) and call any methods defined on those implementations. The messaging infrastructure takes care of dispatching the message to all subscribers of the topic by calling the same method with the same arguments on the registered implementation callbacks;","title":"Topic"},{"location":"reference_guide/messaging_infrastructure/#message-bus","text":"Is the core of the messaging system. Is used at the following scenarios:","title":"Message Bus"},{"location":"reference_guide/messaging_infrastructure/#connection","text":"Manages all subscriptions for particular client within particular bus. keeps number of topic handler mappings (callbacks to invoke when message for the target topic is received) Note : not more than one handler per-topic within the same connection is allowed; it's possible to specify default handler and subscribe to the target topic without explicitly provided callback. Connection will use that default handler when storing (topic-handler) mapping; it's possible to explicitly release acquired resources ( disconnect() method). Also it can be plugged to standard semi-automatic disposing ( Disposable );","title":"Connection"},{"location":"reference_guide/messaging_infrastructure/#putting-altogether","text":"Defining business interface and topic public interface ChangeActionNotifier { Topic < ChangeActionNotifier > CHANGE_ACTION_TOPIC = Topic . create ( \"custom name\" , ChangeActionNotifier . class ) void beforeAction ( Context context ); void afterAction ( Context context ); } Subscribing NOTE If targeting 2019.3 or later, use declarative registration if possible. public void init ( MessageBus bus ) { bus . connect (). subscribe ( ActionTopics . CHANGE_ACTION_TOPIC , new ChangeActionNotifier () { @Override public void beforeAction ( Context context ) { // Process 'before action' event. } @Override public void afterAction ( Context context ) { // Process 'after action' event. } }); } Publishing public void doChange ( Context context ) { ChangeActionNotifier publisher = myBus . syncPublisher ( ActionTopics . CHANGE_ACTION_TOPIC ); publisher . beforeAction ( context ); try { // Do action // ... } finally { publisher . afterAction ( context ) } } Existing resources MessageBus instances are available via ComponentManager.getMessageBus() Many standard interfaces implement a message bus, e.g., Application and Project . A number of public topics are used by the Consulo , e.g., AppTopics , ProjectTopics , etc. So, it's possible to subscribe to them in order to receive information about the processing;","title":"Putting Altogether"},{"location":"reference_guide/messaging_infrastructure/#broadcasting","text":"Message buses can be organised into hierarchies. Moreover, the Consulo has them already: That allows to notify subscribers registered in one message bus on messages sent to another message bus. Example: Here we have a simple hierarchy ( application bus is a parent of project bus ) with three subscribers for the same topic. We get the following if topic1 defines broadcast direction as TO_CHILDREN : 1. A message is sent to topic1 via application bus ; 2. handler1 is notified about the message; 3. The message is delivered to the subscribers of the same topic within project bus ( handler2 and handler3 ); Benefits We don't need to bother with memory management of subscribers that are bound to child buses but interested in parent bus-level events. Consider the example above we may want to have project-specific functionality that reacts to the application-level events. All we need to do is to subscribe to the target topic within the project bus . No hard reference to the project-level subscriber will be stored at application-level then, i.e., we just avoided memory leak on project re-opening. Options Broadcast configuration is defined per-topic. The following options are available: TO_CHILDREN_ (default); NONE ; TO_PARENT ;","title":"Broadcasting"},{"location":"reference_guide/messaging_infrastructure/#nested-messages","text":"Nested message is a message sent (directly or indirectly) during another message processing. The Consulo's Messaging infrastructure guarantees that all messages sent to particular topic will be delivered at the sending order. Example: Suppose we have the following configuration: Let's see what happens if someone sends a message to the target topic: message1 is sent; handler1 receives message1 and sends message2 to the same topic; handler2 receives message1 ; handler2 receives message2 ; handler1 receives message2 ;","title":"Nested Messages"},{"location":"reference_guide/messaging_infrastructure/#tipsntricks","text":"","title":"Tips'n'tricks"},{"location":"reference_guide/messaging_infrastructure/#relief-listeners-management","text":"Messaging infrastructure is very light-weight, so, it's possible to reuse it at local sub-systems in order to relieve Observers construction. Let's see what is necessary to do then: Define business interface to work with; Create shared message bus and topic that uses the interface above ( shared here means that either subject or observers know about them); Let's compare that with a manual implementation: Define listener interface (business interface); Provide reference to the subject to all interested listeners; Add listeners storage and listeners management methods (add/remove) to the subject ; Manually iterate all listeners and call target callback in all places where new event is fired;","title":"Relief Listeners Management"},{"location":"reference_guide/messaging_infrastructure/#avoid-shared-data-modification-from-subscribers","text":"We had a problem in a situation when two subscribers tried to modify the same document ( IDEA-71701 ). The thing is that every document change is performed by the following scenario: before change event is sent to all document listeners and some of them publish new messages during that; actual change is performed; after change event is sent to all document listeners; We had the following then: message1 is sent to the topic with two subscribers; message1 is queued for both subscribers; message1 delivery starts; subscriber1 receives message1 ; subscriber1 issues document modification request at particular range (e.g. document.delete(startOffset, endOffset) ); before change notification is sent to the document listeners; message2 is sent by one of the standard document listeners to another topic within the same message bus during before change processing; the bus tries to deliver all pending messages before queuing message2 ; subscriber2 receives message1 and also modifies a document; the call stack is unwinded and actual change phase of document modification operation requested by subscriber1 begins; The problem is that document range used by subscriber1 for initial modification request is invalid if subscriber2 has changed document's range before it.","title":"Avoid Shared Data Modification from Subscribers"},{"location":"reference_guide/multiple_carets/","text":"Introduction Support for multiple independent carets has been added to editor implementation in IDEA 13.1. Most editor actions (keyboard navigation, text insertion and deletion, etc.) will be applied to each caret independently. Each caret has its own associated selection, which is a continuous range of document characters (can be empty). When after some action two or more carets end up in the same visual position, they are merged into a single caret with their associated selections merged into a single one. A similar thing will happen when selections for several carets become overlapped: only one of the carets will remain, and the selections will be merged. There's a concept of 'primary' caret \u2014 the one on which non-multi-caret-aware actions and the actions which need a single-point document context (like code completion) will operate. Currently, the most recent caret is considered the primary one. Core Functionality Core logic related to multi-caret implementation such as accessing currently existing carets, adding and removing carets, is available via CaretModel interface, some changes also have been made in SelectionModel interface. Check Javadoc of those interfaces for details. Notable changes from old behaviour: Previously existing methods in CaretModel and SelectionModel to query and modify caret and selection positions work by default on the primary caret now. In the context of CaretModel.runForEachCaret method though, they operate on the current caret. So the behaviour of legacy code (not using Caret interface) will depend on the context of its invocation. Block selection doesn't exist as a separate concept anymore. Correspondingly, block-selection-related methods in SelectionModel interface have changed behaviour \u2014 hasBlockSelection() will always return false, setBlockSelection() will create a multi-caret selection equivalent to the requested block selection. getBlockSelectionStarts() and getBlockSelectionEnds() methods work in multi-caret state, returning all selected regions. Editor Actions EditorAction and EditorActionHandler When EditorActionHandler is invoked, an additional parameter will be passed to it \u2014 a caret instance on which it should operate, or null if it's invoked without any caret context. If the handler invokes another handler (delegate handler for the same actionId or a completely unrelated handler), that parameter should normally be passed to the delegate unchanged (unless no context caret has been provided to the handler, but it needs to invoke another handler on a specific caret). Of course, the handler can just ignore the caret parameter if its functionality is not related to caret/selection position. If the handler needs to implement multi-caret functionality it can do so explicitly in the overridden doExecute method, but if it just needs that method to be invoked for each caret, it suffices to pass a parameter to EditorActionHandler constructor to make doExecute called for each caret when the handler is invoked without a specific caret context. Editor Action Delegates The following delegates are available: EnterHandlerDelegate BackspaceHandlerDelegate JoinLinesHandlerDelegate EditorNavigationDelegate SmartEnterProcessor CommentCompleteHandler StatementUpDownMover CodeBlockProvider At the moment there's no need to make any changes in the handlers to support multiple carets \u2014 they are already invoked for each caret. Typing Actions TypedActionHandler, TypedHandlerDelegate TypedActionHandler and TypedHandlerDelegate implementations are invoked only once for each typed character. If those handlers need to support multiple carets, they will need to implement that explicitly. EditorModificationUtil . typeInStringAtCaretHonorMultipleCarets() method is available to do the most common task in this case \u2014 inserting the same text into all caret positions and/or moving all carets relatively to their current position. Examples of its usage: TypedAction . XmlGtTypedHandler . NOTE Starting from version 14, TypedHandlerDelegate implementations are invoked automatically for each caret. If one wants to implement custom multicaret behaviour on typing, TypedActionHandler needs to be provided instead. Code Insight Actions Existing actions inheriting from CodeInsightAction will work for primary caret only. To support multiple carets, one should subclass MultiCaretCodeInsightAction instead. Each caret might have a different editor and PSI instance, so using the old API is not possible.","title":"Multiple Carets"},{"location":"reference_guide/multiple_carets/#introduction","text":"Support for multiple independent carets has been added to editor implementation in IDEA 13.1. Most editor actions (keyboard navigation, text insertion and deletion, etc.) will be applied to each caret independently. Each caret has its own associated selection, which is a continuous range of document characters (can be empty). When after some action two or more carets end up in the same visual position, they are merged into a single caret with their associated selections merged into a single one. A similar thing will happen when selections for several carets become overlapped: only one of the carets will remain, and the selections will be merged. There's a concept of 'primary' caret \u2014 the one on which non-multi-caret-aware actions and the actions which need a single-point document context (like code completion) will operate. Currently, the most recent caret is considered the primary one.","title":"Introduction"},{"location":"reference_guide/multiple_carets/#core-functionality","text":"Core logic related to multi-caret implementation such as accessing currently existing carets, adding and removing carets, is available via CaretModel interface, some changes also have been made in SelectionModel interface. Check Javadoc of those interfaces for details. Notable changes from old behaviour: Previously existing methods in CaretModel and SelectionModel to query and modify caret and selection positions work by default on the primary caret now. In the context of CaretModel.runForEachCaret method though, they operate on the current caret. So the behaviour of legacy code (not using Caret interface) will depend on the context of its invocation. Block selection doesn't exist as a separate concept anymore. Correspondingly, block-selection-related methods in SelectionModel interface have changed behaviour \u2014 hasBlockSelection() will always return false, setBlockSelection() will create a multi-caret selection equivalent to the requested block selection. getBlockSelectionStarts() and getBlockSelectionEnds() methods work in multi-caret state, returning all selected regions.","title":"Core Functionality"},{"location":"reference_guide/multiple_carets/#editor-actions","text":"","title":"Editor Actions"},{"location":"reference_guide/multiple_carets/#editoraction-and-editoractionhandler","text":"When EditorActionHandler is invoked, an additional parameter will be passed to it \u2014 a caret instance on which it should operate, or null if it's invoked without any caret context. If the handler invokes another handler (delegate handler for the same actionId or a completely unrelated handler), that parameter should normally be passed to the delegate unchanged (unless no context caret has been provided to the handler, but it needs to invoke another handler on a specific caret). Of course, the handler can just ignore the caret parameter if its functionality is not related to caret/selection position. If the handler needs to implement multi-caret functionality it can do so explicitly in the overridden doExecute method, but if it just needs that method to be invoked for each caret, it suffices to pass a parameter to EditorActionHandler constructor to make doExecute called for each caret when the handler is invoked without a specific caret context.","title":"EditorAction and EditorActionHandler"},{"location":"reference_guide/multiple_carets/#editor-action-delegates","text":"The following delegates are available: EnterHandlerDelegate BackspaceHandlerDelegate JoinLinesHandlerDelegate EditorNavigationDelegate SmartEnterProcessor CommentCompleteHandler StatementUpDownMover CodeBlockProvider At the moment there's no need to make any changes in the handlers to support multiple carets \u2014 they are already invoked for each caret.","title":"Editor Action Delegates"},{"location":"reference_guide/multiple_carets/#typing-actions","text":"","title":"Typing Actions"},{"location":"reference_guide/multiple_carets/#typedactionhandler-typedhandlerdelegate","text":"TypedActionHandler and TypedHandlerDelegate implementations are invoked only once for each typed character. If those handlers need to support multiple carets, they will need to implement that explicitly. EditorModificationUtil . typeInStringAtCaretHonorMultipleCarets() method is available to do the most common task in this case \u2014 inserting the same text into all caret positions and/or moving all carets relatively to their current position. Examples of its usage: TypedAction . XmlGtTypedHandler . NOTE Starting from version 14, TypedHandlerDelegate implementations are invoked automatically for each caret. If one wants to implement custom multicaret behaviour on typing, TypedActionHandler needs to be provided instead.","title":"TypedActionHandler, TypedHandlerDelegate"},{"location":"reference_guide/multiple_carets/#code-insight-actions","text":"Existing actions inheriting from CodeInsightAction will work for primary caret only. To support multiple carets, one should subclass MultiCaretCodeInsightAction instead. Each caret might have a different editor and PSI instance, so using the old API is not possible.","title":"Code Insight Actions"},{"location":"reference_guide/settings_groups/","text":"As described in Extension Points for Settings , custom Settings can be declared as children of existing parent groups such as tools . These parent groups are the existing categories of Settings in the Consulo-based IDE. However, suppose the custom Settings are rich enough to require multiple levels? For example, a custom Setting implementation has multiple sub-Settings implementations. Extension Point declarations can create this kind of multilayer Settings hierarchy. bullet list {:toc} Extension Points for Parent-Child Settings Relationships There are multiple ways of creating parent-child relationships in groups of Settings: in implementations, or Extension Point declarations. However, there are performance penalties for creating these relationships in implementations because the objects must be instantiated to determine the relationships. This section describes the syntax for declaring more complex parent-child relationships in com.intellij.projectConfigurable or com.intellij.applicationConfigurable EPs. NOTE An application configurable can be a parent of a project configurable. There are two ways of declaring parent-child relationships using the com.intellij.projectConfigurable or com.intellij.applicationConfigurable EPs. The first is to use separate EP declarations that are tied together by the value of one attribute. The second method is to use nested declarations. Parent-Child Settings Using Separate EPs One way of declaring a parent-child relationship is by using two separate declarations. This form can be used regardless of whether the parent Settings declaration is in the same plugin. If the id attribute of the parent is known, a plugin can add Settings as a child of that parent. For example, below are two declarations for project Settings. The first gets added to the tools group, and the second gets added to the id of the parent. The id of the second, child <projectConfigurable> adds a suffix ( servers ) to the id of the parent. <extensions defaultExtensionNs= \"com.intellij\" > <projectConfigurable parentId= \"tools\" id= \"com.intellij.sdk.tasks\" displayName= \"Tasks\" nonDefaultProject= \"true\" instance= \"com.intellij.sdk.TaskConfigurable\" /> <projectConfigurable parentId= \"com.intellij.sdk.tasks\" id= \"com.intellij.sdk.tasks.servers\" displayName= \"Servers\" nonDefaultProject= \"true\" instance= \"com.intellij.sdk.TaskRepositoriesConfigurable\" /> </extensions> See the Attributes for Parent-Child Settings EPs section for details about the suffix id . Parent-Child Settings Using Nested EPs A shorthand for the separate declaration approach is using the com.intellij.configurable EP. This approach nests the child's Settings declaration within the com.intellij.projectConfigurable or com.intellij.applicationConfigurable EP. Using <configurable> EP would not be possible if the parent Settings were declared in another plugin or file. In that case, Parent-Child Settings Using Separate EPs would be used. When using <configurable> EP there isn't a parentId for the child because the nesting implies it. As with using separate EP declarations, formatting restrictions are placed on the child's id attribute - the suffix ( servers ) gets added. See the Attributes for Parent-Child Settings EPs section. The example below demonstrates a <configurable> EP declaration: <extensions defaultExtensionNs= \"com.intellij\" > <projectConfigurable parentId= \"tools\" id= \"com.intellij.sdk.tasks\" displayName= \"Tasks\" nonDefaultProject= \"true\" instance= \"com.intellij.sdk.TaskConfigurable\" /> <configurable id= \"com.intellij.sdk.tasks.servers\" displayName= \"Servers\" nonDefaultProject= \"true\" instance= \"com.intellij.sdk.TaskRepositoriesConfigurable\" /> </projectConfigurable> </extensions> Within the parent <projectConfigurable> EP declaration above, more <configurable> declarations could be added as sibling Settings. Attributes for Parent-Child Settings EPs There is only one unique attribute when declaring a child Settings EP. The other attributes are the same as discussed in Settings EP Attributes . For the child of a parent, the id attribute becomes compound: Attribute Required Value id Y Compound FQN of implementation based on com.intellij.openapi.options.Configurable in the form: XX.YY where: XX is the parent Settings component FQN-based id. YY is unique to the child among other siblings. TIP All children share the parent's id as the basis of their own id . All children have an id suffix that is unique among their siblings. Implementations for Parent-Child Settings Implementations can be based on Configurable , ConfigurableProvider or one of their subtypes. For more information about creating Settings implementations, see Implementations for Settings Extension Points . Configurable Marker Interfaces The Configurable.Composite interface indicates a configurable component has child components. The preferred approach is to specify child components in the EP declaration . Using the Composite interface incurs the penalty of loading child classes while building the tree of Settings Swing components.","title":"Custom Groups"},{"location":"reference_guide/settings_groups/#extension-points-for-parent-child-settings-relationships","text":"There are multiple ways of creating parent-child relationships in groups of Settings: in implementations, or Extension Point declarations. However, there are performance penalties for creating these relationships in implementations because the objects must be instantiated to determine the relationships. This section describes the syntax for declaring more complex parent-child relationships in com.intellij.projectConfigurable or com.intellij.applicationConfigurable EPs. NOTE An application configurable can be a parent of a project configurable. There are two ways of declaring parent-child relationships using the com.intellij.projectConfigurable or com.intellij.applicationConfigurable EPs. The first is to use separate EP declarations that are tied together by the value of one attribute. The second method is to use nested declarations.","title":"Extension Points for Parent-Child Settings Relationships"},{"location":"reference_guide/settings_groups/#parent-child-settings-using-separate-eps","text":"One way of declaring a parent-child relationship is by using two separate declarations. This form can be used regardless of whether the parent Settings declaration is in the same plugin. If the id attribute of the parent is known, a plugin can add Settings as a child of that parent. For example, below are two declarations for project Settings. The first gets added to the tools group, and the second gets added to the id of the parent. The id of the second, child <projectConfigurable> adds a suffix ( servers ) to the id of the parent. <extensions defaultExtensionNs= \"com.intellij\" > <projectConfigurable parentId= \"tools\" id= \"com.intellij.sdk.tasks\" displayName= \"Tasks\" nonDefaultProject= \"true\" instance= \"com.intellij.sdk.TaskConfigurable\" /> <projectConfigurable parentId= \"com.intellij.sdk.tasks\" id= \"com.intellij.sdk.tasks.servers\" displayName= \"Servers\" nonDefaultProject= \"true\" instance= \"com.intellij.sdk.TaskRepositoriesConfigurable\" /> </extensions> See the Attributes for Parent-Child Settings EPs section for details about the suffix id .","title":"Parent-Child Settings Using Separate EPs"},{"location":"reference_guide/settings_groups/#parent-child-settings-using-nested-eps","text":"A shorthand for the separate declaration approach is using the com.intellij.configurable EP. This approach nests the child's Settings declaration within the com.intellij.projectConfigurable or com.intellij.applicationConfigurable EP. Using <configurable> EP would not be possible if the parent Settings were declared in another plugin or file. In that case, Parent-Child Settings Using Separate EPs would be used. When using <configurable> EP there isn't a parentId for the child because the nesting implies it. As with using separate EP declarations, formatting restrictions are placed on the child's id attribute - the suffix ( servers ) gets added. See the Attributes for Parent-Child Settings EPs section. The example below demonstrates a <configurable> EP declaration: <extensions defaultExtensionNs= \"com.intellij\" > <projectConfigurable parentId= \"tools\" id= \"com.intellij.sdk.tasks\" displayName= \"Tasks\" nonDefaultProject= \"true\" instance= \"com.intellij.sdk.TaskConfigurable\" /> <configurable id= \"com.intellij.sdk.tasks.servers\" displayName= \"Servers\" nonDefaultProject= \"true\" instance= \"com.intellij.sdk.TaskRepositoriesConfigurable\" /> </projectConfigurable> </extensions> Within the parent <projectConfigurable> EP declaration above, more <configurable> declarations could be added as sibling Settings.","title":"Parent-Child Settings Using Nested EPs"},{"location":"reference_guide/settings_groups/#attributes-for-parent-child-settings-eps","text":"There is only one unique attribute when declaring a child Settings EP. The other attributes are the same as discussed in Settings EP Attributes . For the child of a parent, the id attribute becomes compound: Attribute Required Value id Y Compound FQN of implementation based on com.intellij.openapi.options.Configurable in the form: XX.YY where: XX is the parent Settings component FQN-based id. YY is unique to the child among other siblings. TIP All children share the parent's id as the basis of their own id . All children have an id suffix that is unique among their siblings.","title":"Attributes for Parent-Child Settings EPs"},{"location":"reference_guide/settings_groups/#implementations-for-parent-child-settings","text":"Implementations can be based on Configurable , ConfigurableProvider or one of their subtypes. For more information about creating Settings implementations, see Implementations for Settings Extension Points .","title":"Implementations for Parent-Child Settings"},{"location":"reference_guide/settings_groups/#configurable-marker-interfaces","text":"The Configurable.Composite interface indicates a configurable component has child components. The preferred approach is to specify child components in the EP declaration . Using the Composite interface incurs the penalty of loading child classes while building the tree of Settings Swing components.","title":"Configurable Marker Interfaces"},{"location":"reference_guide/settings_guide/","text":"Settings persistently store states that control the behavior and appearance of Consulo-based IDEs. On this page, the term \"Settings\" means the same as \"Preferences\" on some platforms. Plugins can create and store Settings to capture their configuration in a way that uses the Consulo Persistence Model . The User Interface (UI) for these custom Settings can be added to the IDE Settings dialog . Settings can affect different levels of scope. This document describes adding custom Settings at the Project and Application (or Global, IDE) levels. bullet list {:toc} Extension Points for Settings Custom Settings implementations are declared in a plugin's configuration ( plugin.xml ) file using one of two Extension Points (EPs), depending on the level of the Settings. Many attributes are shared between the EP declarations. Application and Project Settings typically provide an implementation based on the Configurable interface because they do not have runtime dependencies. See Implementations for Settings Extension Points for more information. NOTE For performance reasons, the recommended approach is to declare as much information as possible about a Settings' implementation using attributes in the Extension Point. If it is not declared, the component must be loaded to retrieve it from the implementation, degrading UI responsiveness. Declaring Application Settings Settings at the Application level use the com.intellij.applicationConfigurable EP. An example <applicationConfigurable> EP declaration is shown below. The declaration indicates the settings are a child of the tools settings group, the implementation FQN is org.company.ApplicationSettingsConfigurable , the unique ID is the same as the implementation FQN, and the (non-localized) title displayed to users is \"My Application Settings\". See Settings Declaration Attributes for more information. <extensions defaultExtensionNs= \"com.intellij\" > <applicationConfigurable parentId= \"tools\" instance= \"org.company.ApplicationSettingsConfigurable\" id= \"org.company.ApplicationSettingsConfigurable\" displayName= \"My Application Settings\" /> </extensions> Declaring Project Settings Project level Settings use the com.intellij.projectConfigurable EP. An example <projectConfigurable> EP declaration is shown below. Similar to the application setting example above, but it includes the additional attribute nonDefaultProject indicating these settings do not apply to the default project . See Settings Declaration Attributes for details. <extensions defaultExtensionNs= \"com.intellij\" > <projectConfigurable parentId= \"tools\" instance= \"org.company.ProjectSettingsConfigurable\" id= \"org.company.ProjectSettingsConfigurable\" displayName= \"My Project Settings\" nonDefaultProject= \"true\" /> </extensions> Settings Declaration Attributes Readers are encouraged to review the Javadoc comments for Configurable because the attribute information applies to ConfigurableProvider as well as Configurable , as noted. This section provides some additional clarification of those comments. Table of Attributes The attributes supported by com.intellij.applicationConfigurable and com.intellij.projectConfigurable EPs are in the table below: Attribute Implementation Basis Required\u2002\u2002 Attribute Value instance Configurable (1) FQN of implementation. See The Configurable Interface for more information. provider ConfigurableProvider (1) FQN of implementation. See The ConfigurableProvider Class for more information. nonDefaultProject Configurable Y Applicable only to the com.intellij.projectConfigurable (project Settings) EP. true = show Settings for all projects except the default project . false = show Settings for all projects. displayName Configurable ConfigurableProvider (2) The non-localized Settings name visible to users, which is needed for the Settings dialog left-side menu. For a localized visible name omit displayName and use the key and bundle attributes. key and bundle Configurable ConfigurableProvider (2) The localization key and bundle for the Settings name visible to users. For non-localized visible names omit key and bundle and use displayName . id Configurable ConfigurableProvider Y The unique, FQN identifier for this implementation. The FQN should be based on the plugin id to ensure uniqueness. parentId Configurable ConfigurableProvider Y This attribute is used to create a hierarchy of Settings. This component is declared one of the specified parentId component's children. Typically used for placing a Settings panel within the Settings Dialog menu. Acceptable values for parentId are given in Values for Parent ID Attribute . groupId is deprecated.(3) groupWeight Configurable ConfigurableProvider N Specifies the weight (stacking order) of this component within the group of a parent configurable component. The default weight is 0, meaning lowest in the order. If one child in a group or a parent component has non-zero weight, all children will be sorted descending by their weight. If the weights are equal, the components will be sorted ascending by their display name. dynamic Configurable.Composite N This component's children are dynamically calculated by calling the getConfigurables() method. Not recommended because it requires loading additional classes while building a Settings tree. If possible, use XML attributes instead. childrenEPName Configurable N Specifies the FQN name of the Extension Point that will be used to calculate the children of this component. Attribute Notes: 1) Either instance or provider must be specified depending on the implementation. 2) One of these attribute sets must be specified depending on whether the displayed Settings name is localized. 3) If both groupId and parentId are specified, a warning is logged. Also, see default entry in Values for Parent ID Attribute . Values for Parent ID Attribute The table below shows the allowed values for the parentId attribute. See the previous section for all supported attributes. parentId Value Group Details default other If neither parentId nor groupId attribute is set, the component is added to the other Settings group. This is undesirable; see other group description. appearance Appearance & Behavior This child group contains Settings to personalize IDE appearance, such as: changing themes and font size. Also, it covers Settings to customize behavior such as keymaps, configuring plugins, and system Settings such as password policies, HTTP proxy, updates, and more. build Build, Execution, Deployment Child group containing Settings to configure project integration with different build tools, modify the default compiler Settings, manage server access configurations, customize the debugger behavior, etc. build.tools Build Integration A subgroup of build . This subgroup configures project integration with build tools such as Maven, Gradle, or Gant. editor Editor Child group containing Settings to personalize source code appearance, such as fonts, highlighting styles, indents, etc. It also contains Settings to customize the editor's appearance, such as line numbers, caret placement, tabs, source code inspections, setting up templates, and file encodings. language Languages and Frameworks Child group containing Settings related to specific language frameworks and technologies used in the project. tools 3rd Party Settings Child group containing Settings to configure integration with third-party applications, specify the SSH Terminal connection Settings, manage server certificates and tasks, configure diagrams layout, etc. root Super Parent The invisible parent of all existing groups. Not used except for IDEs built on top of the Consulo, or extensive suites of Settings. You should not place settings in this group. other Catch-all The Consulo no longer uses this group. Do not use this group. Use the tools group instead. project Project-related Settings The Consulo no longer uses this group. It was intended to store some project-related settings. Do not use this group. Implementations for Settings Extension Points Implementations for com.intellij.projectConfigurable and com.intellij.applicationConfigurable EPs can have one of two bases: * The Configurable interface, which provides a named configurable component with a Swing form. Most Settings providers are based on the Configurable interface or one of its sub- or supertypes. * The ConfigurableProvider class, which can hide a configurable component from the Settings dialog based on runtime conditions. The Configurable Interface Many Settings in the intellij-community code base implement Configurable or one of its subtypes, such as SearchableConfigurable . Readers are encouraged to review the Javadoc comments for Configurable . Constructors Implementations must meet several requirements for constructors. * Application Settings implementations, declared using the applicationConfiguration EP , must have a default constructor with no arguments. * Project Settings implementations, declared using the projectSettings EP , must declare a constructor with a single argument of type Project . * Beginning in 2020.2, constructor injection (other than for Project ) is not allowed. For a Configurable implementation correctly declared using an EP, the implementation's constructor is not invoked by the Consulo until a user chooses the corresponding Settings displayName in the Settings Dialog menu. WARNING The Consulo may instantiate a Configurable implementation on a background thread, so creating Swing components in a constructor can degrade UI responsiveness. Consulo Interactions with Configurable The instantiation of a generic Configurable implementation is documented in the interface file. A few high-level points are reviewed here: * The Configurable.reset() method is invoked immediately after Configurable.createComponent() . Initialization of Setting values in the constructor or createComponent() is unnecessary. * See the Constructors section for information about when a Settings object is instantiated. * Once instantiated, a Configurable instance's lifetime continues regardless of whether the implementation's Settings are changed, or the user chooses a different entry on the Settings Dialog menu. * A Configurable instance's lifetime ends when OK or Cancel is selected in the Settings Dialog. An instance's Configurable.disposeUIResources() is called when the Settings Dialog is closing. To open Settings dialog or show specific Configurable , see ShowSettingsUtil . Configurable Marker Interfaces Implementations based on Configurable can implement marker interfaces, which provide additional flexibility in the implementation. The following nested interfaces are markers, which convey information about the form to the Consulo: * Configurable.NoScroll - Notifies the Settings dialog not to add scroll bars to the form. By default, a plugin's Settings component is put into a scrollable pane. However, a Settings panel can have a JTree , which requires its own JScrollPane . So NoScroll interface should be used to remove the outer JScrollPane . * Configurable.NoMargin - Notifies the Settings dialog not to add an empty border to the form. By default, an empty border is added for a plugin's Settings component. Additional Interfaces Based on Configurable There are classes in the Consulo specialized for particular types of Settings. These subtypes are based on com.intellij.openapi.options.ConfigurableEP . For example, Settings/Preferences | Editor | General |Appearance allows adding Settings via EditorSmartKeysConfigurableEP and com.intellij.editorSmartKeysConfigurable EP. The ConfigurableProvider Class The ConfigurableProvider class only provides a Configurable implementation if its runtime conditions are met. The Consulo first calls the ConfigurableProvider.canCreateConfigurable() , which evaluates runtime conditions to determine if Settings changes make sense in the current context. If the Settings make sense to display, canCreateConfigurable() returns true . In that case the Consulo calls ConfigurableProvider.createConfigurable() , which returns the Configurable object for its Settings implementation. By choosing not to provide a Configuration implementation in some circumstances, the ConfigurableProvider opts out of the Settings display and modification process. The use of ConfigurableProvider as a basis for a Settings implementation is declared using attributes in the EP declaration.","title":"Settings Guide"},{"location":"reference_guide/settings_guide/#extension-points-for-settings","text":"Custom Settings implementations are declared in a plugin's configuration ( plugin.xml ) file using one of two Extension Points (EPs), depending on the level of the Settings. Many attributes are shared between the EP declarations. Application and Project Settings typically provide an implementation based on the Configurable interface because they do not have runtime dependencies. See Implementations for Settings Extension Points for more information. NOTE For performance reasons, the recommended approach is to declare as much information as possible about a Settings' implementation using attributes in the Extension Point. If it is not declared, the component must be loaded to retrieve it from the implementation, degrading UI responsiveness.","title":"Extension Points for Settings"},{"location":"reference_guide/settings_guide/#declaring-application-settings","text":"Settings at the Application level use the com.intellij.applicationConfigurable EP. An example <applicationConfigurable> EP declaration is shown below. The declaration indicates the settings are a child of the tools settings group, the implementation FQN is org.company.ApplicationSettingsConfigurable , the unique ID is the same as the implementation FQN, and the (non-localized) title displayed to users is \"My Application Settings\". See Settings Declaration Attributes for more information. <extensions defaultExtensionNs= \"com.intellij\" > <applicationConfigurable parentId= \"tools\" instance= \"org.company.ApplicationSettingsConfigurable\" id= \"org.company.ApplicationSettingsConfigurable\" displayName= \"My Application Settings\" /> </extensions>","title":"Declaring Application Settings"},{"location":"reference_guide/settings_guide/#declaring-project-settings","text":"Project level Settings use the com.intellij.projectConfigurable EP. An example <projectConfigurable> EP declaration is shown below. Similar to the application setting example above, but it includes the additional attribute nonDefaultProject indicating these settings do not apply to the default project . See Settings Declaration Attributes for details. <extensions defaultExtensionNs= \"com.intellij\" > <projectConfigurable parentId= \"tools\" instance= \"org.company.ProjectSettingsConfigurable\" id= \"org.company.ProjectSettingsConfigurable\" displayName= \"My Project Settings\" nonDefaultProject= \"true\" /> </extensions>","title":"Declaring Project Settings"},{"location":"reference_guide/settings_guide/#settings-declaration-attributes","text":"Readers are encouraged to review the Javadoc comments for Configurable because the attribute information applies to ConfigurableProvider as well as Configurable , as noted. This section provides some additional clarification of those comments.","title":"Settings Declaration Attributes"},{"location":"reference_guide/settings_guide/#table-of-attributes","text":"The attributes supported by com.intellij.applicationConfigurable and com.intellij.projectConfigurable EPs are in the table below: Attribute Implementation Basis Required\u2002\u2002 Attribute Value instance Configurable (1) FQN of implementation. See The Configurable Interface for more information. provider ConfigurableProvider (1) FQN of implementation. See The ConfigurableProvider Class for more information. nonDefaultProject Configurable Y Applicable only to the com.intellij.projectConfigurable (project Settings) EP. true = show Settings for all projects except the default project . false = show Settings for all projects. displayName Configurable ConfigurableProvider (2) The non-localized Settings name visible to users, which is needed for the Settings dialog left-side menu. For a localized visible name omit displayName and use the key and bundle attributes. key and bundle Configurable ConfigurableProvider (2) The localization key and bundle for the Settings name visible to users. For non-localized visible names omit key and bundle and use displayName . id Configurable ConfigurableProvider Y The unique, FQN identifier for this implementation. The FQN should be based on the plugin id to ensure uniqueness. parentId Configurable ConfigurableProvider Y This attribute is used to create a hierarchy of Settings. This component is declared one of the specified parentId component's children. Typically used for placing a Settings panel within the Settings Dialog menu. Acceptable values for parentId are given in Values for Parent ID Attribute . groupId is deprecated.(3) groupWeight Configurable ConfigurableProvider N Specifies the weight (stacking order) of this component within the group of a parent configurable component. The default weight is 0, meaning lowest in the order. If one child in a group or a parent component has non-zero weight, all children will be sorted descending by their weight. If the weights are equal, the components will be sorted ascending by their display name. dynamic Configurable.Composite N This component's children are dynamically calculated by calling the getConfigurables() method. Not recommended because it requires loading additional classes while building a Settings tree. If possible, use XML attributes instead. childrenEPName Configurable N Specifies the FQN name of the Extension Point that will be used to calculate the children of this component. Attribute Notes: 1) Either instance or provider must be specified depending on the implementation. 2) One of these attribute sets must be specified depending on whether the displayed Settings name is localized. 3) If both groupId and parentId are specified, a warning is logged. Also, see default entry in Values for Parent ID Attribute .","title":"Table of Attributes"},{"location":"reference_guide/settings_guide/#values-for-parent-id-attribute","text":"The table below shows the allowed values for the parentId attribute. See the previous section for all supported attributes. parentId Value Group Details default other If neither parentId nor groupId attribute is set, the component is added to the other Settings group. This is undesirable; see other group description. appearance Appearance & Behavior This child group contains Settings to personalize IDE appearance, such as: changing themes and font size. Also, it covers Settings to customize behavior such as keymaps, configuring plugins, and system Settings such as password policies, HTTP proxy, updates, and more. build Build, Execution, Deployment Child group containing Settings to configure project integration with different build tools, modify the default compiler Settings, manage server access configurations, customize the debugger behavior, etc. build.tools Build Integration A subgroup of build . This subgroup configures project integration with build tools such as Maven, Gradle, or Gant. editor Editor Child group containing Settings to personalize source code appearance, such as fonts, highlighting styles, indents, etc. It also contains Settings to customize the editor's appearance, such as line numbers, caret placement, tabs, source code inspections, setting up templates, and file encodings. language Languages and Frameworks Child group containing Settings related to specific language frameworks and technologies used in the project. tools 3rd Party Settings Child group containing Settings to configure integration with third-party applications, specify the SSH Terminal connection Settings, manage server certificates and tasks, configure diagrams layout, etc. root Super Parent The invisible parent of all existing groups. Not used except for IDEs built on top of the Consulo, or extensive suites of Settings. You should not place settings in this group. other Catch-all The Consulo no longer uses this group. Do not use this group. Use the tools group instead. project Project-related Settings The Consulo no longer uses this group. It was intended to store some project-related settings. Do not use this group.","title":"Values for Parent ID Attribute"},{"location":"reference_guide/settings_guide/#implementations-for-settings-extension-points","text":"Implementations for com.intellij.projectConfigurable and com.intellij.applicationConfigurable EPs can have one of two bases: * The Configurable interface, which provides a named configurable component with a Swing form. Most Settings providers are based on the Configurable interface or one of its sub- or supertypes. * The ConfigurableProvider class, which can hide a configurable component from the Settings dialog based on runtime conditions.","title":"Implementations for Settings Extension Points"},{"location":"reference_guide/settings_guide/#the-configurable-interface","text":"Many Settings in the intellij-community code base implement Configurable or one of its subtypes, such as SearchableConfigurable . Readers are encouraged to review the Javadoc comments for Configurable .","title":"The Configurable Interface"},{"location":"reference_guide/settings_guide/#constructors","text":"Implementations must meet several requirements for constructors. * Application Settings implementations, declared using the applicationConfiguration EP , must have a default constructor with no arguments. * Project Settings implementations, declared using the projectSettings EP , must declare a constructor with a single argument of type Project . * Beginning in 2020.2, constructor injection (other than for Project ) is not allowed. For a Configurable implementation correctly declared using an EP, the implementation's constructor is not invoked by the Consulo until a user chooses the corresponding Settings displayName in the Settings Dialog menu. WARNING The Consulo may instantiate a Configurable implementation on a background thread, so creating Swing components in a constructor can degrade UI responsiveness.","title":"Constructors"},{"location":"reference_guide/settings_guide/#consulo-interactions-with-configurable","text":"The instantiation of a generic Configurable implementation is documented in the interface file. A few high-level points are reviewed here: * The Configurable.reset() method is invoked immediately after Configurable.createComponent() . Initialization of Setting values in the constructor or createComponent() is unnecessary. * See the Constructors section for information about when a Settings object is instantiated. * Once instantiated, a Configurable instance's lifetime continues regardless of whether the implementation's Settings are changed, or the user chooses a different entry on the Settings Dialog menu. * A Configurable instance's lifetime ends when OK or Cancel is selected in the Settings Dialog. An instance's Configurable.disposeUIResources() is called when the Settings Dialog is closing. To open Settings dialog or show specific Configurable , see ShowSettingsUtil .","title":"Consulo Interactions with Configurable"},{"location":"reference_guide/settings_guide/#configurable-marker-interfaces","text":"Implementations based on Configurable can implement marker interfaces, which provide additional flexibility in the implementation. The following nested interfaces are markers, which convey information about the form to the Consulo: * Configurable.NoScroll - Notifies the Settings dialog not to add scroll bars to the form. By default, a plugin's Settings component is put into a scrollable pane. However, a Settings panel can have a JTree , which requires its own JScrollPane . So NoScroll interface should be used to remove the outer JScrollPane . * Configurable.NoMargin - Notifies the Settings dialog not to add an empty border to the form. By default, an empty border is added for a plugin's Settings component.","title":"Configurable Marker Interfaces"},{"location":"reference_guide/settings_guide/#additional-interfaces-based-on-configurable","text":"There are classes in the Consulo specialized for particular types of Settings. These subtypes are based on com.intellij.openapi.options.ConfigurableEP . For example, Settings/Preferences | Editor | General |Appearance allows adding Settings via EditorSmartKeysConfigurableEP and com.intellij.editorSmartKeysConfigurable EP.","title":"Additional Interfaces Based on Configurable"},{"location":"reference_guide/settings_guide/#the-configurableprovider-class","text":"The ConfigurableProvider class only provides a Configurable implementation if its runtime conditions are met. The Consulo first calls the ConfigurableProvider.canCreateConfigurable() , which evaluates runtime conditions to determine if Settings changes make sense in the current context. If the Settings make sense to display, canCreateConfigurable() returns true . In that case the Consulo calls ConfigurableProvider.createConfigurable() , which returns the Configurable object for its Settings implementation. By choosing not to provide a Configuration implementation in some circumstances, the ConfigurableProvider opts out of the Settings display and modification process. The use of ConfigurableProvider as a basis for a Settings implementation is declared using attributes in the EP declaration.","title":"The ConfigurableProvider Class"},{"location":"reference_guide/tomcat_integration/","text":"The source code of the Tomcat plugin included in IntelliJ IDEA Ultimate is available as a sample for implementing application server integration plugins. You can find the code under lib\\src\\src_tomcat.zip in the main IntelliJ IDEA Ultimate distribution.","title":"Tomcat Integration"},{"location":"reference_guide/vcs_integration_for_plugins/","text":"This page gives an overview of the Version Control Integration API. Key Concepts FilePath A FilePath represents a path to a file or directory on disk or in the VCS repository. Unlike a VirtualFile , a FilePath can represent a path to a file which doesn't exist on disk. The main difference between a FilePath and a java.io.File is that a FilePath caches the VirtualFile corresponding to the path, so it can be retrieved without doing a VFS search. To create instances of FilePath , the VcsContextFactory API is used. It can be accessed as PeerFactory.getInstance().getVcsContextFactory() FilePath representing paths in a VCS repository, rather than local paths, are created using VcsContextFactory.createFilePathOnNonLocal() . The FilePath.isNonLocal() method returns true for such files. Revision Number A VcsRevisionNumber represents a revision number of the file. If the VCS stores revision numbers as simple integers, the standard VcsRevisionNumber Int implementation can be used. If the VCS has a more complex format of revision numbers (like CVS, which uses a series of numbers delimited with dots), the plugin can provide a custom implementation. ContentRevision A ContentRevision represents a particular revision of a file, which exists either locally or in a VCS repository. It has three main attributes: FilePath specifying the file of which this is a revision. If some version of the file exists locally, this should be a local path. VcsRevisionNumber specifying the revision number of the revision, or VcsRevisionNumber.NULL if the revision exists only locally. Content of the revision. The content is returned as string, and the VCS plugin is responsible for converting the binary file content to correct encoding. To detect the encoding automatically based on the IDE settings and the byte order mark, the method CharsetToolkit.bytesToString() can be used (this API is new in IDEA 7.0.2). Revisions of binary files can also be represented as BinaryContentRevision, which is a subclass of ContentRevision. For binary revisions, the result of getContent() is undefined, and getBinaryContent() can be used to retrieve the contents as a byte array. A useful class which can be used to represent the current on-disk version of a particular file is CurrentContentRevision . FileStatus A FileStatus represents a status of a file in regard to VCS (unversioned, not changed, added, modified and so on). It determines the color used to render the name of the file in the UI. Change A Change represents a single file operation (creation, modification, move/rename or deletion) from a VCS point of view. A Change can represent either a modification which the user has performed locally and not yet committed, a committed modification, or some other type of modification (for example, a shelved change or a difference between two arbitrary revisions). A Change essentially consists of two content revisions: before revision ( null if the Change represents file creation) after revision ( null if the Change represents file deletion) A move or rename is represented by a Change where the before revision and the after revision have different file paths. A custom file status can be specified for a Change if it represents a non-standard modification of the file (for example, a file which has been merged with conflicts). If a custom file status has not been specified, the status is calculated automatically from the change type. ChangeList A ChangeList represents a named group of related changes. There are two main kinds of changelists: LocalChangeList represents a group of modifications done by a user locally. If the VCS also supports the concept of changelists (like Perforce does), the VCS plugin can synchronize IDEA's local changelist structure with that of the VCS. Otherwise, a local changelist is simply a subset of the files checked out or modified by the user. CommittedChangeList represents a set of modifications checked in to the VCS repository. For VCSes which support atomic commit, every committed revision is represented by a CommittedChangeList. For VCSes which use per-file commit (like CVS), the plugin can use heuristics to group a sequence of individual file commits into a CommittedChangeList NOTE The Unversioned Files , Locally Deleted Files , etc., nodes in the Changes view are not actually change lists, and files under those nodes are not represented by ChangeList objects. Plugin Components This section describes the different components which comprise a VCS integration plugin, roughly in the same order as they should be implemented. AbstractVcs This is the main entry point for a VCS plugin, which is used by the Consulo to retrieve all other services provided by the plugin. The recommended way to register an AbstractVcs implementation is to add an extension declaration to plugin.xml, as shown in the following example: <idea-plugin> ... <extensions defaultExtensionNs= \"com.intellij\" > <vcs name= \"svn\" vcsClass= \"org.jetbrains.idea.svn.SvnVcs\" /> </extensions> </idea-plugin> Here name is the unique name of the VCS (this must match the string returned by your implementation of AbstractVcs.getName() ), and vcsClass is your implementation class. ChangeProvider This component is responsible for tracking user changes to the working copy, and reporting these changes to the Consulo core. An implementation of this class is returned from AbstractVcs.getChangeProvider() . The ChangeProvider works in tandem with VcsDirtyScopeManager , which is a component in Consulo core. VcsDirtyScopeManager keeps track of the 'dirty scope' - the set of files for which the VCS file status may be out of date. Files are added to the dirty scope either when they are modified on disk, or when their VCS status is invalidated by an explicit call to VcsDirtyScopeManager.fileDirty() or VcsDirtyScopeManager.dirDirtyRecursively() . After some files have been added to the dirty scope, the dirty scope is passed to ChangeProvider.getChanges() , along with a ChangelistBuilder instance, which serves as a sink to which the ChangeProvider feeds the data about the changed files. This processing happens asynchronously in a background thread. The ChangeProvider can either iterate all files under the dirty scope using VcsDirtyScope.iterate() , or retrieve information about its contents using the getDirtyFiles() and getDirtyDirectoriesRecursively() methods. If it is possible to retrieve the information about the local changes from the VCS in batch, it's strongly preferable to use the second method, as it scales much better for large working copies. The ChangeProvider reports data to ChangelistBuilder using the following methods: processChange() is called for files which have been checked out (or modified if the VCS doesn't use an explicit checkout model), scheduled for addition or deletion, moved or renamed. processUnversionedFile() is called for files which exist on disk, but are not managed by the VCS, not scheduled for addition, and not ignored through .cvsignore or a similar mechanism. processLocallyDeletedFile() is called for files which exist in the VCS repository, but do not exist on disk and are not scheduled for deletion. processIgnoredFile() is called for files which are not managed by the VCS but are ignored through .cvsignore or a similar mechanism. processSwitchedFile() is called for files or directories for which the working copy corresponds to a different branch compared to the working copy of their parent directory. This can be called for the same files for which processSwitchedFile() has already been called.","title":"Overview"},{"location":"reference_guide/vcs_integration_for_plugins/#key-concepts","text":"","title":"Key Concepts"},{"location":"reference_guide/vcs_integration_for_plugins/#filepath","text":"A FilePath represents a path to a file or directory on disk or in the VCS repository. Unlike a VirtualFile , a FilePath can represent a path to a file which doesn't exist on disk. The main difference between a FilePath and a java.io.File is that a FilePath caches the VirtualFile corresponding to the path, so it can be retrieved without doing a VFS search. To create instances of FilePath , the VcsContextFactory API is used. It can be accessed as PeerFactory.getInstance().getVcsContextFactory() FilePath representing paths in a VCS repository, rather than local paths, are created using VcsContextFactory.createFilePathOnNonLocal() . The FilePath.isNonLocal() method returns true for such files.","title":"FilePath"},{"location":"reference_guide/vcs_integration_for_plugins/#revision-number","text":"A VcsRevisionNumber represents a revision number of the file. If the VCS stores revision numbers as simple integers, the standard VcsRevisionNumber Int implementation can be used. If the VCS has a more complex format of revision numbers (like CVS, which uses a series of numbers delimited with dots), the plugin can provide a custom implementation.","title":"Revision Number"},{"location":"reference_guide/vcs_integration_for_plugins/#contentrevision","text":"A ContentRevision represents a particular revision of a file, which exists either locally or in a VCS repository. It has three main attributes: FilePath specifying the file of which this is a revision. If some version of the file exists locally, this should be a local path. VcsRevisionNumber specifying the revision number of the revision, or VcsRevisionNumber.NULL if the revision exists only locally. Content of the revision. The content is returned as string, and the VCS plugin is responsible for converting the binary file content to correct encoding. To detect the encoding automatically based on the IDE settings and the byte order mark, the method CharsetToolkit.bytesToString() can be used (this API is new in IDEA 7.0.2). Revisions of binary files can also be represented as BinaryContentRevision, which is a subclass of ContentRevision. For binary revisions, the result of getContent() is undefined, and getBinaryContent() can be used to retrieve the contents as a byte array. A useful class which can be used to represent the current on-disk version of a particular file is CurrentContentRevision .","title":"ContentRevision"},{"location":"reference_guide/vcs_integration_for_plugins/#filestatus","text":"A FileStatus represents a status of a file in regard to VCS (unversioned, not changed, added, modified and so on). It determines the color used to render the name of the file in the UI.","title":"FileStatus"},{"location":"reference_guide/vcs_integration_for_plugins/#change","text":"A Change represents a single file operation (creation, modification, move/rename or deletion) from a VCS point of view. A Change can represent either a modification which the user has performed locally and not yet committed, a committed modification, or some other type of modification (for example, a shelved change or a difference between two arbitrary revisions). A Change essentially consists of two content revisions: before revision ( null if the Change represents file creation) after revision ( null if the Change represents file deletion) A move or rename is represented by a Change where the before revision and the after revision have different file paths. A custom file status can be specified for a Change if it represents a non-standard modification of the file (for example, a file which has been merged with conflicts). If a custom file status has not been specified, the status is calculated automatically from the change type.","title":"Change"},{"location":"reference_guide/vcs_integration_for_plugins/#changelist","text":"A ChangeList represents a named group of related changes. There are two main kinds of changelists: LocalChangeList represents a group of modifications done by a user locally. If the VCS also supports the concept of changelists (like Perforce does), the VCS plugin can synchronize IDEA's local changelist structure with that of the VCS. Otherwise, a local changelist is simply a subset of the files checked out or modified by the user. CommittedChangeList represents a set of modifications checked in to the VCS repository. For VCSes which support atomic commit, every committed revision is represented by a CommittedChangeList. For VCSes which use per-file commit (like CVS), the plugin can use heuristics to group a sequence of individual file commits into a CommittedChangeList NOTE The Unversioned Files , Locally Deleted Files , etc., nodes in the Changes view are not actually change lists, and files under those nodes are not represented by ChangeList objects.","title":"ChangeList"},{"location":"reference_guide/vcs_integration_for_plugins/#plugin-components","text":"This section describes the different components which comprise a VCS integration plugin, roughly in the same order as they should be implemented.","title":"Plugin Components"},{"location":"reference_guide/vcs_integration_for_plugins/#abstractvcs","text":"This is the main entry point for a VCS plugin, which is used by the Consulo to retrieve all other services provided by the plugin. The recommended way to register an AbstractVcs implementation is to add an extension declaration to plugin.xml, as shown in the following example: <idea-plugin> ... <extensions defaultExtensionNs= \"com.intellij\" > <vcs name= \"svn\" vcsClass= \"org.jetbrains.idea.svn.SvnVcs\" /> </extensions> </idea-plugin> Here name is the unique name of the VCS (this must match the string returned by your implementation of AbstractVcs.getName() ), and vcsClass is your implementation class.","title":"AbstractVcs"},{"location":"reference_guide/vcs_integration_for_plugins/#changeprovider","text":"This component is responsible for tracking user changes to the working copy, and reporting these changes to the Consulo core. An implementation of this class is returned from AbstractVcs.getChangeProvider() . The ChangeProvider works in tandem with VcsDirtyScopeManager , which is a component in Consulo core. VcsDirtyScopeManager keeps track of the 'dirty scope' - the set of files for which the VCS file status may be out of date. Files are added to the dirty scope either when they are modified on disk, or when their VCS status is invalidated by an explicit call to VcsDirtyScopeManager.fileDirty() or VcsDirtyScopeManager.dirDirtyRecursively() . After some files have been added to the dirty scope, the dirty scope is passed to ChangeProvider.getChanges() , along with a ChangelistBuilder instance, which serves as a sink to which the ChangeProvider feeds the data about the changed files. This processing happens asynchronously in a background thread. The ChangeProvider can either iterate all files under the dirty scope using VcsDirtyScope.iterate() , or retrieve information about its contents using the getDirtyFiles() and getDirtyDirectoriesRecursively() methods. If it is possible to retrieve the information about the local changes from the VCS in batch, it's strongly preferable to use the second method, as it scales much better for large working copies. The ChangeProvider reports data to ChangelistBuilder using the following methods: processChange() is called for files which have been checked out (or modified if the VCS doesn't use an explicit checkout model), scheduled for addition or deletion, moved or renamed. processUnversionedFile() is called for files which exist on disk, but are not managed by the VCS, not scheduled for addition, and not ignored through .cvsignore or a similar mechanism. processLocallyDeletedFile() is called for files which exist in the VCS repository, but do not exist on disk and are not scheduled for deletion. processIgnoredFile() is called for files which are not managed by the VCS but are ignored through .cvsignore or a similar mechanism. processSwitchedFile() is called for files or directories for which the working copy corresponds to a different branch compared to the working copy of their parent directory. This can be called for the same files for which processSwitchedFile() has already been called.","title":"ChangeProvider"},{"location":"reference_guide/work_with_icons_and_images/","text":"Icons and images are used widely by Consulo plugins. Plugins need icons mostly for actions, custom components renderers, tool windows, and so on. NOTE Plugin Icons, which represent a plugin itself, have different requirements than icons and images used within a plugin. For more information see the Plugin Icon page. TIP Plugins should reuse existing platform icons whenever possible, see Icons list and AllIcons . A detailed design guideline is available for creating custom icons. How to organize and how to use icons? The best way to deal with icons and other image resources is to put them to a dedicated source root marked as Resources Root , say icons or resources . The getIcon() method of IconLoader can be used to access the icons. NOTE The path to the icon passed in as argument to IconLoader.getIcon() must start with leading / Then define a class/interface in a top-level package called icons holding icon constants as static fields: package icons ; public interface DemoPluginIcons { Icon DemoAction = IconLoader . getIcon ( \"/icons/demoAction.png\" , DemoPluginIcons . class ); Icon StructureToolWindow = IconLoader . getIcon ( \"/icons/toolWindowStructure.png\" , DemoPluginIcons . class ); Icon FileType = IconLoader . getIcon ( \"/icons/myLangFileType.png\" , DemoPluginIcons . class ); } When using Kotlin, fields must be annotated with @JvmField : package icons object DemoPluginIcons { @JvmField val DemoAction = IconLoader . getIcon ( \"/icons/demoAction.png\" , javaClass ) // ... } Use these constants inside plugin.xml as well when specifying icon attribute for <action> or extension points. Note that the package name icons will be automatically prefixed and must not be added manually. <actions> <action id= \"DemoPlugin.DemoAction\" icon= \"DemoPluginIcons.DemoAction\" [...] /> </actions> <extensions defaultExtensionNs= \"com.intellij\" > <toolWindow id= \"CustomStructure\" icon= \"DemoPluginIcons.StructureToolWindow\" [...] /> </extensions> Image Formats Consulo supports Retina displays and has dark theme called Darcula. Thus, every icon should have a dedicated variant for Retina devices and Darcula theme. In some cases, you can skip dark variants if the original icon looks good under Darcula. Required icon sizes depend on the usage as listed in the following table: Usage Icon Size (pixels) Node, Action, Filetype 16x16 Tool window 13x13 Editor gutter 12x12 SVG Format NOTE SVG icons are supported since 2018.2. As SVG icons can be scaled arbitrarily, they provide better results on HiDPI environments or when used in combination with bigger screen fonts (e.g., in presentation mode). A base size denoting the size (in the user space) of the rendered image in 1x scale should be provided. The size is set via the width and height attributes omitting the size units. If unspecified, it defaults to 16x16 pixels. A minimal SVG icon file: <svg xmlns= \"http://www.w3.org/2000/svg\" width= \"16\" height= \"16\" > <rect width= \"100%\" height= \"100%\" fill= \"green\" /> </svg> The naming notation used for PNG icons (see below) is still relevant. However, the @2x version of an SVG icon should still provide the same base size. The icon graphics of such an icon can be expressed in more details via double precision. If the icon graphics are simple enough so that it renders perfectly in every scale, then the @2x version can be omitted. PNG Format NOTE Please consider using SVG icons if your plugin targets 2018.2+. All icon files must be placed in the same directory following this naming pattern (replace .png with .svg for SVG icons): iconName.png W x H pixels (Will be used on non-Retina devices with default theme) iconName@2x.png 2*W x 2*H pixels (Will be used on Retina devices with default theme) iconName_dark.png W x H pixels (Will be used on non-Retina devices with Darcula theme) iconName@2x_dark.png 2*W x 2*H pixels (Will be used on Retina devices with Darcula theme) The IconLoader class will load the icon that matches the best depending on the current environment. Here are examples of toolWindowStructure.png icon representations: Theme/Resolution File name Image Default toolWindowStructure.png Darcula toolWindowStructure_dark.png Default + Retina toolWindowStructure@2x.png Darcula + Retina toolWindowStructure@2x_dark.png","title":"Icons and Images"},{"location":"reference_guide/work_with_icons_and_images/#how-to-organize-and-how-to-use-icons","text":"The best way to deal with icons and other image resources is to put them to a dedicated source root marked as Resources Root , say icons or resources . The getIcon() method of IconLoader can be used to access the icons. NOTE The path to the icon passed in as argument to IconLoader.getIcon() must start with leading / Then define a class/interface in a top-level package called icons holding icon constants as static fields: package icons ; public interface DemoPluginIcons { Icon DemoAction = IconLoader . getIcon ( \"/icons/demoAction.png\" , DemoPluginIcons . class ); Icon StructureToolWindow = IconLoader . getIcon ( \"/icons/toolWindowStructure.png\" , DemoPluginIcons . class ); Icon FileType = IconLoader . getIcon ( \"/icons/myLangFileType.png\" , DemoPluginIcons . class ); } When using Kotlin, fields must be annotated with @JvmField : package icons object DemoPluginIcons { @JvmField val DemoAction = IconLoader . getIcon ( \"/icons/demoAction.png\" , javaClass ) // ... } Use these constants inside plugin.xml as well when specifying icon attribute for <action> or extension points. Note that the package name icons will be automatically prefixed and must not be added manually. <actions> <action id= \"DemoPlugin.DemoAction\" icon= \"DemoPluginIcons.DemoAction\" [...] /> </actions> <extensions defaultExtensionNs= \"com.intellij\" > <toolWindow id= \"CustomStructure\" icon= \"DemoPluginIcons.StructureToolWindow\" [...] /> </extensions>","title":"How to organize and how to use icons?"},{"location":"reference_guide/work_with_icons_and_images/#image-formats","text":"Consulo supports Retina displays and has dark theme called Darcula. Thus, every icon should have a dedicated variant for Retina devices and Darcula theme. In some cases, you can skip dark variants if the original icon looks good under Darcula. Required icon sizes depend on the usage as listed in the following table: Usage Icon Size (pixels) Node, Action, Filetype 16x16 Tool window 13x13 Editor gutter 12x12","title":"Image Formats"},{"location":"reference_guide/work_with_icons_and_images/#svg-format","text":"NOTE SVG icons are supported since 2018.2. As SVG icons can be scaled arbitrarily, they provide better results on HiDPI environments or when used in combination with bigger screen fonts (e.g., in presentation mode). A base size denoting the size (in the user space) of the rendered image in 1x scale should be provided. The size is set via the width and height attributes omitting the size units. If unspecified, it defaults to 16x16 pixels. A minimal SVG icon file: <svg xmlns= \"http://www.w3.org/2000/svg\" width= \"16\" height= \"16\" > <rect width= \"100%\" height= \"100%\" fill= \"green\" /> </svg> The naming notation used for PNG icons (see below) is still relevant. However, the @2x version of an SVG icon should still provide the same base size. The icon graphics of such an icon can be expressed in more details via double precision. If the icon graphics are simple enough so that it renders perfectly in every scale, then the @2x version can be omitted.","title":"SVG Format"},{"location":"reference_guide/work_with_icons_and_images/#png-format","text":"NOTE Please consider using SVG icons if your plugin targets 2018.2+. All icon files must be placed in the same directory following this naming pattern (replace .png with .svg for SVG icons): iconName.png W x H pixels (Will be used on non-Retina devices with default theme) iconName@2x.png 2*W x 2*H pixels (Will be used on Retina devices with default theme) iconName_dark.png W x H pixels (Will be used on non-Retina devices with Darcula theme) iconName@2x_dark.png 2*W x 2*H pixels (Will be used on Retina devices with Darcula theme) The IconLoader class will load the icon that matches the best depending on the current environment. Here are examples of toolWindowStructure.png icon representations: Theme/Resolution File name Image Default toolWindowStructure.png Darcula toolWindowStructure_dark.png Default + Retina toolWindowStructure@2x.png Darcula + Retina toolWindowStructure@2x_dark.png","title":"PNG Format"},{"location":"reference_guide/custom_language_support/additional_minor_features/","text":"A number of minor features are listed in the following format: EP: fully.qualified.extensionPointName - Extension Point Name (must be specified in plugin.xml ) com.extensionPoint.class description text - Extension Point class/interface to provide functionality - Sample 1 - Sample implementation Brace Matching EP: com.intellij.lang.braceMatcher PairedBraceMatcher Returns an array of brace pairs ( BracePair ) specifying the characters for the opening and closing braces and the lexer token types for these characters. (In principle, it is possible to return multi-character tokens, like \"begin\" and \"end\", as the start and end tokens of a brace pair. The IDE will match such braces, but the highlighting for such braces will not be entirely correct.) Certain types of braces can be marked as structural. Structural braces have higher priority than regular braces: they are matched with each other even if there are unmatched braces of different types between them. An opening non-structural brace is not matched with a closing one if one of them is inside a pair of matched structural braces and another is outside. Comment Code EP: com.intellij.lang.commenter Commenter returns the prefix for the line comment, and the prefix and suffix for the block comment if supported by the language. Commenter for Properties language plugin Custom Language Support Tutorial: Commenter Code Folding EP: com.intellij.lang.foldingBuilder FoldingBuilder returns the list of foldable text ranges (as an array of FoldingDescriptor objects), the replacement text which is shown for each range when it is folded, and the default state of each folding region (folded or unfolded). Custom Language Support Tutorial: Folding Builder Join Lines EP: com.intellij.joinLinesHandler JoinLinesHandlerDelegate allows extending support smart/semantic Edit | Join Lines (e.g., String literal split on multiple lines). Smart Enter EP: com.intellij.lang.smartEnterProcessor SmartEnterProcessor handles Edit | Complete Statement (e.g., autocomplete missing semicolon/parentheses). Naming Suggestions EP: com.intellij.nameSuggestionProvider NameSuggestionProvider provides name suggestions for the given element, e.g., for Rename refactoring. Semantic Highlight Usages EP: com.intellij.highlightUsagesHandlerFactory HighlightUsagesHandlerFactory allows highlighting e.g., Exit Points or Exceptions. Parameter Info EP: com.intellij.codeInsight.parameterInfo ParameterInfoHandler provides support for View | Parameter Info . To Do View EP: n/a ParserDefinition.getCommentTokens() must return the set of tokens treated as comments to populate To Do View . Context Info EP: com.intellij.declarationRangeHandler DeclarationRangeHandler provides View | Context Info for custom languages with structure view implementation based on a TreeBasedStructureViewBuilder . Spellchecking EP: com.intellij.spellchecker.support SpellcheckingStrategy provides Tokenizer to use for given PsiElement (return EMPTY_TOKENIZER for no spellchecking). Reference Injection EP: com.intellij.referenceInjector ReferenceInjector allows users to inject pre-defined references (e.g., \"Encoding\", \"File Reference\") into PsiLanguageInjectionHost elements (IntelliLang plugin required). Color Preview/Chooser EP: com.intellij.colorProvider ElementColorProvider renders gutter icon for element containing color information.","title":"Additional Minor Features"},{"location":"reference_guide/custom_language_support/additional_minor_features/#brace-matching","text":"EP: com.intellij.lang.braceMatcher PairedBraceMatcher Returns an array of brace pairs ( BracePair ) specifying the characters for the opening and closing braces and the lexer token types for these characters. (In principle, it is possible to return multi-character tokens, like \"begin\" and \"end\", as the start and end tokens of a brace pair. The IDE will match such braces, but the highlighting for such braces will not be entirely correct.) Certain types of braces can be marked as structural. Structural braces have higher priority than regular braces: they are matched with each other even if there are unmatched braces of different types between them. An opening non-structural brace is not matched with a closing one if one of them is inside a pair of matched structural braces and another is outside.","title":"Brace Matching"},{"location":"reference_guide/custom_language_support/additional_minor_features/#comment-code","text":"EP: com.intellij.lang.commenter Commenter returns the prefix for the line comment, and the prefix and suffix for the block comment if supported by the language. Commenter for Properties language plugin Custom Language Support Tutorial: Commenter","title":"Comment Code"},{"location":"reference_guide/custom_language_support/additional_minor_features/#code-folding","text":"EP: com.intellij.lang.foldingBuilder FoldingBuilder returns the list of foldable text ranges (as an array of FoldingDescriptor objects), the replacement text which is shown for each range when it is folded, and the default state of each folding region (folded or unfolded). Custom Language Support Tutorial: Folding Builder","title":"Code Folding"},{"location":"reference_guide/custom_language_support/additional_minor_features/#join-lines","text":"EP: com.intellij.joinLinesHandler JoinLinesHandlerDelegate allows extending support smart/semantic Edit | Join Lines (e.g., String literal split on multiple lines).","title":"Join Lines"},{"location":"reference_guide/custom_language_support/additional_minor_features/#smart-enter","text":"EP: com.intellij.lang.smartEnterProcessor SmartEnterProcessor handles Edit | Complete Statement (e.g., autocomplete missing semicolon/parentheses).","title":"Smart Enter"},{"location":"reference_guide/custom_language_support/additional_minor_features/#naming-suggestions","text":"EP: com.intellij.nameSuggestionProvider NameSuggestionProvider provides name suggestions for the given element, e.g., for Rename refactoring.","title":"Naming Suggestions"},{"location":"reference_guide/custom_language_support/additional_minor_features/#semantic-highlight-usages","text":"EP: com.intellij.highlightUsagesHandlerFactory HighlightUsagesHandlerFactory allows highlighting e.g., Exit Points or Exceptions.","title":"Semantic Highlight Usages"},{"location":"reference_guide/custom_language_support/additional_minor_features/#parameter-info","text":"EP: com.intellij.codeInsight.parameterInfo ParameterInfoHandler provides support for View | Parameter Info .","title":"Parameter Info"},{"location":"reference_guide/custom_language_support/additional_minor_features/#to-do-view","text":"EP: n/a ParserDefinition.getCommentTokens() must return the set of tokens treated as comments to populate To Do View .","title":"To Do View"},{"location":"reference_guide/custom_language_support/additional_minor_features/#context-info","text":"EP: com.intellij.declarationRangeHandler DeclarationRangeHandler provides View | Context Info for custom languages with structure view implementation based on a TreeBasedStructureViewBuilder .","title":"Context Info"},{"location":"reference_guide/custom_language_support/additional_minor_features/#spellchecking","text":"EP: com.intellij.spellchecker.support SpellcheckingStrategy provides Tokenizer to use for given PsiElement (return EMPTY_TOKENIZER for no spellchecking).","title":"Spellchecking"},{"location":"reference_guide/custom_language_support/additional_minor_features/#reference-injection","text":"EP: com.intellij.referenceInjector ReferenceInjector allows users to inject pre-defined references (e.g., \"Encoding\", \"File Reference\") into PsiLanguageInjectionHost elements (IntelliLang plugin required).","title":"Reference Injection"},{"location":"reference_guide/custom_language_support/additional_minor_features/#color-previewchooser","text":"EP: com.intellij.colorProvider ElementColorProvider renders gutter icon for element containing color information.","title":"Color Preview/Chooser"},{"location":"reference_guide/custom_language_support/code_completion/","text":"Two main types of code completion can be provided by custom language plugins: reference completion and contributor-based completion. Reference completion is easier to implement, but supports only the basic completion action. Contributor-based completion provides more features, supports all three completion types (basic, smart, and class name), and can be used, for example, to implement keyword completion. Reference Completion To fill the completion list, the IDE calls PsiReference.getVariants() either on the reference at the caret location or on a dummy reference that would be placed at the caret. This method needs to return an array of objects containing either strings, PsiElement instances or instances of the LookupElement class (see Lookup Items below). If a PsiElement instance is returned in the array, the completion list shows the icon for the element. The most common way to implement getVariants() is to use the same function for walking up the tree as in PsiReference.resolve() , and a different implementation of PsiScopeProcessor which collects all declarations passed to its processDeclarations() method and returns them as an array for filling the completion list. Symbol Reference Completion WARNING This API is available starting from 2020.3 and currently in development and thus in experimental state. To provide completion variants by a PsiSymbolReference implement PsiCompletableReference . Contributor-Based Completion Implementing the CompletionContributor interface gives you the greatest control over the operation of code completion for your language. NOTE Note that the JavaDoc of that class contains a detailed FAQ for implementing code completion. The core scenario of using CompletionContributor consists of calling the extend() method and passing in the pattern specifying the context in which this completion variant is applicable, as well as a completion provider which generates the items to show in the completion list. Keep in mind that the pattern is checked against the leaf PSI element. If you want to match a composite element, use withParent() or withSuperParent() methods. Examples : - CompletionContributor for completing keywords in MANIFEST.MF files. - Custom Language Support Tutorial: Completion Contributor Lookup Items Items shown in the completion list are represented by instances of the LookupElement interface. These instances are typically created through the LookupElementBuilder class. For every lookup element, you can specify the following attributes: Text. Shown left-aligned. Tail text. Shown next to the main item text, is not used for prefix matching, and can be used, for example, to show the parameter list of the method. Type text. Shown right-aligned in the lookup list and can be used to show the return type or containing class of a method, for example. Icon Text attributes. Bold, Strikeout, etc. Insert handler. The insert handler is a callback which is called when the item is selected and can be used to perform additional modifications of the text (for example, to put in the parentheses for a method call)","title":"Code Completion"},{"location":"reference_guide/custom_language_support/code_completion/#reference-completion","text":"To fill the completion list, the IDE calls PsiReference.getVariants() either on the reference at the caret location or on a dummy reference that would be placed at the caret. This method needs to return an array of objects containing either strings, PsiElement instances or instances of the LookupElement class (see Lookup Items below). If a PsiElement instance is returned in the array, the completion list shows the icon for the element. The most common way to implement getVariants() is to use the same function for walking up the tree as in PsiReference.resolve() , and a different implementation of PsiScopeProcessor which collects all declarations passed to its processDeclarations() method and returns them as an array for filling the completion list.","title":"Reference Completion"},{"location":"reference_guide/custom_language_support/code_completion/#symbol-reference-completion","text":"WARNING This API is available starting from 2020.3 and currently in development and thus in experimental state. To provide completion variants by a PsiSymbolReference implement PsiCompletableReference .","title":"Symbol Reference Completion"},{"location":"reference_guide/custom_language_support/code_completion/#contributor-based-completion","text":"Implementing the CompletionContributor interface gives you the greatest control over the operation of code completion for your language. NOTE Note that the JavaDoc of that class contains a detailed FAQ for implementing code completion. The core scenario of using CompletionContributor consists of calling the extend() method and passing in the pattern specifying the context in which this completion variant is applicable, as well as a completion provider which generates the items to show in the completion list. Keep in mind that the pattern is checked against the leaf PSI element. If you want to match a composite element, use withParent() or withSuperParent() methods. Examples : - CompletionContributor for completing keywords in MANIFEST.MF files. - Custom Language Support Tutorial: Completion Contributor","title":"Contributor-Based Completion"},{"location":"reference_guide/custom_language_support/code_completion/#lookup-items","text":"Items shown in the completion list are represented by instances of the LookupElement interface. These instances are typically created through the LookupElementBuilder class. For every lookup element, you can specify the following attributes: Text. Shown left-aligned. Tail text. Shown next to the main item text, is not used for prefix matching, and can be used, for example, to show the parameter list of the method. Type text. Shown right-aligned in the lookup list and can be used to show the return type or containing class of a method, for example. Icon Text attributes. Bold, Strikeout, etc. Insert handler. The insert handler is a callback which is called when the item is selected and can be used to perform additional modifications of the text (for example, to put in the parentheses for a method call)","title":"Lookup Items"},{"location":"reference_guide/custom_language_support/code_formatting/","text":"The Consulo includes a powerful framework for implementing custom language formatters. In this framework, the plugin specifies the constraints on the spacing between different syntax elements. The formatting engine, provided by the IDE, calculates the smallest number of whitespace modifications that need to be performed on the file to make it match the constraints. The process of formatting a file or a file fragment consists of the following main steps: The formatting model builder ( FormattingModelBuilder ), implemented by the plugin, provides a formatting model ( FormattingModel ) for the document to be formatted The formatting model is requested to build the structure of the file as applies to formatting, as a tree of blocks ( Block ) with an associated indent, wrap, alignment, and spacing settings. The formatting engine calculates the sequence of whitespace characters (spaces, tabs, and/or line breaks) that needs to be placed at every block boundary, based on the plugin's formatting model. The formatting model is requested to insert the calculated whitespace characters at necessary positions in the file. The structure of blocks is usually built so that it mirrors the PSI structure of the file - for example, in Java code, the top-level formatting block covers the entire file. Its children cover individual classes in the file, blocks on the next level cover methods inside classes, etc. The formatter modifies only the characters between blocks, and the tree of blocks must be built so that the bottom-level blocks cover all non-whitespace characters in the file. Otherwise, the characters between blocks may be deleted by the formatter. If the formatting operation does not affect the entire file (for example, if the formatter is called to format the pasted block of text), a complete tree of blocks is not built. Rather, only blocks for the text range covered by the formatting operation and their parents are built. For every block, the plugin specifies the following properties: The spacing ( Spacing ) specifies what spaces or line breaks are inserted between the specified children of the block. The spacing object specifies the minimum and maximum number of spaces that must be placed between the specified child blocks, the minimum number of line breaks to put there, and whether the existing line breaks and blank lines should be preserved. The formatting model can also specify that the spacing between the specified blocks may not be modified by the formatter. The indent specifies how the block is indented relative to its parent block. There are different modes of indenting defined by factory methods in the Indent class. The most commonly used are the none indent (which means the child block is not indented), the regular indent (the child block is indented by the number of spaces specified in the Project Code Style | General | Indent setting), and the continuation indent (based on Project Code Style | General | Continuation Indent setting). If the formatting model does not specify an indent, the \"continuation without first\" mode is used. This default means that the first block in a sequence of blocks with that type is not indented, and the following blocks are indented with a continuation indent. The wrap ( Wrap ) specifies whether the content of the block is wrapped to the next line. Wrapping is performed by inserting a line break before the block content. The plugin can specify that a particular block is never wrapped, always wrapped, or wrapped only if it exceeds the right margin. The alignment ( Alignment ) specifies which blocks should be aligned with each other. If two blocks with the alignment property set to the same object instance are placed in different lines, and if the second block is the first non-whitespace block in its line, the formatter inserts white spaces before the second block, so that it starts from the same column as the first one. For each of these properties, several particular use settings exist, described in the JavaDoc comments for the respective classes. See also SpacingBuilder , which aids in building rule-based configuration. An important special case in using the formatter is the smart indent performed when the user presses the Enter key in a source code file. To determine the indent for the new line, the formatter engine calls the method getChildAttributes() on either the block immediately before the caret or the parent of that block, depending on the return value of the isIncomplete() method for the block before the caret. If the block before the cursor is incomplete (contains elements that the user will probably type but has not yet typed, like a closing parenthesis of the parameter list or the trailing semicolon of a statement), getChildAttributes() is called on the block before the caret; otherwise, it's called on the parent block. New in IntelliJ IDEA 13 : Code formatting can be suppressed per region via special comments . Example : Custom Language Support Tutorial: Formatter Code Style Settings To specify the default indent size for the language provided by your plugin, and to allow the user to configure the tab size and indent size, you need to implement the FileTypeIndentOptionsProvider interface and to register the implementation in the com.intellij.fileTypeIndentOptionsProvider extension point. The return value of createIndentOptions() determines the default indent size. Example : Custom Language Support Tutorial: Code Style Settings Rearranger New in IntelliJ IDEA 12: Allows custom languages to provide user-configurable arrangement/grouping rules for element types supported by language plugin. Rules can be refined via modifiers and name, ordering can be applied additionally. Please see Rearranger and related for JavaDoc.","title":"Code Formatter"},{"location":"reference_guide/custom_language_support/code_formatting/#code-style-settings","text":"To specify the default indent size for the language provided by your plugin, and to allow the user to configure the tab size and indent size, you need to implement the FileTypeIndentOptionsProvider interface and to register the implementation in the com.intellij.fileTypeIndentOptionsProvider extension point. The return value of createIndentOptions() determines the default indent size. Example : Custom Language Support Tutorial: Code Style Settings","title":"Code Style Settings"},{"location":"reference_guide/custom_language_support/code_formatting/#rearranger","text":"New in IntelliJ IDEA 12: Allows custom languages to provide user-configurable arrangement/grouping rules for element types supported by language plugin. Rules can be refined via modifiers and name, ordering can be applied additionally. Please see Rearranger and related for JavaDoc.","title":"Rearranger"},{"location":"reference_guide/custom_language_support/code_inspections_and_intentions/","text":"Inspections The code inspections for custom languages use the same API as all other code inspections, based on the LocalInspectionTool class. The functionality of LocalInspectionTool partially duplicates that of Annotator . The main differences are: - supports batch analysis of code (through the Analyze | Inspect Code... action) - the possibility to turn off the inspection (globally or by suppressing them on various levels) - ability to configure the inspection options. If none of that is required and the analysis only needs to run in the active editor, Annotator provides better performance (because it supports incremental analysis) and more flexibility for highlighting errors. Examples : - Code Inspections Tutorial - A simple inspection for Properties language plugin Intentions The code intentions for custom languages also use the standard API for intentions. The intention classes need to implement the IntentionAction interface and are registered using the com.intellij.intentionAction extension point. Examples: - Code Intentions Tutorial - A simple intention action for Groovy - Custom Language Support Tutorial: Quick Fix","title":"Code Inspections and Intentions"},{"location":"reference_guide/custom_language_support/code_inspections_and_intentions/#inspections","text":"The code inspections for custom languages use the same API as all other code inspections, based on the LocalInspectionTool class. The functionality of LocalInspectionTool partially duplicates that of Annotator . The main differences are: - supports batch analysis of code (through the Analyze | Inspect Code... action) - the possibility to turn off the inspection (globally or by suppressing them on various levels) - ability to configure the inspection options. If none of that is required and the analysis only needs to run in the active editor, Annotator provides better performance (because it supports incremental analysis) and more flexibility for highlighting errors. Examples : - Code Inspections Tutorial - A simple inspection for Properties language plugin","title":"Inspections"},{"location":"reference_guide/custom_language_support/code_inspections_and_intentions/#intentions","text":"The code intentions for custom languages also use the standard API for intentions. The intention classes need to implement the IntentionAction interface and are registered using the com.intellij.intentionAction extension point. Examples: - Code Intentions Tutorial - A simple intention action for Groovy - Custom Language Support Tutorial: Quick Fix","title":"Intentions"},{"location":"reference_guide/custom_language_support/declarations_and_references/","text":"WARNING This API is available starting from 2020.3 and currently in development and thus in experimental state. Declarations Each symbol may be declared in zero or more places, for example: - a C# partial class is a symbol with several declarations; - a property key is a symbol possibly declared in several files simultaneously; - a Java local variable is a symbol with a single declaration; - and a file is a symbol without declarations; it has only references. Declarations are implementations of SymbolDeclaration . Declarations in PSI elements are implementations of PsiSymbolDeclaration . To report a declaration in a PSI element, either: - implement and register PsiSymbolDeclarationProvider ; - or implement PsiSymbolDeclaration directly in the PsiElement . References References are implementations of SymbolReference interface. References from PSI elements are implementations of PsiSymbolReference interface. The main method of SymbolReference is resolveReference() , which returns the collection of symbols to which the reference points, plus additional data. If it is not possible to resolve the reference, for example, if it points to an undefined class, an empty collection gets returned. A counterpart to the resolveReference() method is SymbolReference.resolvesTo() , which checks if the reference resolves to the specified symbol. This method can be implemented to walk the tree only if the element's text is equal to the reference's text. For convenience, if the reference can possibly be resolved: - with a single result, then it might be extended from SingleResultReference ; - to a single symbol without additional data, then it might be extended from SingleTargetReference ; - to multiple symbols without additional data, then SymbolResolveResult.fromSymbol() might be used. Own References Own references are the references found in PSI elements, which are considered as references by the language. Example: PSI element representing x in x * 2 Java expression has an Own reference to a local Java variable, e.g., var x = 42 , because this is a reference from Java language point of view, and Java language support uses it, e.g., for code analysis. To provide Own references by the PsiElement , implement PsiElement.getOwnReferences() in the PsiElement . If the element contains a single reference, Collections.singletonList() can be used External References External references are the references which are not considered as references by the host language. The language support should not rely on their existence/absence, because they might be contributed by other plugins. Example: PSI element representing \"users.txt\" in new File(\"users.txt\") Java expression is a string literal from Java language point of view, but there is a plugin which knows that this literal references a file name, and provides such reference. External references might be contributed to PSI elements that implement PsiExternalReferenceHost . To allow other plugins to contribute references of PsiElement , implement PsiExternalReferenceHost in the PsiElement . To contribute an External reference to the existing PsiExternalReferenceHost , implement and register PsiSymbolReferenceProvider . Implicit References Implicit references are the references which should be part of the mechanism to obtain a target by a reference, without the inverse ability to search or rename such references by a target. Example: var keyword in var x = new Person() Java declaration has an Implicit reference, because it doesn't make sense to obtain the reference by the target class. At the same time it's possible: - to navigate to the class by ctrl-clicking var ; - to start a refactoring (e.g., rename) from the class targeted by this reference; - to view documentation of the class targeted by this reference. To provide an Implicit reference, implement and register ImplicitReferenceProvider .","title":"Declarations and References"},{"location":"reference_guide/custom_language_support/declarations_and_references/#declarations","text":"Each symbol may be declared in zero or more places, for example: - a C# partial class is a symbol with several declarations; - a property key is a symbol possibly declared in several files simultaneously; - a Java local variable is a symbol with a single declaration; - and a file is a symbol without declarations; it has only references. Declarations are implementations of SymbolDeclaration . Declarations in PSI elements are implementations of PsiSymbolDeclaration . To report a declaration in a PSI element, either: - implement and register PsiSymbolDeclarationProvider ; - or implement PsiSymbolDeclaration directly in the PsiElement .","title":"Declarations"},{"location":"reference_guide/custom_language_support/declarations_and_references/#references","text":"References are implementations of SymbolReference interface. References from PSI elements are implementations of PsiSymbolReference interface. The main method of SymbolReference is resolveReference() , which returns the collection of symbols to which the reference points, plus additional data. If it is not possible to resolve the reference, for example, if it points to an undefined class, an empty collection gets returned. A counterpart to the resolveReference() method is SymbolReference.resolvesTo() , which checks if the reference resolves to the specified symbol. This method can be implemented to walk the tree only if the element's text is equal to the reference's text. For convenience, if the reference can possibly be resolved: - with a single result, then it might be extended from SingleResultReference ; - to a single symbol without additional data, then it might be extended from SingleTargetReference ; - to multiple symbols without additional data, then SymbolResolveResult.fromSymbol() might be used.","title":"References"},{"location":"reference_guide/custom_language_support/declarations_and_references/#own-references","text":"Own references are the references found in PSI elements, which are considered as references by the language. Example: PSI element representing x in x * 2 Java expression has an Own reference to a local Java variable, e.g., var x = 42 , because this is a reference from Java language point of view, and Java language support uses it, e.g., for code analysis. To provide Own references by the PsiElement , implement PsiElement.getOwnReferences() in the PsiElement . If the element contains a single reference, Collections.singletonList() can be used","title":"Own References"},{"location":"reference_guide/custom_language_support/declarations_and_references/#external-references","text":"External references are the references which are not considered as references by the host language. The language support should not rely on their existence/absence, because they might be contributed by other plugins. Example: PSI element representing \"users.txt\" in new File(\"users.txt\") Java expression is a string literal from Java language point of view, but there is a plugin which knows that this literal references a file name, and provides such reference. External references might be contributed to PSI elements that implement PsiExternalReferenceHost . To allow other plugins to contribute references of PsiElement , implement PsiExternalReferenceHost in the PsiElement . To contribute an External reference to the existing PsiExternalReferenceHost , implement and register PsiSymbolReferenceProvider .","title":"External References"},{"location":"reference_guide/custom_language_support/declarations_and_references/#implicit-references","text":"Implicit references are the references which should be part of the mechanism to obtain a target by a reference, without the inverse ability to search or rename such references by a target. Example: var keyword in var x = new Person() Java declaration has an Implicit reference, because it doesn't make sense to obtain the reference by the target class. At the same time it's possible: - to navigate to the class by ctrl-clicking var ; - to start a refactoring (e.g., rename) from the class targeted by this reference; - to view documentation of the class targeted by this reference. To provide an Implicit reference, implement and register ImplicitReferenceProvider .","title":"Implicit References"},{"location":"reference_guide/custom_language_support/documentation/","text":"To provide different kinds of documentation support, the plugin needs to provide an implementation of the DocumentationProvider interface and register it in the com.intellij.lang.documentationProvider extension point. A standard base class for such implementations is available in AbstractDocumentationProvider . The getQuickNavigateInfo() method returns the text to be displayed when the user holds the mouse over an element with Ctrl pressed. When generating complete documentation via generateDoc() , use DocumentationMarkup to layout contents (see JavaDoc for details). Additional custom actions can be added to documentation inlays and documentation popup via com.intellij.codeInsight.documentation.DocumentationActionProvider registered in com.intellij.documentationActionProvider extension point. (2020.3) Example : DocumentationProvider for Properties language plugin","title":"Documentation"},{"location":"reference_guide/custom_language_support/find_usages/","text":"The Find Usages action is a multi-step process, and each step of the process requires involvement from the custom language plugin. The language plugin participates in the Find Usages process by registering an implementation of FindUsagesProvider in the com.intellij.lang.findUsagesProvider extension point, and through the PSI implementation using PsiNamedElement and PsiReference interfaces. Examples : - Implementation of FindUsagesProvider in Properties language plugin - Custom Language Support Tutorial: Find Usages The steps of the Find Usages action are the following: * Before the Find Usages action can be invoked, the IDE builds an index of words present in every file in the custom language. Using the WordsScanner implementation returned from FindUsagesProvider.getWordsScanner() , the contents of every file are loaded and passes it to the words scanner, along with the words consumer. The words scanner breaks the text into words, defines the context for each word (code, comments, or literals), and passes the word to the consumer. The simplest way to implement the words scanner is to use the DefaultWordsScanner implementation, passing to it the sets of lexer token types which are treated as identifiers, literals, and comments. The default words scanner will use the lexer to break the text into tokens and handle breaking the text of the comment and literal tokens into individual words. * When the user invokes the Find Usages action, the IDE locates the PSI element the references to be searched. The PSI element at the cursor (the direct tree parent of the token at the cursor position) must be either a PsiNamedElement or a PsiReference which resolves to a PsiNamedElement . The word cache will be used to search for the text returned from the PsiNamedElement.getName() method. Also, if the text range of the PsiNamedElement includes some other text besides the identifier returned from getName() (for example, if the PsiNamedElement represents a JavaScript function and its text range includes the \" function \" keyword in addition to the name of the function), the method getTextOffset() must be overridden for the PsiNamedElement , and must return the start offset of the name identifier within the text range of the element. * Once the element is located, the IDE calls FindUsagesProvider.canFindUsagesFor() to ask the plugin if the Find Usages action applies to the specific element. * When showing the Find Usages dialog to the user, FindUsagesProvider.getType() and FindUsagesProvider.getDescriptiveName() are called to determine how the element should be presented to the user. * For every file containing the searched words, the IDE builds the PSI tree and recursively descends it. The text of each element is broken into words and then scanned. If the element was indexed as an identifier, every word is checked to be a PsiReference resolving to the element the usages of which are searched. If the element was indexed as a comment or literal and the search in comments or literals is enabled, it checks if the word is equal to the searched element's name. * After the usages are collected, results are shown in the usages pane. The text shown for each found element is taken from the FindUsagesProvider.getNodeText() method. To have the title of the found element be correctly displayed in the title of the Find Usages tool window, you need to provide an implementation of the ElementDescriptionProvider interface. The ElementDescriptionLocation passed to the provider in this case will be an instance of UsageViewLongNameLocation . Example: ElementDescriptionProvider for Properties language plugin TIP In cases like function parameters and local variables, consider overriding PsiElement.getUseScope() to return a narrower scope. For instance, you might return just the scope of the nearest function definition. This optimization can significantly reduce the number of files that need to be parsed--and references that need to be resolved--when renaming a function parameter or local variable.","title":"Find Usages"},{"location":"reference_guide/custom_language_support/go_to_class_and_go_to_symbol/","text":"A custom language plugin can provide its own items to be included in the lists shown when the user chooses the Navigate | Class or Navigate | Symbol action. In order to do so, the plugin must provide implementations for the ChooseByNameContributor interface (separate implementations need to be provided for Class and Symbol respectively), and register them in the com.intellij.gotoClassContributor and com.intellij.gotoSymbolContributor extension points. TIP Please consider implementing ChooseByNameContributorEx for better performance. Each contributor needs to be able to return a complete list of names to show in the list for a specified project, which will then be filtered by the IDE according to the text typed by the user in the dialog. Using File-based or Stub indices to obtain matching candidates is highly recommended to improve performance. For each name in that list, the contributor needs to provide a list of NavigationItem instances (typically PsiElement ), which specify the destinations to jump to when a specific name is selected from the list. Example: - Custom Language Support Tutorial: Go To Symbol Contributor","title":"Go to Class and Go to Symbol"},{"location":"reference_guide/custom_language_support/implementing_lexer/","text":"The lexer, or lexical analyzer , defines how a file's contents are broken into tokens. The lexer serves as a foundation for nearly all of the features of custom language plugins, from basic syntax highlighting to advanced code analysis features. The API for the lexer is defined by the Lexer interface. The IDE invokes the lexer in three main contexts, and the plugin can provide different lexer implementations for these contexts: Syntax highlighting: The lexer is returned from the implementation of the SyntaxHighlighterFactory interface which is registered in the com.intellij.lang.syntaxHighlighterFactory extension point. Building the syntax tree of a file: the lexer is expected to be returned from ParserDefinition.createLexer() , and the ParserDefinition interface is registered in the com.intellij.lang.parserDefinition extension point. Building the index of the words contained in the file: if the lexer-based words scanner implementation is used, the lexer is passed to the DefaultWordsScanner constructor. The lexer used for syntax highlighting can be invoked incrementally to process only the file's changed part. In contrast, lexers used in other contexts are always called to process an entire file or a complete language construction embedded in a different language file. A lexer that can be used incrementally may need to return its state , which means the context corresponding to each position in a file. For example, a Java lexer could have separate states for top-level context, comment context, and string literal context. An essential requirement for a syntax highlighting lexer is that its state must be represented by a single integer number returned from Lexer.getState() . That state will be passed to the Lexer.start() method, along with the start offset of the fragment to process, when lexing is resumed from the middle of a file. Lexers used in other contexts can always return 0 from the getState() method. The easiest way to create a lexer for a custom language plugin is to use JFlex . Classes FlexLexer and FlexAdapter adapt JFlex lexers to the Consulo Lexer API. We have a patched version of JFlex that can be used with the lexer skeleton file located at tools/lexer/idea-flex.skeleton in the IntelliJ IDEA Community Edition source to create lexers compatible with FlexAdapter . The patched version of JFlex provides a new command-line option --charat that changes the JFlex generated code to work with the Consulo skeleton. Enabling --charat option passes the source data for lexing as a CharSequence and not as an array of characters. For developing lexers using JFlex, the GrammarKit plugin can be useful. It provides syntax highlighting and other useful features for editing JFlex files. NOTE Lexers, and in particular JFlex-based lexers, need to be created so that they always match the entire contents of the file, without any gaps between tokens, and generate special tokens for characters which are not valid at their location. Lexers must never abort prematurely because of an invalid character. Example : - Lexer definition for Properties language plugin - Custom Language Support Tutorial: Lexer Types of tokens for lexers are defined by instances of IElementType . Many token types common for all languages are defined in the TokenType interface. Custom language plugins should reuse these token types wherever applicable. For all other token types, the plugin needs to create new IElementType instances and associate with the language in which the token type is used. The same IElementType instance should be returned every time a particular token type is encountered by the lexer. Example: Token types for Properties language plugin An important feature that can be implemented at the lexer level is mixing languages within a file, such as embedding fragments of Java code in some template language. Suppose a language supports embedding its fragments in another language. In that case, it needs to define the chameleon token types for different types of fragments that can be embedded, and these token types need to implement the ILazyParseableElementType interface. The enclosing language's lexer needs to return the entire fragment of the embedded language as a single chameleon token, of the type defined by the embedded language. To parse the contents of the chameleon token, the IDE will call the parser of the embedded language through a call to ILazyParseableElementType.parseContents() .","title":"Implementing Lexer"},{"location":"reference_guide/custom_language_support/implementing_parser_and_psi/","text":"Parsing files in Consulo is a two-step process. First, an abstract syntax tree (AST) is built, defining the structure of the program. AST nodes are created internally by the IDE and are represented by instances of the ASTNode class. Each AST node has an associated element type IElementType instance, and the element types are defined by the language plugin. The AST tree's top-level node for a file needs to have a special element type, which extends the IFileElementType class. The AST nodes have a direct mapping to text ranges in the underlying document. The bottom-most nodes of the AST match individual tokens returned by the lexer, and higher-level nodes match multiple-token fragments. Operations performed on nodes of the AST tree, such as inserting, removing, reordering nodes, and so on, are immediately reflected as changes to the underlying document's text. Second, a PSI, or Program Structure Interface, tree is built on top of the AST, adding semantics and methods for manipulating specific language constructs. Nodes of the PSI tree are represented by classes implementing the PsiElement interface and are created by the language plugin in the ParserDefinition.createElement() method. The top-level node of the PSI tree for a file needs to implement the PsiFile interface and is created in the ParserDefinition.createFile() method. Example : ParserDefinition for Properties language plugin The PSI's lifecycle is described in more detail in Fundamentals . The base classes for the PSI implementation, including PsiFileBase , the base implementation of PsiFile , and ASTWrapperPsiElement , the base implementation of PsiElement , are provided by Consulo . While coding parser manually is quite possible, we highly recommend generating parser and corresponding PSI classes from grammars using Grammar-Kit plugin. Besides code generation, it provides various features for editing grammar files: syntax highlighting, quick navigation, refactorings, etc. The Grammar-Kit plugin is built using its own engine; its source code can be found on GitHub . For re-using existing ANTLRv4 grammars, see antlr4-intellij-adaptor library. The language plugin provides the parser implementation as an implementation of the PsiParser interface, returned from ParserDefinition.createParser() . The parser receives an instance of the PsiBuilder class, which is used to get the stream of tokens from the lexer and to hold the intermediate state of the AST being built. The parser must process all tokens returned by the lexer up to the end of the stream, in other words, until PsiBuilder.getTokenType() returns null , even if the tokens are not valid according to the language syntax. Example : PsiParser implementation for Properties language plugin . The parser works by setting pairs of markers ( PsiBuilder.Marker instances) within the stream of tokens received from the lexer. Each pair of markers defines the range of lexer tokens for a single node in the AST tree. If a pair of markers is nested in another pair (starts after its start and ends before its end), it becomes the outer pair's child node. The element type for the marker pair and for the AST node created from it is specified when the end marker is set, which is done by making the call to PsiBuilder.Marker.done() . Also, it is possible to drop a start marker before its end marker has been set. The drop() method drops only a single start marker without affecting any markers added after it, and the rollbackTo() method drops the start marker and all markers added after it and reverts the lexer position to the start marker. These methods can be used to implement lookahead when parsing. The method PsiBuilder.Marker.precede() is useful for right-to-left parsing when you don't know how many markers you need at a specific position until you read more input. For example, a binary expression a+b+c needs to be parsed as ( (a+b) + c ) . Thus, two start markers are needed at the position of the token 'a', but that is not known until the token 'c' is read. When the parser reaches the '+' token following 'b', it can call precede() to duplicate the start marker at 'a' position, and then put its matching end marker after 'c'. An essential feature of PsiBuilder is its handling of whitespace and comments. The types of tokens which are treated as whitespace or comments are defined by the methods getWhitespaceTokens() and getCommentTokens() in the ParserDefinition class. PsiBuilder automatically omits whitespace and comment tokens from the stream of tokens it passes to PsiParser and adjusts the token ranges of AST nodes so that leading and trailing whitespace tokens are not included in the node. The token set returned from ParserDefinition.getCommentTokens() is also used to search for TODO items. To better understand the process of building a PSI tree for a simple expression, you can refer to the following diagram: In general, there is no single right way to implement a PSI for a custom language, and the plugin author can choose the PSI structure and set of methods that are the most convenient for the code which uses the PSI (error analysis, refactorings, and so on). However, one base interface needs to be used by a custom language PSI implementation to support features like rename and find usages. Every element which can be renamed or referenced (a class definition, a method definition and so on) needs to implement the PsiNamedElement interface, with methods getName() and setName() . Several functions which can be used for implementing and using the PSI can be found in the com.intellij.psi.util package, and in particular in the PsiUtilCore and PsiTreeUtil classes. TIP A useful tool for debugging the PSI implementation is the PsiViewer plugin . It can show you the PSI structure built by your plugin, the properties of every PSI element, and highlight its text range. Please see Indexing and PSI Stubs for advanced topics.","title":"Implementing Parser and PSI"},{"location":"reference_guide/custom_language_support/navigation/","text":"WARNING This API is available starting from 2020.3 and currently in development and thus in experimental state. The Go to Declaration or Usages action is performed in several steps. Direct Navigation Direct navigation is the navigation from PsiElement to another PsiElement , such as navigation from break keyword to the end of a loop in Java, without showing any popups. To provide PsiElement for direct navigation, implement and register DirectNavigationProvider . Symbol Navigation If there is no Direct navigation available under the caret, then the Consulo proceeds with Symbol navigation. In this step the Consulo computes the navigation targets based on target symbols, which it obtains by resolving a reference . If there are several target symbols or several navigation targets defined for a symbol, then the IDE shows the navigation popup to ask the user to choose where to go. The NavigationTarget is essentially a pair of a Navigatable and a TargetPopupPresentation instances (where to go and what to show in the popup). To provide navigation targets by a Symbol , either: - implement and register SymbolNavigationProvider ; - or implement NavigatableSymbol in the Symbol . Showing Usages If there are no navigation targets available, then the Consulo starts finding usages of the target symbol obtained by resolving a reference or from a declaration .","title":"Navigation"},{"location":"reference_guide/custom_language_support/navigation/#direct-navigation","text":"Direct navigation is the navigation from PsiElement to another PsiElement , such as navigation from break keyword to the end of a loop in Java, without showing any popups. To provide PsiElement for direct navigation, implement and register DirectNavigationProvider .","title":"Direct Navigation"},{"location":"reference_guide/custom_language_support/navigation/#symbol-navigation","text":"If there is no Direct navigation available under the caret, then the Consulo proceeds with Symbol navigation. In this step the Consulo computes the navigation targets based on target symbols, which it obtains by resolving a reference . If there are several target symbols or several navigation targets defined for a symbol, then the IDE shows the navigation popup to ask the user to choose where to go. The NavigationTarget is essentially a pair of a Navigatable and a TargetPopupPresentation instances (where to go and what to show in the popup). To provide navigation targets by a Symbol , either: - implement and register SymbolNavigationProvider ; - or implement NavigatableSymbol in the Symbol .","title":"Symbol Navigation"},{"location":"reference_guide/custom_language_support/navigation/#showing-usages","text":"If there are no navigation targets available, then the Consulo starts finding usages of the target symbol obtained by resolving a reference or from a declaration .","title":"Showing Usages"},{"location":"reference_guide/custom_language_support/references_and_resolve/","text":"One of the most important and tricky parts in implementing a custom language PSI is resolving references. Resolving references gives users the ability to navigate from a PSI element usage (accessing a variable, calling a method, etc.) to the declaration of that element (the variable's definition, a method declaration, and so on). This feature is needed in order to support the Go to Declaration action invoked by Ctrl-B and Ctrl-Click , and it is a prerequisite for implementing the Find Usages action, the Rename Refactoring and Code Completion . NOTE The Quick Definition action is based on the same mechanism, so it becomes automatically available for all references that can be resolved by the language plugin. All PSI elements which work as references (for which the Go to Declaration action applies) need to implement the PsiElement.getReference() method and to return a PsiReference implementation from that method. The PsiReference interface can be implemented by the same class as PsiElement , or by a different class. An element can also contain multiple references (for example, a string literal can contain multiple substrings which are valid fully-qualified class names), in which case it can implement PsiElement.getReferences() and return the references as an array. The primary method of the PsiReference interface is resolve() , which returns the element to which the reference points, or null if it was not possible to resolve the reference to a valid element (for example, should it point to an undefined class). The resolved element should implement the PsiNamedElement interface. NOTE While the referencing element and the referenced element both may have a name, only the element which introduces the name (e.g., the definition int x = 42 ) needs to implement the PsiNamedElement interface. The referencing element at the point of usage (e.g., the x in the expression x + 1 ) should not implement PsiNamedElement since it does not have a name. TIP In order to enable more advanced IntelliJ functionality, prefer implementing PsiNameIdentifierOwner over PsiNamedElement where possible. A counterpart to the resolve() method is isReferenceTo() , which checks if the reference resolves to the specified element. The latter method can be implemented by calling resolve() and comparing the result with the passed PSI element. Still, additional optimizations are possible (for example, performing the tree walk only if the element text is equal to the text of the reference). Examples : - Reference to a ResourceBundle in the Properties language plugin - Custom Language Support Tutorial: Reference Contributor TIP To optimize getReferences() performance, consider implementing HintedReferenceHost to provide additional hints. Please see also Cache Results of Heavy Computations in Working with PSI efficiently . There are a set of interfaces that can be used as a base for implementing resolve support, namely the PsiScopeProcessor interface and the PsiElement.processDeclarations() method. These interfaces have several extra complexities that are unnecessary for most custom languages (like support for substituting Java generics types). Still, they are required if the custom language can have references to Java code. If Java interoperability is not required, the plugin can forgo the standard interfaces and provide its own, different implementation of resolve. The implementation of resolve based on the standard helper classes contains the following components: A class implements the PsiScopeProcessor interface, which gathers the possible declarations for the reference and stops the resolve process when it has successfully completed. The primary method which needs to be implemented is execute() , which is called to process every declaration encountered during the resolve, and returns true if the resolve needs to be continued or false if the declaration has been found. The methods getHint() and handleEvent() are used for internal optimizations and can be left empty in the PsiScopeProcessor implementations for custom languages. A function which walks the PSI tree up from the reference location until the resolve has successfully completed or until the end of the resolve scope has been reached. If the target of the reference is located in a different file, the file can be located, for example, using FilenameIndex.getFilesByName() (if the file name is known) or by iterating through all custom language files in the project ( iterateContent() in the ProjectFileIndex interface obtained from ProjectRootManager.getFileIndex() ). The individual PSI elements, on which the processDeclarations() method is called during the PSI tree walk. If a PSI element is a declaration, it passes itself to the execute() method of the PsiScopeProcessor passed to it. Also, if necessary, according to the language scoping rules, a PSI element can pass the PsiScopeProcessor to its child elements. Resolving to Multiple Targets An extension of the PsiReference interface, which allows a reference to resolve to multiple targets, is the PsiPolyVariantReference interface. The targets to which the reference resolves are returned from the multiResolve() method. The Go to Declaration action for such references allows the user to choose a navigation target. The implementation of multiResolve() can be also based on PsiScopeProcessor , and can collect all valid targets for the reference instead of stopping when the first valid target is found.","title":"References and Resolve"},{"location":"reference_guide/custom_language_support/references_and_resolve/#resolving-to-multiple-targets","text":"An extension of the PsiReference interface, which allows a reference to resolve to multiple targets, is the PsiPolyVariantReference interface. The targets to which the reference resolves are returned from the multiResolve() method. The Go to Declaration action for such references allows the user to choose a navigation target. The implementation of multiResolve() can be also based on PsiScopeProcessor , and can collect all valid targets for the reference instead of stopping when the first valid target is found.","title":"Resolving to Multiple Targets"},{"location":"reference_guide/custom_language_support/registering_file_type/","text":"The first step in developing a custom language plugin is registering a file type associated with the language. The IDE typically determines the type of a file by looking at its file name or extension. In 2020.2, support for mapping via hashbang is available via hashBangs attribute in com.intellij.fileType extension point. A custom language file type is a class derived from LanguageFileType , which passes a Language subclass to its base class constructor. To register a file type, the plugin developer provides a subclass of FileTypeFactory , which is registered via the com.intellij.fileTypeFactory extension point. NOTE When targeting 2019.2 or later only, using com.intellij.fileType extension point is preferred to using dedicated FileTypeFactory . Examples : - LanguageFileType subclass in Properties language plugin - Custom Language Support Tutorial: Language and File Type To verify that the file type is registered correctly, you can implement the LanguageFileType.getIcon() method and verify that the correct icon (see Working with Icons and Images ) is displayed for files associated with your file type. If you want IDEs to show a hint prompting users that your plugin supports a specific file type, see Plugin Recommendations . To control file type association with the IDE in the operating system, implement com.intellij.openapi.fileTypes.OSFileIdeAssociation (2020.3).","title":"Registering File Type"},{"location":"reference_guide/custom_language_support/rename_refactoring/","text":"The Rename refactoring operation is quite similar to that of Find Usages . It uses the same rules for locating the element to be renamed and the same index of words for finding the files that may have references to the element being renamed. When the rename refactoring is performed, the method PsiNamedElement.setName() is called for the renamed element, and PsiReference.handleElementRename() is called for all references to the renamed element. These methods perform basically the same action: replace the underlying AST node of the PSI element with the node containing the new text entered by the user. Creating an entirely correct AST node from scratch is quite tricky. Thus, surprisingly, the easiest way to get the replacement node is to create a dummy file in the custom language so that it would contain the necessary node in its parse tree, build the parse tree and extract the required node from it. Examples: - setName() implementation for a Properties language plugin - Custom Language Support Tutorial: Reference Contributor To disable renaming for specific elements, implement com.intellij.openapi.util.Condition<T> for PsiElement of type T and register it in com.intellij.vetoRenameCondition extension point. Name Validation NamesValidator allows a plugin to check if the name entered by the user in the Rename dialog is a valid identifier (and not a keyword) according to the custom language rules. If an implementation of this interface is not provided by the plugin, Java rules for validating identifiers are used. Implementations of NamesValidator are registered in the com.intellij.lang.namesValidator extension point. Example : PropertiesNamesValidator for Properties language plugin Custom Rename UI and Workflow Further customization of the Rename refactoring processing is possible on multiple levels. Providing a custom implementation of the RenameHandler interface allows you to entirely replace the UI and workflow of the rename refactoring, and also to support renaming something which is not a PsiElement at all. Example : RenameHandler for renaming a resource bundle in the Properties language plugin If you're okay with the standard UI but need to extend the default logic of renaming, you can provide an implementation of the RenamePsiElementProcessor interface. This allows you to: Rename an element different from the one on which the action was invoked (a super method, for example) Rename multiple elements at once (if their names are linked according to the logic of your language) Check for name conflicts (existing names, etc.) Customize how a search for code references or text references is performed etc. Example : RenamePsiElementProcessor for renaming a property in Properties plugin language","title":"Rename Refactoring"},{"location":"reference_guide/custom_language_support/rename_refactoring/#name-validation","text":"NamesValidator allows a plugin to check if the name entered by the user in the Rename dialog is a valid identifier (and not a keyword) according to the custom language rules. If an implementation of this interface is not provided by the plugin, Java rules for validating identifiers are used. Implementations of NamesValidator are registered in the com.intellij.lang.namesValidator extension point. Example : PropertiesNamesValidator for Properties language plugin","title":"Name Validation"},{"location":"reference_guide/custom_language_support/rename_refactoring/#custom-rename-ui-and-workflow","text":"Further customization of the Rename refactoring processing is possible on multiple levels. Providing a custom implementation of the RenameHandler interface allows you to entirely replace the UI and workflow of the rename refactoring, and also to support renaming something which is not a PsiElement at all. Example : RenameHandler for renaming a resource bundle in the Properties language plugin If you're okay with the standard UI but need to extend the default logic of renaming, you can provide an implementation of the RenamePsiElementProcessor interface. This allows you to: Rename an element different from the one on which the action was invoked (a super method, for example) Rename multiple elements at once (if their names are linked according to the logic of your language) Check for name conflicts (existing names, etc.) Customize how a search for code references or text references is performed etc. Example : RenamePsiElementProcessor for renaming a property in Properties plugin language","title":"Custom Rename UI and Workflow"},{"location":"reference_guide/custom_language_support/safe_delete_refactoring/","text":"The Safe Delete refactoring also builds on the same Find Usages framework as Rename Refactoring . In addition to that, to support Safe Delete , a plugin needs to implement two things: The RefactoringSupportProvider interface, registered in the com.intellij.lang.refactoringSupport extension point, and the isSafeDeleteAvailable() method, which checks if the Safe Delete refactoring is available for a specific PSI element The PsiElement.delete() method for the PsiElement subclasses for which Safe Delete is available. Deleting PSI elements is implemented by deleting the underlying AST nodes from the AST tree (which, in turn, causes the text ranges corresponding to the AST nodes to be deleted from the document). Example: delete() implementation for a Property in Properties language plugin If needed, it's possible to further customize how Safe Delete is performed for a particular type of element (e.g., how references are searched) via SafeDeleteProcessorDelegate . Example : SafeDeleteProcessorDelegate implementation for Properties language plugin","title":"Safe Delete Refactoring"},{"location":"reference_guide/custom_language_support/structure_view/","text":"The Structure View implementation used for a specific file type can be customized on many levels. If a custom language plugin provides an implementation of the StructureView interface, it can completely replace the standard structure view implementation with a custom user interface component. However, for most languages, this is not necessary, and the standard StructureView implementation provided by Consulo can be reused. The starting point for the structure view is the PsiStructureViewFactory interface, which is registered in the com.intellij.lang.psiStructureViewFactory extension point. Examples: - PsiStructureViewFactory for Properties language plugin - Custom Language Support Tutorial: Structure View To reuse the Consulo implementation of the StructureView , the plugin returns a TreeBasedStructureViewBuilder from its PsiStructureViewFactory.getStructureViewBuilder() method. As the builder model, the plugin can specify a subclass of TextEditorBasedStructureViewModel , and by overriding methods of this subclass, it customizes the structure view for a specific language. Example : StructureViewModel for Properties language plugin The main method to override is getRoot() , which returns the instance of a class implementing the StructureViewTreeElement interface. There exists no standard implementation of this interface, so a plugin will need to implement it completely. The structure view tree is usually built as a partial mirror of the PSI tree. In the implementation of StructureViewTreeElement.getChildren() , the plugin can specify which of the child elements of a specific PSI tree node need to be represented as elements in the structure view. Another important method is getPresentation() , which can be used to customize the text, attributes, and icon used to represent an element in the structure view. The implementation of StructureViewTreeElement.getChildren() needs to be matched by TextEditorBasedStructureViewModel.getSuitableClasses() . The latter method returns an array of PsiElement -derived classes, which can be shown as structure view elements. It is used to select the Structure View item matching the cursor position when the structure view is first opened or when the Autoscroll from source option is enabled. Example: StructureViewTreeElement for Properties language plugin","title":"Structure View"},{"location":"reference_guide/custom_language_support/surround_with/","text":"To support the Surround With action, the plugin needs to register one or more implementations of the SurroundDescriptor interface in the com.intellij.lang.surroundDescriptor extension point. Each of the surround descriptors defines a possible type of code fragment that can be surrounded - for example, one surround descriptor can handle surrounding expressions, and another can handle statements. Each surround descriptor, in turn, contains an array of Surrounder objects, defining specific templates which can be used for surrounding the selected code fragment (for example, Surround With if , Surround With for , and so on). When the Surround With action is invoked, the IDE queries all surround descriptors for the language until it finds one that returns a non-empty array from its getElementsToSurround() method. Then it calls the Surrounder.isApplicable() method for each surrounder in that descriptor to check if the specific template is applicable in the current context. Once the user selects a specific surrounder from the popup menu, the Surrounder.surroundElements() method is used to execute the surround action. Example: SurroundDescriptor for Groovy plugin","title":"Surround With"},{"location":"reference_guide/custom_language_support/symbols/","text":"WARNING This API is available starting from 2020.3 and currently in development and thus in experimental state. A symbol is a semantic element in some model, e.g., language model or framework model. The Consulo uses Symbol to represent symbols, and Symbol serves as a link between Platform APIs, such as navigation, finding usages, or renaming. The platform obtains the target symbol from a declaration or by resolving a reference , and then uses it to perform an action. The PsiElement is considered as an element in the source tree (enhanced ASTNode ). Symbol decouples semantic actions from PSI. A Symbol is not required to be backed by a PsiElement , and it is incorrect to try to obtain the PsiElement from a Symbol . Symbol is not required to be bound to a Project as well, meaning the same instance might be shared between projects. Examples : - Java local variable is a symbol in Java language model, it's backed by a PsiVariable element; - Compiled class is a symbol in JVM model, it's backed by JDK library stubs, and it's not bound to any project; - Spring Bean is a symbol in Spring framework model, it's defined on-the-fly by framework support (not backed by a PsiElement ) and bound to a Project ; - Database column is a symbol defined by data source (not backed by a PsiElement ) and not bound to a Project since DB elements might be shared between projects. Lifecycle The Symbol instance is expected to stay valid within a single read action, which means it's safe to pass the instance to different APIs. A Symbol instance should not be referenced between read actions. One should create a pointer via Symbol.createPointer() in the current read action, and then call Pointer.dereference() to obtain a Symbol instance in the subsequent read action.","title":"Symbols"},{"location":"reference_guide/custom_language_support/symbols/#lifecycle","text":"The Symbol instance is expected to stay valid within a single read action, which means it's safe to pass the instance to different APIs. A Symbol instance should not be referenced between read actions. One should create a pointer via Symbol.createPointer() in the current read action, and then call Pointer.dereference() to obtain a Symbol instance in the subsequent read action.","title":"Lifecycle"},{"location":"reference_guide/custom_language_support/syntax_highlighting_and_error_highlighting/","text":"The class used to specify how a particular range of text should be highlighted is called TextAttributesKey . An instance of this class is created for every distinct type of item that should be highlighted (keyword, number, string, etc.). The TextAttributesKey defines the default attributes applied to items of the corresponding type (for example, keywords are bold, numbers are blue, strings are bold and green). Highlighting from multiple TextAttributesKey items can be layered - for example, one key may define an item's boldness and another color. Color Settings The mapping of the TextAttributesKey to specific attributes used in an editor is defined by the EditorColorsScheme class. It can be configured by the user by providing an implementation of ColorSettingPage registered in com.intellij.colorSettingsPage extension point. The Export to HTML feature uses the same syntax highlighting mechanism as the editor, so it will work automatically for custom languages, which provide a syntax highlighter. Examples : - ColorSettingsPage for Properties language plugin - Custom Language Support Tutorial: Color Settings Page NOTE New functionality about Language Defaults and support for additional color schemes are detailed in Color Scheme Management . TIP To force re-highlighting, use DaemonCodeAnalyzer.restart() . The syntax and error highlighting are performed on multiple levels: Lexer, Parser, and (External) Annotator. Lexer The first syntax highlighting level is based on the lexer output and is provided through the SyntaxHighlighter interface. The syntax highlighter returns the TextAttributesKey instances for each token type, which needs special highlighting. For highlighting lexer errors, the standard TextAttributesKey for bad characters HighlighterColors.BAD_CHARACTER can be used. Examples: - SyntaxHighlighter implementation for Properties language plugin - Custom Language Support Tutorial: Syntax Highlighter Parser The second level of error highlighting happens during parsing. If a particular sequence of tokens is invalid according to the grammar of the language, the PsiBuilder.error() method can highlight the invalid tokens and display an error message showing why they are not valid. Annotator The third level of highlighting is performed through the Annotator interface. A plugin can register one or more annotators in the com.intellij.annotator extension point, and these annotators are called during the background highlighting pass to process the elements in the custom language's PSI tree. Annotators can analyze not only the syntax, but also the semantics using PSI, and thus can provide much more complex syntax and error highlighting logic. The annotator can also provide quick fixes to problems it detects. When the file is changed, the annotator is called incrementally to process only changed elements in the PSI tree. NOTE See also Code Inspections which offer a more fine-grained control and some additional features. Errors/Warning See Inspections topic in Consulo UI Guidelines on how to write message texts for highlighting/quick fixes. To highlight a region of text as a warning or error (2020.1 and later): holder . newAnnotation ( HighlightSeverity . WARNING , \"Invalid code\" ) // or HighlightSeverity.ERROR . withFix ( new MyFix ( psiElement )) . create (); In previous versions, call createWarningAnnotation() / createErrorAnnotation() on the AnnotationHolder , and optionally calls registerFix() on the returned Annotation object to add a quick fix for the error or warning. Syntax To apply additional syntax highlighting (2020.1 and later): holder . newSilentAnnotation ( HighlightSeverity . INFORMATION ) . range ( rangeToHighlight ). textAttributes ( MyHighlighter . EXTRA_HIGHLIGHT_ATTRIBUTE ). create (); In previous versions, call AnnotationHolder.createInfoAnnotation() with an empty message and then Annotation.setTextAttributes() . Examples: - Annotator for Properties language plugin - Custom Language Support Tutorial: Annotator External Tool Finally, if the custom language employs external tools for validating files in the language (for example, uses the Xerces library for XML schema validation), it can provide an implementation of the ExternalAnnotator interface and register it in com.intellij.externalAnnotator extension point. The ExternalAnnotator highlighting has the lowest priority and is invoked only after all other background processing has completed. It uses the same AnnotationHolder interface for converting the output of the external tool into editor highlighting. To skip running specific ExternalAnnotator for given file, register ExternalAnnotatorsFilter extension in com.intellij.daemon.externalAnnotatorsFilter extension point.","title":"Syntax Highlighting and Error Highlighting"},{"location":"reference_guide/custom_language_support/syntax_highlighting_and_error_highlighting/#color-settings","text":"The mapping of the TextAttributesKey to specific attributes used in an editor is defined by the EditorColorsScheme class. It can be configured by the user by providing an implementation of ColorSettingPage registered in com.intellij.colorSettingsPage extension point. The Export to HTML feature uses the same syntax highlighting mechanism as the editor, so it will work automatically for custom languages, which provide a syntax highlighter. Examples : - ColorSettingsPage for Properties language plugin - Custom Language Support Tutorial: Color Settings Page NOTE New functionality about Language Defaults and support for additional color schemes are detailed in Color Scheme Management . TIP To force re-highlighting, use DaemonCodeAnalyzer.restart() . The syntax and error highlighting are performed on multiple levels: Lexer, Parser, and (External) Annotator.","title":"Color Settings"},{"location":"reference_guide/custom_language_support/syntax_highlighting_and_error_highlighting/#lexer","text":"The first syntax highlighting level is based on the lexer output and is provided through the SyntaxHighlighter interface. The syntax highlighter returns the TextAttributesKey instances for each token type, which needs special highlighting. For highlighting lexer errors, the standard TextAttributesKey for bad characters HighlighterColors.BAD_CHARACTER can be used. Examples: - SyntaxHighlighter implementation for Properties language plugin - Custom Language Support Tutorial: Syntax Highlighter","title":"Lexer"},{"location":"reference_guide/custom_language_support/syntax_highlighting_and_error_highlighting/#parser","text":"The second level of error highlighting happens during parsing. If a particular sequence of tokens is invalid according to the grammar of the language, the PsiBuilder.error() method can highlight the invalid tokens and display an error message showing why they are not valid.","title":"Parser"},{"location":"reference_guide/custom_language_support/syntax_highlighting_and_error_highlighting/#annotator","text":"The third level of highlighting is performed through the Annotator interface. A plugin can register one or more annotators in the com.intellij.annotator extension point, and these annotators are called during the background highlighting pass to process the elements in the custom language's PSI tree. Annotators can analyze not only the syntax, but also the semantics using PSI, and thus can provide much more complex syntax and error highlighting logic. The annotator can also provide quick fixes to problems it detects. When the file is changed, the annotator is called incrementally to process only changed elements in the PSI tree. NOTE See also Code Inspections which offer a more fine-grained control and some additional features.","title":"Annotator"},{"location":"reference_guide/custom_language_support/syntax_highlighting_and_error_highlighting/#errorswarning","text":"See Inspections topic in Consulo UI Guidelines on how to write message texts for highlighting/quick fixes. To highlight a region of text as a warning or error (2020.1 and later): holder . newAnnotation ( HighlightSeverity . WARNING , \"Invalid code\" ) // or HighlightSeverity.ERROR . withFix ( new MyFix ( psiElement )) . create (); In previous versions, call createWarningAnnotation() / createErrorAnnotation() on the AnnotationHolder , and optionally calls registerFix() on the returned Annotation object to add a quick fix for the error or warning.","title":"Errors/Warning"},{"location":"reference_guide/custom_language_support/syntax_highlighting_and_error_highlighting/#syntax","text":"To apply additional syntax highlighting (2020.1 and later): holder . newSilentAnnotation ( HighlightSeverity . INFORMATION ) . range ( rangeToHighlight ). textAttributes ( MyHighlighter . EXTRA_HIGHLIGHT_ATTRIBUTE ). create (); In previous versions, call AnnotationHolder.createInfoAnnotation() with an empty message and then Annotation.setTextAttributes() . Examples: - Annotator for Properties language plugin - Custom Language Support Tutorial: Annotator","title":"Syntax"},{"location":"reference_guide/custom_language_support/syntax_highlighting_and_error_highlighting/#external-tool","text":"Finally, if the custom language employs external tools for validating files in the language (for example, uses the Xerces library for XML schema validation), it can provide an implementation of the ExternalAnnotator interface and register it in com.intellij.externalAnnotator extension point. The ExternalAnnotator highlighting has the lowest priority and is invoked only after all other background processing has completed. It uses the same AnnotationHolder interface for converting the output of the external tool into editor highlighting. To skip running specific ExternalAnnotator for given file, register ExternalAnnotatorsFilter extension in com.intellij.daemon.externalAnnotatorsFilter extension point.","title":"External Tool"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/","text":"This page provides high-level overview of External System sub-system. There are multiple project management systems ( Apache Maven , Gradle , sbt etc) and it's good to support them at the IDE. Luckily, they all provide a similar set of facilities from the integration point of view: * build IDE project from external system config ( pom.xml , build.gradle etc); * provide a list of available tasks; * allow to execute a particular task; * ... That means that we can separate external system-specific logic and general IDE processing. 'External system' sub-system provides simple API for wrapping external system and extensible IDE-specific processing logic. Project Management Project Data Domain General External system wrapper is required to be able to build project info on the basis of the given external system config. That information is built using in terms of DataNode , Key and ExternalEntityData . Here DataNode class is just a holder for the target data (data type is defined by the Key ). Multiple DataNode objects might be organized in directed graph where every edge identifies parent-child relation. For example, simple one-module project might look as below: Consequence The IDE provides a set of built-in Key s and ExternalEntityData s but any external system integration or third-party plugin developer might enhance project data by defining her own Key and ExternalEntityData and storing them at a child of appropriate DataNode . Managing Project Data We need to process project data is built on external system config basis. Here comes ProjectDataService . It is a strategy which knows how to manage particular ExternalEntityData . For example, when we want to import a project from external model, we can start by the top level DataNode which references project info and then import its data using corresponding service. Custom services can be defined via 'externalProjectDataService' extension. The good thing is that we can separate project parsing and management here. That means that a set of DataNode , Key and ProjectDataServices can be introduced for particular technology and then every external system integration can build corresponding data if necessary using it. Importing from External Model Consulo provides standard API for that. Namely, ProjectImportBuilder and ProjectImportProvider . There are two classes built on template method pattern - AbstractExternalProjectImportBuilder and AbstractExternalProjectImportProvider . Concrete implementations are registered in plugin.xml . Here is an example from the gradle integration plugin: <projectImportProvider implementation=\"org.jetbrains.plugins.gradle.service.settings.GradleProjectImportProvider\"/> <projectImportBuilder implementation=\"org.jetbrains.plugins.gradle.service.settings.GradleProjectImportBuilder\"/> Note that AbstractExternalProjectImportBuilder is built on top of the 'external system settings' controls. Auto-Import It's possible to configure external system integration to automatically refresh project structure when external project's config files are modified. TIP Since 2020.1, auto-import cannot be disabled by user. Auto-Import for ExternalSystemManager implementation Describe project's settings files to track by having external system ExternalSystemManager implement ExternalSystemAutoImportAware . NOTE ExternalSystemAutoImportAware.getAffectedExternalProjectPath() is called quite often, that\u2019s why it\u2019s expected to return control as soon as possible. Helper CachingExternalSystemAutoImportAware class might be used for caching, i.e. ExternalSystemManager which implements ExternalSystemAutoImportAware can have a field like new CachingExternalSystemAutoImportAware(new MyExternalSystemAutoImportAware()) and delegate ExternalSystemAutoImportAware.getAffectedExternalProjectPath() calls to it. Auto-Import for Standalone External Systems Some external systems don\u2019t have ExternalSystemManager (e.g., Maven), but they also can use auto-import core to track changes in settings files. For this, implement ExternalSystemProjectAware interface that describes settings files for tracking and an action to reload project model. Then register the instance with ExternalSystemProjectTracker to start tracking. NOTE Multiple ExternalSystemProjectAware instances can correspond to a single external system. It allows performing project reload differently depending on the set of settings files (project aware per settings file, per module, per external project, etc.). Icon for Reload Notification Since 2020.1, the icon for reload notification can be specified per external system. Implement ExternalSystemIconProvider and register via com.intellij.externalIconProvider extension point in plugin.xml . Alternatively, set reloadIcon field external system implements ExternalSystemIconProvider directly. Settings The general idea is that all external system settings controls are represented by implementations of ExternalSystemSettingsControl interface. There are also external system project-local settings and global external system settings. So, basically particular external system settings UI looks as below: It's recommended to extend from AbstractExternalProjectSettingsControl for implementing project-level settings control as it already handles some of them. Similar approach is used for providing 'import from external system' UI - implementation is expected to extend AbstractImportFromExternalSystemControl and it has not linked external projects list but target external project path control:","title":"External System Integration"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#project-management","text":"","title":"Project Management"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#project-data-domain","text":"General External system wrapper is required to be able to build project info on the basis of the given external system config. That information is built using in terms of DataNode , Key and ExternalEntityData . Here DataNode class is just a holder for the target data (data type is defined by the Key ). Multiple DataNode objects might be organized in directed graph where every edge identifies parent-child relation. For example, simple one-module project might look as below: Consequence The IDE provides a set of built-in Key s and ExternalEntityData s but any external system integration or third-party plugin developer might enhance project data by defining her own Key and ExternalEntityData and storing them at a child of appropriate DataNode .","title":"Project Data Domain"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#managing-project-data","text":"We need to process project data is built on external system config basis. Here comes ProjectDataService . It is a strategy which knows how to manage particular ExternalEntityData . For example, when we want to import a project from external model, we can start by the top level DataNode which references project info and then import its data using corresponding service. Custom services can be defined via 'externalProjectDataService' extension. The good thing is that we can separate project parsing and management here. That means that a set of DataNode , Key and ProjectDataServices can be introduced for particular technology and then every external system integration can build corresponding data if necessary using it.","title":"Managing Project Data"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#importing-from-external-model","text":"Consulo provides standard API for that. Namely, ProjectImportBuilder and ProjectImportProvider . There are two classes built on template method pattern - AbstractExternalProjectImportBuilder and AbstractExternalProjectImportProvider . Concrete implementations are registered in plugin.xml . Here is an example from the gradle integration plugin: <projectImportProvider implementation=\"org.jetbrains.plugins.gradle.service.settings.GradleProjectImportProvider\"/> <projectImportBuilder implementation=\"org.jetbrains.plugins.gradle.service.settings.GradleProjectImportBuilder\"/> Note that AbstractExternalProjectImportBuilder is built on top of the 'external system settings' controls.","title":"Importing from External Model"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#auto-import","text":"It's possible to configure external system integration to automatically refresh project structure when external project's config files are modified. TIP Since 2020.1, auto-import cannot be disabled by user.","title":"Auto-Import"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#auto-import-for-externalsystemmanager-implementation","text":"Describe project's settings files to track by having external system ExternalSystemManager implement ExternalSystemAutoImportAware . NOTE ExternalSystemAutoImportAware.getAffectedExternalProjectPath() is called quite often, that\u2019s why it\u2019s expected to return control as soon as possible. Helper CachingExternalSystemAutoImportAware class might be used for caching, i.e. ExternalSystemManager which implements ExternalSystemAutoImportAware can have a field like new CachingExternalSystemAutoImportAware(new MyExternalSystemAutoImportAware()) and delegate ExternalSystemAutoImportAware.getAffectedExternalProjectPath() calls to it.","title":"Auto-Import for ExternalSystemManager implementation"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#auto-import-for-standalone-external-systems","text":"Some external systems don\u2019t have ExternalSystemManager (e.g., Maven), but they also can use auto-import core to track changes in settings files. For this, implement ExternalSystemProjectAware interface that describes settings files for tracking and an action to reload project model. Then register the instance with ExternalSystemProjectTracker to start tracking. NOTE Multiple ExternalSystemProjectAware instances can correspond to a single external system. It allows performing project reload differently depending on the set of settings files (project aware per settings file, per module, per external project, etc.).","title":"Auto-Import for Standalone External Systems"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#icon-for-reload-notification","text":"Since 2020.1, the icon for reload notification can be specified per external system. Implement ExternalSystemIconProvider and register via com.intellij.externalIconProvider extension point in plugin.xml . Alternatively, set reloadIcon field external system implements ExternalSystemIconProvider directly.","title":"Icon for Reload Notification"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#settings","text":"The general idea is that all external system settings controls are represented by implementations of ExternalSystemSettingsControl interface. There are also external system project-local settings and global external system settings. So, basically particular external system settings UI looks as below: It's recommended to extend from AbstractExternalProjectSettingsControl for implementing project-level settings control as it already handles some of them. Similar approach is used for providing 'import from external system' UI - implementation is expected to extend AbstractImportFromExternalSystemControl and it has not linked external projects list but target external project path control:","title":"Settings"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/","text":"Abstract This article is intended for plugin writers who create custom web server integrations, or some UI for easy XML editing. It describes the Document Object Model (DOM) in Consulo --- an easy way to work with DTD or Schema-based XML models. The following topics will be covered: working with DOM itself (reading/writing tags content, attributes, and subtags) and easy XML editing in the UI by connecting UI to DOM. It's assumed that the reader is familiar with Java, Swing, Consulo XML PSI (classes XmlTag , XmlFile , XmlTagValue , etc.), Consulo plugin development basics (application and project components, file editors). Introduction So, how to operate with XML from an Consulo plugin? Usually, one has to take XmlFile , get its root tag, and then find a required sub-tag by path. The path consists of tag names, each of them a string. Typing these everywhere is tedious and error-prone. Let's assume you have the following XML: <root> <foo> <bar> 42 </bar> <bar> 239 </bar> </foo> </root> Let's say you want to read the contents of the second bar element, namely, \"239\". It's not correct to create chained calls like file . getDocument (). getRootTag (). findFirstSubTag ( \"foo\" ). findSubTags ( \"bar\" ) [ 1 ] . getValue (). getTrimmedText () because each call here may return null . So the code would probably look like this: XmlFile file = ...; final XmlDocument document = file . getDocument (); if ( document != null ) { final XmlTag rootTag = document . getRootTag (); if ( rootTag != null ) { final XmlTag foo = rootTag . findFirstSubTag ( \"foo\" ); if ( foo != null ) { final XmlTag [] bars = foo . findSubTags ( \"bar\" ); if ( bars . length > 1 ) { String s = bars [ 1 ] . getValue (). getTrimmedText (); // do something } } } } Looks awful, doesn't it? But there's a better way to do the same thing. You just need to extend a special interface --- DomElement . For example, let's create several interfaces: interface Root extends com . intellij . util . xml . DomElement { Foo getFoo (); } interface Foo extends com . intellij . util . xml . DomElement { List < Bar > getBars (); } interface Bar extends com . intellij . util . xml . DomElement { String getValue (); } Next, you should create a DomFileDescription object, pass to its constructor the root tag name and root element interface, and register it with extension point com.intellij.dom.fileDescription . NOTE If your plugin targets 2019.1 or later, please use extension point com.intellij.dom.fileMetaData instead and specify rootTagName and domVersion / stubVersion in plugin.xml . You can now get the file element from DomManager . To get the \"239\" value, you only have to write the following code: DomManager manager = DomManager . getDomManager ( project ); Root root = manager . getFileElement ( file ). getRootElement (); List < Bar > bars = root . getFoo (). getBars (); if ( bars . size () > 1 ) { String s = bars . get ( 1 ). getValue (); // do something } I suppose this looks a little bit nicer. You often work with your model in more than one place. Re-creating the model is too inefficient, so we cache it for you, and any subsequent calls to DomManager.getFileElement() will return the same instance. So, it is useful to invoke this method just once, and then keep everywhere only the \"root\" object you've obtained. In this case you wont need to repeat that scary first line, and the code will look even nicer. It is also important to note that with this scenario we avoid potential NullPointerException : our DOM guarantees that every method accessing a tags child will return a not-null element, even if the correspondingly-named sub-tag doesn't exist. That may seem strange at a first glance, but it appears to be rather convenient. How does it work? Simple. Given those interfaces, DOM generates all code for accessing correct sub-tags and creating model elements at runtime. The sub-tag names and element types are taken from method names, return types and method annotations, if any. In most cases annotations can be omitted, as in our example, but this is discussed further in this article anyway. Now let us explore more thoroughly what the DOM can do, and look at possible ways of representing various XML concepts such as tag content, attributes or sub-tags. Later we will discuss basic methods for working with the model, as well as cover more advanced functionality. Finally, we'll see how to easily create an UI editor for DOM model elements. Building the Model Tag Content In XML PSI, tag content is referred to as tag value, so well do the same for consistency. To read and change a tag value, you have to add two methods (getter and setter) to your interface, like this: String getValue (); void setValue ( String s ); These method names ( getValue and setValue ) are standard, and they are used for accessing tag values by default. If you want to use custom method names for the same goal, you should annotate these methods with @TagValue , for example: @TagValue String getTagValue (); @TagValue void setTagValue ( String s ); As you can see, our accessors work with String values. This is natural, since XML represents a text format, and tag content is always text. But sometimes you may want to operate with integers, booleans, enums, or even class names (they, of course, will be represented as PsiClass ), and more generic Java types ( PsiType ). In such cases, you just need to change the type in methods to the one you need, and everything will keep working correctly. Custom Value Types If you operate with even more exotic types, you should tell DOM how to deal with them. First, annotate your accessor methods with the @Convert annotation, and specify your own class that should extend the Converter<T> class in the annotation. Here T is your exotic type, while Converter<T> is a thing that knows how to convert values between String and T . If the value cannot be converted (for example, \"foo\" is not convertible into Integer ), the converter may return null . Please also note that your implementation should have a no-argument constructor. Let us consider an interesting case when T represents an enum value. Usually, the converter just searches for enum elements with the names specified in XML. But sometimes, for their names, you may need or want to use values that are not valid Java identifiers. For example, CMP version in EJB may be \"1.x\" or \"2.x\", but you can't create Java enums with such names. For such cases, let your enum implement NamedEnum interface, and then name your enum elements as you wish. Now, just provide the getValue() implementation that will return the right value to match with XML contents, and voil\u00e0! In our example, the code will look as follows: enum CmpVersion implements NamedEnum { CmpVersion_1_X ( \"1.x\" ), CmpVersion_2_X ( \"2.x\" ); private final String value ; private CmpVersion ( String value ) { this . value = value ; } public String getValue () { return value ; } } As we have already mentioned, an XML tag may have lots of artifacts besides its value: there can be attributes, children, but rather often (e.g., according to DTD or Schema) it should have only the value. Of course such tags also need a DOM element to associate with. And we provide such an element: interface GenericDomValue < T > { T getValue (); void setValue ( T t ); @TagValue String getStringValue (); @TagValue void setStringValue ( String s ); } So, you can just specify a particular T when using this interface --- and everything will work. Methods that work with String are provided for many reasons. For example, your T is PsiClass . It would be useful to highlight invalid values in UI. To get the value to highlight (the string from the XML file) we have the getStringValue() method. The error message will be taken from the converter via getErrorMessage() . Attributes Attributes are also rather simple to deal with. You can read their values, set them, and operate with different types. So it's natural to create something like GenericDomValue<T> and then work as usual. \"Something like\" will be an inheritor, as shown below: interface GenericAttributeValue < T > extends GenericDomValue < T > { XmlAttribute getXmlAttribute (); } Consider that you want to work with an attribute named some-class having a value of type PsiClass : @Attribute ( \"some-class\" ) GenericAttributeValue < PsiClass > getMyAttributeValue (); That's all! Now you can get/set values, resolve this PsiClass , get its String representation, etc. The name of the attribute will be taken from the method name (see next paragraph). If you name your method in a special way, you can even omit the annotation. For example: GenericAttributeValue < PsiClass > getSomeClass (); The DomNameStrategy interface specifies how to convert accessor names to XML element names. Or more precisely, not the full accessor names, but rather the names minus any \"get\", \"set\" or \"is\" prefixes. The strategy class is specified in the @NameStrategy annotation in any DOM element interface. Then any descendants and children of this interface will use this strategy. The default strategy is HyphenNameStrategy , where words are delimited by hyphens (see sample above). Another common variant is JavaNameStrategy that capitalizes the first letter of each word, as in Java's naming convention. In our example, the attribute name would be \"someClass\". If attribute doesn't define a PsiClass , but some other custom T that needs a converter, you just need to specify the @Convert annotation to the getter. Please note that the attributes getter method will never return null , even if the attribute isn't specified in XML. Its getValue() , getStringValue() and getXmlAttribute() methods will return null , but the DOM interface instance will exist and be valid. If the element has an underlying attribute, this can be easily fixed (surely, only if you need that): just call the undefine() method (defined in DomElement ), and the XML attribute disappears, while GenericAttributeValue remains valid. Children: Fixed Number You may often deal with tags that have at most one sub-tag with the given name (e.g. <ejb-name> , <ejb-class> or <cmp-field> ) in tags defining entity EJBs. To work with such children, provide getters for them. These getters should have a return type that extends DomElement : GenericDomValue < String > getEjbName (); GenericDomValue < String > getEjbClass (); CmpField getCmpField (); There's also an annotation to designate such children explicitly: @SubTag . Its \"value\" attribute contains a tag name. If it is not specified, the name is implied from the method name using the current name strategy. Sometimes it is the sub-tag's presence that means something, rather than its content --- <unchecked> in EJB method permissions, for example. If it exists, then permissions are unchecked, otherwise checked. For such things one should create a special GenericDomValue<Boolean> child. Usually its getValue() returns true if there's \"true\" in a tag value, false if there's \"false\" in a tag value, and null otherwise. In the @SubTag annotation, you can specify the attribute like indicator=true . In this case, getValue() will return true if the tag exists and false otherwise. Let's consider another interesting example inspired by EJB, where there is a relation that has two roles, each designating one relation end: first role and second role. Both are represented by tags with the same values. So, we could create a collection of role elements, and every time we access some role we would check if this collection has sufficient number of elements. But one of the main purposes of the DOM is to eliminate unnecessary checks. So why cant we have a fixed (more than one) number of children with the same tag name? Let's have them! @SubTag ( value = \"ejb-relationship-role\" , index = 0 ) EjbRelationshipRole getEjbRelationshipRole1 (); @SubTag ( value = \"ejb-relationship-role\" , index = 1 ) EjbRelationshipRole getEjbRelationshipRole2 (); The first method will return the DOM element for the first subtag named <ejb-relationship-role> , and the second --- for the second one. Hence the term \"fixed-number\" for such children. According to DTD or Schema, there should be fixed number of subtags with the given name. Most often this fixed number is 1; in our case with the relations it is 2. Just like attributes, fixed-number children exist regardless of underlying tag existence. If you need to delete tags, it can be done with the help of the same undefine() method. For children of GenericDomValue type, you can also specify a converter, just as you can for attributes. Children: Collections One more common case in DTD and Schemas is when children have the same tag name and a non-fixed upper limit in count. Their accessors differ from those of the fixed-number children in the following: the return result is Collection or List of a special type that extends DomElement , and if you want to use name strategies, the method name must be in pluralized form. For example, in EJB we would have the following method: List < Entity > getEntities (); There's also an annotation @SubTagList where you can explicitly specify the tag name. Returned collections cannot be modified directly. To delete an element from collection, just call undefine() on this element. The tag will then be removed, and element will become invalid ( DomElement.isValid() == false ). Note that this behavior differs from that of fixed-number children and attributes: they are always valid, even after undefine() . Again, unlike those children types, collection children always have valid underlying XML tags. Adding elements is a little bit harder. Since all DOM elements are created internally, you can't just pass some of your DOM elements to some method, to add the element to the collection. In fact, you have to ask a parent element to add a child to the collection. In our example it's done in the following way: Entity addEntity ( int index ); which adds an element to wherever you want, or Entity addEntity (); which adds a new DOM element to the end of the collection. Please note the singular tense of the word \"Entity\". That's because here we deal with one Entity object, while in the collection getter we dealt with potentially many entities. Now, you can do anything you want with the returned value: modify, define the tag's value, children, etc. The last common case is also a collection, but one consisting of tags with different names that are arbitrarily mixed. To work with it, you should define collection getters for all tag names within the mixed collection, and then define an additional specially annotated getter: // <foo> elements List < Foo > getFoos (); // <bar> elements List < Bar > getBars (); // all <foo> and <bar> elements @SubTagsList ({ \"foo\" , \"bar\" }) List < FooBar > getMergedListOfFoosAndBars (); The annotation here is mandatory - we cannot guess several tag names from one method name. To add elements to such mixed collections, you should create \"add\" methods for each possible tag name: @SubTagsList ( value = { \"foo\" , \"bar\" }, tagName = \"foo\" ) Fubar addFoo (); @SubTagsList ( value = { \"foo\" , \"bar\" }, tagName = \"bar\" ) Fubar addBar ( int index ); The index parameter in the last example means the index in the merged collection, not in the collection of tags named \"bar\". Dynamic Definition You can extend existing DOM model at runtime by implementing com.intellij.util.xml.reflect.DomExtender<T> . Register it in \"extenderClass\" attribute of EP com.intellij.dom.extender , where \"domClass\" specifies DOM class <T> to be extended. DomExtensionsRegistrar provides various methods to register dynamic attributes and children. If the contributed elements depend on anything other than plain XML file content (used framework version, libraries in classpath, ...), make sure to return false from DomExtender.supportsStubs() . Generating DOM from Existing XSD DOM can be generated automatically from existing XSD/DTD. Output correctness/completeness will largely depend on the input scheme and may require additional manual adjustments. Follow these steps: Run IntelliJ IDEA with Plugin DevKit enabled in internal mode Select Tools | Internal Actions | DevKit | Generate DOM Model Select Scheme file and set options, then click \"Generate\" to generate sources Modify generated sources according to your needs IDE Support Plugin DevKit supports the following features for working with DOM related code: DomElement - provide implicit usages for all DOM-related methods defined in inheriting classes (to suppress \"unused method\" warning) DomElementVisitor - provide implicit usages for all DOM-related visitor methods defined in inheriting classes (to suppress \"unused method\" warning) Working with the DOM Class Choosers It often happens that a collection contains same-named tags that may have different structure or even be represented by different types in the DTD or Schema. As an example, JSF Managed Beans may be of three types. If a <managed-bean> tag contains a <map-entries> sub-tag, then the Managed Bean type is MapEntriesBean . If it contains a <list-entries> sub-tag \u2014 can you guess? Right \u2014 ListEntriesBean ! Otherwise it's a PropertyBean (all three interfaces extend ManagedBean ). And when we write List<ManagedBean> getManagedBeans() , we expect to get not only a list where all elements are instances of the ManagedBean interface, but a list where each element is of a certain type, i.e. MapEntriesBean , ListEntriesBean , or PropertyBean . In such cases one should decide which interface the DOM element should actually implement (according to the given tag). This is achieved by extending the TypeChooser abstract class: public abstract class TypeChooser { public abstract Type chooseType ( XmlTag tag ); public abstract void distinguishTag ( XmlTag tag , Type aClass ) throws IncorrectOperationException ; public abstract Type [] getChooserTypes (); } Here, the first method ( chooseType() ) does exactly what it is named after (chooses the particular type, most often it's a class). The second one ( distinguishTag() ) acts in reverse: it modifies a tag so that when the element is read from an XML file next time (for example, after the user has closed and opened the project again), the newly created DOM element will implement the same interface and no model data will be lost. Finally, getChooserTypes() just returns all the types that could be returned by chooseType() . To make your TypeChooser work, register it in your overridden DomFileDescription.initializeFileDescription() method by calling registerTypeChooser() . Useful Methods of DomElement and DomManager PSI Connection Of course, DOM is tightly connected to XML PSI, so there's always a way of getting the XmlTag instance (which can be null for fixed-number children and attributes) using the getXmlTag() method. We remember that in GenericAttributeValue there's also the getXmlAttribute() method. In general case there is getXmlElement() method. You can also get a DOM element by its underlying XML PSI element using the DomManager.getDomElement() method. If DOM element has no underlying XML element, it can be created by calling ensureTagExists() . To delete a tag, use the already known undefine() method. This method will always delete the underlying XML element (tag or attribute). If the element was a collection child, then neither it nor its entire sub-tree will be valid anymore. Tree Structure In every normal tree there's always a possibility to walk up. DomElement is no exception. Method getParent() just returns element's parent in tree. The method <T extends DomElement> T getParentOfType(Class<T> requiredClass, boolean strict) returns the tree ancestor of the given class. You can see the standard strict parameter, that can return the DOM element itself, if it's false and your current DOM element is an instance of requiredClass . Finally, getRoot() will return the DomFileElement , which is the root of every DOM tree. Validity An element becomes invalid if it has been deleted explicitly or due to external PSI changes. Fixed-number children and attributes are meant to stay valid as long as possible, no matter what happens with XML. They can become invalid only if they have collection tree ancestor that has been deleted. Newly created DOM elements are always correct and valid, so their isValid() methods will return true . Element validity is very important, since you cannot invoke any methods on invalid elements (except, of course, isValid() itself). DOM Reflection DOM also has a kind of reflection, called \"Generic Info\". One would use it to be able to access children by tag names directly, instead of calling getter methods. See DomGenericInfo interface and getGenericInfo() methods in DomElement and DomManager for more information. There's also DomElement.getXmlElementName() method that returns the name of a corresponding tag or attribute. Presentation DomElement.getPresentation() returns an instance of ElementPresentation , an interface that knows presentable element type, name, and sometimes even its icon. Presentations are actually obtained from presentation factory objects that, like ClassChoosers's, should be registered in ElementPresentationManager as early as possible. You can specify type name and icon for all elements of some class, ways of getting type name, icon and presentable name for particular objects. When not specified, presentable name is taken from the object itself, if it contains a method annotated with @NameValue annotation, that returns String or GenericValue . If there's no such method, it will return null . For DomElement , there's another way to get this presentable name: DomElement.getGenericInfo().getElementName() . Events If you want to be notified on every change in the DOM model, add DomEventListener to DomManager . DOM supports the following events: tag value changed, element defined/undefined/changed, and collection child added/removed. Highlighting Annotations The DOM supports error checking and highlighting. It's based on annotations which you add to the DOM element in a special place (don't confuse these annotations with the ones of Java 5 \u2014 they are very different). You need to implement the DomElementAnnotator interface, and override DomFileDescription.createAnnotator() method, and create this annotator there. In DomElementsAnnotator.annotate(DomElement element, DomElementsProblemsHolder annotator) you should report about all errors and warnings in the element's sub-tree to the annotator ( DomElementsProblemsHolder.createProblem() ). You should return this annotator in the corresponding virtual method of the DomFileDescription . Automatic Highlighting (BasicDomElementsInspection) The following errors can be highlighted automatically by providing an instance of BasicDomElementsInspection : @Required element missing or having empty text XML value cannot be converted by some Converter name is not unique while it should be The latter case requires you to specify the name getter with @NameValue annotation. The checking uses the DomFileDescription.getIdentityScope() method to get the element defining the root scope in which the name should be unique. To suppress spellchecking annotate your DomElement with @com.intellij.spellchecker.xml.NoSpellchecking . Required Children There is a common case in error highlighting, when one needs to say, that some required sub-tag or attribute is missing. DOM will do this for you automatically, if you annotate the getter for that child with the @Required annotation. For collection children getters, this annotation will mean, that the collection should be not empty (corresponding to '+' sign in DTD). Also, when you create a new element that has required fixed-number or attribute children, their tags or attributes will also be created in XML. Resolving Remember the interface GenericDomValue<T> and its sub-interface GenericAttributeValue<T> ? Remember, that ANY class may be passed as T \u2014 for example, let's interpret GenericDomValue<PsiClass> as a reference to a class. Then we can always consider it as a reference to an object of class T ! With Strings or enums, it is not a very useful idea, but we'll use it in another way. Very often XML has such a structure that an object is declared at some place, and is referenced at some other place (more precisely, in a tag or attribute value). So, if you want to create a method like GenericValue<MyDomElement> getMyDomElementReference() , then you just have to specify a proper converter that will find an instance in your model of MyDomElement with the name specified in the GenericDomValue . That's the core idea. Since creating such converters is quite boring, we've done it for you. You don't have to annotate reference getters at all, as the name resolution will be made automatically. Elements will be searched by name, and the name will be taken from the method annotated with @NameValue . The converter used is DomResolveConverter . Its constructor takes a parameter, so it can't be referenced in @Convert annotation, but its subclasses (if you create them) \u2014 can. If you still want to specify explicitly that your reference to DomElement should be resolved \"model-wide\", use the @Resolve annotation parameterized with the desired class. The resolution scope will be taken from the DomFileDescription.getResolveScope() . In addition to the above, auto-resolving in DOM also provides some features in your XML text editor: error highlighting, completion, Find Usages, Rename Refactoring... Unresolved references will be highlighted, and even completed. If you want to create a custom converter and want to have this code insight with it, you should extend not only the Converter but ResolvingConverter . It has one more method getVariants() , where you'll have to provide the collection consisting of all targets your reference may resolve to. Those familiar with PsiReference will recognize the similarities here. If you need to choose a Converter depending on other values (e.g. in sibling/parent element) or any runtime condition (e.g. presence or version of library), you can use WrappingConverter . See also GenericDomValueConvertersRegistry for managing an extensible registry of available Converters to choose from. Mock and Stable Elements Your DOM elements do not have to be tied to a physical file. DomManager.createMockElement() will help you to create a virtual element of a given class with the given module. An element may be physical or not. 'Physical' here means that DOM will create a mock document for it, so you can enjoy Undo functionality if you pass this document to the right place in file editor. DomElement.copyFrom() allows you to copy information from one DomElement to another. In fact, it just replaces XML tags, and all the old data is lost. Nevertheless, the element's fixed-number children don't become invalid, they only contain new tag values, attribute values, etc. The tree is actually rather conservative. The combination of createMockElement() and copyFrom() is useful for editing element contents in dialogs. You create a mock copy of an element, work with it in the dialog and then, if the user doesn't cancel, copy the element back to the main model. Since it's a common case, a special shortcut method has been created in DomElement , called createMockCopy() . Consulo's XML parser is incremental: changes in text do not cause the whole file to be reparsed. But you should keep in mind that this rule may sometimes not work correctly. For example, your DOM elements can unexpectedly become broken as a result of manual editing of the XML file (even if it didn't happen inside those elements). If a file editor depends on such a broken element, this can lead to closing the tab, which isn't very nice from the user's point of view. For example, suppose you have an entity bean named \"SomeEntity\". You open an editor for it, then you go into the XML, change the tag name from entity to session, and then back to entity. Of course, no DOM element can survive after such blasphemy. But notwithstanding, you still want your editor to stay open! Well, there is a solution, and it's called DomManager.createStableValue(Factory factory) . This method creates a DOM element that delegates all its functionality to some real element (returned from the factory parameter). As soon as that real element becomes invalid, the factory is called once more, and if it returns something valid, it becomes the new delegate. And so on... In the example with EJB, the factory would once again look for an Entity Bean named \"SomeEntity\". Stable DOM elements also implement the StableElement interface, which has the following methods: DomElement getWrappedElement() \u2014 just returns the current element to which all method calls are delegated; void invalidate() \u2014 makes the wrapped element invalid. Any following method call will cause the factory to create a new delegate; void revalidate() \u2014 calls the factory, and if it returns something new (i.e. not the same as the current wrapped element) invalidates the old value and adopts the new one. Visitor Visitor is a very common design pattern. DOM model also has a visitor, and it's called DomElementVisitor . The DomElement interface has methods accept() and acceptChildren() that take this visitor as a parameter. If you look at the interface DomElementVisitor itself, you may be surprised, since it has only one method: visitDomElement(DomElement) . Where is the Visitor pattern? Where are all those methods with names like visitT(T) that are usually found in it? There are no such methods, because the actual interfaces (T's) aren't known to anyone except you. But when you instantiate the DomElementVisitor interface, you may add there these visitT() methods, and they will be called! You may even name them just visit() , specify the type of the parameter, and everything will be fine. For example, if you have two DOM element classes \u2014 Foo and Bar \u2014 your visitor may look like this: class MyVisitor implements DomElementVisitor { void visitDomElement ( DomElement element ) {} void visitFoo ( Foo foo ) {} void visitBar ( Bar bar ) {} } Implementation Sometimes you may want to extend your model with some functionality that isn't directly connected with XML, but relates to your program logic. And the most appropriate place for this functionality is the DOM element interface. What to do then? The simplest case is when you want to add to your interface a method that returns exactly what some other getter in this element (or in one of its children) returns. You can easily write this helper method and annotate it with the @PropertyAccessor annotation, in which you should specify the path consisting of property names (getter names without the \"get\" or \"is\" prefixes). For example, you can write: GenericDomValue < String > getVeryLongName () @PropertyAccessor ( \"very-long-name\" ) GenericDomValue < String > getName () In this case, the second method will return just the same as the first one. If there were \"foo.bar.name\" instead of \"very-long-name\" in the annotation, the system would actually call getFoo().getBar().getName() and return the result to you. Such annotations are useful when you're extending some interface that is inconsistent with your model, or you try to extract a common super-interface from two model interfaces with differently named children that have the same sense (see <ejb-ref> and <ejb-local-ref> ). The case just described is simple, but rare. More often, you really have to incorporate some logic into your model. Then nothing except Java code helps you. And it will. Add the desired methods to your interface, then create an abstract class implementing the interface, and implement there only methods that you added manually and that are not directly connected to your XML model. Note that the class should have a constructor with no arguments. Now you only have to let DOM know that you wish to use this implementation every time you're creating a model element that should implement the necessary interface. Simply register it using extension point com.intellij.dom.implementation and DOM will generate at run-time the class that not only implements the needed interface, but also extends your abstract class. Models Across Multiple Files Many frameworks require a set of XML configuration files (\"fileset\") to work as one model, so resolving/navigation works across all related DOM files. Depending on implementation/plugin, providing filesets implicitly (using existing framework's setup in project) or via user configuration (usually via dedicated Facet ) can be achieved. Extend DomModelFactory (or BaseDomModelFactory for non- Module scope) and provide implementation of your DomModel . Usually you will want to add searcher/utility methods to work with your DomModel implementation. Example can be found in Struts 2 plugin (package com.intellij.struts2.dom.struts.model ). DOM Stubs NOTE Please use it sparingly and only for heavily accessed parts in your DOM model, as it increases disk space usage/indexing run time. DOM elements can be stubbed, so (costly) access to XML/PSI is not necessary (see Indexing and PSI Stubs for similar feature for custom languages). Performance relevant elements, tag or attribute getters can simply be annotated with @com.intellij.util.xml.Stubbed . Return true from DomFileDescription.hasStubs() and increase DomFileDescription.getStubVersion() whenever you change @Stubbed annotations usage in your DOM hierarchy to trigger proper rebuilding of Stubs during indexing. Building a DOM-Based GUI Forms All forms that deal with DOM are organized in a special way. They support two main things: getting data from XML into the UI, and saving UI data to XML. The former is called resetting, the latter \u2014 committing. There's Committable interface that has corresponding methods: commit() and reset() . There's also a way of structuring your forms into smaller parts, namely the Composite pattern: CompositeCommittable . Methods commit() and reset() are invoked automatically on editor tab switch or undo. So you only need to ensure that all your Swing structure is organized in a tree of CompositeCommittable , and all the hard work will be done by the IDE. DOM controls are special descendants of Committable . All of them implement DomUIControl . Note that they are not Swing components \u2014 they are only a way of connecting DOM model and Swing components. One end of the connection \u2014 the DOM element \u2014 is usually specified in the controls constructor. The other end \u2014 Swing component \u2014 can be obtained in 2 ways. The first is to ask DOM control to create it. But that is rather inconvenient if you want to create the forms in, say, IntelliJ IDEA's GUI Designer. In that case, you'll need the second way: ask the control to bind() to an existing Swing component of a correct type (that depends on the type of value that you're editing). After that, your Swing components will be synchronized with DOM, they'll even highlight errors reported by DomElementsAnnotator . Sometimes you may need to do some work (enable or disable some components, change their values) after a particular DOM control is committed. Then you should define the addCommitListener() method of that DOM control and override the CommitListener.afterCommit() method. This method will be invoked inside the same write action as the main commit() , so any changes you do in this method to the XML will be merged with the commit() in the Undo queue. Simple Controls With simple controls, you can edit GenericDomValue : simple text, class names, enums and boolean values. These controls take a special object as a constructor parameter. This object should implement the DomWrapper interface that knows how to set/get values to/from DOM model. We have three major DomWrapper's: DomFixedWrapper<T> redirecting calls to GenericDomValue<T> , DomStringWrapper redirecting calls to string accessors of GenericDomValue , and DomCollectionWrapper that gets/sets values of the first element of the given GenericDomValue collection. Some controls (those having a text field as part of itself) take additional boolean constructor parameter \u2014 commitOnEveryChange , whose meaning is evident from the name. We don't recommend using it anywhere except small dialogs, because committing on every change slows down the system significantly. Most often these controls are created by DomUIFactory.createControl(GenericDomValue) . This method understands which control to create by using DOM reflection ( DomGenericInfo , as you probably remember). But sometimes you may want to create the controls directly. So let's look at the simple controls more closely. BooleanControl It allows you to edit boolean values. The control is bound to JCheckBox . ComboControl The control is bound to a non-editable JComboBox , so it can be used to choose something from a limited set. One case of such a limited set is enum. Or it can be a constructor where you can provide a Factory<List<String>> , and return from this factory anything you want (for example, a list of database names to choose from). By default, the wrong values (written in XML, but not present in the list you've given to the control) are displayed in red. Since it's common practice to specify custom CellRenderer for combo boxes, the control has the isValidValue(String) method. If it returns false on the value you're rendering, you can highlight it in some way, to achieve the same result as the default renderer. Or you can just delegate to that renderer in your own way. BooleanEnumControl Sometimes, when there are only 2 alternatives, it's convenient to use a check box instead of combo box. This control is designed specially for such cases. While being (and being bound to) a check box, the control edits not just \"true\" or \"false\", but any two String values, or two enum elements. In the last case, it has a boolean invertedOrder parameter, to specify which element corresponds to the checked state. By default invertedOrder is set to false , so the first element corresponds to the unchecked state, and the second \u2014 to the checked one. If you set the parameter to true , the states will swap. Editor-Based Controls Please note that editor-based controls are built on Consulo's Editor instead of standard JTextField . Since there's currently no way to instantiate Editor directly through the Open API, controls are bound to special JPanel inheritors, and their bind() method adds the necessary content to those panels. TextControl This control allows you to edit simple string values. The control is bound to a TextPanel component. There's also an inheritor of that panel \u2014 MultiLineTextPanel . If you bind a StringControl to it, a big editor will appear on the screen. In case you don't have space for a big editor, bind it to a BigTextPanel . Then it will be filled with a text editor, and the browse button will be added to open a dialog with the big editor where you can type a longer string. PsiClassControl This is a one-line editor with a browse button that opens the standard class selection dialog. The control accepts class names only. It is bound to PsiClassPanel . PsiTypeControl This is almost the same as PsiClassControl, but allows entering not only class names, but also Java primitive types and even arrays. It is bound to PsiTypePanel . Collection Control There is a special table component where each row represents one collection child. It's called DomCollectionControl<T> , where T is your collection element type. To function properly, it needs DomElement (parent of the collection), some description of the collection (sub-tag name or a DomCollectionChildDescription from DOM reflection), and a ColumnInfo array. This can be passed to the constructor, or can be created in a DomCollectionControl inheritor, in an overriden method createColumnInfos() . What is a column info? It's just a somewhat more comfortable way to work with the table model. It uses Java 5 generics and is more object-oriented. So, it's named ColumnInfo<Item,Aspect> , where Item is a type variable corresponding to the type of elements in the collection, and Aspect is a type variable corresponding to this particular column information type: String , PsiClass , Boolean , etc. The basic things that a column knows are: column name, column class, reading value (Aspect valueOf(Item) ), writing value ( setValue(Item item, Aspect aspect) ), cell renderer ( getRenderer(Item) ), cell \"editability\" ( isCellEditable(Item) ), cell editor ( getEditor(Item) ), etc. There are a lot of predefined column infos, so you'll probably never create a new one. First, if a collection child is a GenericDomValue , it's usually convenient to edit it directly in the table. For this, you may need one of the following classes: StringColumnInfo , BooleanColumnInfo , or more generic GenericValueColumnInfo . But such collections are encountered very rarely. A more common case is when a collection element is more complex and has several GenericDomValue children. Then one may create a column for each of those children. The appropriate column info is ChildGenericValueColumnInfo<T> . It will ask you for a DomFixedChildDescription (one more thing from DOM reflection), a renderer and an editor \u2014 nothing else. So, the main things left to customize are the renderer and the editor. As for the renderer, there are two main choices: DefaultTableCellRenderer , and Consulo's BooleanTableCellRenderer . Editors are more complicated, but they closely resemble simple DOM controls. BooleanTableCellEditor , DefaultCellEditor(JTextField) , ComboTableCellEditor , etc. DomUIFactory.createCellEditor() will create any of them automatically (including the editor for PsiClass ), so that you won't need to think about which one to select every time. Collection control is a complex control, so it's bound to a complex Swing component. It's called DomTableView . It has a toolbar (you can override DomTableView.getToolbarPosition() to customize its location), with Add and Delete buttons. If you want, you may specify custom addition actions in DomCollectionControl.createAdditionActions() (it's recommended to extend ControlAddAction ). If there is only one addition action, it will be invoked after pressing the Add button; if there are many, then a popup menu will be displayed. To change the removal policy, override the DomCollectionControl.doRemove(List<T>) method. The toolbar may also have an Edit button, if you specify that DomCollectionControl.isEditable() . To add a behavior to this button, override DomCollectionControl.doEdit(T) . There can also be a Help button, if you pass a non-null String helpId parameter while constructing your DomTableView . If there are no items in the collection, DomTableView may display a special text ( DomTableView.getEmptyPaneText() ), instead of an empty table. You can add your own popup menu to the control. Call the DomTableView.installPopup() method after construction, and pass a DefaultActionGroup with your popup actions. Tables can have single or multiple (default) row selection. If you want to change this behavior, override DomTableView.allowMultipleRowsSelection() . UI Organization The easiest way to create a DOM-based UI form is to extend the BasicDomElementComponent class. This will require you to pass some DOM element to the constructor. Then you bind an IntelliJ IDEA GUI Designer form to your subclass and design a beautiful form there. You will surely want to bind some controls to DOM UI, in which case you should of course ensure that they have right types. Finally, you should create some DOM controls in class' constructor and bind them. But you can create controls and bind them to the DomElement 's children \u2014 GenericDomValue 's automatically. Just name your components properly and call the bindProperties() method in the constructor. The field names should correspond to the getter names for the element's children. They may also be prefixed with \"my\". Imagine that you have such DOM interface: public interface Converter extends DomElement { GenericDomValue < String > getConverterId (); GenericDomValue < PsiClass > getConverterClass (); } In this case, the UI form class can look like this: public class ConverterComponent extends BasicDomElementComponent < Converter > { private JPanel myRootPane ; private TextPanel myConverterId ; private PsiClassPanel myConverterClass ; public ConverterComponent ( final Converter domElement ) { super ( domElement ); bindProperties (); } } All the fields here are now bound to controls in a GUI form. Very often you'll have to create your own file editor. Then, to use all the binding and undo functionality, it's suggested to inherit your FileEditorProvider from PerspectiveFileEditorProvider , create an instance of DomFileEditor there, and pass a BasicDomElementComponent . To easily create an editor with a caption at the top, like in our EJB and JSF, you may use the static method DomFileEditor.createDomFileEditor() . DomFileEditor automatically listens to all changes in the document corresponding to the given DOM element, and therefore refreshes your component on undo. If you want to listen to changes in additional documents, use the methods addWatchedDocument() , removeWatchedDocument() , addWatchedElement() , removeWatchedElement() in DomFileEditor . Conclusion Thank you for your time and attention. We hope you've found this article really useful. You are welcome to post your questions and comments to our Open API and Plugin Development Forum . Further Material The following bundled open-source plugins make (heavy) use of DOM: Android Ant Plugin DevKit Maven Struts 2 (Ultimate Edition)","title":"XML DOM API"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#abstract","text":"This article is intended for plugin writers who create custom web server integrations, or some UI for easy XML editing. It describes the Document Object Model (DOM) in Consulo --- an easy way to work with DTD or Schema-based XML models. The following topics will be covered: working with DOM itself (reading/writing tags content, attributes, and subtags) and easy XML editing in the UI by connecting UI to DOM. It's assumed that the reader is familiar with Java, Swing, Consulo XML PSI (classes XmlTag , XmlFile , XmlTagValue , etc.), Consulo plugin development basics (application and project components, file editors).","title":"Abstract"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#introduction","text":"So, how to operate with XML from an Consulo plugin? Usually, one has to take XmlFile , get its root tag, and then find a required sub-tag by path. The path consists of tag names, each of them a string. Typing these everywhere is tedious and error-prone. Let's assume you have the following XML: <root> <foo> <bar> 42 </bar> <bar> 239 </bar> </foo> </root> Let's say you want to read the contents of the second bar element, namely, \"239\". It's not correct to create chained calls like file . getDocument (). getRootTag (). findFirstSubTag ( \"foo\" ). findSubTags ( \"bar\" ) [ 1 ] . getValue (). getTrimmedText () because each call here may return null . So the code would probably look like this: XmlFile file = ...; final XmlDocument document = file . getDocument (); if ( document != null ) { final XmlTag rootTag = document . getRootTag (); if ( rootTag != null ) { final XmlTag foo = rootTag . findFirstSubTag ( \"foo\" ); if ( foo != null ) { final XmlTag [] bars = foo . findSubTags ( \"bar\" ); if ( bars . length > 1 ) { String s = bars [ 1 ] . getValue (). getTrimmedText (); // do something } } } } Looks awful, doesn't it? But there's a better way to do the same thing. You just need to extend a special interface --- DomElement . For example, let's create several interfaces: interface Root extends com . intellij . util . xml . DomElement { Foo getFoo (); } interface Foo extends com . intellij . util . xml . DomElement { List < Bar > getBars (); } interface Bar extends com . intellij . util . xml . DomElement { String getValue (); } Next, you should create a DomFileDescription object, pass to its constructor the root tag name and root element interface, and register it with extension point com.intellij.dom.fileDescription . NOTE If your plugin targets 2019.1 or later, please use extension point com.intellij.dom.fileMetaData instead and specify rootTagName and domVersion / stubVersion in plugin.xml . You can now get the file element from DomManager . To get the \"239\" value, you only have to write the following code: DomManager manager = DomManager . getDomManager ( project ); Root root = manager . getFileElement ( file ). getRootElement (); List < Bar > bars = root . getFoo (). getBars (); if ( bars . size () > 1 ) { String s = bars . get ( 1 ). getValue (); // do something } I suppose this looks a little bit nicer. You often work with your model in more than one place. Re-creating the model is too inefficient, so we cache it for you, and any subsequent calls to DomManager.getFileElement() will return the same instance. So, it is useful to invoke this method just once, and then keep everywhere only the \"root\" object you've obtained. In this case you wont need to repeat that scary first line, and the code will look even nicer. It is also important to note that with this scenario we avoid potential NullPointerException : our DOM guarantees that every method accessing a tags child will return a not-null element, even if the correspondingly-named sub-tag doesn't exist. That may seem strange at a first glance, but it appears to be rather convenient. How does it work? Simple. Given those interfaces, DOM generates all code for accessing correct sub-tags and creating model elements at runtime. The sub-tag names and element types are taken from method names, return types and method annotations, if any. In most cases annotations can be omitted, as in our example, but this is discussed further in this article anyway. Now let us explore more thoroughly what the DOM can do, and look at possible ways of representing various XML concepts such as tag content, attributes or sub-tags. Later we will discuss basic methods for working with the model, as well as cover more advanced functionality. Finally, we'll see how to easily create an UI editor for DOM model elements.","title":"Introduction"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#building-the-model","text":"","title":"Building the Model"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#tag-content","text":"In XML PSI, tag content is referred to as tag value, so well do the same for consistency. To read and change a tag value, you have to add two methods (getter and setter) to your interface, like this: String getValue (); void setValue ( String s ); These method names ( getValue and setValue ) are standard, and they are used for accessing tag values by default. If you want to use custom method names for the same goal, you should annotate these methods with @TagValue , for example: @TagValue String getTagValue (); @TagValue void setTagValue ( String s ); As you can see, our accessors work with String values. This is natural, since XML represents a text format, and tag content is always text. But sometimes you may want to operate with integers, booleans, enums, or even class names (they, of course, will be represented as PsiClass ), and more generic Java types ( PsiType ). In such cases, you just need to change the type in methods to the one you need, and everything will keep working correctly.","title":"Tag Content"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#custom-value-types","text":"If you operate with even more exotic types, you should tell DOM how to deal with them. First, annotate your accessor methods with the @Convert annotation, and specify your own class that should extend the Converter<T> class in the annotation. Here T is your exotic type, while Converter<T> is a thing that knows how to convert values between String and T . If the value cannot be converted (for example, \"foo\" is not convertible into Integer ), the converter may return null . Please also note that your implementation should have a no-argument constructor. Let us consider an interesting case when T represents an enum value. Usually, the converter just searches for enum elements with the names specified in XML. But sometimes, for their names, you may need or want to use values that are not valid Java identifiers. For example, CMP version in EJB may be \"1.x\" or \"2.x\", but you can't create Java enums with such names. For such cases, let your enum implement NamedEnum interface, and then name your enum elements as you wish. Now, just provide the getValue() implementation that will return the right value to match with XML contents, and voil\u00e0! In our example, the code will look as follows: enum CmpVersion implements NamedEnum { CmpVersion_1_X ( \"1.x\" ), CmpVersion_2_X ( \"2.x\" ); private final String value ; private CmpVersion ( String value ) { this . value = value ; } public String getValue () { return value ; } } As we have already mentioned, an XML tag may have lots of artifacts besides its value: there can be attributes, children, but rather often (e.g., according to DTD or Schema) it should have only the value. Of course such tags also need a DOM element to associate with. And we provide such an element: interface GenericDomValue < T > { T getValue (); void setValue ( T t ); @TagValue String getStringValue (); @TagValue void setStringValue ( String s ); } So, you can just specify a particular T when using this interface --- and everything will work. Methods that work with String are provided for many reasons. For example, your T is PsiClass . It would be useful to highlight invalid values in UI. To get the value to highlight (the string from the XML file) we have the getStringValue() method. The error message will be taken from the converter via getErrorMessage() .","title":"Custom Value Types"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#attributes","text":"Attributes are also rather simple to deal with. You can read their values, set them, and operate with different types. So it's natural to create something like GenericDomValue<T> and then work as usual. \"Something like\" will be an inheritor, as shown below: interface GenericAttributeValue < T > extends GenericDomValue < T > { XmlAttribute getXmlAttribute (); } Consider that you want to work with an attribute named some-class having a value of type PsiClass : @Attribute ( \"some-class\" ) GenericAttributeValue < PsiClass > getMyAttributeValue (); That's all! Now you can get/set values, resolve this PsiClass , get its String representation, etc. The name of the attribute will be taken from the method name (see next paragraph). If you name your method in a special way, you can even omit the annotation. For example: GenericAttributeValue < PsiClass > getSomeClass (); The DomNameStrategy interface specifies how to convert accessor names to XML element names. Or more precisely, not the full accessor names, but rather the names minus any \"get\", \"set\" or \"is\" prefixes. The strategy class is specified in the @NameStrategy annotation in any DOM element interface. Then any descendants and children of this interface will use this strategy. The default strategy is HyphenNameStrategy , where words are delimited by hyphens (see sample above). Another common variant is JavaNameStrategy that capitalizes the first letter of each word, as in Java's naming convention. In our example, the attribute name would be \"someClass\". If attribute doesn't define a PsiClass , but some other custom T that needs a converter, you just need to specify the @Convert annotation to the getter. Please note that the attributes getter method will never return null , even if the attribute isn't specified in XML. Its getValue() , getStringValue() and getXmlAttribute() methods will return null , but the DOM interface instance will exist and be valid. If the element has an underlying attribute, this can be easily fixed (surely, only if you need that): just call the undefine() method (defined in DomElement ), and the XML attribute disappears, while GenericAttributeValue remains valid.","title":"Attributes"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#children-fixed-number","text":"You may often deal with tags that have at most one sub-tag with the given name (e.g. <ejb-name> , <ejb-class> or <cmp-field> ) in tags defining entity EJBs. To work with such children, provide getters for them. These getters should have a return type that extends DomElement : GenericDomValue < String > getEjbName (); GenericDomValue < String > getEjbClass (); CmpField getCmpField (); There's also an annotation to designate such children explicitly: @SubTag . Its \"value\" attribute contains a tag name. If it is not specified, the name is implied from the method name using the current name strategy. Sometimes it is the sub-tag's presence that means something, rather than its content --- <unchecked> in EJB method permissions, for example. If it exists, then permissions are unchecked, otherwise checked. For such things one should create a special GenericDomValue<Boolean> child. Usually its getValue() returns true if there's \"true\" in a tag value, false if there's \"false\" in a tag value, and null otherwise. In the @SubTag annotation, you can specify the attribute like indicator=true . In this case, getValue() will return true if the tag exists and false otherwise. Let's consider another interesting example inspired by EJB, where there is a relation that has two roles, each designating one relation end: first role and second role. Both are represented by tags with the same values. So, we could create a collection of role elements, and every time we access some role we would check if this collection has sufficient number of elements. But one of the main purposes of the DOM is to eliminate unnecessary checks. So why cant we have a fixed (more than one) number of children with the same tag name? Let's have them! @SubTag ( value = \"ejb-relationship-role\" , index = 0 ) EjbRelationshipRole getEjbRelationshipRole1 (); @SubTag ( value = \"ejb-relationship-role\" , index = 1 ) EjbRelationshipRole getEjbRelationshipRole2 (); The first method will return the DOM element for the first subtag named <ejb-relationship-role> , and the second --- for the second one. Hence the term \"fixed-number\" for such children. According to DTD or Schema, there should be fixed number of subtags with the given name. Most often this fixed number is 1; in our case with the relations it is 2. Just like attributes, fixed-number children exist regardless of underlying tag existence. If you need to delete tags, it can be done with the help of the same undefine() method. For children of GenericDomValue type, you can also specify a converter, just as you can for attributes.","title":"Children: Fixed Number"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#children-collections","text":"One more common case in DTD and Schemas is when children have the same tag name and a non-fixed upper limit in count. Their accessors differ from those of the fixed-number children in the following: the return result is Collection or List of a special type that extends DomElement , and if you want to use name strategies, the method name must be in pluralized form. For example, in EJB we would have the following method: List < Entity > getEntities (); There's also an annotation @SubTagList where you can explicitly specify the tag name. Returned collections cannot be modified directly. To delete an element from collection, just call undefine() on this element. The tag will then be removed, and element will become invalid ( DomElement.isValid() == false ). Note that this behavior differs from that of fixed-number children and attributes: they are always valid, even after undefine() . Again, unlike those children types, collection children always have valid underlying XML tags. Adding elements is a little bit harder. Since all DOM elements are created internally, you can't just pass some of your DOM elements to some method, to add the element to the collection. In fact, you have to ask a parent element to add a child to the collection. In our example it's done in the following way: Entity addEntity ( int index ); which adds an element to wherever you want, or Entity addEntity (); which adds a new DOM element to the end of the collection. Please note the singular tense of the word \"Entity\". That's because here we deal with one Entity object, while in the collection getter we dealt with potentially many entities. Now, you can do anything you want with the returned value: modify, define the tag's value, children, etc. The last common case is also a collection, but one consisting of tags with different names that are arbitrarily mixed. To work with it, you should define collection getters for all tag names within the mixed collection, and then define an additional specially annotated getter: // <foo> elements List < Foo > getFoos (); // <bar> elements List < Bar > getBars (); // all <foo> and <bar> elements @SubTagsList ({ \"foo\" , \"bar\" }) List < FooBar > getMergedListOfFoosAndBars (); The annotation here is mandatory - we cannot guess several tag names from one method name. To add elements to such mixed collections, you should create \"add\" methods for each possible tag name: @SubTagsList ( value = { \"foo\" , \"bar\" }, tagName = \"foo\" ) Fubar addFoo (); @SubTagsList ( value = { \"foo\" , \"bar\" }, tagName = \"bar\" ) Fubar addBar ( int index ); The index parameter in the last example means the index in the merged collection, not in the collection of tags named \"bar\".","title":"Children: Collections"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#dynamic-definition","text":"You can extend existing DOM model at runtime by implementing com.intellij.util.xml.reflect.DomExtender<T> . Register it in \"extenderClass\" attribute of EP com.intellij.dom.extender , where \"domClass\" specifies DOM class <T> to be extended. DomExtensionsRegistrar provides various methods to register dynamic attributes and children. If the contributed elements depend on anything other than plain XML file content (used framework version, libraries in classpath, ...), make sure to return false from DomExtender.supportsStubs() .","title":"Dynamic Definition"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#generating-dom-from-existing-xsd","text":"DOM can be generated automatically from existing XSD/DTD. Output correctness/completeness will largely depend on the input scheme and may require additional manual adjustments. Follow these steps: Run IntelliJ IDEA with Plugin DevKit enabled in internal mode Select Tools | Internal Actions | DevKit | Generate DOM Model Select Scheme file and set options, then click \"Generate\" to generate sources Modify generated sources according to your needs","title":"Generating DOM from Existing XSD"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#ide-support","text":"Plugin DevKit supports the following features for working with DOM related code: DomElement - provide implicit usages for all DOM-related methods defined in inheriting classes (to suppress \"unused method\" warning) DomElementVisitor - provide implicit usages for all DOM-related visitor methods defined in inheriting classes (to suppress \"unused method\" warning)","title":"IDE Support"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#working-with-the-dom","text":"","title":"Working with the DOM"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#class-choosers","text":"It often happens that a collection contains same-named tags that may have different structure or even be represented by different types in the DTD or Schema. As an example, JSF Managed Beans may be of three types. If a <managed-bean> tag contains a <map-entries> sub-tag, then the Managed Bean type is MapEntriesBean . If it contains a <list-entries> sub-tag \u2014 can you guess? Right \u2014 ListEntriesBean ! Otherwise it's a PropertyBean (all three interfaces extend ManagedBean ). And when we write List<ManagedBean> getManagedBeans() , we expect to get not only a list where all elements are instances of the ManagedBean interface, but a list where each element is of a certain type, i.e. MapEntriesBean , ListEntriesBean , or PropertyBean . In such cases one should decide which interface the DOM element should actually implement (according to the given tag). This is achieved by extending the TypeChooser abstract class: public abstract class TypeChooser { public abstract Type chooseType ( XmlTag tag ); public abstract void distinguishTag ( XmlTag tag , Type aClass ) throws IncorrectOperationException ; public abstract Type [] getChooserTypes (); } Here, the first method ( chooseType() ) does exactly what it is named after (chooses the particular type, most often it's a class). The second one ( distinguishTag() ) acts in reverse: it modifies a tag so that when the element is read from an XML file next time (for example, after the user has closed and opened the project again), the newly created DOM element will implement the same interface and no model data will be lost. Finally, getChooserTypes() just returns all the types that could be returned by chooseType() . To make your TypeChooser work, register it in your overridden DomFileDescription.initializeFileDescription() method by calling registerTypeChooser() .","title":"Class Choosers"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#useful-methods-of-domelement-and-dommanager","text":"","title":"Useful Methods of DomElement and DomManager"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#psi-connection","text":"Of course, DOM is tightly connected to XML PSI, so there's always a way of getting the XmlTag instance (which can be null for fixed-number children and attributes) using the getXmlTag() method. We remember that in GenericAttributeValue there's also the getXmlAttribute() method. In general case there is getXmlElement() method. You can also get a DOM element by its underlying XML PSI element using the DomManager.getDomElement() method. If DOM element has no underlying XML element, it can be created by calling ensureTagExists() . To delete a tag, use the already known undefine() method. This method will always delete the underlying XML element (tag or attribute). If the element was a collection child, then neither it nor its entire sub-tree will be valid anymore.","title":"PSI Connection"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#tree-structure","text":"In every normal tree there's always a possibility to walk up. DomElement is no exception. Method getParent() just returns element's parent in tree. The method <T extends DomElement> T getParentOfType(Class<T> requiredClass, boolean strict) returns the tree ancestor of the given class. You can see the standard strict parameter, that can return the DOM element itself, if it's false and your current DOM element is an instance of requiredClass . Finally, getRoot() will return the DomFileElement , which is the root of every DOM tree.","title":"Tree Structure"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#validity","text":"An element becomes invalid if it has been deleted explicitly or due to external PSI changes. Fixed-number children and attributes are meant to stay valid as long as possible, no matter what happens with XML. They can become invalid only if they have collection tree ancestor that has been deleted. Newly created DOM elements are always correct and valid, so their isValid() methods will return true . Element validity is very important, since you cannot invoke any methods on invalid elements (except, of course, isValid() itself).","title":"Validity"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#dom-reflection","text":"DOM also has a kind of reflection, called \"Generic Info\". One would use it to be able to access children by tag names directly, instead of calling getter methods. See DomGenericInfo interface and getGenericInfo() methods in DomElement and DomManager for more information. There's also DomElement.getXmlElementName() method that returns the name of a corresponding tag or attribute.","title":"DOM Reflection"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#presentation","text":"DomElement.getPresentation() returns an instance of ElementPresentation , an interface that knows presentable element type, name, and sometimes even its icon. Presentations are actually obtained from presentation factory objects that, like ClassChoosers's, should be registered in ElementPresentationManager as early as possible. You can specify type name and icon for all elements of some class, ways of getting type name, icon and presentable name for particular objects. When not specified, presentable name is taken from the object itself, if it contains a method annotated with @NameValue annotation, that returns String or GenericValue . If there's no such method, it will return null . For DomElement , there's another way to get this presentable name: DomElement.getGenericInfo().getElementName() .","title":"Presentation"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#events","text":"If you want to be notified on every change in the DOM model, add DomEventListener to DomManager . DOM supports the following events: tag value changed, element defined/undefined/changed, and collection child added/removed.","title":"Events"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#highlighting-annotations","text":"The DOM supports error checking and highlighting. It's based on annotations which you add to the DOM element in a special place (don't confuse these annotations with the ones of Java 5 \u2014 they are very different). You need to implement the DomElementAnnotator interface, and override DomFileDescription.createAnnotator() method, and create this annotator there. In DomElementsAnnotator.annotate(DomElement element, DomElementsProblemsHolder annotator) you should report about all errors and warnings in the element's sub-tree to the annotator ( DomElementsProblemsHolder.createProblem() ). You should return this annotator in the corresponding virtual method of the DomFileDescription .","title":"Highlighting Annotations"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#automatic-highlighting-basicdomelementsinspection","text":"The following errors can be highlighted automatically by providing an instance of BasicDomElementsInspection : @Required element missing or having empty text XML value cannot be converted by some Converter name is not unique while it should be The latter case requires you to specify the name getter with @NameValue annotation. The checking uses the DomFileDescription.getIdentityScope() method to get the element defining the root scope in which the name should be unique. To suppress spellchecking annotate your DomElement with @com.intellij.spellchecker.xml.NoSpellchecking .","title":"Automatic Highlighting (BasicDomElementsInspection)"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#required-children","text":"There is a common case in error highlighting, when one needs to say, that some required sub-tag or attribute is missing. DOM will do this for you automatically, if you annotate the getter for that child with the @Required annotation. For collection children getters, this annotation will mean, that the collection should be not empty (corresponding to '+' sign in DTD). Also, when you create a new element that has required fixed-number or attribute children, their tags or attributes will also be created in XML.","title":"Required Children"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#resolving","text":"Remember the interface GenericDomValue<T> and its sub-interface GenericAttributeValue<T> ? Remember, that ANY class may be passed as T \u2014 for example, let's interpret GenericDomValue<PsiClass> as a reference to a class. Then we can always consider it as a reference to an object of class T ! With Strings or enums, it is not a very useful idea, but we'll use it in another way. Very often XML has such a structure that an object is declared at some place, and is referenced at some other place (more precisely, in a tag or attribute value). So, if you want to create a method like GenericValue<MyDomElement> getMyDomElementReference() , then you just have to specify a proper converter that will find an instance in your model of MyDomElement with the name specified in the GenericDomValue . That's the core idea. Since creating such converters is quite boring, we've done it for you. You don't have to annotate reference getters at all, as the name resolution will be made automatically. Elements will be searched by name, and the name will be taken from the method annotated with @NameValue . The converter used is DomResolveConverter . Its constructor takes a parameter, so it can't be referenced in @Convert annotation, but its subclasses (if you create them) \u2014 can. If you still want to specify explicitly that your reference to DomElement should be resolved \"model-wide\", use the @Resolve annotation parameterized with the desired class. The resolution scope will be taken from the DomFileDescription.getResolveScope() . In addition to the above, auto-resolving in DOM also provides some features in your XML text editor: error highlighting, completion, Find Usages, Rename Refactoring... Unresolved references will be highlighted, and even completed. If you want to create a custom converter and want to have this code insight with it, you should extend not only the Converter but ResolvingConverter . It has one more method getVariants() , where you'll have to provide the collection consisting of all targets your reference may resolve to. Those familiar with PsiReference will recognize the similarities here. If you need to choose a Converter depending on other values (e.g. in sibling/parent element) or any runtime condition (e.g. presence or version of library), you can use WrappingConverter . See also GenericDomValueConvertersRegistry for managing an extensible registry of available Converters to choose from.","title":"Resolving"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#mock-and-stable-elements","text":"Your DOM elements do not have to be tied to a physical file. DomManager.createMockElement() will help you to create a virtual element of a given class with the given module. An element may be physical or not. 'Physical' here means that DOM will create a mock document for it, so you can enjoy Undo functionality if you pass this document to the right place in file editor. DomElement.copyFrom() allows you to copy information from one DomElement to another. In fact, it just replaces XML tags, and all the old data is lost. Nevertheless, the element's fixed-number children don't become invalid, they only contain new tag values, attribute values, etc. The tree is actually rather conservative. The combination of createMockElement() and copyFrom() is useful for editing element contents in dialogs. You create a mock copy of an element, work with it in the dialog and then, if the user doesn't cancel, copy the element back to the main model. Since it's a common case, a special shortcut method has been created in DomElement , called createMockCopy() . Consulo's XML parser is incremental: changes in text do not cause the whole file to be reparsed. But you should keep in mind that this rule may sometimes not work correctly. For example, your DOM elements can unexpectedly become broken as a result of manual editing of the XML file (even if it didn't happen inside those elements). If a file editor depends on such a broken element, this can lead to closing the tab, which isn't very nice from the user's point of view. For example, suppose you have an entity bean named \"SomeEntity\". You open an editor for it, then you go into the XML, change the tag name from entity to session, and then back to entity. Of course, no DOM element can survive after such blasphemy. But notwithstanding, you still want your editor to stay open! Well, there is a solution, and it's called DomManager.createStableValue(Factory factory) . This method creates a DOM element that delegates all its functionality to some real element (returned from the factory parameter). As soon as that real element becomes invalid, the factory is called once more, and if it returns something valid, it becomes the new delegate. And so on... In the example with EJB, the factory would once again look for an Entity Bean named \"SomeEntity\". Stable DOM elements also implement the StableElement interface, which has the following methods: DomElement getWrappedElement() \u2014 just returns the current element to which all method calls are delegated; void invalidate() \u2014 makes the wrapped element invalid. Any following method call will cause the factory to create a new delegate; void revalidate() \u2014 calls the factory, and if it returns something new (i.e. not the same as the current wrapped element) invalidates the old value and adopts the new one.","title":"Mock and Stable Elements"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#visitor","text":"Visitor is a very common design pattern. DOM model also has a visitor, and it's called DomElementVisitor . The DomElement interface has methods accept() and acceptChildren() that take this visitor as a parameter. If you look at the interface DomElementVisitor itself, you may be surprised, since it has only one method: visitDomElement(DomElement) . Where is the Visitor pattern? Where are all those methods with names like visitT(T) that are usually found in it? There are no such methods, because the actual interfaces (T's) aren't known to anyone except you. But when you instantiate the DomElementVisitor interface, you may add there these visitT() methods, and they will be called! You may even name them just visit() , specify the type of the parameter, and everything will be fine. For example, if you have two DOM element classes \u2014 Foo and Bar \u2014 your visitor may look like this: class MyVisitor implements DomElementVisitor { void visitDomElement ( DomElement element ) {} void visitFoo ( Foo foo ) {} void visitBar ( Bar bar ) {} }","title":"Visitor"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#implementation","text":"Sometimes you may want to extend your model with some functionality that isn't directly connected with XML, but relates to your program logic. And the most appropriate place for this functionality is the DOM element interface. What to do then? The simplest case is when you want to add to your interface a method that returns exactly what some other getter in this element (or in one of its children) returns. You can easily write this helper method and annotate it with the @PropertyAccessor annotation, in which you should specify the path consisting of property names (getter names without the \"get\" or \"is\" prefixes). For example, you can write: GenericDomValue < String > getVeryLongName () @PropertyAccessor ( \"very-long-name\" ) GenericDomValue < String > getName () In this case, the second method will return just the same as the first one. If there were \"foo.bar.name\" instead of \"very-long-name\" in the annotation, the system would actually call getFoo().getBar().getName() and return the result to you. Such annotations are useful when you're extending some interface that is inconsistent with your model, or you try to extract a common super-interface from two model interfaces with differently named children that have the same sense (see <ejb-ref> and <ejb-local-ref> ). The case just described is simple, but rare. More often, you really have to incorporate some logic into your model. Then nothing except Java code helps you. And it will. Add the desired methods to your interface, then create an abstract class implementing the interface, and implement there only methods that you added manually and that are not directly connected to your XML model. Note that the class should have a constructor with no arguments. Now you only have to let DOM know that you wish to use this implementation every time you're creating a model element that should implement the necessary interface. Simply register it using extension point com.intellij.dom.implementation and DOM will generate at run-time the class that not only implements the needed interface, but also extends your abstract class.","title":"Implementation"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#models-across-multiple-files","text":"Many frameworks require a set of XML configuration files (\"fileset\") to work as one model, so resolving/navigation works across all related DOM files. Depending on implementation/plugin, providing filesets implicitly (using existing framework's setup in project) or via user configuration (usually via dedicated Facet ) can be achieved. Extend DomModelFactory (or BaseDomModelFactory for non- Module scope) and provide implementation of your DomModel . Usually you will want to add searcher/utility methods to work with your DomModel implementation. Example can be found in Struts 2 plugin (package com.intellij.struts2.dom.struts.model ).","title":"Models Across Multiple Files"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#dom-stubs","text":"NOTE Please use it sparingly and only for heavily accessed parts in your DOM model, as it increases disk space usage/indexing run time. DOM elements can be stubbed, so (costly) access to XML/PSI is not necessary (see Indexing and PSI Stubs for similar feature for custom languages). Performance relevant elements, tag or attribute getters can simply be annotated with @com.intellij.util.xml.Stubbed . Return true from DomFileDescription.hasStubs() and increase DomFileDescription.getStubVersion() whenever you change @Stubbed annotations usage in your DOM hierarchy to trigger proper rebuilding of Stubs during indexing.","title":"DOM Stubs"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#building-a-dom-based-gui","text":"","title":"Building a DOM-Based GUI"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#forms","text":"All forms that deal with DOM are organized in a special way. They support two main things: getting data from XML into the UI, and saving UI data to XML. The former is called resetting, the latter \u2014 committing. There's Committable interface that has corresponding methods: commit() and reset() . There's also a way of structuring your forms into smaller parts, namely the Composite pattern: CompositeCommittable . Methods commit() and reset() are invoked automatically on editor tab switch or undo. So you only need to ensure that all your Swing structure is organized in a tree of CompositeCommittable , and all the hard work will be done by the IDE. DOM controls are special descendants of Committable . All of them implement DomUIControl . Note that they are not Swing components \u2014 they are only a way of connecting DOM model and Swing components. One end of the connection \u2014 the DOM element \u2014 is usually specified in the controls constructor. The other end \u2014 Swing component \u2014 can be obtained in 2 ways. The first is to ask DOM control to create it. But that is rather inconvenient if you want to create the forms in, say, IntelliJ IDEA's GUI Designer. In that case, you'll need the second way: ask the control to bind() to an existing Swing component of a correct type (that depends on the type of value that you're editing). After that, your Swing components will be synchronized with DOM, they'll even highlight errors reported by DomElementsAnnotator . Sometimes you may need to do some work (enable or disable some components, change their values) after a particular DOM control is committed. Then you should define the addCommitListener() method of that DOM control and override the CommitListener.afterCommit() method. This method will be invoked inside the same write action as the main commit() , so any changes you do in this method to the XML will be merged with the commit() in the Undo queue.","title":"Forms"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#simple-controls","text":"With simple controls, you can edit GenericDomValue : simple text, class names, enums and boolean values. These controls take a special object as a constructor parameter. This object should implement the DomWrapper interface that knows how to set/get values to/from DOM model. We have three major DomWrapper's: DomFixedWrapper<T> redirecting calls to GenericDomValue<T> , DomStringWrapper redirecting calls to string accessors of GenericDomValue , and DomCollectionWrapper that gets/sets values of the first element of the given GenericDomValue collection. Some controls (those having a text field as part of itself) take additional boolean constructor parameter \u2014 commitOnEveryChange , whose meaning is evident from the name. We don't recommend using it anywhere except small dialogs, because committing on every change slows down the system significantly. Most often these controls are created by DomUIFactory.createControl(GenericDomValue) . This method understands which control to create by using DOM reflection ( DomGenericInfo , as you probably remember). But sometimes you may want to create the controls directly. So let's look at the simple controls more closely.","title":"Simple Controls"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#booleancontrol","text":"It allows you to edit boolean values. The control is bound to JCheckBox .","title":"BooleanControl"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#combocontrol","text":"The control is bound to a non-editable JComboBox , so it can be used to choose something from a limited set. One case of such a limited set is enum. Or it can be a constructor where you can provide a Factory<List<String>> , and return from this factory anything you want (for example, a list of database names to choose from). By default, the wrong values (written in XML, but not present in the list you've given to the control) are displayed in red. Since it's common practice to specify custom CellRenderer for combo boxes, the control has the isValidValue(String) method. If it returns false on the value you're rendering, you can highlight it in some way, to achieve the same result as the default renderer. Or you can just delegate to that renderer in your own way.","title":"ComboControl"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#booleanenumcontrol","text":"Sometimes, when there are only 2 alternatives, it's convenient to use a check box instead of combo box. This control is designed specially for such cases. While being (and being bound to) a check box, the control edits not just \"true\" or \"false\", but any two String values, or two enum elements. In the last case, it has a boolean invertedOrder parameter, to specify which element corresponds to the checked state. By default invertedOrder is set to false , so the first element corresponds to the unchecked state, and the second \u2014 to the checked one. If you set the parameter to true , the states will swap.","title":"BooleanEnumControl"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#editor-based-controls","text":"Please note that editor-based controls are built on Consulo's Editor instead of standard JTextField . Since there's currently no way to instantiate Editor directly through the Open API, controls are bound to special JPanel inheritors, and their bind() method adds the necessary content to those panels.","title":"Editor-Based Controls"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#textcontrol","text":"This control allows you to edit simple string values. The control is bound to a TextPanel component. There's also an inheritor of that panel \u2014 MultiLineTextPanel . If you bind a StringControl to it, a big editor will appear on the screen. In case you don't have space for a big editor, bind it to a BigTextPanel . Then it will be filled with a text editor, and the browse button will be added to open a dialog with the big editor where you can type a longer string.","title":"TextControl"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#psiclasscontrol","text":"This is a one-line editor with a browse button that opens the standard class selection dialog. The control accepts class names only. It is bound to PsiClassPanel .","title":"PsiClassControl"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#psitypecontrol","text":"This is almost the same as PsiClassControl, but allows entering not only class names, but also Java primitive types and even arrays. It is bound to PsiTypePanel .","title":"PsiTypeControl"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#collection-control","text":"There is a special table component where each row represents one collection child. It's called DomCollectionControl<T> , where T is your collection element type. To function properly, it needs DomElement (parent of the collection), some description of the collection (sub-tag name or a DomCollectionChildDescription from DOM reflection), and a ColumnInfo array. This can be passed to the constructor, or can be created in a DomCollectionControl inheritor, in an overriden method createColumnInfos() . What is a column info? It's just a somewhat more comfortable way to work with the table model. It uses Java 5 generics and is more object-oriented. So, it's named ColumnInfo<Item,Aspect> , where Item is a type variable corresponding to the type of elements in the collection, and Aspect is a type variable corresponding to this particular column information type: String , PsiClass , Boolean , etc. The basic things that a column knows are: column name, column class, reading value (Aspect valueOf(Item) ), writing value ( setValue(Item item, Aspect aspect) ), cell renderer ( getRenderer(Item) ), cell \"editability\" ( isCellEditable(Item) ), cell editor ( getEditor(Item) ), etc. There are a lot of predefined column infos, so you'll probably never create a new one. First, if a collection child is a GenericDomValue , it's usually convenient to edit it directly in the table. For this, you may need one of the following classes: StringColumnInfo , BooleanColumnInfo , or more generic GenericValueColumnInfo . But such collections are encountered very rarely. A more common case is when a collection element is more complex and has several GenericDomValue children. Then one may create a column for each of those children. The appropriate column info is ChildGenericValueColumnInfo<T> . It will ask you for a DomFixedChildDescription (one more thing from DOM reflection), a renderer and an editor \u2014 nothing else. So, the main things left to customize are the renderer and the editor. As for the renderer, there are two main choices: DefaultTableCellRenderer , and Consulo's BooleanTableCellRenderer . Editors are more complicated, but they closely resemble simple DOM controls. BooleanTableCellEditor , DefaultCellEditor(JTextField) , ComboTableCellEditor , etc. DomUIFactory.createCellEditor() will create any of them automatically (including the editor for PsiClass ), so that you won't need to think about which one to select every time. Collection control is a complex control, so it's bound to a complex Swing component. It's called DomTableView . It has a toolbar (you can override DomTableView.getToolbarPosition() to customize its location), with Add and Delete buttons. If you want, you may specify custom addition actions in DomCollectionControl.createAdditionActions() (it's recommended to extend ControlAddAction ). If there is only one addition action, it will be invoked after pressing the Add button; if there are many, then a popup menu will be displayed. To change the removal policy, override the DomCollectionControl.doRemove(List<T>) method. The toolbar may also have an Edit button, if you specify that DomCollectionControl.isEditable() . To add a behavior to this button, override DomCollectionControl.doEdit(T) . There can also be a Help button, if you pass a non-null String helpId parameter while constructing your DomTableView . If there are no items in the collection, DomTableView may display a special text ( DomTableView.getEmptyPaneText() ), instead of an empty table. You can add your own popup menu to the control. Call the DomTableView.installPopup() method after construction, and pass a DefaultActionGroup with your popup actions. Tables can have single or multiple (default) row selection. If you want to change this behavior, override DomTableView.allowMultipleRowsSelection() .","title":"Collection Control"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#ui-organization","text":"The easiest way to create a DOM-based UI form is to extend the BasicDomElementComponent class. This will require you to pass some DOM element to the constructor. Then you bind an IntelliJ IDEA GUI Designer form to your subclass and design a beautiful form there. You will surely want to bind some controls to DOM UI, in which case you should of course ensure that they have right types. Finally, you should create some DOM controls in class' constructor and bind them. But you can create controls and bind them to the DomElement 's children \u2014 GenericDomValue 's automatically. Just name your components properly and call the bindProperties() method in the constructor. The field names should correspond to the getter names for the element's children. They may also be prefixed with \"my\". Imagine that you have such DOM interface: public interface Converter extends DomElement { GenericDomValue < String > getConverterId (); GenericDomValue < PsiClass > getConverterClass (); } In this case, the UI form class can look like this: public class ConverterComponent extends BasicDomElementComponent < Converter > { private JPanel myRootPane ; private TextPanel myConverterId ; private PsiClassPanel myConverterClass ; public ConverterComponent ( final Converter domElement ) { super ( domElement ); bindProperties (); } } All the fields here are now bound to controls in a GUI form. Very often you'll have to create your own file editor. Then, to use all the binding and undo functionality, it's suggested to inherit your FileEditorProvider from PerspectiveFileEditorProvider , create an instance of DomFileEditor there, and pass a BasicDomElementComponent . To easily create an editor with a caption at the top, like in our EJB and JSF, you may use the static method DomFileEditor.createDomFileEditor() . DomFileEditor automatically listens to all changes in the document corresponding to the given DOM element, and therefore refreshes your component on undo. If you want to listen to changes in additional documents, use the methods addWatchedDocument() , removeWatchedDocument() , addWatchedElement() , removeWatchedElement() in DomFileEditor .","title":"UI Organization"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#conclusion","text":"Thank you for your time and attention. We hope you've found this article really useful. You are welcome to post your questions and comments to our Open API and Plugin Development Forum .","title":"Conclusion"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#further-material","text":"The following bundled open-source plugins make (heavy) use of DOM: Android Ant Plugin DevKit Maven Struts 2 (Ultimate Edition)","title":"Further Material"},{"location":"reference_guide/internal_actions/enabling_internal/","text":"There are useful tools, such as the Internal Actions menu, that are only visible if internal mode is enabled in IntelliJ IDEA. Setting Internal Mode in the IDE Properties File There are multiple ways to enable internal mode, but the simplest is within IntelliJ IDEA: * Start IntelliJ IDEA. * From the main menu, select Help | Edit Custom Properties . This selection opens IntelliJ IDEA's idea.properties file. If it does not exist, IntelliJ IDEA will prompt to create one. * Add the line shown below to the idea.properties file: idea.is.internal = true * Save the idea.properties file and restart IntelliJ IDEA. The Internal Actions menu is available in Tools | Internal Actions .","title":"Enabling Internal Mode"},{"location":"reference_guide/internal_actions/enabling_internal/#setting-internal-mode-in-the-ide-properties-file","text":"There are multiple ways to enable internal mode, but the simplest is within IntelliJ IDEA: * Start IntelliJ IDEA. * From the main menu, select Help | Edit Custom Properties . This selection opens IntelliJ IDEA's idea.properties file. If it does not exist, IntelliJ IDEA will prompt to create one. * Add the line shown below to the idea.properties file: idea.is.internal = true * Save the idea.properties file and restart IntelliJ IDEA. The Internal Actions menu is available in Tools | Internal Actions .","title":"Setting Internal Mode in the IDE Properties File"},{"location":"reference_guide/internal_actions/internal_actions_intro/","text":"The Internal Actions menu provides plugin developers with a suite of tools to help develop, debug, and test their Consulo plugins. TIP If the menu item Tools | Internal Actions is not available in IntelliJ IDEA, then the first step is to Enabling Internal Mode Click on the following topics to learn more about the Internal Actions menu. * Enabling Internal Mode provides instructions for enabling the Internal Actions menu in IntelliJ IDEA. * UI Tools has information about some of the Internal Actions menu tools for inspecting and testing plugin UI.","title":"Internal Actions Menu"},{"location":"reference_guide/internal_actions/internal_ui_inspector/","text":"The UI Inspector is a tool to interrogate elements of the IntelliJ IDEA UI to get an internal description of each element. UI elements can be tested interactively by clicking on the element while the UI Inspector is enabled. If the menu item Tools | Internal Actions | UI | UI Inspector is not available in IntelliJ IDEA, then the first step is to enable internal mode Enabling the UI Inspector Before using the UI Inspector , it must be enabled by selecting the menu item Tools | Internal Actions | UI | UI Inspector . The enabled state of the UI Inspector is modal; it remains enabled until it is disabled by selecting the UI Inspector menu item again. Using the UI Inspector While enabled, centering the cursor on a UI element and pressing Control/Cmd + Alt when clicking the mouse reveals the properties of the Swing component. For example, to get information about the Build Project button's icon (hammer) on the toolbar (highlighted in green), put the mouse cursor on the icon and press Control/Cmd + Alt while clicking the mouse. The UI Inspector displays that the icon has the internal path AllIcons.Actions.Compile : Additional Properties Various components used in the Consulo expose additional properties. These can be useful to locate the underlying implementation, related Action, etc. Type Place Properties AnAction Action Button Menu Item Action - AnAction implementation Action ID - Action id Action Plugin ID - contributing plugin ActionToolbar Action Toolbar Toolbar Group - Action Group ID All Groups - contained Action Group IDs DialogWrapper Modal Dialog dialogWrapperClass - DialogWrapper implementation GutterMark Editor Gutter Icon gutter renderer - GutterMark implementation IntentionAction / QuickFix Popup Menu in Editor intention action / quick fix - IntentionAction / QuickFix implementation Tree Tree treeModelClass - javax.swing.tree.TreeModel implementation Custom Swing components can also provide additional properties via UiInspectorContextProvider (2020.1 and later).","title":"Internal Actions - UI Inspector"},{"location":"reference_guide/internal_actions/internal_ui_inspector/#enabling-the-ui-inspector","text":"Before using the UI Inspector , it must be enabled by selecting the menu item Tools | Internal Actions | UI | UI Inspector . The enabled state of the UI Inspector is modal; it remains enabled until it is disabled by selecting the UI Inspector menu item again.","title":"Enabling the UI Inspector"},{"location":"reference_guide/internal_actions/internal_ui_inspector/#using-the-ui-inspector","text":"While enabled, centering the cursor on a UI element and pressing Control/Cmd + Alt when clicking the mouse reveals the properties of the Swing component. For example, to get information about the Build Project button's icon (hammer) on the toolbar (highlighted in green), put the mouse cursor on the icon and press Control/Cmd + Alt while clicking the mouse. The UI Inspector displays that the icon has the internal path AllIcons.Actions.Compile :","title":"Using the UI Inspector"},{"location":"reference_guide/internal_actions/internal_ui_inspector/#additional-properties","text":"Various components used in the Consulo expose additional properties. These can be useful to locate the underlying implementation, related Action, etc. Type Place Properties AnAction Action Button Menu Item Action - AnAction implementation Action ID - Action id Action Plugin ID - contributing plugin ActionToolbar Action Toolbar Toolbar Group - Action Group ID All Groups - contained Action Group IDs DialogWrapper Modal Dialog dialogWrapperClass - DialogWrapper implementation GutterMark Editor Gutter Icon gutter renderer - GutterMark implementation IntentionAction / QuickFix Popup Menu in Editor intention action / quick fix - IntentionAction / QuickFix implementation Tree Tree treeModelClass - javax.swing.tree.TreeModel implementation Custom Swing components can also provide additional properties via UiInspectorContextProvider (2020.1 and later).","title":"Additional Properties"},{"location":"reference_guide/internal_actions/internal_ui_laf_defaults/","text":"The LaF Defaults window provides a key-value pair lookup for UI Controls. It also allows interactive prototyping of UI Control color changes. If the menu item Tools | Internal Actions is not available in IntelliJ IDEA, then the first step is to enable internal mode Opening LaF Defaults The LaF Defaults window is opened by selecting the menu item Tools | Internal Actions | UI | LaF Defaults . The LaF Defaults window has two columns representing key-value pairs for UI Controls: * The Name column contains the UI Control key for each Consulo UI element available at runtime. * The Value column contains the UI Control color value for each Consulo UI element. Using the LaF Panel Finding UI Controls The LaF Defaults window is used interactively by entering a UI element type - e.g. Panel - in the Filter text box at the top. LaF Defaults shows the list of UI Control names matching the filter. Clicking on one of the names narrows the information to show only the key-value pair for that UI element: Prototyping the Color of UI Controls The color of UI Controls can be changed (in real time) by clicking in the Value column next to a Name ( key ) of interest. The Choose Color window is displayed. Color changes can be specified as RGB, hexadecimal, or using the color picker. Pressing the Choose button changes the UI Control color immediately. UI Control colors can be reset using the Choose Color window, or by resetting the UI Theme .","title":"Internal Actions - LaF Defaults"},{"location":"reference_guide/internal_actions/internal_ui_laf_defaults/#opening-laf-defaults","text":"The LaF Defaults window is opened by selecting the menu item Tools | Internal Actions | UI | LaF Defaults . The LaF Defaults window has two columns representing key-value pairs for UI Controls: * The Name column contains the UI Control key for each Consulo UI element available at runtime. * The Value column contains the UI Control color value for each Consulo UI element.","title":"Opening LaF Defaults"},{"location":"reference_guide/internal_actions/internal_ui_laf_defaults/#using-the-laf-panel","text":"","title":"Using the LaF Panel"},{"location":"reference_guide/internal_actions/internal_ui_laf_defaults/#finding-ui-controls","text":"The LaF Defaults window is used interactively by entering a UI element type - e.g. Panel - in the Filter text box at the top. LaF Defaults shows the list of UI Control names matching the filter. Clicking on one of the names narrows the information to show only the key-value pair for that UI element:","title":"Finding UI Controls"},{"location":"reference_guide/internal_actions/internal_ui_laf_defaults/#prototyping-the-color-of-ui-controls","text":"The color of UI Controls can be changed (in real time) by clicking in the Value column next to a Name ( key ) of interest. The Choose Color window is displayed. Color changes can be specified as RGB, hexadecimal, or using the color picker. Pressing the Choose button changes the UI Control color immediately. UI Control colors can be reset using the Choose Color window, or by resetting the UI Theme .","title":"Prototyping the Color of UI Controls"},{"location":"reference_guide/internal_actions/internal_ui_sub/","text":"The Internal Actions UI submenu provides Consulo plugin developers with a suite of tools to help develop, debug, and test their Consulo project UI. TIP If the menu item Tools | Internal Actions is not available in IntelliJ IDEA, then the first step is to Enabling Internal Mode The Tools Available on the UI Submenu Here are some tools available on the UI submenu of the Internal Actions menu: * UI Inspector is a tool to get an internal description with each UI element's properties. * LaF Defaults provides a way to lookup the key-value pair for a UI element, and the ability to prototype the color of UI Controls.","title":"Internal Actions - UI Submenu"},{"location":"reference_guide/internal_actions/internal_ui_sub/#the-tools-available-on-the-ui-submenu","text":"Here are some tools available on the UI submenu of the Internal Actions menu: * UI Inspector is a tool to get an internal description with each UI element's properties. * LaF Defaults provides a way to lookup the key-value pair for a UI element, and the ability to prototype the color of UI Controls.","title":"The Tools Available on the UI Submenu"},{"location":"reference_guide/performance/performance/","text":"TIP IDE Perf plugin provides on-the-fly performance diagnostic tools, including a dedicated view for CachedValue metrics. Working with PSI Efficiently Avoid Expensive Methods in PsiElement Avoid PsiElement methods which are expensive with deep trees. getText() traverses the whole tree under the given element and concatenates strings, consider textMatches() instead. getTextRange() , getContainingFile() , and getProject() traverse the tree up to the file, which can be long in very nested trees. If you only need PSI element length, use getTextLength() . File and project often can be computed once per some analysis and then stored in fields or passed via parameters. Additionally, getText() , getNode() , getTextRange() , etc., all need AST, which can be quite an expensive operation. See below. Avoid Using Many PSI Trees/Documents Avoid loading too many parsed trees or documents into memory at the same time. Ideally, only AST nodes from files open in the editor should be present in the memory. Everything else, even if it's needed for resolve/highlighting purposes, can be accessed via PSI interfaces, but its implementations should use stubs underneath, which are less CPU- and memory-expensive. If stubs don't suit your case well (e.g., the information you need is large and/or very rarely needed, or you're developing a plugin for a language whose PSI you don't control), you can create a custom index or gist . You can use AstLoadingFilter in production and PsiManagerEx.setAssertOnFileLoadingFilter() in tests to ensure you're not loading AST accidentally. The same applies to documents: only the ones opened in editors should be loaded. Usually, you shouldn't need document contents (as most information can be retrieved from PSI). If you nevertheless need documents, consider saving the information you need to provide in a custom index or gist to get it more cheaply later. If you still need documents, then at least ensure you load them one by one and don't hold them on strong references to let GC free the memory as quickly as possible. Cache Results of Heavy Computations These include PsiElement.getReference(s) , PsiReference.resolve() (and multiResolve() and other equivalents), expression types, type inference results, control flow graphs, etc. Usually, CachedValue works well. If the information you cache depends only on a subtree of the current PSI element (and nothing else: no resolve results or other files), you can cache it in a field in that PsiElement and drop the cache in an override of ASTDelegatePsiElement.subtreeChanged() . Improving Indexing Performance Avoid Using AST Use lexer information instead of parsed trees if possible. If impossible, use light AST which doesn't create memory-hungry AST nodes inside, so traversing it might be faster. Make sure to traverse only the nodes you need to. For stub index, implement LightStubBuilder . For other indices, you can obtain the light AST manually via ((PsiDependentFileContent) fileContent).getLighterAST() . If a custom language contains lazy-parseable elements that never or rarely contain any stubs, consider implementing StubBuilder.skipChildProcessingWhenBuildingStubs() (preferably using Lexer/node text). Consider Prebuilt Stubs If your language has a massive standard library, which is mostly the same for all users, you can avoid stub-indexing it in each installation by providing prebuilt stubs with your distribution. See PrebuiltStubsProvider extension. Avoiding UI Freezes Do not Perform Long Operations in UI Thread In particular, don't traverse VFS, parse PSI, resolve references or query FileBasedIndex . There are cases when the platform itself invokes such expensive code (e.g., resolve in AnAction.update() ). We're trying to eliminate them. Meanwhile, you can try to speed up what you can in your plugin, it'll be beneficial anyway, as it'll also improve background highlighting performance. WriteAction s currently have to happen on UI thread, so to speed them up, you can try moving as much as possible out of write action into a preparation step which can be then invoked in background (e.g., using ReadAction.nonBlocking() ). Don't do anything expensive in event listeners. Ideally, you should only clear some caches. You can also schedule background processing of events, but be prepared that some new events might be delivered before your background processing starts, and thus the world might have changed by that moment or even in the middle of background processing. Consider using MergingUpdateQueue and ReadAction.nonBlocking() to mitigate these issues. Massive batches of VFS events can be pre-processed in background, see AsyncFileListener (2019.2 or later). Don't block EDT by long non-cancellable ReadAction s in background threads See General Threading Rules , especially its section on Read Action Cancellability .","title":"Optimizing Performance"},{"location":"reference_guide/performance/performance/#working-with-psi-efficiently","text":"","title":"Working with PSI Efficiently"},{"location":"reference_guide/performance/performance/#avoid-expensive-methods-in-psielement","text":"Avoid PsiElement methods which are expensive with deep trees. getText() traverses the whole tree under the given element and concatenates strings, consider textMatches() instead. getTextRange() , getContainingFile() , and getProject() traverse the tree up to the file, which can be long in very nested trees. If you only need PSI element length, use getTextLength() . File and project often can be computed once per some analysis and then stored in fields or passed via parameters. Additionally, getText() , getNode() , getTextRange() , etc., all need AST, which can be quite an expensive operation. See below.","title":"Avoid Expensive Methods in PsiElement"},{"location":"reference_guide/performance/performance/#avoid-using-many-psi-treesdocuments","text":"Avoid loading too many parsed trees or documents into memory at the same time. Ideally, only AST nodes from files open in the editor should be present in the memory. Everything else, even if it's needed for resolve/highlighting purposes, can be accessed via PSI interfaces, but its implementations should use stubs underneath, which are less CPU- and memory-expensive. If stubs don't suit your case well (e.g., the information you need is large and/or very rarely needed, or you're developing a plugin for a language whose PSI you don't control), you can create a custom index or gist . You can use AstLoadingFilter in production and PsiManagerEx.setAssertOnFileLoadingFilter() in tests to ensure you're not loading AST accidentally. The same applies to documents: only the ones opened in editors should be loaded. Usually, you shouldn't need document contents (as most information can be retrieved from PSI). If you nevertheless need documents, consider saving the information you need to provide in a custom index or gist to get it more cheaply later. If you still need documents, then at least ensure you load them one by one and don't hold them on strong references to let GC free the memory as quickly as possible.","title":"Avoid Using Many PSI Trees/Documents"},{"location":"reference_guide/performance/performance/#cache-results-of-heavy-computations","text":"These include PsiElement.getReference(s) , PsiReference.resolve() (and multiResolve() and other equivalents), expression types, type inference results, control flow graphs, etc. Usually, CachedValue works well. If the information you cache depends only on a subtree of the current PSI element (and nothing else: no resolve results or other files), you can cache it in a field in that PsiElement and drop the cache in an override of ASTDelegatePsiElement.subtreeChanged() .","title":"Cache Results of Heavy Computations"},{"location":"reference_guide/performance/performance/#improving-indexing-performance","text":"","title":"Improving Indexing Performance"},{"location":"reference_guide/performance/performance/#avoid-using-ast","text":"Use lexer information instead of parsed trees if possible. If impossible, use light AST which doesn't create memory-hungry AST nodes inside, so traversing it might be faster. Make sure to traverse only the nodes you need to. For stub index, implement LightStubBuilder . For other indices, you can obtain the light AST manually via ((PsiDependentFileContent) fileContent).getLighterAST() . If a custom language contains lazy-parseable elements that never or rarely contain any stubs, consider implementing StubBuilder.skipChildProcessingWhenBuildingStubs() (preferably using Lexer/node text).","title":"Avoid Using AST"},{"location":"reference_guide/performance/performance/#consider-prebuilt-stubs","text":"If your language has a massive standard library, which is mostly the same for all users, you can avoid stub-indexing it in each installation by providing prebuilt stubs with your distribution. See PrebuiltStubsProvider extension.","title":"Consider Prebuilt Stubs"},{"location":"reference_guide/performance/performance/#avoiding-ui-freezes","text":"","title":"Avoiding UI Freezes"},{"location":"reference_guide/performance/performance/#do-not-perform-long-operations-in-ui-thread","text":"In particular, don't traverse VFS, parse PSI, resolve references or query FileBasedIndex . There are cases when the platform itself invokes such expensive code (e.g., resolve in AnAction.update() ). We're trying to eliminate them. Meanwhile, you can try to speed up what you can in your plugin, it'll be beneficial anyway, as it'll also improve background highlighting performance. WriteAction s currently have to happen on UI thread, so to speed them up, you can try moving as much as possible out of write action into a preparation step which can be then invoked in background (e.g., using ReadAction.nonBlocking() ). Don't do anything expensive in event listeners. Ideally, you should only clear some caches. You can also schedule background processing of events, but be prepared that some new events might be delivered before your background processing starts, and thus the world might have changed by that moment or even in the middle of background processing. Consider using MergingUpdateQueue and ReadAction.nonBlocking() to mitigate these issues. Massive batches of VFS events can be pre-processed in background, see AsyncFileListener (2019.2 or later).","title":"Do not Perform Long Operations in UI Thread"},{"location":"reference_guide/performance/performance/#dont-block-edt-by-long-non-cancellable-readactions-in-background-threads","text":"See General Threading Rules , especially its section on Read Action Cancellability .","title":"Don't block EDT by long non-cancellable ReadActions in background threads"},{"location":"reference_guide/project_model/library/","text":"A library is an archive of compiled code (such as JAR files) that modules depend on. The Consulo supports three types of libraries: * Module Library : the library classes are visible only in this module and the library information is recorded in the module .iml file. * Project Library : the library classes are visible within the project and the library information is recorded under .idea/libraries directory or in the project .ipr file. * Global Library : the library information is recorded in the applicationLibraries.xml file in <User Home>/.IntelliJIdea/config/options directory. Global libraries are similar to project libraries, but are visible for different projects. For more information about libraries, refer to Libraries . A particular type of programmatically defined libraries is Predefined Libraries . bullet list {:toc} Accessing Libraries and Jars Package libraries provides functionality for working with project libraries and jars. Getting a List of Libraries a Module Depends On To get the list of libraries that a module depends on, use OrderEnumerator.forEachLibrary as follows. final List < String > libraryNames = new ArrayList < String > (); ModuleRootManager . getInstance ( module ). orderEntries (). forEachLibrary ( library -> { libraryNames . add ( library . getName ()); return true ; }); Messages . showInfoMessage ( StringUtil . join ( libraryNames , \"\\n\" ), \"Libraries in Module\" ); This sample code outputs a list of libraries that the given module depends on. Getting a List of All Libraries To manage the lists of application and project libraries, use LibraryTable . The list of application-level library tables is accessed by calling LibraryTablesRegistrar.getInstance().getLibraryTable() , whereas the list of project-level library tables is accessed through LibraryTablesRegistrar.getInstance().getLibraryTable() . Once you have a LibraryTable , you can get the libraries in it by calling LibraryTable.getLibraries() . To get the list of all module libraries defined in a given module, use the following API: OrderEntryUtil . getModuleLibraries ( ModuleRootManager . getInstance ( module )); Getting the Library Content Library provides the getUrls() method you can use to get a list of source roots and classes the library includes. To clarify, consider the following code snippet: StringBuilder roots = new StringBuilder ( \"The \" + lib . getName () + \" library includes:\\n\" ); roots . append ( \"Sources:\\n\" ); for ( String each : lib . getUrls ( OrderRootType . SOURCES )) { roots . append ( each ). append ( \"\\n\" ); } roots . append ( \"Classes:\\n\" ); for ( String each : lib . getUrls ( OrderRootType . CLASSES )) { strRoots . append ( each ). append ( \"\\n\" ); } Messages . showInfoMessage ( roots . toString (), \"Library Info\" ); Creating a Library To create a library, perform the following steps: * Get a write action * Obtain the library table to which you want to add the library. Use one of the following, depending on the library level: * LibraryTablesRegistrar.getInstance().getLibraryTable() * LibraryTablesRegistrar.getInstance().getLibraryTable(Project) * ModuleRootManager.getInstance(module).getModifiableModel().getModuleLibraryTable() * Create the library by calling LibraryTable.createLibrary() * Add contents to the library (see below) * For a module-level library, commit the modifiable model returned by ModuleRootManager.getInstance(module).getModifiableModel() . For module-level libraries, you can also use simplified APIs in the ModuleRootModificationUtil class to add a library with a single API call. You can find an example of using these APIs in the project_model code sample. Adding Contents or Modifying a Library To add or change the roots of a library, you need to perform the following steps: * Get a write action * Get a modifiable model for the library, using Library.getModifiableModel() * Use methods such as Library.ModifiableModel.addRoot() to perform the necessary changes * Commit the model using Library.ModifiableModel.commit() . Adding a Library Dependency to a Module Use ModuleRootModificationUtil.addDependency(module, library) from under a write action. Checking Belonging to a Library The ProjectFileIndex interface implements a number of methods you can use to check whether the specified file belongs to the project library classes or library sources. You can use the following methods: To check if a specified virtual file is a compiled class file use ProjectFileIndex . isLibraryClassFile ( virtualFile ) To check if a specified virtual file or directory belongs to library classes use ProjectFileIndex . isInLibraryClasses ( virtualFileorDirectory ) To check if the specified virtual file or directory belongs to library sources use ProjectFileIndex . isInLibrarySource ( virtualFileorDirectory ) See the project_model to see how the method mentioned above can be applied. More details on libraries can be found in the plugin_model code sample. Predefined Libraries EP: com.intellij.additionalLibraryRootsProvider AdditionalLibraryRootsProvider Allows providing synthetic/predefined libraries ( SyntheticLibrary ) in a project without exposing them in the model. By default, they're also hidden from UI.","title":"Library"},{"location":"reference_guide/project_model/library/#accessing-libraries-and-jars","text":"Package libraries provides functionality for working with project libraries and jars.","title":"Accessing Libraries and Jars"},{"location":"reference_guide/project_model/library/#getting-a-list-of-libraries-a-module-depends-on","text":"To get the list of libraries that a module depends on, use OrderEnumerator.forEachLibrary as follows. final List < String > libraryNames = new ArrayList < String > (); ModuleRootManager . getInstance ( module ). orderEntries (). forEachLibrary ( library -> { libraryNames . add ( library . getName ()); return true ; }); Messages . showInfoMessage ( StringUtil . join ( libraryNames , \"\\n\" ), \"Libraries in Module\" ); This sample code outputs a list of libraries that the given module depends on.","title":"Getting a List of Libraries a Module Depends On"},{"location":"reference_guide/project_model/library/#getting-a-list-of-all-libraries","text":"To manage the lists of application and project libraries, use LibraryTable . The list of application-level library tables is accessed by calling LibraryTablesRegistrar.getInstance().getLibraryTable() , whereas the list of project-level library tables is accessed through LibraryTablesRegistrar.getInstance().getLibraryTable() . Once you have a LibraryTable , you can get the libraries in it by calling LibraryTable.getLibraries() . To get the list of all module libraries defined in a given module, use the following API: OrderEntryUtil . getModuleLibraries ( ModuleRootManager . getInstance ( module ));","title":"Getting a List of All Libraries"},{"location":"reference_guide/project_model/library/#getting-the-library-content","text":"Library provides the getUrls() method you can use to get a list of source roots and classes the library includes. To clarify, consider the following code snippet: StringBuilder roots = new StringBuilder ( \"The \" + lib . getName () + \" library includes:\\n\" ); roots . append ( \"Sources:\\n\" ); for ( String each : lib . getUrls ( OrderRootType . SOURCES )) { roots . append ( each ). append ( \"\\n\" ); } roots . append ( \"Classes:\\n\" ); for ( String each : lib . getUrls ( OrderRootType . CLASSES )) { strRoots . append ( each ). append ( \"\\n\" ); } Messages . showInfoMessage ( roots . toString (), \"Library Info\" );","title":"Getting the Library Content"},{"location":"reference_guide/project_model/library/#creating-a-library","text":"To create a library, perform the following steps: * Get a write action * Obtain the library table to which you want to add the library. Use one of the following, depending on the library level: * LibraryTablesRegistrar.getInstance().getLibraryTable() * LibraryTablesRegistrar.getInstance().getLibraryTable(Project) * ModuleRootManager.getInstance(module).getModifiableModel().getModuleLibraryTable() * Create the library by calling LibraryTable.createLibrary() * Add contents to the library (see below) * For a module-level library, commit the modifiable model returned by ModuleRootManager.getInstance(module).getModifiableModel() . For module-level libraries, you can also use simplified APIs in the ModuleRootModificationUtil class to add a library with a single API call. You can find an example of using these APIs in the project_model code sample.","title":"Creating a Library"},{"location":"reference_guide/project_model/library/#adding-contents-or-modifying-a-library","text":"To add or change the roots of a library, you need to perform the following steps: * Get a write action * Get a modifiable model for the library, using Library.getModifiableModel() * Use methods such as Library.ModifiableModel.addRoot() to perform the necessary changes * Commit the model using Library.ModifiableModel.commit() .","title":"Adding Contents or Modifying a Library"},{"location":"reference_guide/project_model/library/#adding-a-library-dependency-to-a-module","text":"Use ModuleRootModificationUtil.addDependency(module, library) from under a write action.","title":"Adding a Library Dependency to a Module"},{"location":"reference_guide/project_model/library/#checking-belonging-to-a-library","text":"The ProjectFileIndex interface implements a number of methods you can use to check whether the specified file belongs to the project library classes or library sources. You can use the following methods: To check if a specified virtual file is a compiled class file use ProjectFileIndex . isLibraryClassFile ( virtualFile ) To check if a specified virtual file or directory belongs to library classes use ProjectFileIndex . isInLibraryClasses ( virtualFileorDirectory ) To check if the specified virtual file or directory belongs to library sources use ProjectFileIndex . isInLibrarySource ( virtualFileorDirectory ) See the project_model to see how the method mentioned above can be applied. More details on libraries can be found in the plugin_model code sample.","title":"Checking Belonging to a Library"},{"location":"reference_guide/project_model/library/#predefined-libraries","text":"EP: com.intellij.additionalLibraryRootsProvider AdditionalLibraryRootsProvider Allows providing synthetic/predefined libraries ( SyntheticLibrary ) in a project without exposing them in the model. By default, they're also hidden from UI.","title":"Predefined Libraries"},{"location":"reference_guide/project_model/module/","text":"A module is a discrete unit of functionality that can be run, tested, and debugged independently. Modules include such things as source code, build scripts, unit tests, deployment descriptors, etc. The key components of a module are: Content roots - the directories where the files belonging to the module (source code, resources, etc.) are stored. Each directory can belong to one and only one module; it's not possible to share a content root between multiple modules. Source roots - A content root can have multiple source roots underneath it. Source roots can have different types: regular source roots, test source roots, resource roots, etc. In Consulo, source roots are used as roots of the package hierarchy structure. Java classes directly under a source root will be in the root package. Source roots can also be used to implement more fine-grained dependency checks. Code under a regular source root cannot depend on code under a test source root. Order entries - the dependencies of a module, which are stored in an ordered list. A dependency can be a reference to an SDK , a library , or another module. Extensions - the extensions of a module, which can store framework(or language) settings. Each extension can provide own per module setting page. In addition to that, a module can store other settings, such as a module-specific SDK , compile output path settings, etc. Plugins can store additional data associated with a module by creating module extensions or module-level components. The Consulo provides a number of classes and interfaces you can use to work with modules: Module ModuleUtil ModuleManager ModuleRootManager ModuleRootModel ModifiableModuleModel ModifiableRootModel This section discusses how to complete some common tasks related to management of modules. How do I get a list of modules the project includes? Use the ModuleManager.getModules() method. How do I get dependencies and classpath of a module? Order entries include SDK, libraries and other modules the module uses. With the Consulo UI, you can view order entries for a module on the Dependencies tab of the Project Structure dialog box. To explore the module dependencies , use the OrderEnumerator class. The following code snippet illustrates how you can get classpath (classes root of all dependencies) for a module: VirtualFile [] roots = ModuleRootManager . getInstance ( module ). orderEntries (). classes (). getRoots (); How do I get the SDK the module uses? Use the ModuleRootManager.getSdk() method. This method returns a value of the Sdk type. The following code snippet illustrates how you can get detailed information on SDK the specified module uses: ModuleRootManager moduleRootManager = ModuleRootManager . getInstance ( module ); Sdk SDK = moduleRootManager . getSdk (); String jdkInfo = \"Module: \" + module . getName () + \" SDK: \" + SDK . getName () + \" SDK version: \" + SDK . getVersionString () + \" SDK home directory: \" + SDK . getHomePath (); How do I get a list of modules on which this module directly depends? Use the ModuleRootManager.getDependencies() method to get an array of the Module type values or the ModuleRootManager.getDependencyModuleNames() to get an array of module names. To clarify, consider the following code snippet: ModuleRootManager moduleRootManager = ModuleRootManager . getInstance ( module ); Module [] dependentModules = moduleRootManager . getDependencies (); String [] dependentModulesNames = moduleRootManager . getDependencyModuleNames (); How do I get a list of modules that depend on this module? Use the ModuleManager.getModuleDependentModules(module) method. Note that you can also check whether a module ( module1 ) depends on another specified module ( module2 ) using the ModuleManager.isModuleDependent() method in the following way: boolean isDependent = ModuleManager . getInstance ( project ). isModuleDependent ( module1 , module2 ); How do I get a module to which the specified file or PSI element belongs? To get the project module to which the specified file belongs, use the ModuleUtil.findModuleForFile() static method. To clarify, consider the following code snippet: String pathToFile = \"C:\\\\users\\\\firstName.LastName\\\\plugins\\\\myPlugin\\src\\MyAction.java\" ; VirtualFile virtualFile = LocalFileSystem . getInstance (). findFileByPath ( pathToFile ); Module module = ModuleUtil . findModuleForFile ( virtualFile , myProject ); String moduleName = module == null ? \"Module not found\" : module . getName (); To get the project module to which the specified PSI element belongs, use the ModuleUtil.findModuleForPsiElement() method. Accessing Module Roots Information about module roots can be accessed via ModuleRootManager . For example, the following snippet shows how to access the content roots of a module: VirtualFile [] contentRoots = ModuleRootManager . getInstance ( module ). getContentRoots (); Checking Belonging to a Module Source Root To check if a virtual file or directory belongs to a module source root, use the ProjectFileIndex.getSourceRootForFile() method. This method returns null if the file or directory does not belong to any source root of modules in the project. VirtualFile moduleSourceRoot = ProjectRootManager . getInstance ( project ). getFileIndex (). getSourceRootForFile ( virtualFileOrDirectory ); Receiving Notifications About Module Changes To receive notifications about module changes (modules being added, removed or renamed), use the message bus and the ProjectTopics.MODULES topic: project . getMessageBus (). connect (). subscribe ( ProjectTopics . MODULES , new ModuleListener () { @Override public void moduleAdded ( @NotNull Project project , @NotNull Module module ) { } });","title":"Module"},{"location":"reference_guide/project_model/module/#how-do-i-get-a-list-of-modules-the-project-includes","text":"Use the ModuleManager.getModules() method.","title":"How do I get a list of modules the project includes?"},{"location":"reference_guide/project_model/module/#how-do-i-get-dependencies-and-classpath-of-a-module","text":"Order entries include SDK, libraries and other modules the module uses. With the Consulo UI, you can view order entries for a module on the Dependencies tab of the Project Structure dialog box. To explore the module dependencies , use the OrderEnumerator class. The following code snippet illustrates how you can get classpath (classes root of all dependencies) for a module: VirtualFile [] roots = ModuleRootManager . getInstance ( module ). orderEntries (). classes (). getRoots ();","title":"How do I get dependencies and classpath of a module?"},{"location":"reference_guide/project_model/module/#how-do-i-get-the-sdk-the-module-uses","text":"Use the ModuleRootManager.getSdk() method. This method returns a value of the Sdk type. The following code snippet illustrates how you can get detailed information on SDK the specified module uses: ModuleRootManager moduleRootManager = ModuleRootManager . getInstance ( module ); Sdk SDK = moduleRootManager . getSdk (); String jdkInfo = \"Module: \" + module . getName () + \" SDK: \" + SDK . getName () + \" SDK version: \" + SDK . getVersionString () + \" SDK home directory: \" + SDK . getHomePath ();","title":"How do I get the SDK the module uses?"},{"location":"reference_guide/project_model/module/#how-do-i-get-a-list-of-modules-on-which-this-module-directly-depends","text":"Use the ModuleRootManager.getDependencies() method to get an array of the Module type values or the ModuleRootManager.getDependencyModuleNames() to get an array of module names. To clarify, consider the following code snippet: ModuleRootManager moduleRootManager = ModuleRootManager . getInstance ( module ); Module [] dependentModules = moduleRootManager . getDependencies (); String [] dependentModulesNames = moduleRootManager . getDependencyModuleNames ();","title":"How do I get a list of modules on which this module directly depends?"},{"location":"reference_guide/project_model/module/#how-do-i-get-a-list-of-modules-that-depend-on-this-module","text":"Use the ModuleManager.getModuleDependentModules(module) method. Note that you can also check whether a module ( module1 ) depends on another specified module ( module2 ) using the ModuleManager.isModuleDependent() method in the following way: boolean isDependent = ModuleManager . getInstance ( project ). isModuleDependent ( module1 , module2 );","title":"How do I get a list of modules that depend on this module?"},{"location":"reference_guide/project_model/module/#how-do-i-get-a-module-to-which-the-specified-file-or-psi-element-belongs","text":"To get the project module to which the specified file belongs, use the ModuleUtil.findModuleForFile() static method. To clarify, consider the following code snippet: String pathToFile = \"C:\\\\users\\\\firstName.LastName\\\\plugins\\\\myPlugin\\src\\MyAction.java\" ; VirtualFile virtualFile = LocalFileSystem . getInstance (). findFileByPath ( pathToFile ); Module module = ModuleUtil . findModuleForFile ( virtualFile , myProject ); String moduleName = module == null ? \"Module not found\" : module . getName (); To get the project module to which the specified PSI element belongs, use the ModuleUtil.findModuleForPsiElement() method.","title":"How do I get a module to which the specified file or PSI element belongs?"},{"location":"reference_guide/project_model/module/#accessing-module-roots","text":"Information about module roots can be accessed via ModuleRootManager . For example, the following snippet shows how to access the content roots of a module: VirtualFile [] contentRoots = ModuleRootManager . getInstance ( module ). getContentRoots ();","title":"Accessing Module Roots"},{"location":"reference_guide/project_model/module/#checking-belonging-to-a-module-source-root","text":"To check if a virtual file or directory belongs to a module source root, use the ProjectFileIndex.getSourceRootForFile() method. This method returns null if the file or directory does not belong to any source root of modules in the project. VirtualFile moduleSourceRoot = ProjectRootManager . getInstance ( project ). getFileIndex (). getSourceRootForFile ( virtualFileOrDirectory );","title":"Checking Belonging to a Module Source Root"},{"location":"reference_guide/project_model/module/#receiving-notifications-about-module-changes","text":"To receive notifications about module changes (modules being added, removed or renamed), use the message bus and the ProjectTopics.MODULES topic: project . getMessageBus (). connect (). subscribe ( ProjectTopics . MODULES , new ModuleListener () { @Override public void moduleAdded ( @NotNull Project project , @NotNull Module module ) { } });","title":"Receiving Notifications About Module Changes"},{"location":"reference_guide/project_model/module_extenions/","text":"To be documented...","title":"Module Extensions"},{"location":"reference_guide/project_model/project/","text":"In the Consulo , a project encapsulates all the source code, libraries, and build instructions into a single organizational unit. Everything done in the IDE is accomplished within the context of a project. A project defines some collections referred to as modules and libraries. Depending on the logical and functional requirements for the project, a single-module or a multi-module project is possible. Working with Projects The Consulo stores the project configuration data in XML files. The list of those files depends on the chosen project format. For file-based format projects (legacy), the information core to the project itself (e.g., location of the component modules, compiler settings, etc.) is stored in the %project_name%.ipr file. The information about modules the project includes is stored in %module_name%.iml files. Module files are created for each module. For directory-based format projects, the project and workspace settings are stored in a number of XML files under the %project_home_directory%/.idea directory. Each XML file is responsible for its own set of settings and can be recognized by its name: projectCodeStyle.xml , encodings.xml , vcs.xml etc. As for the file-based format projects, .iml files describe modules. Note that direct access to project files isn't required to load or save settings. See Persisting State of Components for more information. To work with projects and project files, use the following classes and interfaces: * Project * ProjectRootManager * ProjectManager * ProjectFileIndex Other classes for working with the project model are located in the projectModel-api.openapi package. Basic API classes and interfaces for the concepts of Project , Module and Application are placed in the core-api.openapi package. Getting a List of Source Roots for All Modules in a Project Use the ProjectRootManager.getContentSourceRoots() method. To clarify this, consider the following code snippet: String projectName = project . getName (); VirtualFile [] vFiles = ProjectRootManager . getInstance ( project ). getContentSourceRoots (); String sourceRootsList = Arrays . stream ( vFiles ). map ( VirtualFile :: getUrl ). collect ( Collectors . joining ( \"\\n\" )); Messages . showInfoMessage ( \"Source roots for the \" + projectName + \" plugin:\\n\" + sourceRootsList , \"Project Properties\" ); Checking if a File Belongs to a Project Use ProjectFileIndex to get this information: ProjectFileIndex projectFileIndex = ProjectRootManager . getInstance ( project ). getFileIndex (); Getting the Content or Source Root to Which the a File or Directory Belongs Use the ProjectFileIndex.getContentRootForFile() and ProjectFileIndex.getSourceRootForFile() methods. For example: VirtualFile moduleContentRoot = ProjectRootManager . getInstance ( project ). getFileIndex (). getContentRootForFile ( virtualFileOrDirectory ); VirtualFile moduleSourceRoot = ProjectRootManager . getInstance ( project ). getFileIndex (). getSourceRootForFile ( virtualFileOrDirectory ); Note that this method returns null if the file or directory does not belong to any source root of modules in the project. Checking Whether a File or Directory Is Related to the Project Libraries The ProjectFileIndex interface implements a number of methods you can use to check whether the specified file belongs to the project library classes or library sources: * isLibraryClassFile() : Returns true if the specified virtualFile is a compiled class file. * isInLibraryClasses() : Returns true if the specified virtualFileOrDirectory belongs to library classes. * isInLibrarySource() : Returns true if the specified virtualFileOrDirectory belongs to library sources. Getting the Project SDK Note that by default, the project modules use the project SDK. Optionally, you can configure an individual SDK for each module. See SDK for more details. Changing the Project Structure Utility classes used for modifying the project structure can be found in the package projectModel-impl.openapi . Its roots subpackage contains instances and utilities intended for work with project and module source roots, including ModuleRootModificationUtil and ProjectRootUtil . Project structure changes need to be performed in a write action . Refer to the project_model code sample to learn how project structure modification can be implemented. Receiving Notifications About Project Structure Changes To receive notifications about changes in project structure (modules or libraries being added or removed, module dependencies being changed, and so on), use the message bus and the ProjectTopics.PROJECT_ROOTS topic: project . getMessageBus (). connect (). subscribe ( ProjectTopics . PROJECT_ROOTS , new ModuleRootListener () { @Override public void rootsChanged ( ModuleRootEvent event ) { } }); The event only notifies that something has changed; if more details are needed about what changes have occurred, keep a copy of the state of the project structure model which is relevant, and to compare it with the state after the change.","title":"Overview"},{"location":"reference_guide/project_model/project/#working-with-projects","text":"The Consulo stores the project configuration data in XML files. The list of those files depends on the chosen project format. For file-based format projects (legacy), the information core to the project itself (e.g., location of the component modules, compiler settings, etc.) is stored in the %project_name%.ipr file. The information about modules the project includes is stored in %module_name%.iml files. Module files are created for each module. For directory-based format projects, the project and workspace settings are stored in a number of XML files under the %project_home_directory%/.idea directory. Each XML file is responsible for its own set of settings and can be recognized by its name: projectCodeStyle.xml , encodings.xml , vcs.xml etc. As for the file-based format projects, .iml files describe modules. Note that direct access to project files isn't required to load or save settings. See Persisting State of Components for more information. To work with projects and project files, use the following classes and interfaces: * Project * ProjectRootManager * ProjectManager * ProjectFileIndex Other classes for working with the project model are located in the projectModel-api.openapi package. Basic API classes and interfaces for the concepts of Project , Module and Application are placed in the core-api.openapi package.","title":"Working with Projects"},{"location":"reference_guide/project_model/project/#getting-a-list-of-source-roots-for-all-modules-in-a-project","text":"Use the ProjectRootManager.getContentSourceRoots() method. To clarify this, consider the following code snippet: String projectName = project . getName (); VirtualFile [] vFiles = ProjectRootManager . getInstance ( project ). getContentSourceRoots (); String sourceRootsList = Arrays . stream ( vFiles ). map ( VirtualFile :: getUrl ). collect ( Collectors . joining ( \"\\n\" )); Messages . showInfoMessage ( \"Source roots for the \" + projectName + \" plugin:\\n\" + sourceRootsList , \"Project Properties\" );","title":"Getting a List of Source Roots for All Modules in a Project"},{"location":"reference_guide/project_model/project/#checking-if-a-file-belongs-to-a-project","text":"Use ProjectFileIndex to get this information: ProjectFileIndex projectFileIndex = ProjectRootManager . getInstance ( project ). getFileIndex ();","title":"Checking if a File Belongs to a Project"},{"location":"reference_guide/project_model/project/#getting-the-content-or-source-root-to-which-the-a-file-or-directory-belongs","text":"Use the ProjectFileIndex.getContentRootForFile() and ProjectFileIndex.getSourceRootForFile() methods. For example: VirtualFile moduleContentRoot = ProjectRootManager . getInstance ( project ). getFileIndex (). getContentRootForFile ( virtualFileOrDirectory ); VirtualFile moduleSourceRoot = ProjectRootManager . getInstance ( project ). getFileIndex (). getSourceRootForFile ( virtualFileOrDirectory ); Note that this method returns null if the file or directory does not belong to any source root of modules in the project.","title":"Getting the Content or Source Root to Which the a File or Directory Belongs"},{"location":"reference_guide/project_model/project/#checking-whether-a-file-or-directory-is-related-to-the-project-libraries","text":"The ProjectFileIndex interface implements a number of methods you can use to check whether the specified file belongs to the project library classes or library sources: * isLibraryClassFile() : Returns true if the specified virtualFile is a compiled class file. * isInLibraryClasses() : Returns true if the specified virtualFileOrDirectory belongs to library classes. * isInLibrarySource() : Returns true if the specified virtualFileOrDirectory belongs to library sources.","title":"Checking Whether a File or Directory Is Related to the Project Libraries"},{"location":"reference_guide/project_model/project/#getting-the-project-sdk","text":"Note that by default, the project modules use the project SDK. Optionally, you can configure an individual SDK for each module. See SDK for more details.","title":"Getting the Project SDK"},{"location":"reference_guide/project_model/project/#changing-the-project-structure","text":"Utility classes used for modifying the project structure can be found in the package projectModel-impl.openapi . Its roots subpackage contains instances and utilities intended for work with project and module source roots, including ModuleRootModificationUtil and ProjectRootUtil . Project structure changes need to be performed in a write action . Refer to the project_model code sample to learn how project structure modification can be implemented.","title":"Changing the Project Structure"},{"location":"reference_guide/project_model/project/#receiving-notifications-about-project-structure-changes","text":"To receive notifications about changes in project structure (modules or libraries being added or removed, module dependencies being changed, and so on), use the message bus and the ProjectTopics.PROJECT_ROOTS topic: project . getMessageBus (). connect (). subscribe ( ProjectTopics . PROJECT_ROOTS , new ModuleRootListener () { @Override public void rootsChanged ( ModuleRootEvent event ) { } }); The event only notifies that something has changed; if more details are needed about what changes have occurred, keep a copy of the state of the project structure model which is relevant, and to compare it with the state after the change.","title":"Receiving Notifications About Project Structure Changes"},{"location":"reference_guide/project_model/sdk/","text":"Every project uses a Software Development Kit (SDK). For Java projects, the SDK is referred to as the JDK (Java Development Kit). The SDK determines which API library is used to build the project. If a project is multi-module, the project SDK by default is common for all modules within the project. Optionally, individual SDKs for each module can be configured. For more information about SDKs, see SDK in the IntelliJ IDEA Web Help. Getting Project SDK Information The information about the project SDK is accessed via ProjectRootManager like the following example shows Sdk projectSdk = ProjectRootManager . getInstance ( project ). getProjectSdk (); Getting and Setting Project SDK Attributes To get the project level SDK Sdk projectSDK = ProjectRootManager . getInstance ( project ). getProjectSdk (); To get the project level SDK name: String projectSDKName = ProjectRootManager . getInstance ( project ). getProjectSdkName (); To set the project level SDK: ProjectRootManager . getInstance ( project ). setProjectSdk ( Sdk jdk ); To set the project level SDK name: ProjectRootManager . getInstance ( project ). setProjectSdkName ( String name ); See the project_model code sample to get more familiar with SDK manipulation toolset. Available SDKs ProjectJdkTable can be used to query and modify configured SDKs. Working with a Custom SDK To create a custom SDK, provide a class extending SdkType , leave saveAdditionalData() blank, and register it in the com.intellij.sdkType extension point. To make SDK settings persistent, override setupSdkPaths() and save settings by modificator.commitChanges() : @Override public boolean setupSdkPaths ( @NotNull Sdk sdk , @NotNull SdkModel sdkModel ) { SdkModificator modificator = sdk . getSdkModificator (); modificator . setVersionString ( getVersionString ( sdk )); modificator . commitChanges (); // save return true ; } To let a user select an SDK, see ProjectJdksEditor . However, it is not recommended to use \"SDK\" in non-IntelliJ IDEA IDEs. Although \"SDK\" is available in most JetBrains products, ProjectJdksEditor is specific to Java, making the operation around \"SDK\" difficult. The recommended way of managing \"SDK\" settings is to create a CustomStepProjectGenerator implementation and save settings in a PersistentStateComponent . Assisting in Setting Up an SDK Register the implementation of ProjectSdkSetupValidator in extension point com.intellij.projectSdkSetupValidator to provide quick fix.","title":"SDK"},{"location":"reference_guide/project_model/sdk/#getting-project-sdk-information","text":"The information about the project SDK is accessed via ProjectRootManager like the following example shows Sdk projectSdk = ProjectRootManager . getInstance ( project ). getProjectSdk ();","title":"Getting Project SDK Information"},{"location":"reference_guide/project_model/sdk/#getting-and-setting-project-sdk-attributes","text":"To get the project level SDK Sdk projectSDK = ProjectRootManager . getInstance ( project ). getProjectSdk (); To get the project level SDK name: String projectSDKName = ProjectRootManager . getInstance ( project ). getProjectSdkName (); To set the project level SDK: ProjectRootManager . getInstance ( project ). setProjectSdk ( Sdk jdk ); To set the project level SDK name: ProjectRootManager . getInstance ( project ). setProjectSdkName ( String name ); See the project_model code sample to get more familiar with SDK manipulation toolset.","title":"Getting and Setting Project SDK Attributes"},{"location":"reference_guide/project_model/sdk/#available-sdks","text":"ProjectJdkTable can be used to query and modify configured SDKs.","title":"Available SDKs"},{"location":"reference_guide/project_model/sdk/#working-with-a-custom-sdk","text":"To create a custom SDK, provide a class extending SdkType , leave saveAdditionalData() blank, and register it in the com.intellij.sdkType extension point. To make SDK settings persistent, override setupSdkPaths() and save settings by modificator.commitChanges() : @Override public boolean setupSdkPaths ( @NotNull Sdk sdk , @NotNull SdkModel sdkModel ) { SdkModificator modificator = sdk . getSdkModificator (); modificator . setVersionString ( getVersionString ( sdk )); modificator . commitChanges (); // save return true ; } To let a user select an SDK, see ProjectJdksEditor . However, it is not recommended to use \"SDK\" in non-IntelliJ IDEA IDEs. Although \"SDK\" is available in most JetBrains products, ProjectJdksEditor is specific to Java, making the operation around \"SDK\" difficult. The recommended way of managing \"SDK\" settings is to create a CustomStepProjectGenerator implementation and save settings in a PersistentStateComponent .","title":"Working with a Custom SDK"},{"location":"reference_guide/project_model/sdk/#assisting-in-setting-up-an-sdk","text":"Register the implementation of ProjectSdkSetupValidator in extension point com.intellij.projectSdkSetupValidator to provide quick fix.","title":"Assisting in Setting Up an SDK"},{"location":"tutorials/action_system/","text":"This tutorial leads you through a series of steps which show how to create, register, and customize custom actions and action groups. By registering actions, you can add your own menu items, toolbar buttons and keyboard shortcuts to the IDE user interface. * Creating Actions * Grouping Actions The source code for the action_basics code sample is used throughout this tutorial.","title":"Overview"},{"location":"tutorials/build_system/","text":"The gradle-intellij-plugin Gradle plugin is the recommended solution for building IntelliJ plugins. The plugin takes care of the dependencies of your plugin project - both the base IDE and other plugin dependencies. TIP Consulo Plugin Template makes it easier to create and maintain your IDE plugins, having the Gradle plugin already integrated and CI covered with GitHub Actions. NOTE If a new plugin will be Scala-based, a dedicated SBT plugin sbt-idea-plugin is available. The gradle-intellij-plugin provides tasks to run the IDE with your plugin and to publish your plugin to the JetBrains Plugins Repository . To make sure that your plugin is not affected by API changes , which may happen between major releases of the platform, you can quickly build your plugin against many versions of the base IDE. WARNING When adding additional repositories to your Gradle build script, always use HTTPS protocol. NOTE Please make sure to always upgrade to the latest version of gradle-intellij-plugin . Follow releases on GitHub . Below are a series of guides to developing and deploying Gradle-based Consulo Plugins: Getting Started with Gradle Configuring Gradle Projects Publishing Plugins with Gradle","title":"Building Plugins with Gradle"},{"location":"tutorials/code_inspections/","text":"The Consulo provides tools designed for static code analysis called code inspections , which help the user maintain and clean up code without actually executing it. Custom code inspections can be implemented as Consulo plugins. Examples of the plugin approach are the Consulo SDK code samples inspection_basics and comparing_references_inspection . In addition, the comparing_references_inspection code sample demonstrates implementing a unit test. You can also create custom inspections through the IntelliJ IDEA user interface. See Code Inspection and Creating Custom Inspections for more information. See Inspections topic in Consulo UI Guidelines on naming, writing description, and message texts for inspections. Creating an Inspection Plugin The comparing_references_inspection code sample adds a new inspection to the Java | Probable Bugs group in the Inspections list . The inspection reports when the == or != operator is used between Java expressions of reference types. It illustrates the components for a custom inspection plugin: * Describing an inspection in the plugin configuration file. * Implementing a local inspection class to inspect Java code in the Consulo-based IDE editor. * Creating a visitor to traverse the PSI tree of the Java file being edited, inspecting for problematic syntax. * Implementing a quick fix class to correct syntax problems by altering the PSI tree as needed. Quick fixes are displayed to the user like intentions . * Implementing an inspection preferences panel to display information about the inspection. * Writing an HTML description of the inspection for display in the inspection preferences panel. * Optionally, create a unit test for the plugin. Although the Consulo SDK code samples illustrate implementations of these components, it is often useful to see examples of inspections implemented in the intellij_community code base. This process can help find inspection descriptions and implementations based on what is visible in the IDE UI. The overall approach works for inspections aimed at other languages as well. * Find an existing inspection that is similar to the one you want to implement in the Preferences | Editor | Inspections panel. Note the display name of the inspection. For example, the Java/Probable Bugs inspection \"Object comparison using '==', instead of 'equals()'\" is very similar to comparing_references_inspection . * Use the display name text as the target for a search within the intellij_community project. This will identify a bundle file if the display name is localized. If it is not localized, the search finds either the plugin configuration ( plugin.xml ) file where it is an attribute in the inspection description, or the implementation where it is provided by an overridden method. * In the case of localization, copy the key from the bundle file identified by the search. * Use the key text as the target for a search within the intellij_community project. This search locates the plugin configuration file that describes the inspection. * From the inspection description entry find the implementationClass attribute value. * Use the implementationClass text as the target of a class search in the intellij_community codebase to find the implementation. Creating an Inspection The comparing_references_inspection code sample reports when the == or != operators are used between Java expressions of reference types. The user can apply a quick fix to change a==b to a.equals(b) , or a!=b to !a.equals(b) . The details of the comparing_references_inspection implementation illustrate the components of an inspection plugin. Plugin Configuration File The comparing_references_inspection is described as a <localInspection> extension point in the comparing_references_inspection plugin configuration ( plugin.xml ) file. There exist two types of inspection extensions: * The com.intellij.localInspection extension point is used for inspections that operate on one file at a time, and also operate \"on-the-fly\" as the user edits the file. * The com.intellij.globalInspection extension point is used for inspections that operate across multiple files, and the associated fix might, for example, refactor code between files. The minimum inspection description must contain the implementationClass attribute. As shown in the comparing_references_inspection plugin configuration file, other attributes can be defined in the localInspection element, either with or without localization. In most cases, it is simplest to define the attributes in the plugin configuration file because the underlying parent classes handle most of the class responsibilities based on the configuration file description. Note that some attributes are not displayed to the user, so they are never localized. If required, inspections can define all of the attribute information (except implementationClass ) by overriding methods in the inspection implementation class (not recommended in general). Inspection Implementation Java Class Inspection implementations for Java files, like ComparingReferencesInspection , are often based on the Java class AbstractBaseJavaLocalInspectionTool . The AbstractBaseJavaLocalInspectionTool implementation class offers methods to inspect Java classes, fields, and methods. More generally, localInspection types are based on the class LocalInspectionTool . Examining the class hierarchy for LocalInspectionTool shows that the Consulo provides many child inspection classes for a variety of languages and frameworks. One of these classes is a good basis for a new inspection implementation, but a bespoke implementation can also be based directly on LocalInspectionTool . The primary responsibilities of the inspection implementation class are to provide: * A PsiElementVisitor object to traverse the PSI tree of the file being inspected. * A LocalQuickFix class to change the syntax of an identified problem. * A JPanel to be displayed in the Inspections dialog. The ComparingReferencesInspection class defines two String fields: * QUICK_FIX_NAME defines the string users see when prompted to apply the quick fix. * CHECKED_CLASSES holds a list of class names of interest to the inspection. The overridden ComparingReferencesInspection methods are discussed in the sections below. Visitor Implementation Class The visitor class evaluates whether elements of the file's PSI tree are of interest to an inspection. The ComparingReferencesInspection.buildVisitor() method creates an anonymous visitor class based on JavaElementVisitor to traverse the PSI tree of the Java file being edited, inspecting for suspect syntax. The anonymous class overrides three methods in particular. * visitReferenceExpression() to prevent any duplicate visitation of reference-type expressions. * visitBinaryExpression() , which does all the heavy lifting. It is called to evaluate a PsiBinaryExpression , and it checks to see if the operands are == or != , and if the operands are classes relevant to this inspection. * isCheckedType() evaluates the PsiType of the operands to determine if they are of interest to this inspection. Quick Fix Implementation The quick fix class acts much like an intention, allowing the user to invoke it on the PsiElement (or TextRange ) highlighted by the inspection. The ComparingReferencesInspection implementation uses the nested class CriQuickFix to implement a quick fix based on LocalQuickFix . The CriQuickFix class gives a user the option to change the use of a == b and a != b expression to a.equals(b) and !a.equals(b) respectively. The heavy lifting is done in CriQuickFix.applyFix() , which manipulates the PSI tree to convert the expressions. The change to the PSI tree is accomplished by the usual approach to modification: * Getting a PsiElementFactory . * Creating a new PsiMethodCallExpression . * Substituting the original left and right operands into the new PsiMethodCallExpression . * Replacing the original binary expression with the PsiMethodCallExpression . Inspection Preferences Panel The inspection preferences panel is used to display information and provide additional options for the inspection. The panel created by ComparingReferencesInspection.createOptionsPanel() just defines a single JTextField to display in a JPanel . This JPanel gets added to the default Consulo Inspections Preferences dialog when the comparing_references_inspection short name is selected. The JTextField allows editing of the CHECKED_CLASSES field while displayed in the panel. Note that the Consulo provides most of the UI displayed in the Inspections Preferences panel. As long as the inspection attributes and inspection description are defined correctly, the Consulo displays the information in the Inspections Preferences UI. Inspection Description The inspection description is an HTML file. The description is displayed in the upper right panel of the Inspections Preferences dialog when an inspection is selected from the list. Implicit in using LocalInspectionTool in the class hierarchy of the inspection implementation means following some conventions. * The inspection description file is expected to be located under <resources root>/inspectionDescriptions/ . If the inspection description file is to be located elsewhere, override getDescriptionUrl() in the inspection implementation class. * The name of the description file is expected to be the inspection <short name>.html as provided by the inspection description, or the inspection implementation class. If a short name is not provided by the plugin, the Consulo computes one by removing Inspection suffix from the implementation class name. Inspection Unit Test NOTE Please note that running the test requires setting system property idea.home.path in test {} block of build.gradle The comparing_references_inspection code sample provides a unit test for the inspection. See the Testing Plugins section for general information about plugin testing. The comparing_references_inspection test is based on the UsefulTestCase class, part of the JUnit framework APIs. This class handles much of the underlying boilerplate for tests. By convention, the folder <project root>/testData/ contains the test files. The folder contains pairs of files for each test using the name convention *.java and *.after.java . In the case of comparing_references_inspection the test files are Eq.java / Eq.after.java , and Neq.java / Neq.after.java . The comparing_references_inspection tests run the inspection on the *.java files, implement the quick fix, and compare the results with the respective *.after.java files. Running the Comparing References Inspection Code Sample The comparing_references_inspection code sample adds a new inspection to the Java | Probable Bugs group in the Inspections list . The inspection reports when the == or != operator is used between Java expressions of reference types. To run the sample plugin: * Start IntelliJ IDEA , open the intellij-sdk-docs project, and highlight the comparing_references_inspection module. * Open the Project Structure dialog and ensure that the project settings are valid for your environment. * If necessary, modify the Run/Debug Configurations for the comparing_references_inspection module. * Run the plugin by choosing Run on the main menu. Configuring the Plugin Once the plugin is launched, you can set the plugin options. You can specify the Java classes to participate in the code inspection and the severity level of the found probable bugs. On the main menu, open the Preferences | Editor | Inspections dialog. In the list of the IntelliJ IDEA Java inspections, expand the Probable bugs node, and then click SDK: '==' or '!=' instead of 'equals()' . Under Options , you can specify the following plugin settings: * From the Severity list, select the severity level of probable bugs the plugin finds such as Warning, Info, etc. * In the text box under Severity , specify the semicolon separated list of Java classes to participate in this code inspection. * When finished, click OK . How does it work? The plugin inspects your code opened in the IntelliJ IDEA editor or the code you are typing. The plugin highlights the code fragments where two variables of the reference type are separated by == or != and proposes to replace this code fragment with .equals() : In this example, the str1 and str2 are variables of the String type. Clicking SDK: Use equals() replaces: return ( str1 == str2 ); with the code: return ( str1 . equals ( str2 ));","title":"Code Inspections"},{"location":"tutorials/code_inspections/#creating-an-inspection-plugin","text":"The comparing_references_inspection code sample adds a new inspection to the Java | Probable Bugs group in the Inspections list . The inspection reports when the == or != operator is used between Java expressions of reference types. It illustrates the components for a custom inspection plugin: * Describing an inspection in the plugin configuration file. * Implementing a local inspection class to inspect Java code in the Consulo-based IDE editor. * Creating a visitor to traverse the PSI tree of the Java file being edited, inspecting for problematic syntax. * Implementing a quick fix class to correct syntax problems by altering the PSI tree as needed. Quick fixes are displayed to the user like intentions . * Implementing an inspection preferences panel to display information about the inspection. * Writing an HTML description of the inspection for display in the inspection preferences panel. * Optionally, create a unit test for the plugin. Although the Consulo SDK code samples illustrate implementations of these components, it is often useful to see examples of inspections implemented in the intellij_community code base. This process can help find inspection descriptions and implementations based on what is visible in the IDE UI. The overall approach works for inspections aimed at other languages as well. * Find an existing inspection that is similar to the one you want to implement in the Preferences | Editor | Inspections panel. Note the display name of the inspection. For example, the Java/Probable Bugs inspection \"Object comparison using '==', instead of 'equals()'\" is very similar to comparing_references_inspection . * Use the display name text as the target for a search within the intellij_community project. This will identify a bundle file if the display name is localized. If it is not localized, the search finds either the plugin configuration ( plugin.xml ) file where it is an attribute in the inspection description, or the implementation where it is provided by an overridden method. * In the case of localization, copy the key from the bundle file identified by the search. * Use the key text as the target for a search within the intellij_community project. This search locates the plugin configuration file that describes the inspection. * From the inspection description entry find the implementationClass attribute value. * Use the implementationClass text as the target of a class search in the intellij_community codebase to find the implementation.","title":"Creating an Inspection Plugin"},{"location":"tutorials/code_inspections/#creating-an-inspection","text":"The comparing_references_inspection code sample reports when the == or != operators are used between Java expressions of reference types. The user can apply a quick fix to change a==b to a.equals(b) , or a!=b to !a.equals(b) . The details of the comparing_references_inspection implementation illustrate the components of an inspection plugin.","title":"Creating an Inspection"},{"location":"tutorials/code_inspections/#plugin-configuration-file","text":"The comparing_references_inspection is described as a <localInspection> extension point in the comparing_references_inspection plugin configuration ( plugin.xml ) file. There exist two types of inspection extensions: * The com.intellij.localInspection extension point is used for inspections that operate on one file at a time, and also operate \"on-the-fly\" as the user edits the file. * The com.intellij.globalInspection extension point is used for inspections that operate across multiple files, and the associated fix might, for example, refactor code between files. The minimum inspection description must contain the implementationClass attribute. As shown in the comparing_references_inspection plugin configuration file, other attributes can be defined in the localInspection element, either with or without localization. In most cases, it is simplest to define the attributes in the plugin configuration file because the underlying parent classes handle most of the class responsibilities based on the configuration file description. Note that some attributes are not displayed to the user, so they are never localized. If required, inspections can define all of the attribute information (except implementationClass ) by overriding methods in the inspection implementation class (not recommended in general).","title":"Plugin Configuration File"},{"location":"tutorials/code_inspections/#inspection-implementation-java-class","text":"Inspection implementations for Java files, like ComparingReferencesInspection , are often based on the Java class AbstractBaseJavaLocalInspectionTool . The AbstractBaseJavaLocalInspectionTool implementation class offers methods to inspect Java classes, fields, and methods. More generally, localInspection types are based on the class LocalInspectionTool . Examining the class hierarchy for LocalInspectionTool shows that the Consulo provides many child inspection classes for a variety of languages and frameworks. One of these classes is a good basis for a new inspection implementation, but a bespoke implementation can also be based directly on LocalInspectionTool . The primary responsibilities of the inspection implementation class are to provide: * A PsiElementVisitor object to traverse the PSI tree of the file being inspected. * A LocalQuickFix class to change the syntax of an identified problem. * A JPanel to be displayed in the Inspections dialog. The ComparingReferencesInspection class defines two String fields: * QUICK_FIX_NAME defines the string users see when prompted to apply the quick fix. * CHECKED_CLASSES holds a list of class names of interest to the inspection. The overridden ComparingReferencesInspection methods are discussed in the sections below.","title":"Inspection Implementation Java Class"},{"location":"tutorials/code_inspections/#visitor-implementation-class","text":"The visitor class evaluates whether elements of the file's PSI tree are of interest to an inspection. The ComparingReferencesInspection.buildVisitor() method creates an anonymous visitor class based on JavaElementVisitor to traverse the PSI tree of the Java file being edited, inspecting for suspect syntax. The anonymous class overrides three methods in particular. * visitReferenceExpression() to prevent any duplicate visitation of reference-type expressions. * visitBinaryExpression() , which does all the heavy lifting. It is called to evaluate a PsiBinaryExpression , and it checks to see if the operands are == or != , and if the operands are classes relevant to this inspection. * isCheckedType() evaluates the PsiType of the operands to determine if they are of interest to this inspection.","title":"Visitor Implementation Class"},{"location":"tutorials/code_inspections/#quick-fix-implementation","text":"The quick fix class acts much like an intention, allowing the user to invoke it on the PsiElement (or TextRange ) highlighted by the inspection. The ComparingReferencesInspection implementation uses the nested class CriQuickFix to implement a quick fix based on LocalQuickFix . The CriQuickFix class gives a user the option to change the use of a == b and a != b expression to a.equals(b) and !a.equals(b) respectively. The heavy lifting is done in CriQuickFix.applyFix() , which manipulates the PSI tree to convert the expressions. The change to the PSI tree is accomplished by the usual approach to modification: * Getting a PsiElementFactory . * Creating a new PsiMethodCallExpression . * Substituting the original left and right operands into the new PsiMethodCallExpression . * Replacing the original binary expression with the PsiMethodCallExpression .","title":"Quick Fix Implementation"},{"location":"tutorials/code_inspections/#inspection-preferences-panel","text":"The inspection preferences panel is used to display information and provide additional options for the inspection. The panel created by ComparingReferencesInspection.createOptionsPanel() just defines a single JTextField to display in a JPanel . This JPanel gets added to the default Consulo Inspections Preferences dialog when the comparing_references_inspection short name is selected. The JTextField allows editing of the CHECKED_CLASSES field while displayed in the panel. Note that the Consulo provides most of the UI displayed in the Inspections Preferences panel. As long as the inspection attributes and inspection description are defined correctly, the Consulo displays the information in the Inspections Preferences UI.","title":"Inspection Preferences Panel"},{"location":"tutorials/code_inspections/#inspection-description","text":"The inspection description is an HTML file. The description is displayed in the upper right panel of the Inspections Preferences dialog when an inspection is selected from the list. Implicit in using LocalInspectionTool in the class hierarchy of the inspection implementation means following some conventions. * The inspection description file is expected to be located under <resources root>/inspectionDescriptions/ . If the inspection description file is to be located elsewhere, override getDescriptionUrl() in the inspection implementation class. * The name of the description file is expected to be the inspection <short name>.html as provided by the inspection description, or the inspection implementation class. If a short name is not provided by the plugin, the Consulo computes one by removing Inspection suffix from the implementation class name.","title":"Inspection Description"},{"location":"tutorials/code_inspections/#inspection-unit-test","text":"NOTE Please note that running the test requires setting system property idea.home.path in test {} block of build.gradle The comparing_references_inspection code sample provides a unit test for the inspection. See the Testing Plugins section for general information about plugin testing. The comparing_references_inspection test is based on the UsefulTestCase class, part of the JUnit framework APIs. This class handles much of the underlying boilerplate for tests. By convention, the folder <project root>/testData/ contains the test files. The folder contains pairs of files for each test using the name convention *.java and *.after.java . In the case of comparing_references_inspection the test files are Eq.java / Eq.after.java , and Neq.java / Neq.after.java . The comparing_references_inspection tests run the inspection on the *.java files, implement the quick fix, and compare the results with the respective *.after.java files.","title":"Inspection Unit Test"},{"location":"tutorials/code_inspections/#running-the-comparing-references-inspection-code-sample","text":"The comparing_references_inspection code sample adds a new inspection to the Java | Probable Bugs group in the Inspections list . The inspection reports when the == or != operator is used between Java expressions of reference types. To run the sample plugin: * Start IntelliJ IDEA , open the intellij-sdk-docs project, and highlight the comparing_references_inspection module. * Open the Project Structure dialog and ensure that the project settings are valid for your environment. * If necessary, modify the Run/Debug Configurations for the comparing_references_inspection module. * Run the plugin by choosing Run on the main menu.","title":"Running the Comparing References Inspection Code Sample"},{"location":"tutorials/code_inspections/#configuring-the-plugin","text":"Once the plugin is launched, you can set the plugin options. You can specify the Java classes to participate in the code inspection and the severity level of the found probable bugs. On the main menu, open the Preferences | Editor | Inspections dialog. In the list of the IntelliJ IDEA Java inspections, expand the Probable bugs node, and then click SDK: '==' or '!=' instead of 'equals()' . Under Options , you can specify the following plugin settings: * From the Severity list, select the severity level of probable bugs the plugin finds such as Warning, Info, etc. * In the text box under Severity , specify the semicolon separated list of Java classes to participate in this code inspection. * When finished, click OK .","title":"Configuring the Plugin"},{"location":"tutorials/code_inspections/#how-does-it-work","text":"The plugin inspects your code opened in the IntelliJ IDEA editor or the code you are typing. The plugin highlights the code fragments where two variables of the reference type are separated by == or != and proposes to replace this code fragment with .equals() : In this example, the str1 and str2 are variables of the String type. Clicking SDK: Use equals() replaces: return ( str1 == str2 ); with the code: return ( str1 . equals ( str2 ));","title":"How does it work?"},{"location":"tutorials/code_intentions/","text":"This topic describes the conditional_operator_intention , a sample plugin that adds a new intention action to the Consulo Intentions list. In addition, the sample plugin contains a JUnit-based test. About Intention Actions The Consulo analyzes your code and helps handle situations that may result in errors. When a possible problem is suspected, the IDE suggests an appropriate intention action, denoted with special icons. For more information, refer to Intention Actions in the IntelliJ IDEA Web Help. You can view a list of all available intention actions using the Intention List provided by the IDE. To display Intention List Open the Settings dialog box. Under IDE Settings , click Intentions . This displays the list of all intention actions currently available in IntelliJ IDEA . The intention actions are grouped according to the areas of their use. To enable/disable an intention action, select/deselect the check box to its left. Techniques Used The conditional_operator_intention sample plugin illustrates the use of the following techniques: How to analyze a PSI tree . How to find a Java token of interest in the PSI tree. How to invoke a quick fix action for a token element under cursor using the PsiElementBaseIntentionAction class. How to create a JUnit test for this plugin using the IdeaTestFixtureFactory class. Sample Plugin The ConditionalOperatorConverter sample plugin is available in the <%IntelliJ SDK Docs project%>/code_samples/conditional_operator_intention directory. When launched, this plugin adds the Convert ternary operator if statement item to the Conditional Operator node in the IDEA Intentions list: Running the Plugin To run the sample plugin Start IntelliJ IDEA and open the conditionalOperatorConvertor plugin project saved into the <%IntelliJ SDK Docs project%>/code_samples/conditional_operator_intention directory. Open the Project Structure dialog and ensure that the project settings are valid for your environment. If necessary, modify the Run/Debug Configurations and Run the plugin by choosing the Run on the main menu. How does it work? The plugin analyzes symbols under the cursor in your code opened in the IDEA editor. If the cursor is positioned on the \"?\" conditional operator, IntelliJ IDEA proposes to replace this conditional (ternary) operator with the \"if-then-else\" statement: In this example, the code: return ( n >= 0 ) ? n : - n ; will be replaced with the code: if (( n >= 0 )) { return n ; } else { return - n ; } Testing the Plugin NOTE Please note that running the test requires setting system property idea.home.path in test {} block of build.gradle The sample plugin contains the ConditionalOperatorConverterTest Java class and the test data in the test/testData/ directory. To perform the plugin test, run the ConditionalOperatorConverterTest.testIntention() method. For detailed information about testing and all related procedures, refer to Testing in the IntelliJ IDEA Web Help.","title":"Intentions"},{"location":"tutorials/code_intentions/#about-intention-actions","text":"The Consulo analyzes your code and helps handle situations that may result in errors. When a possible problem is suspected, the IDE suggests an appropriate intention action, denoted with special icons. For more information, refer to Intention Actions in the IntelliJ IDEA Web Help. You can view a list of all available intention actions using the Intention List provided by the IDE. To display Intention List Open the Settings dialog box. Under IDE Settings , click Intentions . This displays the list of all intention actions currently available in IntelliJ IDEA . The intention actions are grouped according to the areas of their use. To enable/disable an intention action, select/deselect the check box to its left.","title":"About Intention Actions"},{"location":"tutorials/code_intentions/#techniques-used","text":"The conditional_operator_intention sample plugin illustrates the use of the following techniques: How to analyze a PSI tree . How to find a Java token of interest in the PSI tree. How to invoke a quick fix action for a token element under cursor using the PsiElementBaseIntentionAction class. How to create a JUnit test for this plugin using the IdeaTestFixtureFactory class.","title":"Techniques Used"},{"location":"tutorials/code_intentions/#sample-plugin","text":"The ConditionalOperatorConverter sample plugin is available in the <%IntelliJ SDK Docs project%>/code_samples/conditional_operator_intention directory. When launched, this plugin adds the Convert ternary operator if statement item to the Conditional Operator node in the IDEA Intentions list:","title":"Sample Plugin"},{"location":"tutorials/code_intentions/#running-the-plugin","text":"To run the sample plugin Start IntelliJ IDEA and open the conditionalOperatorConvertor plugin project saved into the <%IntelliJ SDK Docs project%>/code_samples/conditional_operator_intention directory. Open the Project Structure dialog and ensure that the project settings are valid for your environment. If necessary, modify the Run/Debug Configurations and Run the plugin by choosing the Run on the main menu.","title":"Running the Plugin"},{"location":"tutorials/code_intentions/#how-does-it-work","text":"The plugin analyzes symbols under the cursor in your code opened in the IDEA editor. If the cursor is positioned on the \"?\" conditional operator, IntelliJ IDEA proposes to replace this conditional (ternary) operator with the \"if-then-else\" statement: In this example, the code: return ( n >= 0 ) ? n : - n ; will be replaced with the code: if (( n >= 0 )) { return n ; } else { return - n ; }","title":"How does it work?"},{"location":"tutorials/code_intentions/#testing-the-plugin","text":"NOTE Please note that running the test requires setting system property idea.home.path in test {} block of build.gradle The sample plugin contains the ConditionalOperatorConverterTest Java class and the test data in the test/testData/ directory. To perform the plugin test, run the ConditionalOperatorConverterTest.testIntention() method. For detailed information about testing and all related procedures, refer to Testing in the IntelliJ IDEA Web Help.","title":"Testing the Plugin"},{"location":"tutorials/custom_language_support_tutorial/","text":"In this tutorial we will add support for a .properties language and its usages within Java code. TIP Consulo support for custom languages is discussed in more depth in the Custom Language Support section. Corresponding parts are linked under \"Reference\" on top of each page in this tutorial. The example plugin used in this tutorial is the simple_language_plugin code sample. This a step-by-step tutorial, and it requires completing each step, in order: 1. Prerequisites 2. Language and File Type 3. Grammar and Parser 4. Lexer and Parser Definition 5. Syntax Highlighter and Color Settings Page 6. PSI Helpers and Utilities 7. Annotator 8. Line Marker Provider 9. Completion Contributor 10. Reference Contributor 11. Find Usages Provider 12. Folding Builder 13. Go To Symbol Contributor 14. Structure View Factory 15. Formatter 16. Code Style Settings 17. Commenter 18. Quick Fix","title":"Custom Language Support Tutorial"},{"location":"tutorials/editor_basics/","text":"This tutorial will lead you through the series of steps showing how to work with the Consulo Editor, how to access and modify text it contains, and how to handle events sent to the editor. * 1. Working With Text * 2. Editor coordinate systems: positions and offsets * 3. Handling Editor Events Note: The part of the API described in this tutorial only allows operations with text. For operations that require access to the PSI please see the PSI Cookbook section. See also: The following are referenced in the tutorial: * The editor_basics plugin code sample, * editor-ui-api package , * Those not found in editor-ui-api package: * EditorActionManager , * EditorActionHandler , * TypedActionHandler , * TypedAction . Related topics: * Action System * Threading Issues","title":"Overview"},{"location":"tutorials/github_template/","text":"Consulo Plugin Template is a repository that provides a pure boilerplate template to make it easier to create a new plugin project using the recommended Gradle setup . The main goal of this template is to speed up the setup phase of plugin development for both new and experienced developers by preconfiguring the project scaffold and CI, linking to the proper documentation pages, and keeping everything organized. GitHub Template allows you to create a new repository from the scaffold without having to copy and paste content, clone repositories, or clear the history manually. All you have to do is click the Use this template button on the GitHub project page. After that, the GitHub Actions workflow will be triggered to override or remove any template-specific configurations, such as the plugin name, current changelog, etc. Once this is complete, the project is ready to be cloned to your local environment and opened with IntelliJ IDEA . For more details, please refer to the Consulo Plugin Template project documentation.","title":"Consulo Plugin Template"},{"location":"tutorials/live_templates/","text":"Live Templates are customizable rules that allow developers to abbreviate repetitive patterns of text in the editor. When a user types the designated abbreviation followed by a configurable expansion key (usually Tab ), the IDE transforms the preceding input sequence to its full-length output, and update the cursor position. For example, consider a for loop. Typically, the end user would need to type for (int i = 0; i < 10; i++) {<Enter><Tab><Enter><Enter>}<Up> . This pattern may be shortened to fori<Tab> and the remaining contents will be expanded, leaving the following structure: for ( int i = [|] ; i < [] ; i ++ ) { [] } As the user completes each section of the for loop and presses Tab , the cursor advances to the next position in the editor. For more information about creating Custom Live Templates, refer to the corresponding documentation . These sections describe how to add Live Templates, and their associated building blocks, to plugins. * Adding Live Templates to a Plugin * Creating New Functions for Live Templates * Surround Templates","title":"Overview"},{"location":"tutorials/run_configurations/","text":"These series of steps show how to register and implement a simple Run Configuration. Run Configurations are used to run internal and external processes from within Consulo based products. To get familiar with the concept of a Run Configuration refer Run/Debug Configuration section of IntelliJ IDEA Web Help Pre-Requirements Create an empty plugin project as described in Creating a Plugin Project . 1. Register a New ConfigurationType Add new configurationType extension to the plugin.xml <extensions defaultExtensionNs= \"com.intellij\" > <configurationType implementation= \"org.jetbrains.sdk.runConfiguration.DemoRunConfigurationType\" /> </extensions> 2. Implement ConfigurationType Implement ConfigurationType interface registered in the Step 1. public class DemoRunConfigurationType implements ConfigurationType { @Override public String getDisplayName () { return \"Demo\" ; } @Override public String getConfigurationTypeDescription () { return \"Demo Run Configuration Type\" ; } @Override public Icon getIcon () { return AllIcons . General . Information ; } @NotNull @Override public String getId () { return \"DemoRunConfiguration\" ; } @Override public ConfigurationFactory [] getConfigurationFactories () { return new ConfigurationFactory [] { new DemoConfigurationFactory ( this )}; } } 3. Implement a ConfigurationFactory Implement a new ConfigurationFactory through which custom run configurations will be created. public class DemoConfigurationFactory extends ConfigurationFactory { private static final String FACTORY_NAME = \"Demo configuration factory\" ; protected DemoConfigurationFactory ( ConfigurationType type ) { super ( type ); } @Override public RunConfiguration createTemplateConfiguration ( Project project ) { return new DemoRunConfiguration ( project , this , \"Demo\" ); } @Override public String getName () { return FACTORY_NAME ; } } 4. Implement a Run Configuration To make your changes visible from the UI, implement a new Run Configuration. Note: In most of the cases you can derive a custom Run Configuration class from the RunConfigurationBase . If you need to implement specific settings externalization rules and I/O behaviour, use RunConfiguration interface. public class DemoRunConfiguration extends RunConfigurationBase { protected DemoRunConfiguration ( Project project , ConfigurationFactory factory , String name ) { super ( project , factory , name ); } @NotNull @Override public SettingsEditor <? extends RunConfiguration > getConfigurationEditor () { return new DemoSettingsEditor (); } @Override public void checkConfiguration () throws RuntimeConfigurationException { } @Nullable @Override public RunProfileState getState ( @NotNull Executor executor , @NotNull ExecutionEnvironment executionEnvironment ) throws ExecutionException { return null ; } } 5. Create and Implement Run Configuration UI Form Make sure UI Designer plugin is enabled . Create a new UI form that defines, how an inner part of the new Run Configuration should look like. Default Run Configuration will be looking like this: 6. Bind the UI Form The UI Form should be bound with a Java class responsible for handling UI components logic. public class DemoSettingsEditor extends SettingsEditor < DemoRunConfiguration > { private JPanel myPanel ; private LabeledComponent < ComponentWithBrowseButton > myMainClass ; @Override protected void resetEditorFrom ( DemoRunConfiguration demoRunConfiguration ) { } @Override protected void applyEditorTo ( DemoRunConfiguration demoRunConfiguration ) throws ConfigurationException { } @NotNull @Override protected JComponent createEditor () { return myPanel ; } private void createUIComponents () { myMainClass = new LabeledComponent < ComponentWithBrowseButton > (); myMainClass . setComponent ( new TextFieldWithBrowseButton ()); } } 7. Compile and Run the Plugin Refer to Running and Debugging a Plugin . After going through the steps described above you can create a custom Run Configuration from your plugin.","title":"Run Configurations Tutorial"},{"location":"tutorials/run_configurations/#pre-requirements","text":"Create an empty plugin project as described in Creating a Plugin Project .","title":"Pre-Requirements"},{"location":"tutorials/run_configurations/#1-register-a-new-configurationtype","text":"Add new configurationType extension to the plugin.xml <extensions defaultExtensionNs= \"com.intellij\" > <configurationType implementation= \"org.jetbrains.sdk.runConfiguration.DemoRunConfigurationType\" /> </extensions>","title":"1. Register a New ConfigurationType"},{"location":"tutorials/run_configurations/#2-implement-configurationtype","text":"Implement ConfigurationType interface registered in the Step 1. public class DemoRunConfigurationType implements ConfigurationType { @Override public String getDisplayName () { return \"Demo\" ; } @Override public String getConfigurationTypeDescription () { return \"Demo Run Configuration Type\" ; } @Override public Icon getIcon () { return AllIcons . General . Information ; } @NotNull @Override public String getId () { return \"DemoRunConfiguration\" ; } @Override public ConfigurationFactory [] getConfigurationFactories () { return new ConfigurationFactory [] { new DemoConfigurationFactory ( this )}; } }","title":"2. Implement ConfigurationType"},{"location":"tutorials/run_configurations/#3-implement-a-configurationfactory","text":"Implement a new ConfigurationFactory through which custom run configurations will be created. public class DemoConfigurationFactory extends ConfigurationFactory { private static final String FACTORY_NAME = \"Demo configuration factory\" ; protected DemoConfigurationFactory ( ConfigurationType type ) { super ( type ); } @Override public RunConfiguration createTemplateConfiguration ( Project project ) { return new DemoRunConfiguration ( project , this , \"Demo\" ); } @Override public String getName () { return FACTORY_NAME ; } }","title":"3. Implement a ConfigurationFactory"},{"location":"tutorials/run_configurations/#4-implement-a-run-configuration","text":"To make your changes visible from the UI, implement a new Run Configuration. Note: In most of the cases you can derive a custom Run Configuration class from the RunConfigurationBase . If you need to implement specific settings externalization rules and I/O behaviour, use RunConfiguration interface. public class DemoRunConfiguration extends RunConfigurationBase { protected DemoRunConfiguration ( Project project , ConfigurationFactory factory , String name ) { super ( project , factory , name ); } @NotNull @Override public SettingsEditor <? extends RunConfiguration > getConfigurationEditor () { return new DemoSettingsEditor (); } @Override public void checkConfiguration () throws RuntimeConfigurationException { } @Nullable @Override public RunProfileState getState ( @NotNull Executor executor , @NotNull ExecutionEnvironment executionEnvironment ) throws ExecutionException { return null ; } }","title":"4. Implement a Run Configuration"},{"location":"tutorials/run_configurations/#5-create-and-implement-run-configuration-ui-form","text":"Make sure UI Designer plugin is enabled . Create a new UI form that defines, how an inner part of the new Run Configuration should look like. Default Run Configuration will be looking like this:","title":"5. Create and Implement Run Configuration UI Form"},{"location":"tutorials/run_configurations/#6-bind-the-ui-form","text":"The UI Form should be bound with a Java class responsible for handling UI components logic. public class DemoSettingsEditor extends SettingsEditor < DemoRunConfiguration > { private JPanel myPanel ; private LabeledComponent < ComponentWithBrowseButton > myMainClass ; @Override protected void resetEditorFrom ( DemoRunConfiguration demoRunConfiguration ) { } @Override protected void applyEditorTo ( DemoRunConfiguration demoRunConfiguration ) throws ConfigurationException { } @NotNull @Override protected JComponent createEditor () { return myPanel ; } private void createUIComponents () { myMainClass = new LabeledComponent < ComponentWithBrowseButton > (); myMainClass . setComponent ( new TextFieldWithBrowseButton ()); } }","title":"6. Bind the UI Form"},{"location":"tutorials/run_configurations/#7-compile-and-run-the-plugin","text":"Refer to Running and Debugging a Plugin . After going through the steps described above you can create a custom Run Configuration from your plugin.","title":"7. Compile and Run the Plugin"},{"location":"tutorials/settings_tutorial/","text":"Introduction As discussed in the Settings Guide , plugins can add Settings to Consulo-based IDEs. The IDE displays the Settings in response to a user choosing Settings/Preferences . Custom Settings are displayed and function just like those native to the IDE. bullet list {:toc} Overview of a Custom Settings Implementation Using the SDK code sample settings , this tutorial illustrates the steps to create custom Application-level Settings. Many Consulo Settings implementations use fewer classes, but the settings code sample factors the functionality into three classes for clarity: * The AppSettingsConfigurable is analogous to a Controller in the MVC model - it interacts with the other two Settings classes and the Consulo, * The AppSettingsState is like a Model because it stores the Settings persistently, * The AppSettingsComponent is similar to a View because it displays and captures edits to the values of the Settings. The structure of the implementation is the same for Project Settings, but there are minor differences in the Configurable implementation and Extension Point (EP) declaration . The AppSettingsState Class The AppSettingsState class persistently stores the custom Settings. It is based on the Consulo Persistence Model . Declaring AppSettingsState Given a Light Service is not used, the persistent data class must be declared as a Service EP in the plugin.xml file. If these were Project Settings, the com.intellij.projectService EP would be used. However, because these are Application Settings, the com.intellij.applicationService EP is used with the FQN of the implementation class: <extensions defaultExtensionNs= \"com.intellij\" > <applicationService serviceImplementation= \"org.intellij.sdk.settings.AppSettingsState\" /> </extensions> Creating the AppSettingState Implementation As discussed in Implementing the PersistentStateComponent Interface , AppSettingsState uses the pattern of implementing PersistentStateComponent itself: { % include / code_samples / settings / src / main / java / org / intellij / sdk / settings / AppSettingsState . java % } Storage Annotation The @State annotation, located just above the class declaration, defines the data storage location . For AppSettingsState , the data name parameter is the FQN of the class. Using FQN is a best practice to follow, and is required if custom data gets stored in the standard project or workspace files. The storages parameter utilizes the @Storage annotation to define a custom file name for the AppSettingsState data. In this case, the file is located in the options directory of the configuration directory for the IDE. Persistent Data Fields The AppSettingState implementation has two public fields: a String and a boolean . Conceptually these fields hold the name of a user, and whether that person is an IntelliJ IDEA user, respectively. See Implementing the State Class for more information about how PersistentStateComponent serializes public fields. AppSettingState Methods The fields are so limited and straightforward for this class that encapsulation is not used for simplicity. All that's needed for functionality is to override the two methods called by the Consulo when a new component state is loaded ( PersistentStateComponent.loadState() ), and when a state is saved ( PersistentStateComponent.getState() ). See PersistentStateComponent for more information about these methods. One static convenience method has been added - AppSettingState.getInstance() - which allows AppSettingsConfigurable to easily acquire a reference to AppSettingState . The AppSettingsComponent Class The role of the AppSettingsComponent is to provide a JPanel for the custom Settings to the IDE Settings Dialog. The AppSettingsComponent has-a JPanel , and is responsible for its lifetime. The AppSettingsComponent is instantiated by AppSettingsConfigurable . Creating the AppSettingsComponent Implementation The AppSettingsComponent defines a JPanel containing a JBTextField and a JBCheckBox to hold and display the data that maps to the data fields of AppSettingsState : { % include / code_samples / settings / src / main / java / org / intellij / sdk / settings / AppSettingsComponent . java % } AppSettingsComponent Methods The constructor builds the JPanel using the convenient FormBuilder , and saves a reference to the JPanel . The rest of the class are simple accessors and mutators to encapsulate the UI components used on the JPanel . The AppSettingsConfigurable Class The methods of AppSettingsConfigurable are called by the Consulo, and AppSettingsConfigurable in turn interacts with AppSettingsComponent and AppSettingState . Declaring the AppSettingsConfigurable As described in Declaring Application Settings , the com.intellij.applicationConfigurable is used as the EP. An explanation of this declaration can be found in Declaring Application Settings : <extensions defaultExtensionNs= \"com.intellij\" > <applicationConfigurable parentId= \"tools\" instance= \"org.intellij.sdk.settings.AppSettingsConfigurable\" id= \"org.intellij.sdk.settings.AppSettingsConfigurable\" displayName= \"SDK: Application Settings Example\" /> </extensions> Creating the AppSettingsConfigurable Implementation The AppSettingsConfigurable class implements Configurable interface. The class has one field to hold a reference to the AppSettingsComponent . { % include / code_samples / settings / src / main / java / org / intellij / sdk / settings / AppSettingsConfigurable . java % } AppSettingsConfigurable Methods All the methods in this class are overrides of the methods in the Configurable interface. Readers are encouraged to review the Javadoc comments for the Configurable methods. Also review notes about Consulo Interactions with Configurable methods. Testing the Custom Settings Plugin After performing the steps described above, compile and run the plugin in a Development Instance to see the custom Settings available in the Settings Dialog. Open the IDE Settings by selecting Settings/Preferences | Tools | SDK: Application Settings Example . The settings are preloaded with the default values: {:width=\"600px\"} Now edit the settings values to \"John Doe\" and click the checkbox. Click on the OK button to close the Settings dialog and save the changes. Exit the Development Instance. Open the file SdkSettingsPlugin.xml to see the Settings persistently stored. In this demonstration the file resides in code_samples/settings/build/idea-sandbox/config/options/ , but see IDE Development Instances for the general Development Instance case, or Default IDE directories if you are testing the settings plugin directly in an IDE. {:width=\"600px\"}","title":"Settings Tutorial"},{"location":"tutorials/settings_tutorial/#introduction","text":"As discussed in the Settings Guide , plugins can add Settings to Consulo-based IDEs. The IDE displays the Settings in response to a user choosing Settings/Preferences . Custom Settings are displayed and function just like those native to the IDE. bullet list {:toc}","title":"Introduction"},{"location":"tutorials/settings_tutorial/#overview-of-a-custom-settings-implementation","text":"Using the SDK code sample settings , this tutorial illustrates the steps to create custom Application-level Settings. Many Consulo Settings implementations use fewer classes, but the settings code sample factors the functionality into three classes for clarity: * The AppSettingsConfigurable is analogous to a Controller in the MVC model - it interacts with the other two Settings classes and the Consulo, * The AppSettingsState is like a Model because it stores the Settings persistently, * The AppSettingsComponent is similar to a View because it displays and captures edits to the values of the Settings. The structure of the implementation is the same for Project Settings, but there are minor differences in the Configurable implementation and Extension Point (EP) declaration .","title":"Overview of a Custom Settings Implementation"},{"location":"tutorials/settings_tutorial/#the-appsettingsstate-class","text":"The AppSettingsState class persistently stores the custom Settings. It is based on the Consulo Persistence Model .","title":"The AppSettingsState Class"},{"location":"tutorials/settings_tutorial/#declaring-appsettingsstate","text":"Given a Light Service is not used, the persistent data class must be declared as a Service EP in the plugin.xml file. If these were Project Settings, the com.intellij.projectService EP would be used. However, because these are Application Settings, the com.intellij.applicationService EP is used with the FQN of the implementation class: <extensions defaultExtensionNs= \"com.intellij\" > <applicationService serviceImplementation= \"org.intellij.sdk.settings.AppSettingsState\" /> </extensions>","title":"Declaring AppSettingsState"},{"location":"tutorials/settings_tutorial/#creating-the-appsettingstate-implementation","text":"As discussed in Implementing the PersistentStateComponent Interface , AppSettingsState uses the pattern of implementing PersistentStateComponent itself: { % include / code_samples / settings / src / main / java / org / intellij / sdk / settings / AppSettingsState . java % }","title":"Creating the AppSettingState Implementation"},{"location":"tutorials/settings_tutorial/#storage-annotation","text":"The @State annotation, located just above the class declaration, defines the data storage location . For AppSettingsState , the data name parameter is the FQN of the class. Using FQN is a best practice to follow, and is required if custom data gets stored in the standard project or workspace files. The storages parameter utilizes the @Storage annotation to define a custom file name for the AppSettingsState data. In this case, the file is located in the options directory of the configuration directory for the IDE.","title":"Storage Annotation"},{"location":"tutorials/settings_tutorial/#persistent-data-fields","text":"The AppSettingState implementation has two public fields: a String and a boolean . Conceptually these fields hold the name of a user, and whether that person is an IntelliJ IDEA user, respectively. See Implementing the State Class for more information about how PersistentStateComponent serializes public fields.","title":"Persistent Data Fields"},{"location":"tutorials/settings_tutorial/#appsettingstate-methods","text":"The fields are so limited and straightforward for this class that encapsulation is not used for simplicity. All that's needed for functionality is to override the two methods called by the Consulo when a new component state is loaded ( PersistentStateComponent.loadState() ), and when a state is saved ( PersistentStateComponent.getState() ). See PersistentStateComponent for more information about these methods. One static convenience method has been added - AppSettingState.getInstance() - which allows AppSettingsConfigurable to easily acquire a reference to AppSettingState .","title":"AppSettingState Methods"},{"location":"tutorials/settings_tutorial/#the-appsettingscomponent-class","text":"The role of the AppSettingsComponent is to provide a JPanel for the custom Settings to the IDE Settings Dialog. The AppSettingsComponent has-a JPanel , and is responsible for its lifetime. The AppSettingsComponent is instantiated by AppSettingsConfigurable .","title":"The AppSettingsComponent Class"},{"location":"tutorials/settings_tutorial/#creating-the-appsettingscomponent-implementation","text":"The AppSettingsComponent defines a JPanel containing a JBTextField and a JBCheckBox to hold and display the data that maps to the data fields of AppSettingsState : { % include / code_samples / settings / src / main / java / org / intellij / sdk / settings / AppSettingsComponent . java % }","title":"Creating the AppSettingsComponent Implementation"},{"location":"tutorials/settings_tutorial/#appsettingscomponent-methods","text":"The constructor builds the JPanel using the convenient FormBuilder , and saves a reference to the JPanel . The rest of the class are simple accessors and mutators to encapsulate the UI components used on the JPanel .","title":"AppSettingsComponent Methods"},{"location":"tutorials/settings_tutorial/#the-appsettingsconfigurable-class","text":"The methods of AppSettingsConfigurable are called by the Consulo, and AppSettingsConfigurable in turn interacts with AppSettingsComponent and AppSettingState .","title":"The AppSettingsConfigurable Class"},{"location":"tutorials/settings_tutorial/#declaring-the-appsettingsconfigurable","text":"As described in Declaring Application Settings , the com.intellij.applicationConfigurable is used as the EP. An explanation of this declaration can be found in Declaring Application Settings : <extensions defaultExtensionNs= \"com.intellij\" > <applicationConfigurable parentId= \"tools\" instance= \"org.intellij.sdk.settings.AppSettingsConfigurable\" id= \"org.intellij.sdk.settings.AppSettingsConfigurable\" displayName= \"SDK: Application Settings Example\" /> </extensions>","title":"Declaring the AppSettingsConfigurable"},{"location":"tutorials/settings_tutorial/#creating-the-appsettingsconfigurable-implementation","text":"The AppSettingsConfigurable class implements Configurable interface. The class has one field to hold a reference to the AppSettingsComponent . { % include / code_samples / settings / src / main / java / org / intellij / sdk / settings / AppSettingsConfigurable . java % }","title":"Creating the AppSettingsConfigurable Implementation"},{"location":"tutorials/settings_tutorial/#appsettingsconfigurable-methods","text":"All the methods in this class are overrides of the methods in the Configurable interface. Readers are encouraged to review the Javadoc comments for the Configurable methods. Also review notes about Consulo Interactions with Configurable methods.","title":"AppSettingsConfigurable Methods"},{"location":"tutorials/settings_tutorial/#testing-the-custom-settings-plugin","text":"After performing the steps described above, compile and run the plugin in a Development Instance to see the custom Settings available in the Settings Dialog. Open the IDE Settings by selecting Settings/Preferences | Tools | SDK: Application Settings Example . The settings are preloaded with the default values: {:width=\"600px\"} Now edit the settings values to \"John Doe\" and click the checkbox. Click on the OK button to close the Settings dialog and save the changes. Exit the Development Instance. Open the file SdkSettingsPlugin.xml to see the Settings persistently stored. In this demonstration the file resides in code_samples/settings/build/idea-sandbox/config/options/ , but see IDE Development Instances for the general Development Instance case, or Default IDE directories if you are testing the settings plugin directly in an IDE. {:width=\"600px\"}","title":"Testing the Custom Settings Plugin"},{"location":"tutorials/tree_structure_view/","text":"This tutorial is meant to illustrate how the project tree structure view appearance can be modified programmatically. If you need to know more about basic concepts of a project view in IntelliJ-based IDEs, please refer to Exploring The Project Structure of IntelliJ IDEA Web Help . Series of step below show how to filter out and keep visible only text files and directories in the Project View Panel. Pre-Requirements Create an empty plugin project. See Creating a Plugin Project . 1. Register Custom TreeStructure Provider Add new treeStructureProvider extension to the plugin.xml < extensions defaultExtensionNs = \"com.intellij\" > < treeStructureProvider implementation = \"org.intellij.sdk.treeStructureProvider.TextOnlyTreeStructureProvider\" /> </ extensions > 2. Implement Custom TreeStructureProvider To provide custom Structure View behaviour you need to implement TreeStructureProvider interface. public class TextOnlyTreeStructureProvider implements TreeStructureProvider { @NotNull @Override public Collection < AbstractTreeNode > modify ( @NotNull AbstractTreeNode parent , @NotNull Collection < AbstractTreeNode > children , ViewSettings settings ) { return null ; } @Nullable @Override public Object getData ( Collection < AbstractTreeNode > collection , String s ) { return null ; } } 3. Override modify() Method To implement Tree Structure nodes filtering logic, override modify() method. The example below shows how to filter out all the Project View nodes except those which correspond to text files and directories. { % include / code_samples / tree_structure_provider / src / main / java / org / intellij / sdk / treeStructureProvider / TextOnlyTreeStructureProvider . java % } 4. Compile and Run the Plugin Compile and run the code sample from this tutorial. Refer to Running and Debugging a Plugin . After going through the steps described above you can see only text files and directories belonging to a project in the Project View. Check out plugin source code and build the project to see how TreeStructureView provider works in practice.","title":"Modifying Project View Structure"},{"location":"tutorials/tree_structure_view/#pre-requirements","text":"Create an empty plugin project. See Creating a Plugin Project .","title":"Pre-Requirements"},{"location":"tutorials/tree_structure_view/#1-register-custom-treestructure-provider","text":"Add new treeStructureProvider extension to the plugin.xml < extensions defaultExtensionNs = \"com.intellij\" > < treeStructureProvider implementation = \"org.intellij.sdk.treeStructureProvider.TextOnlyTreeStructureProvider\" /> </ extensions >","title":"1. Register Custom TreeStructure Provider"},{"location":"tutorials/tree_structure_view/#2-implement-custom-treestructureprovider","text":"To provide custom Structure View behaviour you need to implement TreeStructureProvider interface. public class TextOnlyTreeStructureProvider implements TreeStructureProvider { @NotNull @Override public Collection < AbstractTreeNode > modify ( @NotNull AbstractTreeNode parent , @NotNull Collection < AbstractTreeNode > children , ViewSettings settings ) { return null ; } @Nullable @Override public Object getData ( Collection < AbstractTreeNode > collection , String s ) { return null ; } }","title":"2. Implement Custom TreeStructureProvider"},{"location":"tutorials/tree_structure_view/#3-override-modify-method","text":"To implement Tree Structure nodes filtering logic, override modify() method. The example below shows how to filter out all the Project View nodes except those which correspond to text files and directories. { % include / code_samples / tree_structure_provider / src / main / java / org / intellij / sdk / treeStructureProvider / TextOnlyTreeStructureProvider . java % }","title":"3. Override modify() Method"},{"location":"tutorials/tree_structure_view/#4-compile-and-run-the-plugin","text":"Compile and run the code sample from this tutorial. Refer to Running and Debugging a Plugin . After going through the steps described above you can see only text files and directories belonging to a project in the Project View. Check out plugin source code and build the project to see how TreeStructureView provider works in practice.","title":"4. Compile and Run the Plugin"},{"location":"tutorials/action_system/grouping_action/","text":"If an implementation requires several actions, or there are simply too many actions that overload the menu, the actions can be placed into groups. This tutorial demonstrates adding an action to an existing group, creating a new action group, and action groups with a variable number of actions. The sample code discussed in this tutorial is from the code sample action_basics . Some content in this tutorial assumes the reader is familiar with the tutorial for Creating Actions . bullet list {:toc} Simple Action Groups In this first example, the action group will be available as a top-level menu item, and actions are represented as drop-down menu items. The group is based on a default Consulo implementation. Creating Simple Groups Grouping can be registered by adding a <group> element to the <actions> section of a plugin's plugin.xml file. This example has no class attribute in the <group> element because the Consulo framework will supply a default implementation class for the group. This default implementation is used if a set of actions belonging to the group is static, i.e., does not change at runtime, which is the majority of cases. The id attribute must be unique, so incorporating the plugin ID or package name is the best practice. The popup attribute determines whether actions in the group are placed in a submenu. The icon attribute specifies the FQN of an Icon object to be displayed. No compact attribute is specified, which means this group will support submenus. See Registering Actions in plugin.xml for more information about these attributes. <group id= \"org.intellij.sdk.action.GroupedActions\" text= \"Static Grouped Actions\" popup= \"true\" icon= \"SdkIcons.Sdk_default_icon\" > </group> Binding Action Groups to UI Components The following sample shows how to use an <add-to-group> element to place a custom action group relative to an entry in the Tools menu. The attribute relative-to-action references the action id for PopupDialogAction , not a native IntelliJ menu entry. Rather PopupDialogAction is defined in the same plugin.xml file. This group is placed after the single entry for the action PopupDialogAction , as defined in the tutorial Creating Actions . <group id= \"org.intellij.sdk.action.GroupedActions\" text= \"Static Grouped Actions\" popup= \"true\" icon= \"SdkIcons.Sdk_default_icon\" > <add-to-group group-id= \"ToolsMenu\" anchor= \"after\" relative-to-action= \"org.intellij.sdk.action.PopupDialogAction\" /> </group> Adding a New Action to the Static Grouped Actions The PopupDialogAction implementation will be reused and registered in the newly created static group. The id attribute for the reused PopupDialogAction implementation is set to a unique value, org.intellij.sdk.action.GroupPopDialogAction . This value differentiates this new <action> entry from the id previously used to register this action implementation in the Creating Actions tutorial. A unique id supports reuse of action classes in more than one menu or group. The action in this group will display the menu text \"A Group Action\". <group id= \"org.intellij.sdk.action.GroupedActions\" text= \"Static Grouped Actions\" popup= \"true\" icon= \"SdkIcons.Sdk_default_icon\" > <add-to-group group-id= \"ToolsMenu\" anchor= \"after\" relative-to-action= \"org.intellij.sdk.action.PopupDialogAction\" /> <action class= \"org.intellij.sdk.action.PopupDialogAction\" id= \"org.intellij.sdk.action.GroupPopDialogAction\" text= \"A Group Action\" description= \"SDK static grouped action example\" icon= \"SdkIcons.Sdk_default_icon\" > </action> </group> After performing the steps described above, the action group and its content will be available in the Tools menu. The underlying PopupDialogAction implementation is reused for two entries in the Tools menu: * Once for the top menu entry Tools | Pop Dialog Action with the action id equal to org.intellij.sdk.action.PopupDialogAction as set in the Creating Actions tutorial. * A second time for the menu entry Tools | Static Grouped Actions | A Group Action with the action id equal to org.intellij.sdk.action.GroupPopDialogAction . {:width=\"550px\"} Implementing Custom Action Group Classes In some cases, the specific behavior of a group of actions needs to depend on the context. The solution is analogous to making a single action entry dependent on context . The steps below show how to make a group of actions available and visible if certain conditions are met. In this case, the condition is having an instance of an editor is available. This condition is needed because the custom action group is added to an IntelliJ menu that is only enabled for editing. Extending DefaultActionGroup The DefaultActionGroup is an implementation of ActionGroup . The DefaultActionGroup class is used to add child actions and separators between them to a group. This class is used if a set of actions belonging to the group does not change at runtime. As an example, extend DefaultActionGroup to create the CustomDefaultActionGroup class in the action_basics code sample: public class CustomDefaultActionGroup extends DefaultActionGroup { @Override public void update ( AnActionEvent event ) { // Enable/disable depending on whether user is editing... } } Registering the Custom Action Group As in the case with the static action group, the action <group> should be declared in the <actions> section of the plugin.xml file, for example, the action_basics plugin. For demonstration purposes, this implementation will use localization. The <group> element declaration below shows: * An optional resource bundle declaration outside of the <actions> section for localizing actions. * The presence of the class attribute in the <group> element tells the Consulo framework to use CustomDefaultActionGroup rather than the default implementation. * Setting the group's popup attribute to allow submenus. * The text and description attributes are omitted in the <group> declaration in favor of using the localization resource bundle to define them. * There is no icon attribute for the group; the CustomDefaultActionGroup implementation will add an icon for the group . * The <add-to-group> element specifies adding the group in the first position of the existing EditorPopupMenu . <resource-bundle> messages.BasicActionsBundle </resource-bundle> <actions> <group id= \"org.intellij.sdk.action.CustomDefaultActionGroup\" class= \"org.intellij.sdk.action.CustomDefaultActionGroup\" popup= \"true\" > <add-to-group group-id= \"EditorPopupMenu\" anchor= \"first\" /> </group> </actions> Adding Actions to the Custom Group As in Static Grouped Actions , the PopupDialogAction action is added as an <action> element in the <group> element. In the <action> element declaration below: * The class attribute in the <action> element has the same FQN to reuse this action implementation. * The id attribute is unique to distinguish it from other uses of the implementation in the Action System. * The text and description attributes are omitted in the <action> declaration; they are instead defined using the localization resource bundle. * The SDK icon is declared for use with this action. <group id= \"org.intellij.sdk.action.CustomDefaultActionGroup\" class= \"org.intellij.sdk.action.CustomDefaultActionGroup\" popup= \"true\" icon= \"SdkIcons.Sdk_default_icon\" > <add-to-group group-id= \"EditorPopupMenu\" anchor= \"first\" /> <action id= \"org.intellij.sdk.action.CustomGroupedAction\" class= \"org.intellij.sdk.action.PopupDialogAction\" icon= \"SdkIcons.Sdk_default_icon\" /> </group> Now the translations for the text and description attributes must be provided in the resource bundle BasicActionsBundle.properties file according to Localizing Actions and Groups . Note there are two sets of text and description translations, one for the action and one for the group. Conceivably, there could be another set of translations for the action if it used the <override-text> attribute. action.org.intellij.sdk.action.CustomGroupedAction.text = A Popup Action[en] action.org.intellij.sdk.action.CustomGroupedAction.description = SDK popup grouped action example[en] group.org.intellij.sdk.action.CustomDefaultActionGroup.text = Popup Grouped Actions[en] group.org.intellij.sdk.action.CustomDefaultActionGroup.description = Custom defaultActionGroup demo[en] Providing Specific Behavior for the Custom Group Override the CustomDefaultActionGroup.update() method to make the group visible only if there's an instance of the editor available. Also, a custom icon is added to demonstrate that group icons can be changed depending on the action context: public class CustomDefaultActionGroup extends DefaultActionGroup { @Override public void update ( AnActionEvent event ) { // Enable/disable depending on whether user is editing Editor editor = event . getData ( CommonDataKeys . EDITOR ); event . getPresentation (). setEnabled ( editor != null ); // Take this opportunity to set an icon for the group. event . getPresentation (). setIcon ( SdkIcons . Sdk_default_icon ); } } After compiling and running the code sample above and opening a file in the editor and right-clicking, the Editing menu will pop up containing a new group of actions in the first position. Note the group and actions come from the resource file as all contain the suffix \"[en]\". The new group will also have an icon: Action Groups with Variable Actions Sets If a set of actions belonging to a custom group varies depending on the context, the group must extend ActionGroup . The set of actions in the ActionGroup is dynamically defined. Creating Variable Action Group To create a group of actions with a variable number of actions, extend ActionGroup . For example, as in the action_basics class DynamicActionGroup code: public class DynamicActionGroup extends ActionGroup { } Registering a Variable Action Group To register the dynamic menu group, a <group> attribute needs to be placed in the <actions> section of plugin .xml . When enabled, this group appears at the entry just below the Static Grouped Actions in the Tools menu: <group id= \"org.intellij.sdk.action.DynamicActionGroup\" class= \"org.intellij.sdk.action.DynamicActionGroup\" popup= \"true\" text= \"Dynamically Grouped Actions\" description= \"SDK dynamically grouped action example\" icon= \"SdkIcons.Sdk_default_icon\" > <add-to-group group-id= \"ToolsMenu\" anchor= \"after\" relative-to-action= \"org.intellij.sdk.action.GroupedActions\" /> </group> WARNING If a <group> element's class attribute names a class derived from ActionGroup , then any static <action> declarations in that group throw an exception. For a statically defined group, use DefaultActionGroup . Adding Child Actions to the Dynamic Group To add actions to the DynamicActionGroup , a non-empty array of AnAction instances should be returned from the DynamicActionGroup.getChildren() method. Here again, reuse the PopupDialogAction implementation. This use case is why PopupDialogAction overrides a constructor: public class DynamicActionGroup extends ActionGroup { @NotNull @Override public AnAction [] getChildren ( AnActionEvent e ) { return new AnAction [] { new PopupDialogAction ( \"Action Added at Runtime\" , \"Dynamic Action Demo\" , SdkIcons . Sdk_default_icon ) }; } } After providing the implementation of DynamicActionGroup and making it return a non-empty array of actions, the third position in the Tools menu will contain a new group of actions: {:width=\"600px\"}","title":"Grouping Actions"},{"location":"tutorials/action_system/grouping_action/#simple-action-groups","text":"In this first example, the action group will be available as a top-level menu item, and actions are represented as drop-down menu items. The group is based on a default Consulo implementation.","title":"Simple Action Groups"},{"location":"tutorials/action_system/grouping_action/#creating-simple-groups","text":"Grouping can be registered by adding a <group> element to the <actions> section of a plugin's plugin.xml file. This example has no class attribute in the <group> element because the Consulo framework will supply a default implementation class for the group. This default implementation is used if a set of actions belonging to the group is static, i.e., does not change at runtime, which is the majority of cases. The id attribute must be unique, so incorporating the plugin ID or package name is the best practice. The popup attribute determines whether actions in the group are placed in a submenu. The icon attribute specifies the FQN of an Icon object to be displayed. No compact attribute is specified, which means this group will support submenus. See Registering Actions in plugin.xml for more information about these attributes. <group id= \"org.intellij.sdk.action.GroupedActions\" text= \"Static Grouped Actions\" popup= \"true\" icon= \"SdkIcons.Sdk_default_icon\" > </group>","title":"Creating Simple Groups"},{"location":"tutorials/action_system/grouping_action/#binding-action-groups-to-ui-components","text":"The following sample shows how to use an <add-to-group> element to place a custom action group relative to an entry in the Tools menu. The attribute relative-to-action references the action id for PopupDialogAction , not a native IntelliJ menu entry. Rather PopupDialogAction is defined in the same plugin.xml file. This group is placed after the single entry for the action PopupDialogAction , as defined in the tutorial Creating Actions . <group id= \"org.intellij.sdk.action.GroupedActions\" text= \"Static Grouped Actions\" popup= \"true\" icon= \"SdkIcons.Sdk_default_icon\" > <add-to-group group-id= \"ToolsMenu\" anchor= \"after\" relative-to-action= \"org.intellij.sdk.action.PopupDialogAction\" /> </group>","title":"Binding Action Groups to UI Components"},{"location":"tutorials/action_system/grouping_action/#adding-a-new-action-to-the-static-grouped-actions","text":"The PopupDialogAction implementation will be reused and registered in the newly created static group. The id attribute for the reused PopupDialogAction implementation is set to a unique value, org.intellij.sdk.action.GroupPopDialogAction . This value differentiates this new <action> entry from the id previously used to register this action implementation in the Creating Actions tutorial. A unique id supports reuse of action classes in more than one menu or group. The action in this group will display the menu text \"A Group Action\". <group id= \"org.intellij.sdk.action.GroupedActions\" text= \"Static Grouped Actions\" popup= \"true\" icon= \"SdkIcons.Sdk_default_icon\" > <add-to-group group-id= \"ToolsMenu\" anchor= \"after\" relative-to-action= \"org.intellij.sdk.action.PopupDialogAction\" /> <action class= \"org.intellij.sdk.action.PopupDialogAction\" id= \"org.intellij.sdk.action.GroupPopDialogAction\" text= \"A Group Action\" description= \"SDK static grouped action example\" icon= \"SdkIcons.Sdk_default_icon\" > </action> </group> After performing the steps described above, the action group and its content will be available in the Tools menu. The underlying PopupDialogAction implementation is reused for two entries in the Tools menu: * Once for the top menu entry Tools | Pop Dialog Action with the action id equal to org.intellij.sdk.action.PopupDialogAction as set in the Creating Actions tutorial. * A second time for the menu entry Tools | Static Grouped Actions | A Group Action with the action id equal to org.intellij.sdk.action.GroupPopDialogAction . {:width=\"550px\"}","title":"Adding a New Action to the Static Grouped Actions"},{"location":"tutorials/action_system/grouping_action/#implementing-custom-action-group-classes","text":"In some cases, the specific behavior of a group of actions needs to depend on the context. The solution is analogous to making a single action entry dependent on context . The steps below show how to make a group of actions available and visible if certain conditions are met. In this case, the condition is having an instance of an editor is available. This condition is needed because the custom action group is added to an IntelliJ menu that is only enabled for editing.","title":"Implementing Custom Action Group Classes"},{"location":"tutorials/action_system/grouping_action/#extending-defaultactiongroup","text":"The DefaultActionGroup is an implementation of ActionGroup . The DefaultActionGroup class is used to add child actions and separators between them to a group. This class is used if a set of actions belonging to the group does not change at runtime. As an example, extend DefaultActionGroup to create the CustomDefaultActionGroup class in the action_basics code sample: public class CustomDefaultActionGroup extends DefaultActionGroup { @Override public void update ( AnActionEvent event ) { // Enable/disable depending on whether user is editing... } }","title":"Extending DefaultActionGroup"},{"location":"tutorials/action_system/grouping_action/#registering-the-custom-action-group","text":"As in the case with the static action group, the action <group> should be declared in the <actions> section of the plugin.xml file, for example, the action_basics plugin. For demonstration purposes, this implementation will use localization. The <group> element declaration below shows: * An optional resource bundle declaration outside of the <actions> section for localizing actions. * The presence of the class attribute in the <group> element tells the Consulo framework to use CustomDefaultActionGroup rather than the default implementation. * Setting the group's popup attribute to allow submenus. * The text and description attributes are omitted in the <group> declaration in favor of using the localization resource bundle to define them. * There is no icon attribute for the group; the CustomDefaultActionGroup implementation will add an icon for the group . * The <add-to-group> element specifies adding the group in the first position of the existing EditorPopupMenu . <resource-bundle> messages.BasicActionsBundle </resource-bundle> <actions> <group id= \"org.intellij.sdk.action.CustomDefaultActionGroup\" class= \"org.intellij.sdk.action.CustomDefaultActionGroup\" popup= \"true\" > <add-to-group group-id= \"EditorPopupMenu\" anchor= \"first\" /> </group> </actions>","title":"Registering the Custom Action Group"},{"location":"tutorials/action_system/grouping_action/#adding-actions-to-the-custom-group","text":"As in Static Grouped Actions , the PopupDialogAction action is added as an <action> element in the <group> element. In the <action> element declaration below: * The class attribute in the <action> element has the same FQN to reuse this action implementation. * The id attribute is unique to distinguish it from other uses of the implementation in the Action System. * The text and description attributes are omitted in the <action> declaration; they are instead defined using the localization resource bundle. * The SDK icon is declared for use with this action. <group id= \"org.intellij.sdk.action.CustomDefaultActionGroup\" class= \"org.intellij.sdk.action.CustomDefaultActionGroup\" popup= \"true\" icon= \"SdkIcons.Sdk_default_icon\" > <add-to-group group-id= \"EditorPopupMenu\" anchor= \"first\" /> <action id= \"org.intellij.sdk.action.CustomGroupedAction\" class= \"org.intellij.sdk.action.PopupDialogAction\" icon= \"SdkIcons.Sdk_default_icon\" /> </group> Now the translations for the text and description attributes must be provided in the resource bundle BasicActionsBundle.properties file according to Localizing Actions and Groups . Note there are two sets of text and description translations, one for the action and one for the group. Conceivably, there could be another set of translations for the action if it used the <override-text> attribute. action.org.intellij.sdk.action.CustomGroupedAction.text = A Popup Action[en] action.org.intellij.sdk.action.CustomGroupedAction.description = SDK popup grouped action example[en] group.org.intellij.sdk.action.CustomDefaultActionGroup.text = Popup Grouped Actions[en] group.org.intellij.sdk.action.CustomDefaultActionGroup.description = Custom defaultActionGroup demo[en]","title":"Adding Actions to the Custom Group"},{"location":"tutorials/action_system/grouping_action/#providing-specific-behavior-for-the-custom-group","text":"Override the CustomDefaultActionGroup.update() method to make the group visible only if there's an instance of the editor available. Also, a custom icon is added to demonstrate that group icons can be changed depending on the action context: public class CustomDefaultActionGroup extends DefaultActionGroup { @Override public void update ( AnActionEvent event ) { // Enable/disable depending on whether user is editing Editor editor = event . getData ( CommonDataKeys . EDITOR ); event . getPresentation (). setEnabled ( editor != null ); // Take this opportunity to set an icon for the group. event . getPresentation (). setIcon ( SdkIcons . Sdk_default_icon ); } } After compiling and running the code sample above and opening a file in the editor and right-clicking, the Editing menu will pop up containing a new group of actions in the first position. Note the group and actions come from the resource file as all contain the suffix \"[en]\". The new group will also have an icon:","title":"Providing Specific Behavior for the Custom Group"},{"location":"tutorials/action_system/grouping_action/#action-groups-with-variable-actions-sets","text":"If a set of actions belonging to a custom group varies depending on the context, the group must extend ActionGroup . The set of actions in the ActionGroup is dynamically defined.","title":"Action Groups with Variable Actions Sets"},{"location":"tutorials/action_system/grouping_action/#creating-variable-action-group","text":"To create a group of actions with a variable number of actions, extend ActionGroup . For example, as in the action_basics class DynamicActionGroup code: public class DynamicActionGroup extends ActionGroup { }","title":"Creating Variable Action Group"},{"location":"tutorials/action_system/grouping_action/#registering-a-variable-action-group","text":"To register the dynamic menu group, a <group> attribute needs to be placed in the <actions> section of plugin .xml . When enabled, this group appears at the entry just below the Static Grouped Actions in the Tools menu: <group id= \"org.intellij.sdk.action.DynamicActionGroup\" class= \"org.intellij.sdk.action.DynamicActionGroup\" popup= \"true\" text= \"Dynamically Grouped Actions\" description= \"SDK dynamically grouped action example\" icon= \"SdkIcons.Sdk_default_icon\" > <add-to-group group-id= \"ToolsMenu\" anchor= \"after\" relative-to-action= \"org.intellij.sdk.action.GroupedActions\" /> </group> WARNING If a <group> element's class attribute names a class derived from ActionGroup , then any static <action> declarations in that group throw an exception. For a statically defined group, use DefaultActionGroup .","title":"Registering a Variable Action Group"},{"location":"tutorials/action_system/grouping_action/#adding-child-actions-to-the-dynamic-group","text":"To add actions to the DynamicActionGroup , a non-empty array of AnAction instances should be returned from the DynamicActionGroup.getChildren() method. Here again, reuse the PopupDialogAction implementation. This use case is why PopupDialogAction overrides a constructor: public class DynamicActionGroup extends ActionGroup { @NotNull @Override public AnAction [] getChildren ( AnActionEvent e ) { return new AnAction [] { new PopupDialogAction ( \"Action Added at Runtime\" , \"Dynamic Action Demo\" , SdkIcons . Sdk_default_icon ) }; } } After providing the implementation of DynamicActionGroup and making it return a non-empty array of actions, the third position in the Tools menu will contain a new group of actions: {:width=\"600px\"}","title":"Adding Child Actions to the Dynamic Group"},{"location":"tutorials/action_system/working_with_custom_actions/","text":"Introduction Plugins can add actions to existing IDE menus and toolbars, as well as add new menus and toolbars. The Consulo calls the actions of plugins in response to user interactions with the IDE. However, the actions of a plugin must first be defined and registered with the Consulo. Using the SDK code sample action_basics , this tutorial illustrates the steps to create an action for a plugin. bullet list {:toc} Creating a Custom Action Custom actions extend the abstract class AnAction . Classes that extend it should override AnAction.update() , and must override AnAction.actionPerformed() . * The update() method implements the code that enables or disables an action. * The actionPerformed() method implements the code that executes when an action is invoked by the user. As an example, PopupDialogAction overrides AnAction for the action_basics code sample. public class PopupDialogAction extends AnAction { @Override public void update ( AnActionEvent e ) { // Using the event, evaluate the context, and enable or disable the action. } @Override public void actionPerformed ( @NotNull AnActionEvent e ) { // Using the event, implement an action. For example, create and show a dialog. } } WARNING AnAction classes do not have class fields of any kind. This restriction prevents memory leaks. For more information about why, see Action Implementation . At this stage, update() implicitly defaults always to enable this action. The implementation of actionPerformed() does nothing. These methods fully implemented in Developing the AnAction Methods below. Before fleshing out those methods, to complete this minimal implementation, PopupDialogAction must be registered with the Consulo. Registering a Custom Action Actions are registered by declaring them in code or by declaring them in the <actions> section of a plugin configuration ( plugin.xml ) file. This section describes using IDE tooling - the New Action Form - to add a declaration to the plugin.xml file, and then tuning registration attributes manually. A more comprehensive explanation of action registration is available in the Action Registration section of this guide. Registering an Action with the New Action Form IntelliJ IDEA has an embedded inspection that spots unregistered actions. Verify the inspection is enabled at Settings/Preferences | Editor | Inspections | Plugin DevKit | Code | Component/Action not registered . Here is an example for this stage of the PopupDialogAction class: {:width=\"600px\"} To register PopupDialogAction and set up its basic attributes press Alt + Shift + Enter . Fill out the New Action form to set up the parameters for PopupDialogAction : {:width=\"800px\"} The fields of the form are: * Action ID - Every action must have a unique ID. If the action class is used in only one place in the IDE UI, then the class FQN is a good default for the ID. Using the action class in multiple places requires mangling the ID, such as adding a suffix to the FQN, for each ID. * Class Name - The FQN implementation class for the action. If the same action is used in multiple places in the IDE UI, the implementation FQN can be reused with a different Action ID . * Name - The text to appear in the menu. * Description - Hint text to be displayed. * Add to Group - The action group - menu or toolbar - to which the action is added. Clicking in the list of groups and typing invokes a search, such as \"ToolsMenu.\" * Anchor - Where the menu action should be placed in the Tools menu relative to the other actions in that menu. In this case, PopupDialogAction would be available in the Tools menu, it would be placed at the top, and would have no shortcuts. After finishing the New Action form and applying the changes, the <actions> section of the plugin's plugins.xml file would contain: <actions> <action id= \"org.intellij.sdk.action.PopupDialogAction\" class= \"org.intellij.sdk.action.PopupDialogAction\" text= \"Pop Dialog Action\" description= \"SDK action example\" > <add-to-group group-id= \"ToolsMenu\" anchor= \"first\" /> </action> </actions> The <action> element declares the Action ID ( id ,) Class Name ( class ,) Name ( text ,) and Description from the New Action form. The <add-to-group> element declares where the action will appear and mirrors the names of entries from the form. This declaration is adequate, but adding more attributes is discussed in the next section. Setting Registration Attributes Manually An action declaration can be added manually to the plugin.xml file. An exhaustive list of declaration elements and attributes is presented in Registering Actions in plugin.xml . Attributes are added by selecting them from the New Action form, or by editing the registration declaration directly in the plugin.xml file. The <action> declaration for PopupDialogAction in the action_basics plugin.xml file. It also contains an attribute for an Icon and encloses elements declaring text overrides, keyboard and mouse shortcuts, and to which menu group the action should be added. The full declaration is: <action id= \"org.intellij.sdk.action.PopupDialogAction\" class= \"org.intellij.sdk.action.PopupDialogAction\" text= \"Action Basics Plugin: Pop Dialog Action\" description= \"SDK action example\" icon= \"SdkIcons.Sdk_default_icon\" > <override-text place= \"MainMenu\" text= \"Pop Dialog Action\" /> <keyboard-shortcut first-keystroke= \"control alt A\" second-keystroke= \"C\" keymap= \"$default\" /> <mouse-shortcut keystroke= \"control button3 doubleClick\" keymap= \"$default\" /> <add-to-group group-id= \"ToolsMenu\" anchor= \"first\" /> </action> Using Override-Text for an Action By using the override-text element introduced in 2020.1 of the Consulo, the action text can be different depending on the context of where the action appears: menu, toolbar, etc. The example above uses this element to ensure the shorter text \"Pop Dialog Action\" is shown anywhere the action appears in the Main Menu structure. Otherwise, the default, more explanatory text \"Action Basics Plugin: Pop Dialog Action\" is shown. For more information, see Setting the Override-Text Element Testing the Minimal Custom Action Implementation After performing the steps described above, compile and run the plugin to see the newly created action available as a Tools Menu item, which is within the context of the Main Menu: {:width=\"350px\"} To see the alternate, more verbose text declared by the override-text element, use Help | Find Action... and search for \"Pop Dialog Action\". The search shows the verbose menu text in a context outside of the Main Menu: {:width=\"500px\"} Selecting the action from the menu, keyboard/mouse shortcuts, or Find Action won't do anything at this point because the implementations are empty. However, it confirms the new entry appears at Tools | Pop Dialog Action and Help | Find Action... . Developing the AnAction Methods At this point, the new action PopupDialogAction is registered with the Consulo and functions in the sense that update() and actionPerformed() are called in response to user interaction with the IDE Tools menu. However, neither method implements any code to perform useful work. This section describes adding useful code to these methods. The update() method defaults to always enable the action, which is satisfactory for intermediate testing. So actionPerformed() will be developed first. Extending the actionPerformed() Method Adding code to the PopupDialogAction.actionPerformed() method makes the action do something useful. The code below gets information from the anActionEvent input parameter and constructs a message dialog. A generic icon, and the dlgMsg and dlgTitle attributes from the invoking menu action are displayed. However, code in this method could manipulate a project, invoke an inspection, change the contents of a file, etc. For demonstration purposes the AnActionEvent.getData() method tests if a Navigatable object is available. If so, information about the selected element is added to the dialog. See Determining the Action Context for more information about accessing information from the AnActionEvent input parameter. @Override public void actionPerformed ( @NotNull AnActionEvent event ) { // Using the event, create and show a dialog Project currentProject = event . getProject (); StringBuffer dlgMsg = new StringBuffer ( event . getPresentation (). getText () + \" Selected!\" ); String dlgTitle = event . getPresentation (). getDescription (); // If an element is selected in the editor, add info about it. Navigatable nav = event . getData ( CommonDataKeys . NAVIGATABLE ); if ( nav != null ) { dlgMsg . append ( String . format ( \"\\nSelected Element: %s\" , nav . toString ())); } Messages . showMessageDialog ( currentProject , dlgMsg . toString (), dlgTitle , Messages . getInformationIcon ()); } Extending the update() Method Adding code to PopupDialogAction.update() gives finer control of the action's visibility and availability. The action's state and(or) presentation can be dynamically changed depending on the context. WARNING This method needs to execute very quickly . For more information about this constraint, see the warning in Overriding the AnAction.update Method . In this example, the update() method relies on a Project object being available. This requirement means the user must have at least one project open in the IDE for the PopupDialogAction to be available. So the update() method disables the action for contexts where a Project object isn't defined. The availability (enabled and visible) is set on the Presentation object. Setting both the enabled state and visibility produces consistent behavior despite possible host menu settings, as discussed in Grouping Actions . @Override public void update ( AnActionEvent e ) { // Set the availability based on whether a project is open Project project = e . getProject (); e . getPresentation (). setEnabledAndVisible ( project != null ); } The update() method does not check to see if a Navigatable object is available before enabling PopupDialogAction . This check is unnecessary because using the Navigatable object is opportunistic in actionPerformed() . See Determining the Action Context for more information about accessing information from the AnActionEvent input parameter. Other Method Overrides A constructor is overridden in PopupDialogAction , but this is an artifact of reusing this class for a dynamically created menu action. Otherwise, overriding constructors for AnAction is not required. Testing the Custom Action After compiling and running the plugin project and invoking the action, the dialog will pop up: {:width=\"800px\"}","title":"Creating Actions"},{"location":"tutorials/action_system/working_with_custom_actions/#introduction","text":"Plugins can add actions to existing IDE menus and toolbars, as well as add new menus and toolbars. The Consulo calls the actions of plugins in response to user interactions with the IDE. However, the actions of a plugin must first be defined and registered with the Consulo. Using the SDK code sample action_basics , this tutorial illustrates the steps to create an action for a plugin. bullet list {:toc}","title":"Introduction"},{"location":"tutorials/action_system/working_with_custom_actions/#creating-a-custom-action","text":"Custom actions extend the abstract class AnAction . Classes that extend it should override AnAction.update() , and must override AnAction.actionPerformed() . * The update() method implements the code that enables or disables an action. * The actionPerformed() method implements the code that executes when an action is invoked by the user. As an example, PopupDialogAction overrides AnAction for the action_basics code sample. public class PopupDialogAction extends AnAction { @Override public void update ( AnActionEvent e ) { // Using the event, evaluate the context, and enable or disable the action. } @Override public void actionPerformed ( @NotNull AnActionEvent e ) { // Using the event, implement an action. For example, create and show a dialog. } } WARNING AnAction classes do not have class fields of any kind. This restriction prevents memory leaks. For more information about why, see Action Implementation . At this stage, update() implicitly defaults always to enable this action. The implementation of actionPerformed() does nothing. These methods fully implemented in Developing the AnAction Methods below. Before fleshing out those methods, to complete this minimal implementation, PopupDialogAction must be registered with the Consulo.","title":"Creating a Custom Action"},{"location":"tutorials/action_system/working_with_custom_actions/#registering-a-custom-action","text":"Actions are registered by declaring them in code or by declaring them in the <actions> section of a plugin configuration ( plugin.xml ) file. This section describes using IDE tooling - the New Action Form - to add a declaration to the plugin.xml file, and then tuning registration attributes manually. A more comprehensive explanation of action registration is available in the Action Registration section of this guide.","title":"Registering a Custom Action"},{"location":"tutorials/action_system/working_with_custom_actions/#registering-an-action-with-the-new-action-form","text":"IntelliJ IDEA has an embedded inspection that spots unregistered actions. Verify the inspection is enabled at Settings/Preferences | Editor | Inspections | Plugin DevKit | Code | Component/Action not registered . Here is an example for this stage of the PopupDialogAction class: {:width=\"600px\"} To register PopupDialogAction and set up its basic attributes press Alt + Shift + Enter . Fill out the New Action form to set up the parameters for PopupDialogAction : {:width=\"800px\"} The fields of the form are: * Action ID - Every action must have a unique ID. If the action class is used in only one place in the IDE UI, then the class FQN is a good default for the ID. Using the action class in multiple places requires mangling the ID, such as adding a suffix to the FQN, for each ID. * Class Name - The FQN implementation class for the action. If the same action is used in multiple places in the IDE UI, the implementation FQN can be reused with a different Action ID . * Name - The text to appear in the menu. * Description - Hint text to be displayed. * Add to Group - The action group - menu or toolbar - to which the action is added. Clicking in the list of groups and typing invokes a search, such as \"ToolsMenu.\" * Anchor - Where the menu action should be placed in the Tools menu relative to the other actions in that menu. In this case, PopupDialogAction would be available in the Tools menu, it would be placed at the top, and would have no shortcuts. After finishing the New Action form and applying the changes, the <actions> section of the plugin's plugins.xml file would contain: <actions> <action id= \"org.intellij.sdk.action.PopupDialogAction\" class= \"org.intellij.sdk.action.PopupDialogAction\" text= \"Pop Dialog Action\" description= \"SDK action example\" > <add-to-group group-id= \"ToolsMenu\" anchor= \"first\" /> </action> </actions> The <action> element declares the Action ID ( id ,) Class Name ( class ,) Name ( text ,) and Description from the New Action form. The <add-to-group> element declares where the action will appear and mirrors the names of entries from the form. This declaration is adequate, but adding more attributes is discussed in the next section.","title":"Registering an Action with the New Action Form"},{"location":"tutorials/action_system/working_with_custom_actions/#setting-registration-attributes-manually","text":"An action declaration can be added manually to the plugin.xml file. An exhaustive list of declaration elements and attributes is presented in Registering Actions in plugin.xml . Attributes are added by selecting them from the New Action form, or by editing the registration declaration directly in the plugin.xml file. The <action> declaration for PopupDialogAction in the action_basics plugin.xml file. It also contains an attribute for an Icon and encloses elements declaring text overrides, keyboard and mouse shortcuts, and to which menu group the action should be added. The full declaration is: <action id= \"org.intellij.sdk.action.PopupDialogAction\" class= \"org.intellij.sdk.action.PopupDialogAction\" text= \"Action Basics Plugin: Pop Dialog Action\" description= \"SDK action example\" icon= \"SdkIcons.Sdk_default_icon\" > <override-text place= \"MainMenu\" text= \"Pop Dialog Action\" /> <keyboard-shortcut first-keystroke= \"control alt A\" second-keystroke= \"C\" keymap= \"$default\" /> <mouse-shortcut keystroke= \"control button3 doubleClick\" keymap= \"$default\" /> <add-to-group group-id= \"ToolsMenu\" anchor= \"first\" /> </action>","title":"Setting Registration Attributes Manually"},{"location":"tutorials/action_system/working_with_custom_actions/#using-override-text-for-an-action","text":"By using the override-text element introduced in 2020.1 of the Consulo, the action text can be different depending on the context of where the action appears: menu, toolbar, etc. The example above uses this element to ensure the shorter text \"Pop Dialog Action\" is shown anywhere the action appears in the Main Menu structure. Otherwise, the default, more explanatory text \"Action Basics Plugin: Pop Dialog Action\" is shown. For more information, see Setting the Override-Text Element","title":"Using Override-Text for an Action"},{"location":"tutorials/action_system/working_with_custom_actions/#testing-the-minimal-custom-action-implementation","text":"After performing the steps described above, compile and run the plugin to see the newly created action available as a Tools Menu item, which is within the context of the Main Menu: {:width=\"350px\"} To see the alternate, more verbose text declared by the override-text element, use Help | Find Action... and search for \"Pop Dialog Action\". The search shows the verbose menu text in a context outside of the Main Menu: {:width=\"500px\"} Selecting the action from the menu, keyboard/mouse shortcuts, or Find Action won't do anything at this point because the implementations are empty. However, it confirms the new entry appears at Tools | Pop Dialog Action and Help | Find Action... .","title":"Testing the Minimal Custom Action Implementation"},{"location":"tutorials/action_system/working_with_custom_actions/#developing-the-anaction-methods","text":"At this point, the new action PopupDialogAction is registered with the Consulo and functions in the sense that update() and actionPerformed() are called in response to user interaction with the IDE Tools menu. However, neither method implements any code to perform useful work. This section describes adding useful code to these methods. The update() method defaults to always enable the action, which is satisfactory for intermediate testing. So actionPerformed() will be developed first.","title":"Developing the AnAction Methods"},{"location":"tutorials/action_system/working_with_custom_actions/#extending-the-actionperformed-method","text":"Adding code to the PopupDialogAction.actionPerformed() method makes the action do something useful. The code below gets information from the anActionEvent input parameter and constructs a message dialog. A generic icon, and the dlgMsg and dlgTitle attributes from the invoking menu action are displayed. However, code in this method could manipulate a project, invoke an inspection, change the contents of a file, etc. For demonstration purposes the AnActionEvent.getData() method tests if a Navigatable object is available. If so, information about the selected element is added to the dialog. See Determining the Action Context for more information about accessing information from the AnActionEvent input parameter. @Override public void actionPerformed ( @NotNull AnActionEvent event ) { // Using the event, create and show a dialog Project currentProject = event . getProject (); StringBuffer dlgMsg = new StringBuffer ( event . getPresentation (). getText () + \" Selected!\" ); String dlgTitle = event . getPresentation (). getDescription (); // If an element is selected in the editor, add info about it. Navigatable nav = event . getData ( CommonDataKeys . NAVIGATABLE ); if ( nav != null ) { dlgMsg . append ( String . format ( \"\\nSelected Element: %s\" , nav . toString ())); } Messages . showMessageDialog ( currentProject , dlgMsg . toString (), dlgTitle , Messages . getInformationIcon ()); }","title":"Extending the actionPerformed() Method"},{"location":"tutorials/action_system/working_with_custom_actions/#extending-the-update-method","text":"Adding code to PopupDialogAction.update() gives finer control of the action's visibility and availability. The action's state and(or) presentation can be dynamically changed depending on the context. WARNING This method needs to execute very quickly . For more information about this constraint, see the warning in Overriding the AnAction.update Method . In this example, the update() method relies on a Project object being available. This requirement means the user must have at least one project open in the IDE for the PopupDialogAction to be available. So the update() method disables the action for contexts where a Project object isn't defined. The availability (enabled and visible) is set on the Presentation object. Setting both the enabled state and visibility produces consistent behavior despite possible host menu settings, as discussed in Grouping Actions . @Override public void update ( AnActionEvent e ) { // Set the availability based on whether a project is open Project project = e . getProject (); e . getPresentation (). setEnabledAndVisible ( project != null ); } The update() method does not check to see if a Navigatable object is available before enabling PopupDialogAction . This check is unnecessary because using the Navigatable object is opportunistic in actionPerformed() . See Determining the Action Context for more information about accessing information from the AnActionEvent input parameter.","title":"Extending the update() Method"},{"location":"tutorials/action_system/working_with_custom_actions/#other-method-overrides","text":"A constructor is overridden in PopupDialogAction , but this is an artifact of reusing this class for a dynamically created menu action. Otherwise, overriding constructors for AnAction is not required.","title":"Other Method Overrides"},{"location":"tutorials/action_system/working_with_custom_actions/#testing-the-custom-action","text":"After compiling and running the plugin project and invoking the action, the dialog will pop up: {:width=\"800px\"}","title":"Testing the Custom Action"},{"location":"tutorials/build_system/deployment/","text":"Once you have configured Gradle support, you can automatically build and deploy your plugin to the JetBrains Plugins Repository . To automatically deploy a plugin, you need to have already published the plugin to the plugin repository at least once. Please see the guide page for manually publishing a plugin for the first time. TIP Please see Marketing for remarks on how to prepare your plugin for optimal presentation. WARNING When adding additional repositories to your Gradle build script, always use HTTPS protocol. bullet list {:toc} Building Distribution For manual distribution or local installation, invoke the buildPlugin Gradle task to create the plugin distribution. The resulting JAR/ZIP is located in build/distributions and can then be installed either manually or uploaded to a custom plugin repository . Providing Your Hub Permanent Token to Gradle To deploy a plugin to the JetBrains Plugins Repository, you need to supply your JetBrains Hub Permanent Token . This section describes two options to supply your Hub Permanent Token via Gradle using: * Environment variables, * Parameters to the Gradle task. Using Environment Variables Start by defining an environment variable such as: export ORG_GRADLE_PROJECT_intellijPublishToken = 'YOUR_HUB_TOKEN_HERE' NOTE On macOS systems, environment variables set in .bash_profile are only visible to processes you run from bash. Environment variables visible to all processes need to be defined in Environment.plist . Now provide the environment variable in the run configuration with which you run the publishPlugin task locally. To do so, create a Gradle run configuration (if not already done), choose your Gradle project, specify the publishPlugin task, and then add the environment variable. publishPlugin { token = System . getenv ( \"ORG_GRADLE_PROJECT_intellijPublishToken\" ) } Note that you still need to put some default values (can be empty) in the Gradle properties because otherwise, you will get a compilation error. Using Parameters for the Gradle Task Like using environment variables, you can also pass your token as a parameter to the Gradle task. For example, you can provide the parameter -Dorg.gradle.project.intellijPublishToken=YOUR_HUB_TOKEN_HERE on the command line or by putting it in the arguments of your Gradle run configuration. Note that also, in this case, you still need to put some default values in your Gradle properties. Deploying a Plugin with Gradle The first step when deploying a plugin is to confirm that it works correctly. You may wish to verify this by installing your plugin from disk on a fresh instance of your target IDE(s). Publishing a Plugin Once you are confident, the plugin works as intended, make sure the plugin version is updated, as the JetBrains Plugins Repository won't accept multiple artifacts with the same version. To deploy a new version of your plugin to the JetBrains Plugins Repository, invoke the publishPlugin Gradle task. Now check the most recent version of your plugin on the JetBrains Plugins Repository . If successfully deployed, any users who currently have your plugin installed on an available version of the Consulo are notified of a new update available as soon as the update has been verified. Specifying a Release Channel You may also deploy plugins to a release channel of your choosing, by configuring the publishPlugin.channels property. For example: publishPlugin { channels 'beta' } When empty, this uses the default plugin repository, available to all JetBrains Plugins Repository users. However, you can publish it to an arbitrarily-named channel. These non-default release channels are treated as separate repositories. When using a non-default release channel, users need to configure a new custom plugin repository in their IDE to install your plugin. For example, if you specify publishPlugin.channels 'canary' , then users need to add the https://plugins.jetbrains.com/plugins/canary/list repository to install the plugin and receive updates. Popular channel names include: * alpha : https://plugins.jetbrains.com/plugins/alpha/list * beta : https://plugins.jetbrains.com/plugins/beta/list * eap : https://plugins.jetbrains.com/plugins/eap/list More information about the available configuration options is in the documentation of the IntelliJ Gradle plugin .","title":"Publishing Plugins with Gradle"},{"location":"tutorials/build_system/deployment/#building-distribution","text":"For manual distribution or local installation, invoke the buildPlugin Gradle task to create the plugin distribution. The resulting JAR/ZIP is located in build/distributions and can then be installed either manually or uploaded to a custom plugin repository .","title":"Building Distribution"},{"location":"tutorials/build_system/deployment/#providing-your-hub-permanent-token-to-gradle","text":"To deploy a plugin to the JetBrains Plugins Repository, you need to supply your JetBrains Hub Permanent Token . This section describes two options to supply your Hub Permanent Token via Gradle using: * Environment variables, * Parameters to the Gradle task.","title":"Providing Your Hub Permanent Token to Gradle"},{"location":"tutorials/build_system/deployment/#using-environment-variables","text":"Start by defining an environment variable such as: export ORG_GRADLE_PROJECT_intellijPublishToken = 'YOUR_HUB_TOKEN_HERE' NOTE On macOS systems, environment variables set in .bash_profile are only visible to processes you run from bash. Environment variables visible to all processes need to be defined in Environment.plist . Now provide the environment variable in the run configuration with which you run the publishPlugin task locally. To do so, create a Gradle run configuration (if not already done), choose your Gradle project, specify the publishPlugin task, and then add the environment variable. publishPlugin { token = System . getenv ( \"ORG_GRADLE_PROJECT_intellijPublishToken\" ) } Note that you still need to put some default values (can be empty) in the Gradle properties because otherwise, you will get a compilation error.","title":"Using Environment Variables"},{"location":"tutorials/build_system/deployment/#using-parameters-for-the-gradle-task","text":"Like using environment variables, you can also pass your token as a parameter to the Gradle task. For example, you can provide the parameter -Dorg.gradle.project.intellijPublishToken=YOUR_HUB_TOKEN_HERE on the command line or by putting it in the arguments of your Gradle run configuration. Note that also, in this case, you still need to put some default values in your Gradle properties.","title":"Using Parameters for the Gradle Task"},{"location":"tutorials/build_system/deployment/#deploying-a-plugin-with-gradle","text":"The first step when deploying a plugin is to confirm that it works correctly. You may wish to verify this by installing your plugin from disk on a fresh instance of your target IDE(s).","title":"Deploying a Plugin with Gradle"},{"location":"tutorials/build_system/deployment/#publishing-a-plugin","text":"Once you are confident, the plugin works as intended, make sure the plugin version is updated, as the JetBrains Plugins Repository won't accept multiple artifacts with the same version. To deploy a new version of your plugin to the JetBrains Plugins Repository, invoke the publishPlugin Gradle task. Now check the most recent version of your plugin on the JetBrains Plugins Repository . If successfully deployed, any users who currently have your plugin installed on an available version of the Consulo are notified of a new update available as soon as the update has been verified.","title":"Publishing a Plugin"},{"location":"tutorials/build_system/deployment/#specifying-a-release-channel","text":"You may also deploy plugins to a release channel of your choosing, by configuring the publishPlugin.channels property. For example: publishPlugin { channels 'beta' } When empty, this uses the default plugin repository, available to all JetBrains Plugins Repository users. However, you can publish it to an arbitrarily-named channel. These non-default release channels are treated as separate repositories. When using a non-default release channel, users need to configure a new custom plugin repository in their IDE to install your plugin. For example, if you specify publishPlugin.channels 'canary' , then users need to add the https://plugins.jetbrains.com/plugins/canary/list repository to install the plugin and receive updates. Popular channel names include: * alpha : https://plugins.jetbrains.com/plugins/alpha/list * beta : https://plugins.jetbrains.com/plugins/beta/list * eap : https://plugins.jetbrains.com/plugins/eap/list More information about the available configuration options is in the documentation of the IntelliJ Gradle plugin .","title":"Specifying a Release Channel"},{"location":"tutorials/build_system/gradle_guide/","text":"This page serves as a guide to the Gradle-based plugin configuration for Consulo projects. The IntelliJ IDEA Ultimate and Community editions bundle the Gradle and Plugin DevKit plugins to support Gradle-based development. The Getting Started with Gradle page provides a tutorial for creating Gradle-based Consulo plugins. It may be useful to review the Consulo page, particularly the description of versioning in the Open Source section. WARNING When adding additional repositories to your Gradle build script, always use HTTPS protocol. bullet list {:toc} Overview of the Gradle Plugin The Gradle plugin is built from the open-source project gradle-intellij-plugin . This plugin adds Gradle tasks that enable developing Consulo plugins. The README file has a reference for configuring these tasks. When getting started, there are several items to note on the README page: * At the top of the page, the latest production version of the plugin is listed. It is advised to upgrade to the latest available version regularly. * Also, at the top is the minimum required version of Gradle. * The table of extended Gradle Tasks has a succinct description for each task added by the plugin. This documentation will focus on the configuration and use four of those tasks: * Setup DSL - intellij { ... } . * Running DSL - runIde { ... } * Patching DSL - patchPluginXml { ... } * Publishing DSL - publishPlugin { ... } * Examples are always a helpful resource, and at the bottom of the page are links to example open-source Consulo plugin projects based on Gradle. * Almost every Gradle plugin attribute has a default value that will work to get started on a Gradle-based Consulo plugin project. Guide to Configuring Gradle Plugin Functionality This section presents a guided tour of Gradle plugin attributes to achieve the commonly desired functionality. Configuring the Gradle Plugin for Building Consulo Plugin Projects By default, the Gradle plugin will build a plugin project against the Consulo defined by the latest EAP snapshot of the IntelliJ IDEA Community Edition. NOTE Using EAP versions of the Consulo requires adding the Snapshots repository to the build.gradle file (see Consulo Artifacts Repositories ). If a matching version of the specified Consulo is not available on the local machine, the Gradle plugin downloads the correct version and type. IntelliJ IDEA then indexes the build and any associated source code and JetBrains Java Runtime. Consulo Configuration Explicitly setting the Setup DSL attributes intellij.version and intellij.type tells the Gradle plugin to use that configuration of the Consulo to create the plugin project. All available platform versions can be browsed in the Consulo Artifacts Repositories . If the chosen platform version is not available in the repositories, or a local installation of the target IDE is the desired type and version of the Consulo, use intellij.localPath to point to that installation. If the intellij.localPath attribute is set, do not set the intellij.version and intellij.type attributes as this could result in undefined behavior. Plugin Dependencies Consulo plugin projects may depend on either bundled or third-party plugins. In that case, a project should build against a version of those plugins that match the Consulo version used to build the plugin project. The Gradle plugin will fetch any plugins in the list defined by intellij.plugins . See the Gradle plugin README for information about specifying the plugin and version. Note that this attribute describes a dependency so that the Gradle plugin can fetch the required artifacts. The runtime dependency must be added in the Plugin Configuration ( plugin.xml ) file as described in Plugin Dependencies . Configuring the Gradle Plugin for Running Consulo Plugin Projects By default, the Gradle plugin will use the same version of the Consulo for the IDE Development Instance, as was used for building the plugin. Using the corresponding JetBrains Runtime is also the default, so for this use case, no further configuration is required. Running Against Alternate Versions and Types of Consulo-Based IDEs The Consulo IDE used for the Development Instance can be different from that used to build the plugin project. Setting the Running DSL attribute runIde.ideDirectory will define an IDE to be used for the Development Instance. This attribute is commonly used when running or debugging a plugin in an alternate Consulo-based IDE . Running Against Alternate Versions of the JetBrains Runtime Every version of the Consulo has a corresponding version of the JetBrains Runtime . A different version of the runtime can be used by specifying the runIde.jbrVersion attribute, describing a version of the JetBrains Runtime that should be used by the IDE Development Instance. The Gradle plugin will fetch the specified JetBrains Runtime as needed. Managing Directories Used by the Gradle Plugin There are several attributes to control where the Gradle plugin places directories for downloads and use by the IDE Development Instance. The location of the sandbox home directory and its subdirectories can be controlled with Gradle plugin attributes. The intellij.sandboxDirectory attribute is used to set the path for the sandbox directory to be used while running the plugin in an IDE Development Instance. Locations of the sandbox subdirectories can be controlled using the runIde.configDirectory , runIde.pluginsDirectory , and runIde.systemDirectory attributes. If the intellij.sandboxDirectory path is explicitly set, the subdirectory attributes default to the new sandbox directory. The storage location of downloaded IDE versions and components defaults to the Gradle cache directory. However, it can be controlled by setting the intellij.ideaDependencyCachePath attribute. Controlling Downloads by the Gradle Plugin As mentioned in the section about configuring the Consulo used for building plugin projects, the Gradle plugin will fetch the version of the Consulo specified by the default or by the intellij attributes. Standardizing the versions of the Gradle plugin and the Gradle system across projects will minimize the time spent downloading versions. There are controls for managing the gradle-intellij-plugin version, and the version of the Gradle itself. The plugin version is defined in the plugins {} section of a project's build.gradle file. The version of the Gradle is defined in <PROJECT ROOT>/gradle/wrapper/gradle-wrapper.properties . Patching the Plugin Configuration File A plugin project's plugin.xml file has element values that are \"patched\" at build time from the attributes of the patchPluginXml task ( Patching DSL ). As many as possible of the attributes in the Patching DSL will be substituted into the corresponding element values in a plugin project's plugin.xml file: * If a patchPluginXml attribute default value is defined, the attribute value will be patched in plugin.xml regardless of whether the patchPluginXml task appears in the build.gradle file . * For example, the default values for the attributes patchPluginXml.sinceBuild and patchPluginXml.untilBuild are defined based on the declared (or default) value of intellij.version . So by default patchPluginXml.sinceBuild and patchPluginXml.untilBuild are substituted into the <idea-version> element's since-build and until-build attributes in the plugin.xml file. * If a patchPluginXml attribute value is explicitly defined, the attribute value will be substituted in plugin.xml . * If both patchPluginXml.sinceBuild and patchPluginXml.untilBuild attributes are explicitly set, both are substituted in plugin.xml . * If one attribute is explicitly set (e.g. patchPluginXml.sinceBuild ) and one is not (e.g. patchPluginXml.untilBuild has a default value,) both attributes are patched at their respective (explicit and default) values. * For no substitution of the <idea-version> element's since-build and until-build attributes, one of the following must appear in the build.gradle file: * Either set intellij.updateSinceUntilBuild = false , which will disable substituting both since-build and until-build attributes, * Or, for independent control, set patchPluginXml.sinceBuild(null) and patchPluginXml.untilBuild(null) depending on whether the intention is to disable one or both substitutions. A best practice to avoid confusion is to replace the elements in plugin.xml the Gradle plugin will patch that with a comment. That way, the values for these parameters do not appear in two places in the source code. The Gradle plugin will add the necessary elements as part of the patching process. For those patchPluginXml attributes that contain descriptions such as changeNotes and pluginDescription , a CDATA block is not necessary when using HTML elements. TIP To maintain and generate an up-to-date changelog, try using Gradle Changelog Plugin . As discussed in Components of a Wizard-Generated Gradle Consulo Plugin , the Gradle properties project.version , project.group , and rootProject.name are all generated based on the input to the Wizard. However, the gradle-intellij-plugin does not combine and substitute those Gradle properties for the default <id> and <name> elements in the plugin.xml file. The best practice is to keep project.version current. By default, if you modify project.version in build.gradle , the Gradle plugin will automatically update the <version> value in the plugin.xml file. This practice keeps all version declarations synchronized. Verifying Plugin The Gradle plugin provides two tasks that allow for running integrity and compatibility tests: - verifyPlugin - validates completeness and contents of plugin.xml descriptors as well as plugin\u2019s archive structure, - runPluginVerifier - runs the IntelliJ Plugin Verifier tool to check the binary compatibility with specified IntelliJ IDE builds. Plugin Verifier integration task allows for configuring the exact IDE versions that your plugin will be checked against. Please check the Plugin Verifier DSL for more details. Publishing with the Gradle Plugin Please review the Publishing Plugins with Gradle page before using the Publishing DSL attributes. That documentation explains different ways to use Gradle for plugin uploads without exposing account credentials. Common Gradle Plugin Configurations for Development Different combinations of Gradle plugin attributes are needed to create the desired build or IDE Development Instance environment. This section reviews some of the more common configurations. Plugins Targeting IntelliJ IDEA Consulo plugins targeting IntelliJ IDEA have the most straightforward Gradle plugin configuration. * Determine the version of IntelliJ IDEA to use for building the plugin project ; this is the desired version of the Consulo. This can be EAP (default) or determined from the build number ranges . * If a production version of IntelliJ IDEA is the desired target, set the intellij version attributes accordingly. * Set the necessary plugin dependencies , if any. * If the plugin project should be run or debugged in an IDE Development Instance based on the same IntelliJ IDEA version, no further attributes need to be set for the IDE Development Instance. This is the default behavior and is the most common use case. * If the plugin project should be run or debugged in an IDE Development Instance based on an alternate version of the Consulo, set the Running DSL attribute accordingly. * If the plugin project should be run using a JetBrains Runtime other than the default for the IDE Development Instance, specify the JetBrains Runtime version . * Set the appropriate attributes for patching the plugin.xml file . Plugins Targeting Alternate Consulo-Based IDEs Gradle also supports developing plugins to run in IDEs that are based on the Consulo. For more information, see the Developing for Multiple Products page of this guide.","title":"Configuring Gradle Projects"},{"location":"tutorials/build_system/gradle_guide/#overview-of-the-gradle-plugin","text":"The Gradle plugin is built from the open-source project gradle-intellij-plugin . This plugin adds Gradle tasks that enable developing Consulo plugins. The README file has a reference for configuring these tasks. When getting started, there are several items to note on the README page: * At the top of the page, the latest production version of the plugin is listed. It is advised to upgrade to the latest available version regularly. * Also, at the top is the minimum required version of Gradle. * The table of extended Gradle Tasks has a succinct description for each task added by the plugin. This documentation will focus on the configuration and use four of those tasks: * Setup DSL - intellij { ... } . * Running DSL - runIde { ... } * Patching DSL - patchPluginXml { ... } * Publishing DSL - publishPlugin { ... } * Examples are always a helpful resource, and at the bottom of the page are links to example open-source Consulo plugin projects based on Gradle. * Almost every Gradle plugin attribute has a default value that will work to get started on a Gradle-based Consulo plugin project.","title":"Overview of the Gradle Plugin"},{"location":"tutorials/build_system/gradle_guide/#guide-to-configuring-gradle-plugin-functionality","text":"This section presents a guided tour of Gradle plugin attributes to achieve the commonly desired functionality.","title":"Guide to Configuring Gradle Plugin Functionality"},{"location":"tutorials/build_system/gradle_guide/#configuring-the-gradle-plugin-for-building-consulo-plugin-projects","text":"By default, the Gradle plugin will build a plugin project against the Consulo defined by the latest EAP snapshot of the IntelliJ IDEA Community Edition. NOTE Using EAP versions of the Consulo requires adding the Snapshots repository to the build.gradle file (see Consulo Artifacts Repositories ). If a matching version of the specified Consulo is not available on the local machine, the Gradle plugin downloads the correct version and type. IntelliJ IDEA then indexes the build and any associated source code and JetBrains Java Runtime.","title":"Configuring the Gradle Plugin for Building Consulo Plugin Projects"},{"location":"tutorials/build_system/gradle_guide/#consulo-configuration","text":"Explicitly setting the Setup DSL attributes intellij.version and intellij.type tells the Gradle plugin to use that configuration of the Consulo to create the plugin project. All available platform versions can be browsed in the Consulo Artifacts Repositories . If the chosen platform version is not available in the repositories, or a local installation of the target IDE is the desired type and version of the Consulo, use intellij.localPath to point to that installation. If the intellij.localPath attribute is set, do not set the intellij.version and intellij.type attributes as this could result in undefined behavior.","title":"Consulo Configuration"},{"location":"tutorials/build_system/gradle_guide/#plugin-dependencies","text":"Consulo plugin projects may depend on either bundled or third-party plugins. In that case, a project should build against a version of those plugins that match the Consulo version used to build the plugin project. The Gradle plugin will fetch any plugins in the list defined by intellij.plugins . See the Gradle plugin README for information about specifying the plugin and version. Note that this attribute describes a dependency so that the Gradle plugin can fetch the required artifacts. The runtime dependency must be added in the Plugin Configuration ( plugin.xml ) file as described in Plugin Dependencies .","title":"Plugin Dependencies"},{"location":"tutorials/build_system/gradle_guide/#configuring-the-gradle-plugin-for-running-consulo-plugin-projects","text":"By default, the Gradle plugin will use the same version of the Consulo for the IDE Development Instance, as was used for building the plugin. Using the corresponding JetBrains Runtime is also the default, so for this use case, no further configuration is required.","title":"Configuring the Gradle Plugin for Running Consulo Plugin Projects"},{"location":"tutorials/build_system/gradle_guide/#running-against-alternate-versions-and-types-of-consulo-based-ides","text":"The Consulo IDE used for the Development Instance can be different from that used to build the plugin project. Setting the Running DSL attribute runIde.ideDirectory will define an IDE to be used for the Development Instance. This attribute is commonly used when running or debugging a plugin in an alternate Consulo-based IDE .","title":"Running Against Alternate Versions and Types of Consulo-Based IDEs"},{"location":"tutorials/build_system/gradle_guide/#running-against-alternate-versions-of-the-jetbrains-runtime","text":"Every version of the Consulo has a corresponding version of the JetBrains Runtime . A different version of the runtime can be used by specifying the runIde.jbrVersion attribute, describing a version of the JetBrains Runtime that should be used by the IDE Development Instance. The Gradle plugin will fetch the specified JetBrains Runtime as needed.","title":"Running Against Alternate Versions of the JetBrains Runtime"},{"location":"tutorials/build_system/gradle_guide/#managing-directories-used-by-the-gradle-plugin","text":"There are several attributes to control where the Gradle plugin places directories for downloads and use by the IDE Development Instance. The location of the sandbox home directory and its subdirectories can be controlled with Gradle plugin attributes. The intellij.sandboxDirectory attribute is used to set the path for the sandbox directory to be used while running the plugin in an IDE Development Instance. Locations of the sandbox subdirectories can be controlled using the runIde.configDirectory , runIde.pluginsDirectory , and runIde.systemDirectory attributes. If the intellij.sandboxDirectory path is explicitly set, the subdirectory attributes default to the new sandbox directory. The storage location of downloaded IDE versions and components defaults to the Gradle cache directory. However, it can be controlled by setting the intellij.ideaDependencyCachePath attribute.","title":"Managing Directories Used by the Gradle Plugin"},{"location":"tutorials/build_system/gradle_guide/#controlling-downloads-by-the-gradle-plugin","text":"As mentioned in the section about configuring the Consulo used for building plugin projects, the Gradle plugin will fetch the version of the Consulo specified by the default or by the intellij attributes. Standardizing the versions of the Gradle plugin and the Gradle system across projects will minimize the time spent downloading versions. There are controls for managing the gradle-intellij-plugin version, and the version of the Gradle itself. The plugin version is defined in the plugins {} section of a project's build.gradle file. The version of the Gradle is defined in <PROJECT ROOT>/gradle/wrapper/gradle-wrapper.properties .","title":"Controlling Downloads by the Gradle Plugin"},{"location":"tutorials/build_system/gradle_guide/#patching-the-plugin-configuration-file","text":"A plugin project's plugin.xml file has element values that are \"patched\" at build time from the attributes of the patchPluginXml task ( Patching DSL ). As many as possible of the attributes in the Patching DSL will be substituted into the corresponding element values in a plugin project's plugin.xml file: * If a patchPluginXml attribute default value is defined, the attribute value will be patched in plugin.xml regardless of whether the patchPluginXml task appears in the build.gradle file . * For example, the default values for the attributes patchPluginXml.sinceBuild and patchPluginXml.untilBuild are defined based on the declared (or default) value of intellij.version . So by default patchPluginXml.sinceBuild and patchPluginXml.untilBuild are substituted into the <idea-version> element's since-build and until-build attributes in the plugin.xml file. * If a patchPluginXml attribute value is explicitly defined, the attribute value will be substituted in plugin.xml . * If both patchPluginXml.sinceBuild and patchPluginXml.untilBuild attributes are explicitly set, both are substituted in plugin.xml . * If one attribute is explicitly set (e.g. patchPluginXml.sinceBuild ) and one is not (e.g. patchPluginXml.untilBuild has a default value,) both attributes are patched at their respective (explicit and default) values. * For no substitution of the <idea-version> element's since-build and until-build attributes, one of the following must appear in the build.gradle file: * Either set intellij.updateSinceUntilBuild = false , which will disable substituting both since-build and until-build attributes, * Or, for independent control, set patchPluginXml.sinceBuild(null) and patchPluginXml.untilBuild(null) depending on whether the intention is to disable one or both substitutions. A best practice to avoid confusion is to replace the elements in plugin.xml the Gradle plugin will patch that with a comment. That way, the values for these parameters do not appear in two places in the source code. The Gradle plugin will add the necessary elements as part of the patching process. For those patchPluginXml attributes that contain descriptions such as changeNotes and pluginDescription , a CDATA block is not necessary when using HTML elements. TIP To maintain and generate an up-to-date changelog, try using Gradle Changelog Plugin . As discussed in Components of a Wizard-Generated Gradle Consulo Plugin , the Gradle properties project.version , project.group , and rootProject.name are all generated based on the input to the Wizard. However, the gradle-intellij-plugin does not combine and substitute those Gradle properties for the default <id> and <name> elements in the plugin.xml file. The best practice is to keep project.version current. By default, if you modify project.version in build.gradle , the Gradle plugin will automatically update the <version> value in the plugin.xml file. This practice keeps all version declarations synchronized.","title":"Patching the Plugin Configuration File"},{"location":"tutorials/build_system/gradle_guide/#verifying-plugin","text":"The Gradle plugin provides two tasks that allow for running integrity and compatibility tests: - verifyPlugin - validates completeness and contents of plugin.xml descriptors as well as plugin\u2019s archive structure, - runPluginVerifier - runs the IntelliJ Plugin Verifier tool to check the binary compatibility with specified IntelliJ IDE builds. Plugin Verifier integration task allows for configuring the exact IDE versions that your plugin will be checked against. Please check the Plugin Verifier DSL for more details.","title":"Verifying Plugin"},{"location":"tutorials/build_system/gradle_guide/#publishing-with-the-gradle-plugin","text":"Please review the Publishing Plugins with Gradle page before using the Publishing DSL attributes. That documentation explains different ways to use Gradle for plugin uploads without exposing account credentials.","title":"Publishing with the Gradle Plugin"},{"location":"tutorials/build_system/gradle_guide/#common-gradle-plugin-configurations-for-development","text":"Different combinations of Gradle plugin attributes are needed to create the desired build or IDE Development Instance environment. This section reviews some of the more common configurations.","title":"Common Gradle Plugin Configurations for Development"},{"location":"tutorials/build_system/gradle_guide/#plugins-targeting-intellij-idea","text":"Consulo plugins targeting IntelliJ IDEA have the most straightforward Gradle plugin configuration. * Determine the version of IntelliJ IDEA to use for building the plugin project ; this is the desired version of the Consulo. This can be EAP (default) or determined from the build number ranges . * If a production version of IntelliJ IDEA is the desired target, set the intellij version attributes accordingly. * Set the necessary plugin dependencies , if any. * If the plugin project should be run or debugged in an IDE Development Instance based on the same IntelliJ IDEA version, no further attributes need to be set for the IDE Development Instance. This is the default behavior and is the most common use case. * If the plugin project should be run or debugged in an IDE Development Instance based on an alternate version of the Consulo, set the Running DSL attribute accordingly. * If the plugin project should be run using a JetBrains Runtime other than the default for the IDE Development Instance, specify the JetBrains Runtime version . * Set the appropriate attributes for patching the plugin.xml file .","title":"Plugins Targeting IntelliJ IDEA"},{"location":"tutorials/build_system/gradle_guide/#plugins-targeting-alternate-consulo-based-ides","text":"Gradle also supports developing plugins to run in IDEs that are based on the Consulo. For more information, see the Developing for Multiple Products page of this guide.","title":"Plugins Targeting Alternate Consulo-Based IDEs"},{"location":"tutorials/build_system/prerequisites/","text":"Gradle is the preferred solution for creating Consulo plugins. The IntelliJ IDEA Ultimate and Community editions bundle the necessary plugins to support Gradle-based development. These IntelliJ IDEA plugins are Gradle and Plugin DevKit , which are enabled by default. To verify these plugins are installed and enabled, see the help section about Managing Plugins . TIP Consulo Plugin Template makes it easier to create and maintain your IDE plugins, having the Gradle plugin already integrated and CI covered with GitHub Actions. WARNING When adding additional repositories to your Gradle build script, always use HTTPS protocol. bullet list {:toc} Creating a Gradle-Based Consulo Plugin with New Project Wizard Creating new Gradle-based Consulo plugin projects is performed using the New Project Wizard . The Wizard creates all the necessary project files based on a few template inputs. Before creating a new Gradle project, familiarize yourself with the help topic Creating a new Gradle project , which is a tutorial for creating general Gradle projects in IntelliJ IDEA. This page emphasizes the steps in the process of creating Consulo plugin projects that are Gradle-based. WARNING Please note that Gradle 6.1 has a known bug that prevents using it for developing plugins, please upgrade to 6.1.1 or later. Launch the New Project Wizard . It guides you through the Gradle project creation process with two screens. New Project Configuration Screen On the first screen, the type of project is configured: * From the project type pane on the left, choose Gradle . * Specify the Project SDK based on the Java 8 JDK. This SDK will be the default JRE used to run Gradle, and the JDK version used to compile the plugin Java sources. NOTE When targeting 2020.3 and later only, using Java 11 is now required, please see blog post In the Additional Libraries and Frameworks panel, select Java and Consulo Plugin . These settings will be used for the remainder of this tutorial. Optionally: * To include support for the Kotlin language in the plugin, check the Kotlin/JVM box (circled in green below). This option can be selected with or without the Java language. * To create the build.gradle file as a Kotlin build script ( build.gradle.kts ) rather than Groovy, check the Kotlin DSL build script box (circled in magenta below). Then click Next : {:width=\"800px\"} Project Naming/Artifact Coordinates Screen Expand the Artifact Coordinates section and specify a GroupId, ArtifactId, and Version using Maven naming conventions. * GroupId is typically a Java package name, and it is used for the Gradle property project.group value in the project's build.gradle file. For this example, enter com.your.company . * ArtifactId is the default name of the project JAR file (without version). It is also used for the Gradle property rootProject.name value in the project's settings.gradle file. For this example, enter my_gradle_plugin . * Version is used for the Gradle property project.version value in the build.gradle file. For this example, enter 1.0 . The Name field is synced automatically with the specified ArtifactId . Specify the path for the new project in Location and click Finish to continue and generate the project. Components of a Wizard-Generated Gradle Consulo Plugin For the example my_gradle_plugin , the New Project Wizard creates the following directory content: my_gradle_plugin \u251c\u2500\u2500 build.gradle \u251c\u2500\u2500 gradle \u2502 \u2514\u2500\u2500 wrapper \u2502 \u251c\u2500\u2500 gradle-wrapper.jar \u2502 \u2514\u2500\u2500 gradle-wrapper.properties \u251c\u2500\u2500 gradlew \u251c\u2500\u2500 gradlew.bat \u251c\u2500\u2500 settings.gradle \u2514\u2500\u2500 src \u251c\u2500\u2500 main \u2502 \u251c\u2500\u2500 java \u2502 \u2514\u2500\u2500 resources \u2502 \u2514\u2500\u2500 META-INF \u2502 \u2514\u2500\u2500 plugin.xml \u2514\u2500\u2500 test \u251c\u2500\u2500 java \u2514\u2500\u2500 resources The default Consulo build.gradle file (see next paragraph). The Gradle Wrapper files, and in particular the gradle-wrapper.properties file, which specifies the version of the Gradle to be used to build the plugin. If needed, the IntelliJ IDEA Gradle plugin downloads the version of the Gradle specified in this file. The settings.gradle file, containing a definition of the rootProject.name . The META-INF directory under the default main SourceSet contains the plugin configuration file . The generated my_gradle_plugin project build.gradle file: plugins { id 'java' id 'org.jetbrains.intellij' version '0.6.5' } group 'com.your.company' version '1.0' sourceCompatibility = 1.8 repositories { mavenCentral () } dependencies { testImplementation group: 'junit' , name: 'junit' , version: '4.12' } // See https://github.com/JetBrains/gradle-intellij-plugin/ intellij { version '2020.1' } patchPluginXml { changeNotes \"\"\" Add change notes here.<br> <em>most HTML tags may be used</em>\"\"\" } Two plugins to Gradle are explicitly declared: The Gradle Java plugin. The gradle-intellij-plugin . The GroupId from the Wizard Project Naming/Artifact Coordinates Screen is the project.group value. The Version from the Wizard Project Naming/Artifact Coordinates Screen is the project.version value. The sourceCompatibility line is injected to enforce using Java 8 JDK to compile Java sources. The only comment in the file is a link to the README.md for the gradle-intellij-plugin, which is a reference for its configuration DSL. The value of the Setup DSL attribute intellij.version specifies the version of the Consulo to be used to build the plugin. It defaults to the version of IntelliJ IDEA that was used to run the New Project Wizard. The value of the Patching DSL attribute patchPluginXml.changeNotes is set to a place holder text. Plugin Gradle Properties and Plugin Configuration File Elements The Gradle properties rootProject.name and project.group will not, in general, match the respective plugin configuration file plugin.xml elements <name> and <id> . There is no Consulo-related reason they should as they serve different functions. The <name> element (used as the plugin's display name) is often the same as rootProject.name , but it can be more explanatory. The <id> value must be a unique identifier over all plugins, typically a concatenation of the specified GroupId and ArtifactId . Please note that it is impossible to change the <id> of a published plugin without losing automatic updates for existing installations. Adding Gradle Support to an Existing DevKit-Based Consulo Plugin Converting a DevKit-based plugin project to a Gradle-based plugin project can be done using the New Project Wizard to create a Gradle-based project around the existing DevKit-based project: * Ensure the directory containing the DevKit-based Consulo plugin project can be fully recovered if necessary. * Delete all the artifacts of the DevKit-based project: * .idea directory * [modulename].iml file * out directory * Arrange the existing source files within the project directory in the Gradle SourceSet format. * Use the New Project Wizard as though creating a new Gradle project from scratch. * On the Project Naming/Artifact Coordinates Screen set the values to: * GroupId to the existing package in the initial source set. * ArtifactId to the name of the existing plugin. * Version to the same as the existing plugin. * Name to the name of the existing plugin. (It should be pre-filled from the ArtifactId ) * Set the Location to the directory of the existing plugin. * Click Finish to create the new Gradle-based plugin. * Add more modules using Gradle Source Sets as needed. Running a Simple Gradle-Based Consulo Plugin Gradle projects are run from the IDE's Gradle Tool window. Adding Code to the Project Before running my_gradle_project , some code can be added to provide simple functionality. See the Creating Actions tutorial for step-by-step instructions for adding a menu action. Executing the Plugin Open the Gradle tool window and search for the runIde task: * If it\u2019s not in the list, hit the Refresh button at the top of the Gradle window. * Or Create a new Gradle Run Configuration . {:width=\"398px\"} Double-click on the runIde task to execute it. See the IntelliJ IDEA help for more information about Working with Gradle tasks . Finally, when my_gradle_plugin launches in the IDE development instance, there should be a new menu under the Tools menu.","title":"Getting Started with Gradle"},{"location":"tutorials/build_system/prerequisites/#creating-a-gradle-based-consulo-plugin-with-new-project-wizard","text":"Creating new Gradle-based Consulo plugin projects is performed using the New Project Wizard . The Wizard creates all the necessary project files based on a few template inputs. Before creating a new Gradle project, familiarize yourself with the help topic Creating a new Gradle project , which is a tutorial for creating general Gradle projects in IntelliJ IDEA. This page emphasizes the steps in the process of creating Consulo plugin projects that are Gradle-based. WARNING Please note that Gradle 6.1 has a known bug that prevents using it for developing plugins, please upgrade to 6.1.1 or later. Launch the New Project Wizard . It guides you through the Gradle project creation process with two screens.","title":"Creating a Gradle-Based Consulo Plugin with New Project Wizard"},{"location":"tutorials/build_system/prerequisites/#new-project-configuration-screen","text":"On the first screen, the type of project is configured: * From the project type pane on the left, choose Gradle . * Specify the Project SDK based on the Java 8 JDK. This SDK will be the default JRE used to run Gradle, and the JDK version used to compile the plugin Java sources. NOTE When targeting 2020.3 and later only, using Java 11 is now required, please see blog post In the Additional Libraries and Frameworks panel, select Java and Consulo Plugin . These settings will be used for the remainder of this tutorial. Optionally: * To include support for the Kotlin language in the plugin, check the Kotlin/JVM box (circled in green below). This option can be selected with or without the Java language. * To create the build.gradle file as a Kotlin build script ( build.gradle.kts ) rather than Groovy, check the Kotlin DSL build script box (circled in magenta below). Then click Next : {:width=\"800px\"}","title":"New Project Configuration Screen"},{"location":"tutorials/build_system/prerequisites/#project-namingartifact-coordinates-screen","text":"Expand the Artifact Coordinates section and specify a GroupId, ArtifactId, and Version using Maven naming conventions. * GroupId is typically a Java package name, and it is used for the Gradle property project.group value in the project's build.gradle file. For this example, enter com.your.company . * ArtifactId is the default name of the project JAR file (without version). It is also used for the Gradle property rootProject.name value in the project's settings.gradle file. For this example, enter my_gradle_plugin . * Version is used for the Gradle property project.version value in the build.gradle file. For this example, enter 1.0 . The Name field is synced automatically with the specified ArtifactId . Specify the path for the new project in Location and click Finish to continue and generate the project.","title":"Project Naming/Artifact Coordinates Screen"},{"location":"tutorials/build_system/prerequisites/#components-of-a-wizard-generated-gradle-consulo-plugin","text":"For the example my_gradle_plugin , the New Project Wizard creates the following directory content: my_gradle_plugin \u251c\u2500\u2500 build.gradle \u251c\u2500\u2500 gradle \u2502 \u2514\u2500\u2500 wrapper \u2502 \u251c\u2500\u2500 gradle-wrapper.jar \u2502 \u2514\u2500\u2500 gradle-wrapper.properties \u251c\u2500\u2500 gradlew \u251c\u2500\u2500 gradlew.bat \u251c\u2500\u2500 settings.gradle \u2514\u2500\u2500 src \u251c\u2500\u2500 main \u2502 \u251c\u2500\u2500 java \u2502 \u2514\u2500\u2500 resources \u2502 \u2514\u2500\u2500 META-INF \u2502 \u2514\u2500\u2500 plugin.xml \u2514\u2500\u2500 test \u251c\u2500\u2500 java \u2514\u2500\u2500 resources The default Consulo build.gradle file (see next paragraph). The Gradle Wrapper files, and in particular the gradle-wrapper.properties file, which specifies the version of the Gradle to be used to build the plugin. If needed, the IntelliJ IDEA Gradle plugin downloads the version of the Gradle specified in this file. The settings.gradle file, containing a definition of the rootProject.name . The META-INF directory under the default main SourceSet contains the plugin configuration file . The generated my_gradle_plugin project build.gradle file: plugins { id 'java' id 'org.jetbrains.intellij' version '0.6.5' } group 'com.your.company' version '1.0' sourceCompatibility = 1.8 repositories { mavenCentral () } dependencies { testImplementation group: 'junit' , name: 'junit' , version: '4.12' } // See https://github.com/JetBrains/gradle-intellij-plugin/ intellij { version '2020.1' } patchPluginXml { changeNotes \"\"\" Add change notes here.<br> <em>most HTML tags may be used</em>\"\"\" } Two plugins to Gradle are explicitly declared: The Gradle Java plugin. The gradle-intellij-plugin . The GroupId from the Wizard Project Naming/Artifact Coordinates Screen is the project.group value. The Version from the Wizard Project Naming/Artifact Coordinates Screen is the project.version value. The sourceCompatibility line is injected to enforce using Java 8 JDK to compile Java sources. The only comment in the file is a link to the README.md for the gradle-intellij-plugin, which is a reference for its configuration DSL. The value of the Setup DSL attribute intellij.version specifies the version of the Consulo to be used to build the plugin. It defaults to the version of IntelliJ IDEA that was used to run the New Project Wizard. The value of the Patching DSL attribute patchPluginXml.changeNotes is set to a place holder text.","title":"Components of a Wizard-Generated Gradle Consulo Plugin"},{"location":"tutorials/build_system/prerequisites/#plugin-gradle-properties-and-plugin-configuration-file-elements","text":"The Gradle properties rootProject.name and project.group will not, in general, match the respective plugin configuration file plugin.xml elements <name> and <id> . There is no Consulo-related reason they should as they serve different functions. The <name> element (used as the plugin's display name) is often the same as rootProject.name , but it can be more explanatory. The <id> value must be a unique identifier over all plugins, typically a concatenation of the specified GroupId and ArtifactId . Please note that it is impossible to change the <id> of a published plugin without losing automatic updates for existing installations.","title":"Plugin Gradle Properties and Plugin Configuration File Elements"},{"location":"tutorials/build_system/prerequisites/#adding-gradle-support-to-an-existing-devkit-based-consulo-plugin","text":"Converting a DevKit-based plugin project to a Gradle-based plugin project can be done using the New Project Wizard to create a Gradle-based project around the existing DevKit-based project: * Ensure the directory containing the DevKit-based Consulo plugin project can be fully recovered if necessary. * Delete all the artifacts of the DevKit-based project: * .idea directory * [modulename].iml file * out directory * Arrange the existing source files within the project directory in the Gradle SourceSet format. * Use the New Project Wizard as though creating a new Gradle project from scratch. * On the Project Naming/Artifact Coordinates Screen set the values to: * GroupId to the existing package in the initial source set. * ArtifactId to the name of the existing plugin. * Version to the same as the existing plugin. * Name to the name of the existing plugin. (It should be pre-filled from the ArtifactId ) * Set the Location to the directory of the existing plugin. * Click Finish to create the new Gradle-based plugin. * Add more modules using Gradle Source Sets as needed.","title":"Adding Gradle Support to an Existing DevKit-Based Consulo Plugin"},{"location":"tutorials/build_system/prerequisites/#running-a-simple-gradle-based-consulo-plugin","text":"Gradle projects are run from the IDE's Gradle Tool window.","title":"Running a Simple Gradle-Based Consulo Plugin"},{"location":"tutorials/build_system/prerequisites/#adding-code-to-the-project","text":"Before running my_gradle_project , some code can be added to provide simple functionality. See the Creating Actions tutorial for step-by-step instructions for adding a menu action.","title":"Adding Code to the Project"},{"location":"tutorials/build_system/prerequisites/#executing-the-plugin","text":"Open the Gradle tool window and search for the runIde task: * If it\u2019s not in the list, hit the Refresh button at the top of the Gradle window. * Or Create a new Gradle Run Configuration . {:width=\"398px\"} Double-click on the runIde task to execute it. See the IntelliJ IDEA help for more information about Working with Gradle tasks . Finally, when my_gradle_plugin launches in the IDE development instance, there should be a new menu under the Tools menu.","title":"Executing the Plugin"},{"location":"tutorials/custom_language_support/annotator/","text":"An Annotator helps highlight and annotate any code based on specific rules. This section adds annotation functionality to support the Simple Language in the context of Java code. Reference : Annotator bullet list {:toc} Required Project Configuration Changes Classes defined in this step of the tutorial depend on com.intellij.psi.PsiLiteralExpression at runtime. Using PsiLiteralExpression introduces a dependency on com.intellij.modules.java . Beginning in version 2019.2 of the Consulo these dependencies are declared in plugin.xml : <depends> com.intellij.modules.java </depends> The dependency is also declared in the build.gradle file: intellij { plugins = [ 'java' ] } 7.1. Define an Annotator The SimpleAnnotator subclasses Annotator . Consider a literal string that starts with \"simple:\" as a prefix of a Simple Language key. It isn't part of the Simple Language, but it is a useful convention for detecting Simple Language keys embedded as string literals in other languages, like Java. Annotate the simple:key literal expression, and differentiate between a well-formed vs. an unresolved property. NOTE The use of new AnnotationHolder syntax starting 2020.2, which uses the builder format. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleAnnotator . java % } TIP If the above code is copied at this stage of the tutorial, then remove the line below the comment \"** Tutorial step 18.3 \u2026\" The quick fix class in that line is not defined until later in the tutorial. 7.2. Register the Annotator Using the com.intellij.annotator extension point in the plugin configuration file, register the Simple Language annotator class with the Consulo: <extensions defaultExtensionNs= \"com.intellij\" > <annotator language= \"JAVA\" implementationClass= \"org.intellij.sdk.language.SimpleAnnotator\" /> </extensions> 7.3. Run the Project As a test, define the following Java file containing a Simple Language prefix:value pair: public class Test { public static void main ( String [] args ) { System . out . println ( \"simple:website\" ); } } Open this Java file in an IDE Development Instance running the simple_language_plugin to check if the IDE resolves a property: {:width=\"800px\"} If the property is an undefined name, the annotator flags the code with an error. {:width=\"800px\"} Try changing the Simple Language color settings to differentiate the annotation from the default language color settings.","title":"7. Annotator"},{"location":"tutorials/custom_language_support/annotator/#required-project-configuration-changes","text":"Classes defined in this step of the tutorial depend on com.intellij.psi.PsiLiteralExpression at runtime. Using PsiLiteralExpression introduces a dependency on com.intellij.modules.java . Beginning in version 2019.2 of the Consulo these dependencies are declared in plugin.xml : <depends> com.intellij.modules.java </depends> The dependency is also declared in the build.gradle file: intellij { plugins = [ 'java' ] }","title":"Required Project Configuration Changes"},{"location":"tutorials/custom_language_support/annotator/#71-define-an-annotator","text":"The SimpleAnnotator subclasses Annotator . Consider a literal string that starts with \"simple:\" as a prefix of a Simple Language key. It isn't part of the Simple Language, but it is a useful convention for detecting Simple Language keys embedded as string literals in other languages, like Java. Annotate the simple:key literal expression, and differentiate between a well-formed vs. an unresolved property. NOTE The use of new AnnotationHolder syntax starting 2020.2, which uses the builder format. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleAnnotator . java % } TIP If the above code is copied at this stage of the tutorial, then remove the line below the comment \"** Tutorial step 18.3 \u2026\" The quick fix class in that line is not defined until later in the tutorial.","title":"7.1. Define an Annotator"},{"location":"tutorials/custom_language_support/annotator/#72-register-the-annotator","text":"Using the com.intellij.annotator extension point in the plugin configuration file, register the Simple Language annotator class with the Consulo: <extensions defaultExtensionNs= \"com.intellij\" > <annotator language= \"JAVA\" implementationClass= \"org.intellij.sdk.language.SimpleAnnotator\" /> </extensions>","title":"7.2. Register the Annotator"},{"location":"tutorials/custom_language_support/annotator/#73-run-the-project","text":"As a test, define the following Java file containing a Simple Language prefix:value pair: public class Test { public static void main ( String [] args ) { System . out . println ( \"simple:website\" ); } } Open this Java file in an IDE Development Instance running the simple_language_plugin to check if the IDE resolves a property: {:width=\"800px\"} If the property is an undefined name, the annotator flags the code with an error. {:width=\"800px\"} Try changing the Simple Language color settings to differentiate the annotation from the default language color settings.","title":"7.3. Run the Project"},{"location":"tutorials/custom_language_support/code_style_settings/","text":"Code style settings enable defining formatting options. A code style settings provider creates an instance of the settings and also creates an options page in settings/preferences. This example creates a settings/preferences page that uses the default language code style settings, customized by a language code style settings provider. Reference : Code Style Settings bullet list {:toc} 16.1. Define Code Style Settings Define a code style settings for Simple Language by subclassing CustomCodeStyleSettings . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleCodeStyleSettings . java % } 16.2. Define Code Style Settings Provider The code style settings provider gives the Consulo a standard way to instantiate CustomCodeStyleSettings for the Simple Language. Define a code style settings provider for Simple Language by subclassing CodeStyleSettingsProvider . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleCodeStyleSettingsProvider . java % } 16.3. Register the Code Style Settings Provider The SimpleCodeStyleSettingsProvider implementation is registered with the Consulo in the plugin configuration file using the com.intellij.codeStyleSettingsProvider extension point. <extensions defaultExtensionNs= \"com.intellij\" > <codeStyleSettingsProvider implementation= \"org.intellij.sdk.language.SimpleCodeStyleSettingsProvider\" /> </extensions> 16.4. Define the Language Code Style Settings Provider Define a code style settings provider for Simple Language by subclassing LanguageCodeStyleSettingsProvider , which provides common code style settings for a specific language. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleLanguageCodeStyleSettingsProvider . java % } 16.5. Register the Language Code Style Settings Provider The SimpleLanguageCodeStyleSettingsProvider implementation is registered with the Consulo in the plugin configuration file using the com.intellij.langCodeStyleSettingsProvider extension point. <extensions defaultExtensionNs= \"com.intellij\" > <langCodeStyleSettingsProvider implementation= \"org.intellij.sdk.language.SimpleLanguageCodeStyleSettingsProvider\" /> </extensions> 16.6. Run the Project In the IDE Development Instance, open the Simple Language code formatting page: Preferences/Settings | Editor | Code Style | Simple .","title":"16. Code Style Settings"},{"location":"tutorials/custom_language_support/code_style_settings/#161-define-code-style-settings","text":"Define a code style settings for Simple Language by subclassing CustomCodeStyleSettings . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleCodeStyleSettings . java % }","title":"16.1. Define Code Style Settings"},{"location":"tutorials/custom_language_support/code_style_settings/#162-define-code-style-settings-provider","text":"The code style settings provider gives the Consulo a standard way to instantiate CustomCodeStyleSettings for the Simple Language. Define a code style settings provider for Simple Language by subclassing CodeStyleSettingsProvider . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleCodeStyleSettingsProvider . java % }","title":"16.2. Define Code Style Settings Provider"},{"location":"tutorials/custom_language_support/code_style_settings/#163-register-the-code-style-settings-provider","text":"The SimpleCodeStyleSettingsProvider implementation is registered with the Consulo in the plugin configuration file using the com.intellij.codeStyleSettingsProvider extension point. <extensions defaultExtensionNs= \"com.intellij\" > <codeStyleSettingsProvider implementation= \"org.intellij.sdk.language.SimpleCodeStyleSettingsProvider\" /> </extensions>","title":"16.3. Register the Code Style Settings Provider"},{"location":"tutorials/custom_language_support/code_style_settings/#164-define-the-language-code-style-settings-provider","text":"Define a code style settings provider for Simple Language by subclassing LanguageCodeStyleSettingsProvider , which provides common code style settings for a specific language. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleLanguageCodeStyleSettingsProvider . java % }","title":"16.4. Define the Language Code Style Settings Provider"},{"location":"tutorials/custom_language_support/code_style_settings/#165-register-the-language-code-style-settings-provider","text":"The SimpleLanguageCodeStyleSettingsProvider implementation is registered with the Consulo in the plugin configuration file using the com.intellij.langCodeStyleSettingsProvider extension point. <extensions defaultExtensionNs= \"com.intellij\" > <langCodeStyleSettingsProvider implementation= \"org.intellij.sdk.language.SimpleLanguageCodeStyleSettingsProvider\" /> </extensions>","title":"16.5. Register the Language Code Style Settings Provider"},{"location":"tutorials/custom_language_support/code_style_settings/#166-run-the-project","text":"In the IDE Development Instance, open the Simple Language code formatting page: Preferences/Settings | Editor | Code Style | Simple .","title":"16.6. Run the Project"},{"location":"tutorials/custom_language_support/commenter/","text":"A commenter enables the user to comment-out a line of code at the cursor or selected code automatically. The Commenter defines support for Code | Comment with Line Comment and Code | Comment with Block Comment actions. bullet list {:toc} 17.1. Define a Commenter The commenter for Simple Language defines the line comment prefix as # . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleCommenter . java % } 17.2. Register the Commenter The SimpleCommenter implementation is registered in the plugin configuration file using the com.intellij.lang.commenter extension point. <extensions defaultExtensionNs= \"com.intellij\" > <lang.commenter language= \"Simple\" implementationClass= \"org.intellij.sdk.language.SimpleCommenter\" /> </extensions> 17.3. Run the Project Open the example Simple Language properties file in the IDE Development Instance. Place the cursor at the website line. Select Code | Comment with Line Comment . The line is converted to a comment. Select Code | Comment with Line Comment again, and the comment is converted back to active code.","title":"17. Commenter"},{"location":"tutorials/custom_language_support/commenter/#171-define-a-commenter","text":"The commenter for Simple Language defines the line comment prefix as # . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleCommenter . java % }","title":"17.1. Define a Commenter"},{"location":"tutorials/custom_language_support/commenter/#172-register-the-commenter","text":"The SimpleCommenter implementation is registered in the plugin configuration file using the com.intellij.lang.commenter extension point. <extensions defaultExtensionNs= \"com.intellij\" > <lang.commenter language= \"Simple\" implementationClass= \"org.intellij.sdk.language.SimpleCommenter\" /> </extensions>","title":"17.2. Register the Commenter"},{"location":"tutorials/custom_language_support/commenter/#173-run-the-project","text":"Open the example Simple Language properties file in the IDE Development Instance. Place the cursor at the website line. Select Code | Comment with Line Comment . The line is converted to a comment. Select Code | Comment with Line Comment again, and the comment is converted back to active code.","title":"17.3. Run the Project"},{"location":"tutorials/custom_language_support/completion_contributor/","text":"Custom languages provide code completion using one of two approaches: Contributor and Reference-based (see 10. Reference Contributor ) completion. Reference : Code Completion bullet list {:toc} 9.1. Define a Completion Contributor For this tutorial, the simple_language_plugin provides custom completion for values in Simple Language property files. Create a completion contributor by subclassing CompletionContributor . This rudimentary completion contributor always adds \"Hello\" to the results set, regardless of context: { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleCompletionContributor . java % } 9.2. Register the Completion Contributor The SimpleCompletionContributor implementation is registered in the plugin configuration file with the Consulo using the com.intellij.completion.contributor extension point. <extensions defaultExtensionNs= \"com.intellij\" > <completion.contributor language= \"Simple\" implementationClass= \"org.intellij.sdk.language.SimpleCompletionContributor\" /> </extensions> 9.3. Run the Project Run the simple_language_plugin in a Development Instance and open the test.simple file. Erase the property \"English\" and invoke Basic Code Completion . The choice \"Hello\" is shown:","title":"9. Completion Contributor"},{"location":"tutorials/custom_language_support/completion_contributor/#91-define-a-completion-contributor","text":"For this tutorial, the simple_language_plugin provides custom completion for values in Simple Language property files. Create a completion contributor by subclassing CompletionContributor . This rudimentary completion contributor always adds \"Hello\" to the results set, regardless of context: { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleCompletionContributor . java % }","title":"9.1. Define a Completion Contributor"},{"location":"tutorials/custom_language_support/completion_contributor/#92-register-the-completion-contributor","text":"The SimpleCompletionContributor implementation is registered in the plugin configuration file with the Consulo using the com.intellij.completion.contributor extension point. <extensions defaultExtensionNs= \"com.intellij\" > <completion.contributor language= \"Simple\" implementationClass= \"org.intellij.sdk.language.SimpleCompletionContributor\" /> </extensions>","title":"9.2. Register the Completion Contributor"},{"location":"tutorials/custom_language_support/completion_contributor/#93-run-the-project","text":"Run the simple_language_plugin in a Development Instance and open the test.simple file. Erase the property \"English\" and invoke Basic Code Completion . The choice \"Hello\" is shown:","title":"9.3. Run the Project"},{"location":"tutorials/custom_language_support/find_usages_provider/","text":"A FindUsagesProvider uses a word scanner to build an index of words in every file. A scanner breaks the text into words and defines the context for each word. Reference : Find Usages bullet list {:toc} 11.1. Define a Find Usages Provider The SimpleFindUsagesProvider implements FindUsagesProvider . Using the DefaultWordsScanner ensures the scanner implementation is thread-safe. See the comments in FindUsagesProvider for more information. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleFindUsagesProvider . java % } 11.2. Register the Find Usages Provider The SimpleFindUsagesProvider implementation is registered with the Consulo in the plugin configuration file using the com.intellij.lang.findUsagesProvider extension point. <extensions defaultExtensionNs= \"com.intellij\" > <lang.findUsagesProvider language= \"Simple\" implementationClass= \"org.intellij.sdk.language.SimpleFindUsagesProvider\" /> </extensions> 11.3. Run the Project Rebuild the project, and run simple_language_plugin in a Development Instance. The IDE now supports Find Usages for any property with a reference:","title":"11. Find Usages Provider"},{"location":"tutorials/custom_language_support/find_usages_provider/#111-define-a-find-usages-provider","text":"The SimpleFindUsagesProvider implements FindUsagesProvider . Using the DefaultWordsScanner ensures the scanner implementation is thread-safe. See the comments in FindUsagesProvider for more information. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleFindUsagesProvider . java % }","title":"11.1. Define a Find Usages Provider"},{"location":"tutorials/custom_language_support/find_usages_provider/#112-register-the-find-usages-provider","text":"The SimpleFindUsagesProvider implementation is registered with the Consulo in the plugin configuration file using the com.intellij.lang.findUsagesProvider extension point. <extensions defaultExtensionNs= \"com.intellij\" > <lang.findUsagesProvider language= \"Simple\" implementationClass= \"org.intellij.sdk.language.SimpleFindUsagesProvider\" /> </extensions>","title":"11.2. Register the Find Usages Provider"},{"location":"tutorials/custom_language_support/find_usages_provider/#113-run-the-project","text":"Rebuild the project, and run simple_language_plugin in a Development Instance. The IDE now supports Find Usages for any property with a reference:","title":"11.3. Run the Project"},{"location":"tutorials/custom_language_support/folding_builder/","text":"A folding builder identifies the folding regions in the code. In this step of the tutorial, the folding builder is used to identify folding regions and replace the regions with specific text. Rather than the usual practice of using a folding builder to collapse a class, method, or comments to fewer lines, the folding builder replaces Simple Language keys with their corresponding values. bullet list {:toc} 12.1. Define a Folding Builder The SimpleFoldingBuilder replaces usages of properties with their values by default. Start by subclassing FoldingBuilderEx Note that SimpleFoldingBuilder also implements DumbAware , which means the class is allowed to run in dumb mode, when indices are in background update. NOTE A folding builder must implement DumbAware to function in this tutorial and pass tests. The buildFoldRegions() method searches down a PSI tree from root to find all literal expressions containing the simple prefix simple: . The remainder of such a string is expected to contain a Simple Language key, and so the text range is stored as a FoldingDescriptor . The getPlaceholderText() method retrieves the Simple Language value corresponding to the key associated with the (ASTNode) provided. The Consulo uses the value to substitute for the key when the code gets folded. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleFoldingBuilder . java % } 12.2. Register the Folding Builder The SimpleFoldingBuilder implementation is registered with the Consulo in the plugin configuration file using the com.intellij.lang.foldingBuilder extension point. <extensions defaultExtensionNs= \"com.intellij\" > <lang.foldingBuilder language= \"JAVA\" implementationClass= \"org.intellij.sdk.language.SimpleFoldingBuilder\" /> </extensions> 12.3. Run the Project Rebuild the project, and run simple_language_plugin in a Development Instance. Now when a Java file is opened in the Editor, it shows the property's value instead of the key. This is because SimpleFoldingBuilder.isCollapsedByDefault() always returns true . Try using Code | Folding | Expand All to show the key rather than the value.","title":"12. Folding Builder"},{"location":"tutorials/custom_language_support/folding_builder/#121-define-a-folding-builder","text":"The SimpleFoldingBuilder replaces usages of properties with their values by default. Start by subclassing FoldingBuilderEx Note that SimpleFoldingBuilder also implements DumbAware , which means the class is allowed to run in dumb mode, when indices are in background update. NOTE A folding builder must implement DumbAware to function in this tutorial and pass tests. The buildFoldRegions() method searches down a PSI tree from root to find all literal expressions containing the simple prefix simple: . The remainder of such a string is expected to contain a Simple Language key, and so the text range is stored as a FoldingDescriptor . The getPlaceholderText() method retrieves the Simple Language value corresponding to the key associated with the (ASTNode) provided. The Consulo uses the value to substitute for the key when the code gets folded. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleFoldingBuilder . java % }","title":"12.1. Define a Folding Builder"},{"location":"tutorials/custom_language_support/folding_builder/#122-register-the-folding-builder","text":"The SimpleFoldingBuilder implementation is registered with the Consulo in the plugin configuration file using the com.intellij.lang.foldingBuilder extension point. <extensions defaultExtensionNs= \"com.intellij\" > <lang.foldingBuilder language= \"JAVA\" implementationClass= \"org.intellij.sdk.language.SimpleFoldingBuilder\" /> </extensions>","title":"12.2. Register the Folding Builder"},{"location":"tutorials/custom_language_support/folding_builder/#123-run-the-project","text":"Rebuild the project, and run simple_language_plugin in a Development Instance. Now when a Java file is opened in the Editor, it shows the property's value instead of the key. This is because SimpleFoldingBuilder.isCollapsedByDefault() always returns true . Try using Code | Folding | Expand All to show the key rather than the value.","title":"12.3. Run the Project"},{"location":"tutorials/custom_language_support/formatter/","text":"The Consulo includes a powerful framework for implementing formatting for custom languages. A formatter enables reformatting code automatically based on code style settings. The formatter controls spaces, indents, wrap, and alignment. Reference : Code Formatter bullet list {:toc} 15.1. Define a Block The formatting model represents the formatting structure of a file as a tree of Block objects, with associated indent, wrap, alignment and spacing settings. The goal is to cover each PSI element with such a block. Since each block builds its children's blocks, it can generate extra blocks or skip any PSI elements. Define SimpleBlock based on AbstractBlock . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleBlock . java % } 15.2. Define a Formatting Model Builder Define a formatter that removes extra spaces except for the single spaces around the property separator. For example, reformat \"foo = bar\" to \"foo = bar\". Create SimpleFormattingModelBuilder by subclassing FormattingModelBuilder . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleFormattingModelBuilder . java % } 15.3. Register the Formatter The SimpleFormattingModelBuilder implementation is registered with the Consulo in the plugin configuration file using the com.intellij.lang.formatter extension point. <extensions defaultExtensionNs= \"com.intellij\" > <lang.formatter language= \"Simple\" implementationClass= \"org.intellij.sdk.language.SimpleFormattingModelBuilder\" /> </extensions> 15.4. Run the Project Add some extra spaces around the = separator between language and English . Reformat the code by selecting Code | Show Reformat File Dialog and choose Run .","title":"15. Formatter"},{"location":"tutorials/custom_language_support/formatter/#151-define-a-block","text":"The formatting model represents the formatting structure of a file as a tree of Block objects, with associated indent, wrap, alignment and spacing settings. The goal is to cover each PSI element with such a block. Since each block builds its children's blocks, it can generate extra blocks or skip any PSI elements. Define SimpleBlock based on AbstractBlock . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleBlock . java % }","title":"15.1. Define a Block"},{"location":"tutorials/custom_language_support/formatter/#152-define-a-formatting-model-builder","text":"Define a formatter that removes extra spaces except for the single spaces around the property separator. For example, reformat \"foo = bar\" to \"foo = bar\". Create SimpleFormattingModelBuilder by subclassing FormattingModelBuilder . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleFormattingModelBuilder . java % }","title":"15.2. Define a Formatting Model Builder"},{"location":"tutorials/custom_language_support/formatter/#153-register-the-formatter","text":"The SimpleFormattingModelBuilder implementation is registered with the Consulo in the plugin configuration file using the com.intellij.lang.formatter extension point. <extensions defaultExtensionNs= \"com.intellij\" > <lang.formatter language= \"Simple\" implementationClass= \"org.intellij.sdk.language.SimpleFormattingModelBuilder\" /> </extensions>","title":"15.3. Register the Formatter"},{"location":"tutorials/custom_language_support/formatter/#154-run-the-project","text":"Add some extra spaces around the = separator between language and English . Reformat the code by selecting Code | Show Reformat File Dialog and choose Run .","title":"15.4. Run the Project"},{"location":"tutorials/custom_language_support/go_to_symbol_contributor/","text":"A Go to Symbol Contributor helps the user to navigate to any PSI element by its name. Reference : Go to Class and Go to Symbol bullet list {:toc} 13.1. Define a Helper Method for Generated PSI Elements To specify how a PSI element looks like in the Go To Symbol popup window, Structure tool window, or other components, it should implement getPresentation() . This method gets defined in the utility class SimplePsiImplUtil , and the parser and PSI classes must be regenerated. Add the following method to SimplePsiImplUtil : public static ItemPresentation getPresentation ( final SimpleProperty element ) { return new ItemPresentation () { @Nullable @Override public String getPresentableText () { return element . getKey (); } @Nullable @Override public String getLocationString () { return element . getContainingFile (). getName (); } @Nullable @Override public Icon getIcon ( boolean unused ) { return SimpleIcons . FILE ; } }; } 13.2. Update Grammar and Regenerate the Parser Now add the SimplePsiImplUtil.getPresentation() to the property methods definition in the Simple.bnf grammar file by replacing the property definition with the lines below. Don't forget to regenerate the parser after updating the file! Right-click on the Simple.bnf file and select Generate Parser Code . property :: = ( KEY ? SEPARATOR VALUE ? ) | KEY { mixin = \"org.intellij.sdk.language.psi.impl.SimpleNamedElementImpl\" implements = \"org.intellij.sdk.language.psi.SimpleNamedElement\" methods =[ getKey getValue getName setName getNameIdentifier getPresentation ] } 13.3. Define a Go to Symbol Contributor To enable the simple_language_plugin to contribute items to Navigate | Class..., File..., Symbol... lists, subclass ChooseByNameContributor to create SimpleChooseByNameContributor : { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleChooseByNameContributor . java % } 13.4. Register the Go To Symbol Contributor The SimpleChooseByNameContributor implementation is registered with the Consulo in the plugin configuration file using the com.intellij.gotoSymbolContributor extension point. <extensions defaultExtensionNs= \"com.intellij\" > <gotoSymbolContributor implementation= \"org.intellij.sdk.language.SimpleChooseByNameContributor\" /> </extensions> 13.5. Run the Project Rebuild the project, and run simple_language_plugin in a Development Instance. The IDE now supports navigating to a property definition by name pattern via Navigate | Symbol action. {:width=\"800px\"}","title":"13. Go To Symbol Contributor"},{"location":"tutorials/custom_language_support/go_to_symbol_contributor/#131-define-a-helper-method-for-generated-psi-elements","text":"To specify how a PSI element looks like in the Go To Symbol popup window, Structure tool window, or other components, it should implement getPresentation() . This method gets defined in the utility class SimplePsiImplUtil , and the parser and PSI classes must be regenerated. Add the following method to SimplePsiImplUtil : public static ItemPresentation getPresentation ( final SimpleProperty element ) { return new ItemPresentation () { @Nullable @Override public String getPresentableText () { return element . getKey (); } @Nullable @Override public String getLocationString () { return element . getContainingFile (). getName (); } @Nullable @Override public Icon getIcon ( boolean unused ) { return SimpleIcons . FILE ; } }; }","title":"13.1. Define a Helper Method for Generated PSI Elements"},{"location":"tutorials/custom_language_support/go_to_symbol_contributor/#132-update-grammar-and-regenerate-the-parser","text":"Now add the SimplePsiImplUtil.getPresentation() to the property methods definition in the Simple.bnf grammar file by replacing the property definition with the lines below. Don't forget to regenerate the parser after updating the file! Right-click on the Simple.bnf file and select Generate Parser Code . property :: = ( KEY ? SEPARATOR VALUE ? ) | KEY { mixin = \"org.intellij.sdk.language.psi.impl.SimpleNamedElementImpl\" implements = \"org.intellij.sdk.language.psi.SimpleNamedElement\" methods =[ getKey getValue getName setName getNameIdentifier getPresentation ] }","title":"13.2. Update Grammar and Regenerate the Parser"},{"location":"tutorials/custom_language_support/go_to_symbol_contributor/#133-define-a-go-to-symbol-contributor","text":"To enable the simple_language_plugin to contribute items to Navigate | Class..., File..., Symbol... lists, subclass ChooseByNameContributor to create SimpleChooseByNameContributor : { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleChooseByNameContributor . java % }","title":"13.3. Define a Go to Symbol Contributor"},{"location":"tutorials/custom_language_support/go_to_symbol_contributor/#134-register-the-go-to-symbol-contributor","text":"The SimpleChooseByNameContributor implementation is registered with the Consulo in the plugin configuration file using the com.intellij.gotoSymbolContributor extension point. <extensions defaultExtensionNs= \"com.intellij\" > <gotoSymbolContributor implementation= \"org.intellij.sdk.language.SimpleChooseByNameContributor\" /> </extensions>","title":"13.4. Register the Go To Symbol Contributor"},{"location":"tutorials/custom_language_support/go_to_symbol_contributor/#135-run-the-project","text":"Rebuild the project, and run simple_language_plugin in a Development Instance. The IDE now supports navigating to a property definition by name pattern via Navigate | Symbol action. {:width=\"800px\"}","title":"13.5. Run the Project"},{"location":"tutorials/custom_language_support/grammar_and_parser/","text":"In order for the Consulo to parse a Simple Language file, tokens and elements must be defined based on IElementType . The Simple Language grammar must also be defined to generate a parser. Reference : Implementing a Parser and PSI bullet item {:toc} 3.1. Define a Token Type Create SimpleTokenType in the org.intellij.sdk.language.psi package (see the simple_language_plugin code sample) by subclassing IElementType . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / psi / SimpleTokenType . java % } 3.2. Define an Element Type Create the SimpleElementType in the org.intellij.sdk.language.psi package by subclassing IElementType . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / psi / SimpleElementType . java % } 3.3. Define the Grammar Define a grammar for the Simple Language in the com/intellij/sdk/language/Simple.bnf file. { parserClass = \"org.intellij.sdk.language.parser.SimpleParser\" extends = \"com.intellij.extapi.psi.ASTWrapperPsiElement\" psiClassPrefix = \"Simple\" psiImplClassSuffix = \"Impl\" psiPackage = \"org.intellij.sdk.language.psi\" psiImplPackage = \"org.intellij.sdk.language.psi.impl\" elementTypeHolderClass = \"org.intellij.sdk.language.psi.SimpleTypes\" elementTypeClass = \"org.intellij.sdk.language.psi.SimpleElementType\" tokenTypeClass = \"org.intellij.sdk.language.psi.SimpleTokenType\" } simpleFile : := item_* private item_ : := (property|COMMENT|CRLF) property : := (KEY? SEPARATOR VALUE?) | KEY As shown, a properties file can contain properties, comments, and line breaks. Please see Grammar Kit documentation for more details on BNF syntax. The grammar defines the flexibility of the support for a language. The above grammar specifies that a property may have or may not have key and value. This flexibility allows the Consulo to recognize incorrectly defined properties and provide corresponding code analysis and quick-fixes. Note that the SimpleTypes class in the elementTypeHolderClass field above specifies the name of a class that gets generated from the grammar; it doesn't exist at this point. 3.4. Generate a Parser Now that the grammar is defined generate a parser with PSI classes via Generate Parser Code from the context menu on the Simple.bnf file. This step generates a parser and PSI elements in the /src/main/gen folder of the project. Mark this folder as Generated Sources Root and make sure everything compiles without errors. TIP Gradle plugin gradle-grammarkit-plugin can be used alternatively. {:width=\"800px\"}","title":"3. Grammar and Parser"},{"location":"tutorials/custom_language_support/grammar_and_parser/#31-define-a-token-type","text":"Create SimpleTokenType in the org.intellij.sdk.language.psi package (see the simple_language_plugin code sample) by subclassing IElementType . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / psi / SimpleTokenType . java % }","title":"3.1. Define a Token Type"},{"location":"tutorials/custom_language_support/grammar_and_parser/#32-define-an-element-type","text":"Create the SimpleElementType in the org.intellij.sdk.language.psi package by subclassing IElementType . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / psi / SimpleElementType . java % }","title":"3.2. Define an Element Type"},{"location":"tutorials/custom_language_support/grammar_and_parser/#33-define-the-grammar","text":"Define a grammar for the Simple Language in the com/intellij/sdk/language/Simple.bnf file. { parserClass = \"org.intellij.sdk.language.parser.SimpleParser\" extends = \"com.intellij.extapi.psi.ASTWrapperPsiElement\" psiClassPrefix = \"Simple\" psiImplClassSuffix = \"Impl\" psiPackage = \"org.intellij.sdk.language.psi\" psiImplPackage = \"org.intellij.sdk.language.psi.impl\" elementTypeHolderClass = \"org.intellij.sdk.language.psi.SimpleTypes\" elementTypeClass = \"org.intellij.sdk.language.psi.SimpleElementType\" tokenTypeClass = \"org.intellij.sdk.language.psi.SimpleTokenType\" } simpleFile : := item_* private item_ : := (property|COMMENT|CRLF) property : := (KEY? SEPARATOR VALUE?) | KEY As shown, a properties file can contain properties, comments, and line breaks. Please see Grammar Kit documentation for more details on BNF syntax. The grammar defines the flexibility of the support for a language. The above grammar specifies that a property may have or may not have key and value. This flexibility allows the Consulo to recognize incorrectly defined properties and provide corresponding code analysis and quick-fixes. Note that the SimpleTypes class in the elementTypeHolderClass field above specifies the name of a class that gets generated from the grammar; it doesn't exist at this point.","title":"3.3. Define the Grammar"},{"location":"tutorials/custom_language_support/grammar_and_parser/#34-generate-a-parser","text":"Now that the grammar is defined generate a parser with PSI classes via Generate Parser Code from the context menu on the Simple.bnf file. This step generates a parser and PSI elements in the /src/main/gen folder of the project. Mark this folder as Generated Sources Root and make sure everything compiles without errors. TIP Gradle plugin gradle-grammarkit-plugin can be used alternatively. {:width=\"800px\"}","title":"3.4. Generate a Parser"},{"location":"tutorials/custom_language_support/language_and_filetype/","text":"The Consulo determines file type by examining the name of a file. Each language has Language and LanguageFileType objects defining the language. Register the LanguageFileType with the Consulo in the plugin configuration file. Reference : Registering a File Type bullet item {:toc} 2.1. Define the Language The language implemented in this tutorial is named \"Simple\" - note the case of the name. The SimpleLanguage class is defined in the org.intellij.sdk.language package of the simple_language_plugin code sample: { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleLanguage . java % } 2.2. Define an Icon The icon for the Simple Language is defined by the SimpleIcons class. There is nothing uniquely Simple Language-specific about defining the icon itself. The definition follows a pattern similar to defining, e.g., SdkIcons . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleIcons . java % } 2.3. Define a FileType The Simple Language file type is defined by subclassing LanguageFileType : { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleFileType . java % } 2.4. Register the FileType Directly Direct registration is possible when targeting version 2019.2 (and later) of the Consulo - no FileTypeFactory is required. Instead, the file type is registered via the com.intellij.fileType extension point in plugin.xml : <extensions defaultExtensionNs= \"com.intellij\" > <fileType name= \"Simple File\" implementationClass= \"org.intellij.sdk.language.SimpleFileType\" fieldName= \"INSTANCE\" language= \"Simple\" extensions= \"simple\" /> </extensions> Skip to section 2.6 . 2.5. Register the FileType Using a Factory This pattern is necessary when targeting versions of the Consulo prior to 2019.2 2.5.1 Define a FileType Factory First, define SimpleFileTypeFactory as a subclass of FileTypeFactory . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleFileTypeFactory . java % } 2.5.2 Register the FileType Factory The SimpleFileTypeFactory is registered using the com.intellij.openapi.fileTypes.FileTypeFactory extension point in plugin.xml . <extensions defaultExtensionNs= \"com.intellij\" > <fileTypeFactory implementation= \"org.intellij.sdk.language.SimpleFileTypeFactory\" /> </extensions> 2.6. Run the Project Create an empty file with the extension *.simple , and IntelliJ IDEA automatically associates it with our language. Note the appearance of the Simple Language file icon next to the test.simple file in the Project Tool Window , and the editor tab for the file. {:width=\"800px\"}","title":"2. Language and File Type"},{"location":"tutorials/custom_language_support/language_and_filetype/#21-define-the-language","text":"The language implemented in this tutorial is named \"Simple\" - note the case of the name. The SimpleLanguage class is defined in the org.intellij.sdk.language package of the simple_language_plugin code sample: { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleLanguage . java % }","title":"2.1. Define the Language"},{"location":"tutorials/custom_language_support/language_and_filetype/#22-define-an-icon","text":"The icon for the Simple Language is defined by the SimpleIcons class. There is nothing uniquely Simple Language-specific about defining the icon itself. The definition follows a pattern similar to defining, e.g., SdkIcons . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleIcons . java % }","title":"2.2. Define an Icon"},{"location":"tutorials/custom_language_support/language_and_filetype/#23-define-a-filetype","text":"The Simple Language file type is defined by subclassing LanguageFileType : { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleFileType . java % }","title":"2.3. Define a FileType"},{"location":"tutorials/custom_language_support/language_and_filetype/#24-register-the-filetype-directly","text":"Direct registration is possible when targeting version 2019.2 (and later) of the Consulo - no FileTypeFactory is required. Instead, the file type is registered via the com.intellij.fileType extension point in plugin.xml : <extensions defaultExtensionNs= \"com.intellij\" > <fileType name= \"Simple File\" implementationClass= \"org.intellij.sdk.language.SimpleFileType\" fieldName= \"INSTANCE\" language= \"Simple\" extensions= \"simple\" /> </extensions> Skip to section 2.6 .","title":"2.4. Register the FileType Directly"},{"location":"tutorials/custom_language_support/language_and_filetype/#25-register-the-filetype-using-a-factory","text":"This pattern is necessary when targeting versions of the Consulo prior to 2019.2","title":"2.5. Register the FileType Using a Factory"},{"location":"tutorials/custom_language_support/language_and_filetype/#251-define-a-filetype-factory","text":"First, define SimpleFileTypeFactory as a subclass of FileTypeFactory . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleFileTypeFactory . java % }","title":"2.5.1 Define a FileType Factory"},{"location":"tutorials/custom_language_support/language_and_filetype/#252-register-the-filetype-factory","text":"The SimpleFileTypeFactory is registered using the com.intellij.openapi.fileTypes.FileTypeFactory extension point in plugin.xml . <extensions defaultExtensionNs= \"com.intellij\" > <fileTypeFactory implementation= \"org.intellij.sdk.language.SimpleFileTypeFactory\" /> </extensions>","title":"2.5.2 Register the FileType Factory"},{"location":"tutorials/custom_language_support/language_and_filetype/#26-run-the-project","text":"Create an empty file with the extension *.simple , and IntelliJ IDEA automatically associates it with our language. Note the appearance of the Simple Language file icon next to the test.simple file in the Project Tool Window , and the editor tab for the file. {:width=\"800px\"}","title":"2.6. Run the Project"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/","text":"The lexical analyzer defines how the contents of a file are broken into tokens, which is the basis for supporting custom language features. The easiest way to create a lexer is to use JFlex . Reference : Implementing Lexer bullet item {:toc} Required Project Configuration Change The previous tutorial step Grammar and Parser , and this page, generate source files in the directory src/main/gen . To include those files, the project's sourceSets must be expanded by inserting the following line in the project's build.gradle file: sourceSets . main . java . srcDirs 'src/main/gen' Or the following line in the project's build.gradle.kts file: sourceSets [ \"main\" ] . java . srcDirs ( \"src/main/gen\" ) 4.1. Define a Lexer Define a Simple.flex file with rules for the Simple Language lexer, as demonstrated in org.intellij.sdk.language.Simple.flex . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / Simple . flex % } 4.2. Generate a Lexer Class Now generate a lexer class via JFlex Generator from the context menu on Simple.flex file. The Grammar-Kit plugin uses the JFlex lexer generation. When running for the first time, JFlex prompts for a destination folder to download the JFlex library and skeleton. Choose the project root directory, for example code_samples/simple_language_plugin . After that, the IDE generates the lexer under the gen directory, for example in simple_language_plugin/src/main/gen/org/intellij/sdk/language/SimpleLexer . TIP Gradle plugin gradle-grammarkit-plugin can be used alternatively. See Implementing Lexer for more information about using JFlex with the Consulo. 4.3. Define a Lexer Adapter The JFlex lexer needs to be adapted to the Consulo Lexer API. This is done by subclassing FlexAdapter . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleLexerAdapter . java % } 4.4. Define a Root File The SimpleFile implementation is the top-level node of the tree of PsiElements for a Simple Language file. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / psi / SimpleFile . java % } 4.5. Define a Parser The Simple Language parser is defined by subclassing ParserDefinition . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleParserDefinition . java % } 4.6. Register the Parser Definition Registering the parser definition in the plugin.xml file makes it available to the Consulo. Use the com.intellij.lang.parserDefinition extension point for registration. For example, see simple_language_plugin/src/main/resources/META-INF/plugin.xml . <extensions defaultExtensionNs= \"com.intellij\" > <lang.parserDefinition language= \"Simple\" implementationClass= \"org.intellij.sdk.language.SimpleParserDefinition\" /> </extensions> 4.7. Run the Project With the simple_language_plugin loaded in a Development Instance, create a test.simple properties file with the following content: # You are reading the \".properties\" entry. ! The exclamation mark can also mark text as comments. website = https://en.wikipedia.org/ language = English # The backslash below tells the application to continue reading # the value onto the next line. message = Welcome to \\ Wikipedia! # Add spaces to the key key\\ with\\ spaces = This is the value that could be looked up with the key \"key with spaces\". # Unicode tab : \\u0009 Now open the PsiViewer tool window and check how the lexer breaks the content of the file into tokens, and the parser parsed the tokens into PSI elements.","title":"4. Lexer and Parser Definition"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/#required-project-configuration-change","text":"The previous tutorial step Grammar and Parser , and this page, generate source files in the directory src/main/gen . To include those files, the project's sourceSets must be expanded by inserting the following line in the project's build.gradle file: sourceSets . main . java . srcDirs 'src/main/gen' Or the following line in the project's build.gradle.kts file: sourceSets [ \"main\" ] . java . srcDirs ( \"src/main/gen\" )","title":"Required Project Configuration Change"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/#41-define-a-lexer","text":"Define a Simple.flex file with rules for the Simple Language lexer, as demonstrated in org.intellij.sdk.language.Simple.flex . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / Simple . flex % }","title":"4.1. Define a Lexer"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/#42-generate-a-lexer-class","text":"Now generate a lexer class via JFlex Generator from the context menu on Simple.flex file. The Grammar-Kit plugin uses the JFlex lexer generation. When running for the first time, JFlex prompts for a destination folder to download the JFlex library and skeleton. Choose the project root directory, for example code_samples/simple_language_plugin . After that, the IDE generates the lexer under the gen directory, for example in simple_language_plugin/src/main/gen/org/intellij/sdk/language/SimpleLexer . TIP Gradle plugin gradle-grammarkit-plugin can be used alternatively. See Implementing Lexer for more information about using JFlex with the Consulo.","title":"4.2. Generate a Lexer Class"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/#43-define-a-lexer-adapter","text":"The JFlex lexer needs to be adapted to the Consulo Lexer API. This is done by subclassing FlexAdapter . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleLexerAdapter . java % }","title":"4.3. Define a Lexer Adapter"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/#44-define-a-root-file","text":"The SimpleFile implementation is the top-level node of the tree of PsiElements for a Simple Language file. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / psi / SimpleFile . java % }","title":"4.4. Define a Root File"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/#45-define-a-parser","text":"The Simple Language parser is defined by subclassing ParserDefinition . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleParserDefinition . java % }","title":"4.5. Define a Parser"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/#46-register-the-parser-definition","text":"Registering the parser definition in the plugin.xml file makes it available to the Consulo. Use the com.intellij.lang.parserDefinition extension point for registration. For example, see simple_language_plugin/src/main/resources/META-INF/plugin.xml . <extensions defaultExtensionNs= \"com.intellij\" > <lang.parserDefinition language= \"Simple\" implementationClass= \"org.intellij.sdk.language.SimpleParserDefinition\" /> </extensions>","title":"4.6. Register the Parser Definition"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/#47-run-the-project","text":"With the simple_language_plugin loaded in a Development Instance, create a test.simple properties file with the following content: # You are reading the \".properties\" entry. ! The exclamation mark can also mark text as comments. website = https://en.wikipedia.org/ language = English # The backslash below tells the application to continue reading # the value onto the next line. message = Welcome to \\ Wikipedia! # Add spaces to the key key\\ with\\ spaces = This is the value that could be looked up with the key \"key with spaces\". # Unicode tab : \\u0009 Now open the PsiViewer tool window and check how the lexer breaks the content of the file into tokens, and the parser parsed the tokens into PSI elements.","title":"4.7. Run the Project"},{"location":"tutorials/custom_language_support/line_marker_provider/","text":"Line markers help annotate code with icons on the gutter. These markers can provide navigation targets to related code. bullet list {:toc} 8.1. Define a Line Marker Provider A line marker provider annotates usages of Simple Language properties within Java code and provides navigation to the definition of these properties. The visual marker is a Simple Language icon in the gutter of the Editor window. The Simple Language marker provider subclasses RelatedItemLineMarkerProvider . For this example, override the collectNavigationMarkers() method to collect usage of a Simple Language key and separators : { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleLineMarkerProvider . java % } 8.2. Best Practices for Implementing Line Marker Providers This section addresses important details about implementing a marker provider. The collectNavigationMarkers() method should: * Only return line marker information consistent with the element passed into the method. For example, do not return a class marker if getLineMarkerInfo() was called with an element that corresponds to a method . * Return line marker information for the appropriate element at the correct scope of the PSI tree. For example, do not return method marker for PsiMethod . Instead, return it for the PsiIdentifier which contains the name of the method. {:width=\"900px\"} What happens when a LineMarkerProvider returns marker information for a PsiElement that is a higher node in the PSI tree? For example, if MyWrongLineMarkerProvider() erroneously returns a PsiMethod instead of a PsiIdentifier element: public class MyWrongLineMarkerProvider implements LineMarkerProvider { public LineMarkerInfo getLineMarkerInfo ( @NotNull PsiElement element ) { if ( element instanceof PsiMethod ) return new LineMarkerInfo ( element , ...); return null ; } } The consequences of the MyWrongLineMarkerProvider() implementation have to do with how the Consulo performs inspections. For performance reasons, inspection, and specifically the LineMarkersPass queries all LineMarkerProviders in two phases: * The first pass is for all elements visible in the Editor window, * The second pass is for the rest of the elements in the file. If providers return nothing for either area, the line markers get cleared. However, if a method like actionPerformed() is not completely visible in the Editor window (as shown in the image above,) and MyWrongLineMarkerProvider() returns marker info for the PsiMethod instead of PsiIdentifier , then: * The first pass removes line marker info because whole PsiMethod isn't visible. * The second pass tries to add a line marker because MyWrongLineMarkerProvider() is called for the PsiMethod . As a result, the line marker icon would blink annoyingly . To fix this problem, rewrite MyWrongLineMarkerProvider to return info for PsiIdentifier instead of PsiMethod as shown below: public class MyCorrectLineMarkerProvider implements LineMarkerProvider { public LineMarkerInfo getLineMarkerInfo ( @NotNull PsiElement element ) { if ( element instanceof PsiIdentifier && element . getParent () instanceof PsiMethod ) return new LineMarkerInfo ( element , ...); return null ; } } 8.3. Register the Line Marker Provider The SimpleLineMarkerProvider implementation is registered with the Consulo in the plugin configuration file using the com.intellij.codeInsight.lineMarkerProvider extension point. <extensions defaultExtensionNs= \"com.intellij\" > <codeInsight.lineMarkerProvider language= \"JAVA\" implementationClass= \"org.intellij.sdk.language.SimpleLineMarkerProvider\" /> </extensions> 8.4. Run the Project Run the simple_language_plugin in a Development Instance and open the Test file . Now the icon appears next to line 3 on the gutter. A user can click on the icon to navigate to the property definition.","title":"8. Line Marker Provider"},{"location":"tutorials/custom_language_support/line_marker_provider/#81-define-a-line-marker-provider","text":"A line marker provider annotates usages of Simple Language properties within Java code and provides navigation to the definition of these properties. The visual marker is a Simple Language icon in the gutter of the Editor window. The Simple Language marker provider subclasses RelatedItemLineMarkerProvider . For this example, override the collectNavigationMarkers() method to collect usage of a Simple Language key and separators : { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleLineMarkerProvider . java % }","title":"8.1. Define a Line Marker Provider"},{"location":"tutorials/custom_language_support/line_marker_provider/#82-best-practices-for-implementing-line-marker-providers","text":"This section addresses important details about implementing a marker provider. The collectNavigationMarkers() method should: * Only return line marker information consistent with the element passed into the method. For example, do not return a class marker if getLineMarkerInfo() was called with an element that corresponds to a method . * Return line marker information for the appropriate element at the correct scope of the PSI tree. For example, do not return method marker for PsiMethod . Instead, return it for the PsiIdentifier which contains the name of the method. {:width=\"900px\"} What happens when a LineMarkerProvider returns marker information for a PsiElement that is a higher node in the PSI tree? For example, if MyWrongLineMarkerProvider() erroneously returns a PsiMethod instead of a PsiIdentifier element: public class MyWrongLineMarkerProvider implements LineMarkerProvider { public LineMarkerInfo getLineMarkerInfo ( @NotNull PsiElement element ) { if ( element instanceof PsiMethod ) return new LineMarkerInfo ( element , ...); return null ; } } The consequences of the MyWrongLineMarkerProvider() implementation have to do with how the Consulo performs inspections. For performance reasons, inspection, and specifically the LineMarkersPass queries all LineMarkerProviders in two phases: * The first pass is for all elements visible in the Editor window, * The second pass is for the rest of the elements in the file. If providers return nothing for either area, the line markers get cleared. However, if a method like actionPerformed() is not completely visible in the Editor window (as shown in the image above,) and MyWrongLineMarkerProvider() returns marker info for the PsiMethod instead of PsiIdentifier , then: * The first pass removes line marker info because whole PsiMethod isn't visible. * The second pass tries to add a line marker because MyWrongLineMarkerProvider() is called for the PsiMethod . As a result, the line marker icon would blink annoyingly . To fix this problem, rewrite MyWrongLineMarkerProvider to return info for PsiIdentifier instead of PsiMethod as shown below: public class MyCorrectLineMarkerProvider implements LineMarkerProvider { public LineMarkerInfo getLineMarkerInfo ( @NotNull PsiElement element ) { if ( element instanceof PsiIdentifier && element . getParent () instanceof PsiMethod ) return new LineMarkerInfo ( element , ...); return null ; } }","title":"8.2. Best Practices for Implementing Line Marker Providers"},{"location":"tutorials/custom_language_support/line_marker_provider/#83-register-the-line-marker-provider","text":"The SimpleLineMarkerProvider implementation is registered with the Consulo in the plugin configuration file using the com.intellij.codeInsight.lineMarkerProvider extension point. <extensions defaultExtensionNs= \"com.intellij\" > <codeInsight.lineMarkerProvider language= \"JAVA\" implementationClass= \"org.intellij.sdk.language.SimpleLineMarkerProvider\" /> </extensions>","title":"8.3. Register the Line Marker Provider"},{"location":"tutorials/custom_language_support/line_marker_provider/#84-run-the-project","text":"Run the simple_language_plugin in a Development Instance and open the Test file . Now the icon appears next to line 3 on the gutter. A user can click on the icon to navigate to the property definition.","title":"8.4. Run the Project"},{"location":"tutorials/custom_language_support/prerequisites/","text":"1.1. Download and Install IntelliJ IDEA Download and install either IntelliJ IDEA Ultimate or IntelliJ IDEA Community Edition from here . 1.2. Check out Community Edition Source Files NOTE While not required, having the full sources of the platform and all bundled plugins available for browsing allows finding related implementations. Download the IntelliJ IDEA Community Edition source files as described in the IntelliJ IDEA Community Edition README file. 1.3. Install Required Plugins Make sure that the bundled Plugin DevKit plugin is enabled. Install and enable Grammar-Kit and PsiViewer plugins. 1.4. Create a Project Create an Consulo Plugin project .","title":"1. Prerequisites"},{"location":"tutorials/custom_language_support/prerequisites/#11-download-and-install-intellij-idea","text":"Download and install either IntelliJ IDEA Ultimate or IntelliJ IDEA Community Edition from here .","title":"1.1. Download and Install IntelliJ IDEA"},{"location":"tutorials/custom_language_support/prerequisites/#12-check-out-community-edition-source-files","text":"NOTE While not required, having the full sources of the platform and all bundled plugins available for browsing allows finding related implementations. Download the IntelliJ IDEA Community Edition source files as described in the IntelliJ IDEA Community Edition README file.","title":"1.2. Check out Community Edition Source Files"},{"location":"tutorials/custom_language_support/prerequisites/#13-install-required-plugins","text":"Make sure that the bundled Plugin DevKit plugin is enabled. Install and enable Grammar-Kit and PsiViewer plugins.","title":"1.3. Install Required Plugins"},{"location":"tutorials/custom_language_support/prerequisites/#14-create-a-project","text":"Create an Consulo Plugin project .","title":"1.4. Create a Project"},{"location":"tutorials/custom_language_support/psi_helper_and_utilities/","text":"Helper classes and utilities can be embedded in the code generated by Grammar-Kit. bullet item {:toc} 6.1. Define Helper Methods for Generated PSI Elements Custom methods in PSI classes are defined separately, and Grammar-Kit embeds them into generated code. Define a utility class with these helper methods: package org.intellij.sdk.language.psi.impl ; import com.intellij.lang.ASTNode ; public class SimplePsiImplUtil { public static String getKey ( SimpleProperty element ) { ASTNode keyNode = element . getNode (). findChildByType ( SimpleTypes . KEY ); if ( keyNode != null ) { // IMPORTANT: Convert embedded escaped spaces to simple spaces return keyNode . getText (). replaceAll ( \"\\\\\\\\ \" , \" \" ); } else { return null ; } } public static String getValue ( SimpleProperty element ) { ASTNode valueNode = element . getNode (). findChildByType ( SimpleTypes . VALUE ); if ( valueNode != null ) { return valueNode . getText (); } else { return null ; } } } The parser generates the SimpleProperty interface referenced in the code above. 6.2. Update Grammar and Regenerate the Parser Now the utility class is added to the grammar file via the psiImplUtilClass attribute. Add methods for a particular rule to specify which one should be used for PSI classes. Compare the last line of the grammar below to the previous definition . { parserClass = \"org.intellij.sdk.language.parser.SimpleParser\" extends = \"com.intellij.extapi.psi.ASTWrapperPsiElement\" psiClassPrefix = \"Simple\" psiImplClassSuffix = \"Impl\" psiPackage = \"org.intellij.sdk.language.psi\" psiImplPackage = \"org.intellij.sdk.language.psi.impl\" elementTypeHolderClass = \"org.intellij.sdk.language.psi.SimpleTypes\" elementTypeClass = \"org.intellij.sdk.language.psi.SimpleElementType\" tokenTypeClass = \"org.intellij.sdk.language.psi.SimpleTokenType\" psiImplUtilClass = \"org.intellij.sdk.language.psi.impl.SimplePsiImplUtil\" } simpleFile :: = item_ * private item_ :: = ( property | COMMENT | CRLF ) property :: = ( KEY ? SEPARATOR VALUE ? ) | KEY { methods =[ getKey getValue ] } After making changes to the grammar, regenerate the parser and PSI classes. 6.3. Define a Utility to Search Properties Create a utility class to search PSI elements for defined properties over the project. This utility will be used later when implementing code completion . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleUtil . java % }","title":"6. PSI Helpers and Utilities"},{"location":"tutorials/custom_language_support/psi_helper_and_utilities/#61-define-helper-methods-for-generated-psi-elements","text":"Custom methods in PSI classes are defined separately, and Grammar-Kit embeds them into generated code. Define a utility class with these helper methods: package org.intellij.sdk.language.psi.impl ; import com.intellij.lang.ASTNode ; public class SimplePsiImplUtil { public static String getKey ( SimpleProperty element ) { ASTNode keyNode = element . getNode (). findChildByType ( SimpleTypes . KEY ); if ( keyNode != null ) { // IMPORTANT: Convert embedded escaped spaces to simple spaces return keyNode . getText (). replaceAll ( \"\\\\\\\\ \" , \" \" ); } else { return null ; } } public static String getValue ( SimpleProperty element ) { ASTNode valueNode = element . getNode (). findChildByType ( SimpleTypes . VALUE ); if ( valueNode != null ) { return valueNode . getText (); } else { return null ; } } } The parser generates the SimpleProperty interface referenced in the code above.","title":"6.1. Define Helper Methods for Generated PSI Elements"},{"location":"tutorials/custom_language_support/psi_helper_and_utilities/#62-update-grammar-and-regenerate-the-parser","text":"Now the utility class is added to the grammar file via the psiImplUtilClass attribute. Add methods for a particular rule to specify which one should be used for PSI classes. Compare the last line of the grammar below to the previous definition . { parserClass = \"org.intellij.sdk.language.parser.SimpleParser\" extends = \"com.intellij.extapi.psi.ASTWrapperPsiElement\" psiClassPrefix = \"Simple\" psiImplClassSuffix = \"Impl\" psiPackage = \"org.intellij.sdk.language.psi\" psiImplPackage = \"org.intellij.sdk.language.psi.impl\" elementTypeHolderClass = \"org.intellij.sdk.language.psi.SimpleTypes\" elementTypeClass = \"org.intellij.sdk.language.psi.SimpleElementType\" tokenTypeClass = \"org.intellij.sdk.language.psi.SimpleTokenType\" psiImplUtilClass = \"org.intellij.sdk.language.psi.impl.SimplePsiImplUtil\" } simpleFile :: = item_ * private item_ :: = ( property | COMMENT | CRLF ) property :: = ( KEY ? SEPARATOR VALUE ? ) | KEY { methods =[ getKey getValue ] } After making changes to the grammar, regenerate the parser and PSI classes.","title":"6.2. Update Grammar and Regenerate the Parser"},{"location":"tutorials/custom_language_support/psi_helper_and_utilities/#63-define-a-utility-to-search-properties","text":"Create a utility class to search PSI elements for defined properties over the project. This utility will be used later when implementing code completion . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleUtil . java % }","title":"6.3. Define a Utility to Search Properties"},{"location":"tutorials/custom_language_support/quick_fix/","text":"A quick fix for a custom language supports the Consulo-based IDE feature Intention Actions . For the Simple Language, this tutorial adds a quick fix that helps to define an unresolved property from its usage. Reference : Code Inspections and Intentions bullet list {:toc} 18.1. Update the Element Factory The SimpleElementFactory is updated to include two new methods to support the user choice of creating a new property for the Simple Language quick fix. The new createCRLF() method supports adding a newline to the end of the test.simple file before adding a new property. A new overload of createProperty() creates a new key - value pair for Simple Language. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / psi / SimpleElementFactory . java % } 18.2. Define an Intention Action The SimpleCreatePropertyQuickFix creates a property in the file chosen by the user - in this case, a Java file containing a prefix:key - and navigate to this property after creation. Under the hood, SimpleCreatePropertyQuickFix is an Intention Action. For a more in-depth example of an Intention Action, see conditional_operator_intention . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleCreatePropertyQuickFix . java % } 18.3. Update the Annotator When a badProperty annotation is created, the badProperty.registerFix() method is called. This method call registers the SimpleCreatePropertyQuickFix as the Intention Action for the Consulo to use to correct the problem. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleAnnotator . java % } 18.4. Run the Project Open the test Java file in an IDE Development Instance running the simple_language_plugin . To test SimpleCreatePropertyQuickFix , change simple:website to simple:website.url . The key website.url is highlighted by SimpleAnnotator as an invalid key, as shown below. Choose \"Create Property\". {:width=\"800px\"} The IDE opens the test.simple file and adds website.url as a new key. Add the new value jetbrains.com for the new website.url key. Now switch back to the Java file; the new key is highlighted as valid.","title":"18. Quick Fix"},{"location":"tutorials/custom_language_support/quick_fix/#181-update-the-element-factory","text":"The SimpleElementFactory is updated to include two new methods to support the user choice of creating a new property for the Simple Language quick fix. The new createCRLF() method supports adding a newline to the end of the test.simple file before adding a new property. A new overload of createProperty() creates a new key - value pair for Simple Language. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / psi / SimpleElementFactory . java % }","title":"18.1. Update the Element Factory"},{"location":"tutorials/custom_language_support/quick_fix/#182-define-an-intention-action","text":"The SimpleCreatePropertyQuickFix creates a property in the file chosen by the user - in this case, a Java file containing a prefix:key - and navigate to this property after creation. Under the hood, SimpleCreatePropertyQuickFix is an Intention Action. For a more in-depth example of an Intention Action, see conditional_operator_intention . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleCreatePropertyQuickFix . java % }","title":"18.2. Define an Intention Action"},{"location":"tutorials/custom_language_support/quick_fix/#183-update-the-annotator","text":"When a badProperty annotation is created, the badProperty.registerFix() method is called. This method call registers the SimpleCreatePropertyQuickFix as the Intention Action for the Consulo to use to correct the problem. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleAnnotator . java % }","title":"18.3. Update the Annotator"},{"location":"tutorials/custom_language_support/quick_fix/#184-run-the-project","text":"Open the test Java file in an IDE Development Instance running the simple_language_plugin . To test SimpleCreatePropertyQuickFix , change simple:website to simple:website.url . The key website.url is highlighted by SimpleAnnotator as an invalid key, as shown below. Choose \"Create Property\". {:width=\"800px\"} The IDE opens the test.simple file and adds website.url as a new key. Add the new value jetbrains.com for the new website.url key. Now switch back to the Java file; the new key is highlighted as valid.","title":"18.4. Run the Project"},{"location":"tutorials/custom_language_support/reference_contributor/","text":"The references functionality is one of the most important parts in the implementation of custom language support. Resolving references means the ability to go from the usage of an element to its declaration, completion, rename refactoring, find usages, etc. NOTE Every PSI element that can be renamed or referenced needs to implement PsiNamedElement interface. Reference : References and Resolve bullet list {:toc} 10.1. Define a Named Element Class The classes below show how the Simple Language fulfills the need to implement PsiNamedElement . The SimpleNamedElement interface is subclassed from PsiNameIdentifierOwner . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / psi / SimpleNamedElement . java % } The SimpleNamedElementImpl class implements the SimpleNamedElement interface and extends ASTWrapperPsiElement . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / psi / impl / SimpleNamedElementImpl . java % } 10.2. Define Helper Methods for Generated PSI Elements Modify SimplePsiImplUtil to support new methods that get added to the PSI class for Simple Language. Note that SimpleElementFactory isn't defined until the next step , so for now it shows as an error. public class SimplePsiImplUtil { // ... public static String getName ( SimpleProperty element ) { return getKey ( element ); } public static PsiElement setName ( SimpleProperty element , String newName ) { ASTNode keyNode = element . getNode (). findChildByType ( SimpleTypes . KEY ); if ( keyNode != null ) { SimpleProperty property = SimpleElementFactory . createProperty ( element . getProject (), newName ); ASTNode newKeyNode = property . getFirstChild (). getNode (); element . getNode (). replaceChild ( keyNode , newKeyNode ); } return element ; } public static PsiElement getNameIdentifier ( SimpleProperty element ) { ASTNode keyNode = element . getNode (). findChildByType ( SimpleTypes . KEY ); if ( keyNode != null ) { return keyNode . getPsi (); } else { return null ; } } // ... } 10.3. Define an Element Factory The SimpleElementFactory provides methods for creating SimpleFile . package org.intellij.sdk.language.psi ; import com.intellij.openapi.project.Project ; import com.intellij.psi.* ; import org.intellij.sdk.language.SimpleFileType ; public class SimpleElementFactory { public static SimpleProperty createProperty ( Project project , String name ) { final SimpleFile file = createFile ( project , name ); return ( SimpleProperty ) file . getFirstChild (); } public static SimpleFile createFile ( Project project , String text ) { String name = \"dummy.simple\" ; return ( SimpleFile ) PsiFileFactory . getInstance ( project ). createFileFromText ( name , SimpleFileType . INSTANCE , text ); } } 10.4. Update Grammar and Regenerate the Parser Now make corresponding changes to the Simple.bnf grammar file by replacing the property definition with the lines below. Don't forget to regenerate the parser after updating the file! Right-click on the Simple.bnf file and select Generate Parser Code . property :: = ( KEY ? SEPARATOR VALUE ? ) | KEY { mixin = \"org.intellij.sdk.language.psi.impl.SimpleNamedElementImpl\" implements = \"org.intellij.sdk.language.psi.SimpleNamedElement\" methods =[ getKey getValue getName setName getNameIdentifier ] } 10.5. Define a Reference Now define a reference class to resolve a property from its usage. This requires extending PsiReferenceBase and implementing PsiPolyVariantReference . The latter enables the reference to resolve to more than one element or to resolve result(s) for a superset of valid resolve cases. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleReference . java % } 10.6. Define a Reference Contributor A reference contributor allows the simple_language_plugin to provide references to Simple Language from elements in other languages such as Java. Create SimpleReferenceContributor by subclassing PsiReferenceContributor . Contribute a reference to each usage of a property: { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleReferenceContributor . java % } 10.7. Register the Reference Contributor The SimpleReferenceContributor implementation is registered with the Consulo using the com.intellij.psi.referenceContributor extension point. <extensions defaultExtensionNs= \"com.intellij\" > <psi.referenceContributor implementation= \"org.intellij.sdk.language.SimpleReferenceContributor\" /> </extensions> 10.8. Run the Project Rebuild the project, and run simple_language_plugin in a Development Instance. The IDE now resolves the property and provides completion suggestions: {:width=\"800px\"} The Rename refactoring functionality is now available from definition and usages. {:width=\"800px\"} 10.9. Define a Refactoring Support Provider Support for in-place refactoring is specified explicitly in a refactoring support provider. Create SimpleRefactoringSupportProvider by subclassing RefactoringSupportProvider As long as an element is a SimpleProperty it is allowed to be refactored: { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleRefactoringSupportProvider . java % } 10.10. Register the Refactoring Support Provider The SimpleRefactoringSupportProvider implementation is registered with the Consulo in the plugin configuration file using the com.intellij.lang.refactoringSupport extension point. <extensions defaultExtensionNs= \"com.intellij\" > <lang.refactoringSupport language= \"Simple\" implementationClass= \"org.intellij.sdk.language.SimpleRefactoringSupportProvider\" /> </extensions> 10.11. Run the Project Rebuild the project, and run simple_language_plugin in a Development Instance. The IDE now supports refactoring suggestions: {:width=\"800px\"}","title":"10. Reference Contributor"},{"location":"tutorials/custom_language_support/reference_contributor/#101-define-a-named-element-class","text":"The classes below show how the Simple Language fulfills the need to implement PsiNamedElement . The SimpleNamedElement interface is subclassed from PsiNameIdentifierOwner . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / psi / SimpleNamedElement . java % } The SimpleNamedElementImpl class implements the SimpleNamedElement interface and extends ASTWrapperPsiElement . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / psi / impl / SimpleNamedElementImpl . java % }","title":"10.1. Define a Named Element Class"},{"location":"tutorials/custom_language_support/reference_contributor/#102-define-helper-methods-for-generated-psi-elements","text":"Modify SimplePsiImplUtil to support new methods that get added to the PSI class for Simple Language. Note that SimpleElementFactory isn't defined until the next step , so for now it shows as an error. public class SimplePsiImplUtil { // ... public static String getName ( SimpleProperty element ) { return getKey ( element ); } public static PsiElement setName ( SimpleProperty element , String newName ) { ASTNode keyNode = element . getNode (). findChildByType ( SimpleTypes . KEY ); if ( keyNode != null ) { SimpleProperty property = SimpleElementFactory . createProperty ( element . getProject (), newName ); ASTNode newKeyNode = property . getFirstChild (). getNode (); element . getNode (). replaceChild ( keyNode , newKeyNode ); } return element ; } public static PsiElement getNameIdentifier ( SimpleProperty element ) { ASTNode keyNode = element . getNode (). findChildByType ( SimpleTypes . KEY ); if ( keyNode != null ) { return keyNode . getPsi (); } else { return null ; } } // ... }","title":"10.2. Define Helper Methods for Generated PSI Elements"},{"location":"tutorials/custom_language_support/reference_contributor/#103-define-an-element-factory","text":"The SimpleElementFactory provides methods for creating SimpleFile . package org.intellij.sdk.language.psi ; import com.intellij.openapi.project.Project ; import com.intellij.psi.* ; import org.intellij.sdk.language.SimpleFileType ; public class SimpleElementFactory { public static SimpleProperty createProperty ( Project project , String name ) { final SimpleFile file = createFile ( project , name ); return ( SimpleProperty ) file . getFirstChild (); } public static SimpleFile createFile ( Project project , String text ) { String name = \"dummy.simple\" ; return ( SimpleFile ) PsiFileFactory . getInstance ( project ). createFileFromText ( name , SimpleFileType . INSTANCE , text ); } }","title":"10.3. Define an Element Factory"},{"location":"tutorials/custom_language_support/reference_contributor/#104-update-grammar-and-regenerate-the-parser","text":"Now make corresponding changes to the Simple.bnf grammar file by replacing the property definition with the lines below. Don't forget to regenerate the parser after updating the file! Right-click on the Simple.bnf file and select Generate Parser Code . property :: = ( KEY ? SEPARATOR VALUE ? ) | KEY { mixin = \"org.intellij.sdk.language.psi.impl.SimpleNamedElementImpl\" implements = \"org.intellij.sdk.language.psi.SimpleNamedElement\" methods =[ getKey getValue getName setName getNameIdentifier ] }","title":"10.4. Update Grammar and Regenerate the Parser"},{"location":"tutorials/custom_language_support/reference_contributor/#105-define-a-reference","text":"Now define a reference class to resolve a property from its usage. This requires extending PsiReferenceBase and implementing PsiPolyVariantReference . The latter enables the reference to resolve to more than one element or to resolve result(s) for a superset of valid resolve cases. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleReference . java % }","title":"10.5. Define a Reference"},{"location":"tutorials/custom_language_support/reference_contributor/#106-define-a-reference-contributor","text":"A reference contributor allows the simple_language_plugin to provide references to Simple Language from elements in other languages such as Java. Create SimpleReferenceContributor by subclassing PsiReferenceContributor . Contribute a reference to each usage of a property: { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleReferenceContributor . java % }","title":"10.6. Define a Reference Contributor"},{"location":"tutorials/custom_language_support/reference_contributor/#107-register-the-reference-contributor","text":"The SimpleReferenceContributor implementation is registered with the Consulo using the com.intellij.psi.referenceContributor extension point. <extensions defaultExtensionNs= \"com.intellij\" > <psi.referenceContributor implementation= \"org.intellij.sdk.language.SimpleReferenceContributor\" /> </extensions>","title":"10.7. Register the Reference Contributor"},{"location":"tutorials/custom_language_support/reference_contributor/#108-run-the-project","text":"Rebuild the project, and run simple_language_plugin in a Development Instance. The IDE now resolves the property and provides completion suggestions: {:width=\"800px\"} The Rename refactoring functionality is now available from definition and usages. {:width=\"800px\"}","title":"10.8. Run the Project"},{"location":"tutorials/custom_language_support/reference_contributor/#109-define-a-refactoring-support-provider","text":"Support for in-place refactoring is specified explicitly in a refactoring support provider. Create SimpleRefactoringSupportProvider by subclassing RefactoringSupportProvider As long as an element is a SimpleProperty it is allowed to be refactored: { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleRefactoringSupportProvider . java % }","title":"10.9. Define a Refactoring Support Provider"},{"location":"tutorials/custom_language_support/reference_contributor/#1010-register-the-refactoring-support-provider","text":"The SimpleRefactoringSupportProvider implementation is registered with the Consulo in the plugin configuration file using the com.intellij.lang.refactoringSupport extension point. <extensions defaultExtensionNs= \"com.intellij\" > <lang.refactoringSupport language= \"Simple\" implementationClass= \"org.intellij.sdk.language.SimpleRefactoringSupportProvider\" /> </extensions>","title":"10.10. Register the Refactoring Support Provider"},{"location":"tutorials/custom_language_support/reference_contributor/#1011-run-the-project","text":"Rebuild the project, and run simple_language_plugin in a Development Instance. The IDE now supports refactoring suggestions: {:width=\"800px\"}","title":"10.11. Run the Project"},{"location":"tutorials/custom_language_support/structure_view_factory/","text":"The structure view can be customized for a specific file type. Creating a structure view factory allows showing the structure of any file in a Structure Tool Window for easy navigation between items in the current editor. Reference : Structure View bullet list {:toc} 14.1. Define a Structure View Factory The structure view factory implements PsiStructureViewFactory . The getStructureViewBuilder() implementation reuses the Consulo class TreeBasedStructureViewBuilder . At this point the project will not compile until SimpleStructureViewModel is implemented below . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleStructureViewFactory . java % } 14.2. Define a Structure View Model The SimpleStructureViewModel is created by implementing StructureViewModel , which defines the model for data displayed in the standard structure view. It also extends StructureViewModelBase , an implementation that links the model to a text editor. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleStructureViewModel . java % } 14.3. Define a Structure View Element The SimpleStructureViewElement implements StructureViewTreeElement and SortableTreeElement . The StructureViewTreeElement represents an element in the Structure View tree model. The SortableTreeElement represents an item in a smart tree that allows using text other than the presentable text as a key for alphabetic sorting. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleStructureViewElement . java % } 14.4. Register the Structure View Factory The SimpleStructureViewFactory implementation is registered with the Consulo in the plugin configuration file using the com.intellij.lang.psiStructureViewFactory extension point. <extensions defaultExtensionNs= \"com.intellij\" > <lang.psiStructureViewFactory language= \"Simple\" implementationClass= \"org.intellij.sdk.language.SimpleStructureViewFactory\" /> </extensions> 14.5. Run the Project Rebuild the project, and run simple_language_plugin in a Development Instance. Open the test.simple file and choose View | Tool Windows | Structure . The IDE now supports a structure view of the Simple Language:","title":"14. Structure View Factory"},{"location":"tutorials/custom_language_support/structure_view_factory/#141-define-a-structure-view-factory","text":"The structure view factory implements PsiStructureViewFactory . The getStructureViewBuilder() implementation reuses the Consulo class TreeBasedStructureViewBuilder . At this point the project will not compile until SimpleStructureViewModel is implemented below . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleStructureViewFactory . java % }","title":"14.1. Define a Structure View Factory"},{"location":"tutorials/custom_language_support/structure_view_factory/#142-define-a-structure-view-model","text":"The SimpleStructureViewModel is created by implementing StructureViewModel , which defines the model for data displayed in the standard structure view. It also extends StructureViewModelBase , an implementation that links the model to a text editor. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleStructureViewModel . java % }","title":"14.2. Define a Structure View Model"},{"location":"tutorials/custom_language_support/structure_view_factory/#143-define-a-structure-view-element","text":"The SimpleStructureViewElement implements StructureViewTreeElement and SortableTreeElement . The StructureViewTreeElement represents an element in the Structure View tree model. The SortableTreeElement represents an item in a smart tree that allows using text other than the presentable text as a key for alphabetic sorting. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleStructureViewElement . java % }","title":"14.3. Define a Structure View Element"},{"location":"tutorials/custom_language_support/structure_view_factory/#144-register-the-structure-view-factory","text":"The SimpleStructureViewFactory implementation is registered with the Consulo in the plugin configuration file using the com.intellij.lang.psiStructureViewFactory extension point. <extensions defaultExtensionNs= \"com.intellij\" > <lang.psiStructureViewFactory language= \"Simple\" implementationClass= \"org.intellij.sdk.language.SimpleStructureViewFactory\" /> </extensions>","title":"14.4. Register the Structure View Factory"},{"location":"tutorials/custom_language_support/structure_view_factory/#145-run-the-project","text":"Rebuild the project, and run simple_language_plugin in a Development Instance. Open the test.simple file and choose View | Tool Windows | Structure . The IDE now supports a structure view of the Simple Language:","title":"14.5. Run the Project"},{"location":"tutorials/custom_language_support/syntax_highlighter_and_color_settings_page/","text":"The first level of syntax highlighting is based on the lexer output, and is provided by SyntaxHighlighter . A plugin can also define color settings based on ColorSettingPage so the user can configure highlight colors. The SimpleSyntaxHighlighter , SimpleSyntaxHighlighterFactory , and SimpleColorSettingsPage discussed on this page are demonstrated in the simple_language_plugin code sample. Reference : Syntax Highlighting and Error Highlighting bullet list {:toc} 5.1. Define a Syntax Highlighter The Simple Language syntax highlighter class extends SyntaxHighlighterBase . As recommended in Color Scheme Management , the Simple Language highlighting text attributes are specified as a dependency on one of standard Consulo keys. For the Simple Language, define only one scheme. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleSyntaxHighlighter . java % } 5.2. Define a Syntax Highlighter Factory The factory provides a standard way for the Consulo to instantiate the syntax highlighter for Simple Language files. Here, SimpleSyntaxHighlighterFactory subclasses SyntaxHighlighterFactory . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleSyntaxHighlighterFactory . java % } 5.3. Register the Syntax Highlighter Factory Register the factory with the Consulo in the plugin configuration file using the com.intellij.lang.syntaxHighlighterFactory extension point. <extensions defaultExtensionNs= \"com.intellij\" > <lang.syntaxHighlighterFactory language= \"Simple\" implementationClass= \"org.intellij.sdk.language.SimpleSyntaxHighlighterFactory\" /> </extensions> 5.4. Run the Project Open the example Simple Language properties file ( test.simple ) in the IDE Development Instance. The colors for Simple Language Key, Separator, and Value highlighting default to the IDE Language Defaults for Keyword, Braces, Operators, and Strings, respectively. 5.5. Define a Color Settings Page The color settings page adds the ability for users to customize color settings for the highlighting in Simple Language files. The SimpleColorSettingsPage implements ColorSettingsPage . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleColorSettingsPage . java % } 5.6. Register the Color Settings Page Register the Simple Language color settings page with the Consulo in the plugin configuration file using the com.intellij.colorSettingsPage extension point. <extensions defaultExtensionNs= \"com.intellij\" > <colorSettingsPage implementation= \"org.intellij.sdk.language.SimpleColorSettingsPage\" /> </extensions> 5.7. Run the Project In the IDE Development Instance, open the Simple Language highlight settings page: Preferences/Settings | Editor | Color Scheme | Simple . Each color initially inherits from a Language Defaults value.","title":"5. Syntax Highlighter and Color Settings Page"},{"location":"tutorials/custom_language_support/syntax_highlighter_and_color_settings_page/#51-define-a-syntax-highlighter","text":"The Simple Language syntax highlighter class extends SyntaxHighlighterBase . As recommended in Color Scheme Management , the Simple Language highlighting text attributes are specified as a dependency on one of standard Consulo keys. For the Simple Language, define only one scheme. { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleSyntaxHighlighter . java % }","title":"5.1. Define a Syntax Highlighter"},{"location":"tutorials/custom_language_support/syntax_highlighter_and_color_settings_page/#52-define-a-syntax-highlighter-factory","text":"The factory provides a standard way for the Consulo to instantiate the syntax highlighter for Simple Language files. Here, SimpleSyntaxHighlighterFactory subclasses SyntaxHighlighterFactory . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleSyntaxHighlighterFactory . java % }","title":"5.2. Define a Syntax Highlighter Factory"},{"location":"tutorials/custom_language_support/syntax_highlighter_and_color_settings_page/#53-register-the-syntax-highlighter-factory","text":"Register the factory with the Consulo in the plugin configuration file using the com.intellij.lang.syntaxHighlighterFactory extension point. <extensions defaultExtensionNs= \"com.intellij\" > <lang.syntaxHighlighterFactory language= \"Simple\" implementationClass= \"org.intellij.sdk.language.SimpleSyntaxHighlighterFactory\" /> </extensions>","title":"5.3. Register the Syntax Highlighter Factory"},{"location":"tutorials/custom_language_support/syntax_highlighter_and_color_settings_page/#54-run-the-project","text":"Open the example Simple Language properties file ( test.simple ) in the IDE Development Instance. The colors for Simple Language Key, Separator, and Value highlighting default to the IDE Language Defaults for Keyword, Braces, Operators, and Strings, respectively.","title":"5.4. Run the Project"},{"location":"tutorials/custom_language_support/syntax_highlighter_and_color_settings_page/#55-define-a-color-settings-page","text":"The color settings page adds the ability for users to customize color settings for the highlighting in Simple Language files. The SimpleColorSettingsPage implements ColorSettingsPage . { % include / code_samples / simple_language_plugin / src / main / java / org / intellij / sdk / language / SimpleColorSettingsPage . java % }","title":"5.5. Define a Color Settings Page"},{"location":"tutorials/custom_language_support/syntax_highlighter_and_color_settings_page/#56-register-the-color-settings-page","text":"Register the Simple Language color settings page with the Consulo in the plugin configuration file using the com.intellij.colorSettingsPage extension point. <extensions defaultExtensionNs= \"com.intellij\" > <colorSettingsPage implementation= \"org.intellij.sdk.language.SimpleColorSettingsPage\" /> </extensions>","title":"5.6. Register the Color Settings Page"},{"location":"tutorials/custom_language_support/syntax_highlighter_and_color_settings_page/#57-run-the-project","text":"In the IDE Development Instance, open the Simple Language highlight settings page: Preferences/Settings | Editor | Color Scheme | Simple . Each color initially inherits from a Language Defaults value.","title":"5.7. Run the Project"},{"location":"tutorials/editor_basics/coordinates_system/","text":"The previous tutorial Working with Text demonstrated how to use actions to access a caret placed in a document open in an editor. The examples replaced selected text in a document by using information about the caret. Every caret has a set of properties describing its position in one of several coordinate systems. This tutorial describes how to access information about the caret(s) in an editor. The tutorial presents the following sections: bullet list {:toc} Introduction In this tutorial, the editor_basics code sample is used to explore caret positions. In particular, the Caret Position action added by editor_basics to the editor context menu is used to retrieve information about the current caret position. A keyboard shortcut can also initiate the action. {:width=\"600px\"} The source code for the Java class behind the menu action is EditorAreaIllustration . The focus of discussion will be the EditorAreaIllustration.actionPerformed() method. For more information about creating action classes, see the Actions Tutorial which covers the topic in depth. Caret Positions from the CaretModel and Caret Objects The properties of a caret can be accessed by obtaining an instance of the CaretModel object. As in the Working with Text tutorial, the AnActionEvent is used to get the Editor object. The Editor object provides access to the CaretModel object, as shown below: public class EditorAreaIllustration extends AnAction { @Override public void actionPerformed ( @NotNull final AnActionEvent e ) { // Get access to the editor and caret model. update() validated editor's existence. final Editor editor = e . getRequiredData ( CommonDataKeys . EDITOR ); final CaretModel caretModel = editor . getCaretModel (); } } Editor Coordinate Systems When a Document is opened, the Editor assigns an internal, zero-based coordinate system to lines and columns in the Document . The first line in a Document and the first character in each line are assigned the zero position. Every character in a Document is assigned an Offset , which is a zero-based count of the characters from the beginning of the file to that character. These LogicalPosition coordinates are used to describe the line and column number for a caret position. Note that the Logical Position coordinate system is different from the editor UI, which is one-based rather than zero-based. Logical Position coordinates and other coordinate systems discussed in this tutorial can be used to characterize any location in an Editor , not just carets. Hints used for code insights are characterized in terms of these coordinates, for example HintManager.getHintPosition() . Custom visual elements displayed in an Editor , called Inlay objects, are also expressed in terms of these coordinate systems. The diagram below shows the Logical Position coordinate system applied to some example content. The character \"s\" in the red box represents placing the cursor on that character. It has the caret position of line 1, column 9, and Offset 28. More about caret Offsets is discussed below. {:width=\"800px\"} The Multiple Carets documentation covers the subject of more than one caret in an Editor. For this tutorial, be aware there may be more than one caret in an Editor at any given time. Consequently, examples use the Primary Caret in an Editor . If there is only one caret in an Editor , it is the Primary Caret. For the case of multiple carets in an Editor , the Primary Caret is the one on which query and update methods in the model operate at the moment. Caret Logical Position The caret Logical Position is a zero-based, (line and column) position of the caret in the Editor. Logical Position information is obtained from the LogicalPosition object for that caret. The Logical Position line number of a caret ignores the effects of settings that change the presentation of a Document within the Editor. Examples of these settings are Code (Line) Folding and Soft Line Wrap . These effects mean regardless of whether one or more lines in an Editor are folded or soft-wrapped, the caret Logical Position line number will not change. In the example Java file below, Logical Position line numbers 1-3 are folded into line 0. The caret - a blue block - is placed on the letter \"p\" in \"public.\" Using the editor_basics Caret Position action to inspect the caret, it is reported to be at Logical Position (5,0) - which is line 5, character 0 - the first character in the line. This means that caret Logical Position is not changed by Code Folding: {:width=\"800px\"} However, note that applying Code Folding does change the reported Visual Position of the caret even if the Logical Position stays constant. More about Visual Position is discussed below. However, it's clear combinations of Code Folding and Soft Wrap means that one Logical Position of a caret could map to multiple Visual Positions. The Editor interface provides methods to work with a caret Logical and Visual Position, such as the method Editor.logicalToVisualPosition() . Caret Visual Position A caret's Visual Position differs from Logical Position in that it takes into account editor presentation settings such as Code Folding and Soft Line Wrap. In doing so, VisualPosition counts - zero-based - the lines of a Document that can be displayed in an Editor. Consequently, Visual Positions can't be uniquely mapped to Logical Positions or corresponding lines in the underlying Document . For example, Soft Line Wrap affects the Visual Position of succeeding lines. In the image below, Soft Line Wrap is applied to Logical line three. With the caret placed at the same character location as in previous tests, it is evident the Logical Position has not changed. However, the Visual Position line number has increased by one! The comments on each line illustrate how the Soft Wrap portion of Logical line three is evaluated as Visual Position line four, as though it was a separate line. {:width=\"800px\"} The Logical and Visual Position objects for a caret are obtained from the Caret object, as shown in the code snippet below. public class EditorAreaIllustration extends AnAction { @Override public void actionPerformed ( @NotNull final AnActionEvent e ) { // Get access to the editor and caret model. final Editor editor = e . getRequiredData ( CommonDataKeys . EDITOR ); final CaretModel caretModel = editor . getCaretModel (); final Caret primaryCaret = caretModel . getPrimaryCaret (); LogicalPosition logicalPos = primaryCaret . getLogicalPosition (); VisualPosition visualPos = primaryCaret . getVisualPosition (); } } Caret Column Position The Column Position is a count of characters from the beginning of a Logical (Position) line to the current caret position in that line. Characters are counted using a zero-based numbering system, so the first character of a line is numbered zero. Note that Column Position is different from the editor UI, which uses a one-based numbering scheme. Column Position includes: * Whitespace, such as tabs. Tabs can occupy multiple columns, up to the tab size set for the editor. * The character selected by the caret. Caret Lean The Column Position of a caret is the boundary between two characters. A caret can be associated with either a preceding or succeeding character. The association is important in bidirectional text, where mapping from Logical Column Position to Visual Column Position is not continuous. As defined in the LogicalPosition class, if a caret position is associated with a succeeding character it Leans Forward . Otherwise, it is associated with the preceding character. As defined in the VisualPosition class, if a caret position is associated with a succeeding character it Leans Right . Otherwise, it is associated with the preceding character. Examples of Caret Lean In the example below, placing a (blue) block caret on the first visible character in Logical line three produces a column position of 0 for both Visual and Logical Positions. Note that the text is unidirectional in this example. In the Logical Position the caret leans forward, meaning it is associated with the succeeding character in the Logical line. For the Visual Position the caret leans right, indicating its association with the succeeding character in the Visual line. {:width=\"800px\"} Consider the Java snippet below, and use the editor_basics Caret Position action to report caret information at each step. Be sure to use the keyboard shortcut to invoke the action so that the caret position is not disturbed. The line containing the String variable declaration contains bidirectional text. Starting on the left end of the line, and using the arrow key to advance a line-shaped cursor to between the (\" characters reveals discontinuities in caret coordinate column positions. * After the caret first moves from between g( to between (\" , the Logical and Visual Positions have equal column positions of 28, and neither leans. Note the value of the caret positions you measure may have different starting values because of line indentation, but the sign and magnitude of the changes in position will be the same. * Advancing the caret once more does not appear to visually move the cursor. However, the Logical Position column increases to 61, and although the Visual Position column does not change, it leans right. * Continuing to advance the cursor (to the right) through the string causes the Logical Position column to decrease , and the Visual Position column to increase . * Once the cursor advances to between the \". characters, the Logical Position column position is again 28, and leans forward. The Visual Position column position is now 61. * Moving the caret right once more does not appear to visually advance the cursor. However, the Logical Position and Visual Position column values are both 61, and both lean. * As the cursor advances to the right, both Logical and Visual column values increase. public void showNow () { //234567890123456789012345678901234567890123456789012345678901234567890 String str = new String ( \"\u062a\u0639\u0637\u064a \u064a\u0648\u0646\u064a\u0643\u0648\u062f \u0631\u0642\u0645\u0627 \u0641\u0631\u064a\u062f\u0627 \u0644\u0643\u0644 \u062d\u0631\u0641\" . getBytes (), java . nio . charset . StandardCharsets . UTF_8 ); System . out . println ( str ); } The apparent discontinuity in Logical Position is because the RTL portion of the string is treated (or counted) in the logical character order in which it would be written. The apparent continuity in Visual Position is because the RTL portion of the string is counted in the visual order in which it is displayed in the code. Caret Offset The Offset of a caret is a character count from the beginning of a Document to the caret position. Caret offsets are always calculated in terms of Logical Position. The caret Offset includes: * The first (0th) character in a document. * Whitespace characters, including newline and tabs. * Any characters after end-of-line if the IDE settings permit them. ( Preferences | Editor | General | Virtual Space ) * The character selected by the caret. The example below demonstrates the Offset of a caret placed at the first character of Logical line one. Note the Offset is 22, which is one greater than the number of visible characters on line zero, and the first character on line one. This apparent discrepancy is actually correct because the Offset includes the newline character for line zero. {:width=\"800px\"} Displaying Caret Positions To display the values of caret Logical and Visual positions, and Offset, a Messages.showInfoMessage() method shows them in the form of notification as the action is performed. public class EditorAreaIllustration extends AnAction { public void actionPerformed ( @NotNull final AnActionEvent e ) { // Get access to the editor and caret model. final Editor editor = e . getRequiredData ( CommonDataKeys . EDITOR ); final CaretModel caretModel = editor . getCaretModel (); // Getting the primary caret ensures we get the correct one of a possible many. final Caret primaryCaret = caretModel . getPrimaryCaret (); // Get the caret information LogicalPosition logicalPos = primaryCaret . getLogicalPosition (); VisualPosition visualPos = primaryCaret . getVisualPosition (); int caretOffset = primaryCaret . getOffset (); // Build and display the caret report. String report = logicalPos . toString () + \"\\n\" + visualPos . toString () + \"\\n\" + \"Offset: \" + caretOffset ; Messages . showInfoMessage ( report . toString (), \"Caret Parameters Inside The Editor\" ); } }","title":"2. Editor Coordinates System. Positions and Offsets"},{"location":"tutorials/editor_basics/coordinates_system/#introduction","text":"In this tutorial, the editor_basics code sample is used to explore caret positions. In particular, the Caret Position action added by editor_basics to the editor context menu is used to retrieve information about the current caret position. A keyboard shortcut can also initiate the action. {:width=\"600px\"} The source code for the Java class behind the menu action is EditorAreaIllustration . The focus of discussion will be the EditorAreaIllustration.actionPerformed() method. For more information about creating action classes, see the Actions Tutorial which covers the topic in depth.","title":"Introduction"},{"location":"tutorials/editor_basics/coordinates_system/#caret-positions-from-the-caretmodel-and-caret-objects","text":"The properties of a caret can be accessed by obtaining an instance of the CaretModel object. As in the Working with Text tutorial, the AnActionEvent is used to get the Editor object. The Editor object provides access to the CaretModel object, as shown below: public class EditorAreaIllustration extends AnAction { @Override public void actionPerformed ( @NotNull final AnActionEvent e ) { // Get access to the editor and caret model. update() validated editor's existence. final Editor editor = e . getRequiredData ( CommonDataKeys . EDITOR ); final CaretModel caretModel = editor . getCaretModel (); } }","title":"Caret Positions from the CaretModel and Caret Objects"},{"location":"tutorials/editor_basics/coordinates_system/#editor-coordinate-systems","text":"When a Document is opened, the Editor assigns an internal, zero-based coordinate system to lines and columns in the Document . The first line in a Document and the first character in each line are assigned the zero position. Every character in a Document is assigned an Offset , which is a zero-based count of the characters from the beginning of the file to that character. These LogicalPosition coordinates are used to describe the line and column number for a caret position. Note that the Logical Position coordinate system is different from the editor UI, which is one-based rather than zero-based. Logical Position coordinates and other coordinate systems discussed in this tutorial can be used to characterize any location in an Editor , not just carets. Hints used for code insights are characterized in terms of these coordinates, for example HintManager.getHintPosition() . Custom visual elements displayed in an Editor , called Inlay objects, are also expressed in terms of these coordinate systems. The diagram below shows the Logical Position coordinate system applied to some example content. The character \"s\" in the red box represents placing the cursor on that character. It has the caret position of line 1, column 9, and Offset 28. More about caret Offsets is discussed below. {:width=\"800px\"} The Multiple Carets documentation covers the subject of more than one caret in an Editor. For this tutorial, be aware there may be more than one caret in an Editor at any given time. Consequently, examples use the Primary Caret in an Editor . If there is only one caret in an Editor , it is the Primary Caret. For the case of multiple carets in an Editor , the Primary Caret is the one on which query and update methods in the model operate at the moment.","title":"Editor Coordinate Systems"},{"location":"tutorials/editor_basics/coordinates_system/#caret-logical-position","text":"The caret Logical Position is a zero-based, (line and column) position of the caret in the Editor. Logical Position information is obtained from the LogicalPosition object for that caret. The Logical Position line number of a caret ignores the effects of settings that change the presentation of a Document within the Editor. Examples of these settings are Code (Line) Folding and Soft Line Wrap . These effects mean regardless of whether one or more lines in an Editor are folded or soft-wrapped, the caret Logical Position line number will not change. In the example Java file below, Logical Position line numbers 1-3 are folded into line 0. The caret - a blue block - is placed on the letter \"p\" in \"public.\" Using the editor_basics Caret Position action to inspect the caret, it is reported to be at Logical Position (5,0) - which is line 5, character 0 - the first character in the line. This means that caret Logical Position is not changed by Code Folding: {:width=\"800px\"} However, note that applying Code Folding does change the reported Visual Position of the caret even if the Logical Position stays constant. More about Visual Position is discussed below. However, it's clear combinations of Code Folding and Soft Wrap means that one Logical Position of a caret could map to multiple Visual Positions. The Editor interface provides methods to work with a caret Logical and Visual Position, such as the method Editor.logicalToVisualPosition() .","title":"Caret Logical Position"},{"location":"tutorials/editor_basics/coordinates_system/#caret-visual-position","text":"A caret's Visual Position differs from Logical Position in that it takes into account editor presentation settings such as Code Folding and Soft Line Wrap. In doing so, VisualPosition counts - zero-based - the lines of a Document that can be displayed in an Editor. Consequently, Visual Positions can't be uniquely mapped to Logical Positions or corresponding lines in the underlying Document . For example, Soft Line Wrap affects the Visual Position of succeeding lines. In the image below, Soft Line Wrap is applied to Logical line three. With the caret placed at the same character location as in previous tests, it is evident the Logical Position has not changed. However, the Visual Position line number has increased by one! The comments on each line illustrate how the Soft Wrap portion of Logical line three is evaluated as Visual Position line four, as though it was a separate line. {:width=\"800px\"} The Logical and Visual Position objects for a caret are obtained from the Caret object, as shown in the code snippet below. public class EditorAreaIllustration extends AnAction { @Override public void actionPerformed ( @NotNull final AnActionEvent e ) { // Get access to the editor and caret model. final Editor editor = e . getRequiredData ( CommonDataKeys . EDITOR ); final CaretModel caretModel = editor . getCaretModel (); final Caret primaryCaret = caretModel . getPrimaryCaret (); LogicalPosition logicalPos = primaryCaret . getLogicalPosition (); VisualPosition visualPos = primaryCaret . getVisualPosition (); } }","title":"Caret Visual Position"},{"location":"tutorials/editor_basics/coordinates_system/#caret-column-position","text":"The Column Position is a count of characters from the beginning of a Logical (Position) line to the current caret position in that line. Characters are counted using a zero-based numbering system, so the first character of a line is numbered zero. Note that Column Position is different from the editor UI, which uses a one-based numbering scheme. Column Position includes: * Whitespace, such as tabs. Tabs can occupy multiple columns, up to the tab size set for the editor. * The character selected by the caret.","title":"Caret Column Position"},{"location":"tutorials/editor_basics/coordinates_system/#caret-lean","text":"The Column Position of a caret is the boundary between two characters. A caret can be associated with either a preceding or succeeding character. The association is important in bidirectional text, where mapping from Logical Column Position to Visual Column Position is not continuous. As defined in the LogicalPosition class, if a caret position is associated with a succeeding character it Leans Forward . Otherwise, it is associated with the preceding character. As defined in the VisualPosition class, if a caret position is associated with a succeeding character it Leans Right . Otherwise, it is associated with the preceding character.","title":"Caret Lean"},{"location":"tutorials/editor_basics/coordinates_system/#examples-of-caret-lean","text":"In the example below, placing a (blue) block caret on the first visible character in Logical line three produces a column position of 0 for both Visual and Logical Positions. Note that the text is unidirectional in this example. In the Logical Position the caret leans forward, meaning it is associated with the succeeding character in the Logical line. For the Visual Position the caret leans right, indicating its association with the succeeding character in the Visual line. {:width=\"800px\"} Consider the Java snippet below, and use the editor_basics Caret Position action to report caret information at each step. Be sure to use the keyboard shortcut to invoke the action so that the caret position is not disturbed. The line containing the String variable declaration contains bidirectional text. Starting on the left end of the line, and using the arrow key to advance a line-shaped cursor to between the (\" characters reveals discontinuities in caret coordinate column positions. * After the caret first moves from between g( to between (\" , the Logical and Visual Positions have equal column positions of 28, and neither leans. Note the value of the caret positions you measure may have different starting values because of line indentation, but the sign and magnitude of the changes in position will be the same. * Advancing the caret once more does not appear to visually move the cursor. However, the Logical Position column increases to 61, and although the Visual Position column does not change, it leans right. * Continuing to advance the cursor (to the right) through the string causes the Logical Position column to decrease , and the Visual Position column to increase . * Once the cursor advances to between the \". characters, the Logical Position column position is again 28, and leans forward. The Visual Position column position is now 61. * Moving the caret right once more does not appear to visually advance the cursor. However, the Logical Position and Visual Position column values are both 61, and both lean. * As the cursor advances to the right, both Logical and Visual column values increase. public void showNow () { //234567890123456789012345678901234567890123456789012345678901234567890 String str = new String ( \"\u062a\u0639\u0637\u064a \u064a\u0648\u0646\u064a\u0643\u0648\u062f \u0631\u0642\u0645\u0627 \u0641\u0631\u064a\u062f\u0627 \u0644\u0643\u0644 \u062d\u0631\u0641\" . getBytes (), java . nio . charset . StandardCharsets . UTF_8 ); System . out . println ( str ); } The apparent discontinuity in Logical Position is because the RTL portion of the string is treated (or counted) in the logical character order in which it would be written. The apparent continuity in Visual Position is because the RTL portion of the string is counted in the visual order in which it is displayed in the code.","title":"Examples of Caret Lean"},{"location":"tutorials/editor_basics/coordinates_system/#caret-offset","text":"The Offset of a caret is a character count from the beginning of a Document to the caret position. Caret offsets are always calculated in terms of Logical Position. The caret Offset includes: * The first (0th) character in a document. * Whitespace characters, including newline and tabs. * Any characters after end-of-line if the IDE settings permit them. ( Preferences | Editor | General | Virtual Space ) * The character selected by the caret. The example below demonstrates the Offset of a caret placed at the first character of Logical line one. Note the Offset is 22, which is one greater than the number of visible characters on line zero, and the first character on line one. This apparent discrepancy is actually correct because the Offset includes the newline character for line zero. {:width=\"800px\"}","title":"Caret Offset"},{"location":"tutorials/editor_basics/coordinates_system/#displaying-caret-positions","text":"To display the values of caret Logical and Visual positions, and Offset, a Messages.showInfoMessage() method shows them in the form of notification as the action is performed. public class EditorAreaIllustration extends AnAction { public void actionPerformed ( @NotNull final AnActionEvent e ) { // Get access to the editor and caret model. final Editor editor = e . getRequiredData ( CommonDataKeys . EDITOR ); final CaretModel caretModel = editor . getCaretModel (); // Getting the primary caret ensures we get the correct one of a possible many. final Caret primaryCaret = caretModel . getPrimaryCaret (); // Get the caret information LogicalPosition logicalPos = primaryCaret . getLogicalPosition (); VisualPosition visualPos = primaryCaret . getVisualPosition (); int caretOffset = primaryCaret . getOffset (); // Build and display the caret report. String report = logicalPos . toString () + \"\\n\" + visualPos . toString () + \"\\n\" + \"Offset: \" + caretOffset ; Messages . showInfoMessage ( report . toString (), \"Caret Parameters Inside The Editor\" ); } }","title":"Displaying Caret Positions"},{"location":"tutorials/editor_basics/editor_events/","text":"The previous tutorial Editor Coordinate Systems described working with caret coordinate systems in an editor window. Caret position was discussed in terms of Logical Position, Visual Position, and Offset. This tutorial introduces the Editor Action system, which handles actions activated by keystroke events in the editor. Two classes from the editor_basics code sample are used to illustrate: * Using an Consulo EditorActionHandler to manipulate a caret. * Creating and registering a custom TypedActionHandler to intercept keystrokes and change the document. The tutorial presents the following sections: bullet list {:toc} Using an Consulo EditorActionHandler In this portion of the tutorial, the editor_basics code sample is used to demonstrate cloning an existing caret. A custom action class will use EditorActionManager to access a specific EditorActionHandler for caret cloning. The editor_basics code sample adds an Editor Add Caret menu item to the editor context menu: {:width=\"600px\"} Creating the Menu Action Class The source code for the Java action class is EditorHandlerIllustration , a subclass of AnAction . For more information about creating action classes, see the Actions Tutorial which covers the topic in depth. The EditorHandlerIllustration action is registered in the editor_basic plugin.xml file. Note that this action class is registered to appear on the Editor context menu. <actions> <action id= \"EditorBasics.EditorHandlerIllustration\" class= \"org.intellij.sdk.editor.EditorHandlerIllustration\" text= \"Editor Add Caret\" description= \"Adds a second caret below the existing one.\" icon= \"SdkIcons.Sdk_default_icon\" > <add-to-group group-id= \"EditorPopupMenu\" anchor= \"first\" /> </action> </action> Setting Visibility for the Action Menu Entry Under what conditions should the EditorHandlerIllustration action be capable of cloning a caret? Only if the following conditions are met in the EditorHandlerIllustration.update() method: * A project is open, * An editor is available, * There is at least one caret active in the editor. After ensuring that Project and Editor objects are available, the Editor object is used to verify there is at least one caret: public class EditorHandlerIllustration extends AnAction { @Override public void update ( @NotNull final AnActionEvent e ) { final Project project = e . getProject (); final Editor editor = e . getData ( CommonDataKeys . EDITOR ); // Make sure at least one caret is available boolean menuAllowed = false ; if ( editor != null && project != null ) { // Ensure the list of carets in the editor is not empty menuAllowed = ! editor . getCaretModel (). getAllCarets (). isEmpty (); } e . getPresentation (). setEnabledAndVisible ( menuAllowed ); } } Acquiring the Correct EditorActionHandler When the EditorHandlerIllustration.actionPerformed() method clones the caret, it should use the appropriate Consulo EditorActionHandler . An instance of EditorActionManager is required to obtain the correct EditorActionHandler . The EditorActionManager class provides a static method to do this. To request the correct EditorActionHandler from EditorActionManager , consult the IdeActions interface for the correct constant to pass into the EditorActionManager.getActionHandler() method. For cloning a caret below the primary caret, the constant is ACTION_EDITOR_CLONE_CARET_BELOW . Based on that constant, the EditorActionManager returns an instance of CloneCaretActionHandler , a subclass of EditorActionHandler . // Snippet from EditorHandlerIllustration.actionPerformed() final EditorActionManager actionManager = EditorActionManager . getInstance (); final EditorActionHandler actionHandler = actionManager . getActionHandler ( IdeActions . ACTION_EDITOR_CLONE_CARET_BELOW ); Using an EditorActionHandler to Clone the Caret To clone the caret requires only calling the EditorActionHandler.execute() method and passing in the appropriate context. public class EditorHandlerIllustration extends AnAction { @Override public void actionPerformed ( @NotNull final AnActionEvent e ) { final Editor editor = e . getRequiredData ( CommonDataKeys . EDITOR ); final EditorActionManager actionManager = EditorActionManager . getInstance (); final EditorActionHandler actionHandler = actionManager . getActionHandler ( IdeActions . ACTION_EDITOR_CLONE_CARET_BELOW ); actionHandler . execute ( editor , editor . getCaretModel (). getPrimaryCaret (), e . getDataContext ()); } } Creating a Custom TypedActionHandler The TypedActionHandler interface is the basis for classes that handle keystroke events from the editor. Custom implementations of the class are registered to handle editor keystroke events, and receive a callback for each keystroke. The steps below explain how to use TypedActionHandler to customize the behavior of the editor when keystroke events are received. Implementing a Custom TypedActionHandler Class First, a subclass such as MyTypedHandler is created based on TypedActionHandler . The class overrides the method TypedActionHandler.execute() , which is the callback for editor keystroke events. Implementing the Keystroke Event Handling Logic Override the TypedActionHandler.execute() method in MyTypedHandler to implement the logic for handling keystroke events. This method is called every time a key is pressed when the Editor Tool Window has focus. In the following example, the MyTypedHandler.execute() method inserts \"editor_basics\\n\" at the zero caret Offset position when a keystroke event occurs. As explained in Working with Text , safe modifications to the document must be in the context of a write action. So although a method on the Document interface does the String insertion, the write action ensures a stable context. class MyTypedHandler implements TypedActionHandler { @Override public void execute ( @NotNull Editor editor , char c , @NotNull DataContext dataContext ) { final Document document = editor . getDocument (); final Project project = editor . getProject (); Runnable runnable = () -> document . insertString ( 0 , \"editor_basics\\n\" ); WriteCommandAction . runWriteCommandAction ( project , runnable ); } } Registering a Custom TypedActionHandler A custom implementation of TypedActionHandler must be registered to replace the existing typing handler to receive editor keystroke events. The registration is done through the TypedAction class. As is shown in the snippet below, the EditorActionManager is used to get access to the TypedAction class. The method TypedAction.setupHandler() is used to register the custom MyTypedHandler class: public class EditorHandlerIllustration extends AnAction { static { final EditorActionManager actionManager = EditorActionManager . getInstance (); final TypedAction typedAction = actionManager . getTypedAction (); typedAction . setupHandler ( new MyTypedHandler ()); } } Placing the registration code in the EditorHandlerIllustration class is somewhat arbitrary in the sense that the registration of MyTypedHandler has nothing to do with the EditorHandlerIllustration class. However, the EditorHandlerIllustration class is convenient because as an action it gets instantiated at application startup. On instantiation, the static block of code in EditorHandlerIllustration gets evaluated. In the editor_basics code sample any of the AnAction derived classes would work for registering MyTypedHandler .","title":"3. Handling Editor Events"},{"location":"tutorials/editor_basics/editor_events/#using-an-consulo-editoractionhandler","text":"In this portion of the tutorial, the editor_basics code sample is used to demonstrate cloning an existing caret. A custom action class will use EditorActionManager to access a specific EditorActionHandler for caret cloning. The editor_basics code sample adds an Editor Add Caret menu item to the editor context menu: {:width=\"600px\"}","title":"Using an Consulo EditorActionHandler"},{"location":"tutorials/editor_basics/editor_events/#creating-the-menu-action-class","text":"The source code for the Java action class is EditorHandlerIllustration , a subclass of AnAction . For more information about creating action classes, see the Actions Tutorial which covers the topic in depth. The EditorHandlerIllustration action is registered in the editor_basic plugin.xml file. Note that this action class is registered to appear on the Editor context menu. <actions> <action id= \"EditorBasics.EditorHandlerIllustration\" class= \"org.intellij.sdk.editor.EditorHandlerIllustration\" text= \"Editor Add Caret\" description= \"Adds a second caret below the existing one.\" icon= \"SdkIcons.Sdk_default_icon\" > <add-to-group group-id= \"EditorPopupMenu\" anchor= \"first\" /> </action> </action>","title":"Creating the Menu Action Class"},{"location":"tutorials/editor_basics/editor_events/#setting-visibility-for-the-action-menu-entry","text":"Under what conditions should the EditorHandlerIllustration action be capable of cloning a caret? Only if the following conditions are met in the EditorHandlerIllustration.update() method: * A project is open, * An editor is available, * There is at least one caret active in the editor. After ensuring that Project and Editor objects are available, the Editor object is used to verify there is at least one caret: public class EditorHandlerIllustration extends AnAction { @Override public void update ( @NotNull final AnActionEvent e ) { final Project project = e . getProject (); final Editor editor = e . getData ( CommonDataKeys . EDITOR ); // Make sure at least one caret is available boolean menuAllowed = false ; if ( editor != null && project != null ) { // Ensure the list of carets in the editor is not empty menuAllowed = ! editor . getCaretModel (). getAllCarets (). isEmpty (); } e . getPresentation (). setEnabledAndVisible ( menuAllowed ); } }","title":"Setting Visibility for the Action Menu Entry"},{"location":"tutorials/editor_basics/editor_events/#acquiring-the-correct-editoractionhandler","text":"When the EditorHandlerIllustration.actionPerformed() method clones the caret, it should use the appropriate Consulo EditorActionHandler . An instance of EditorActionManager is required to obtain the correct EditorActionHandler . The EditorActionManager class provides a static method to do this. To request the correct EditorActionHandler from EditorActionManager , consult the IdeActions interface for the correct constant to pass into the EditorActionManager.getActionHandler() method. For cloning a caret below the primary caret, the constant is ACTION_EDITOR_CLONE_CARET_BELOW . Based on that constant, the EditorActionManager returns an instance of CloneCaretActionHandler , a subclass of EditorActionHandler . // Snippet from EditorHandlerIllustration.actionPerformed() final EditorActionManager actionManager = EditorActionManager . getInstance (); final EditorActionHandler actionHandler = actionManager . getActionHandler ( IdeActions . ACTION_EDITOR_CLONE_CARET_BELOW );","title":"Acquiring the Correct EditorActionHandler"},{"location":"tutorials/editor_basics/editor_events/#using-an-editoractionhandler-to-clone-the-caret","text":"To clone the caret requires only calling the EditorActionHandler.execute() method and passing in the appropriate context. public class EditorHandlerIllustration extends AnAction { @Override public void actionPerformed ( @NotNull final AnActionEvent e ) { final Editor editor = e . getRequiredData ( CommonDataKeys . EDITOR ); final EditorActionManager actionManager = EditorActionManager . getInstance (); final EditorActionHandler actionHandler = actionManager . getActionHandler ( IdeActions . ACTION_EDITOR_CLONE_CARET_BELOW ); actionHandler . execute ( editor , editor . getCaretModel (). getPrimaryCaret (), e . getDataContext ()); } }","title":"Using an EditorActionHandler to Clone the Caret"},{"location":"tutorials/editor_basics/editor_events/#creating-a-custom-typedactionhandler","text":"The TypedActionHandler interface is the basis for classes that handle keystroke events from the editor. Custom implementations of the class are registered to handle editor keystroke events, and receive a callback for each keystroke. The steps below explain how to use TypedActionHandler to customize the behavior of the editor when keystroke events are received.","title":"Creating a Custom TypedActionHandler"},{"location":"tutorials/editor_basics/editor_events/#implementing-a-custom-typedactionhandler-class","text":"First, a subclass such as MyTypedHandler is created based on TypedActionHandler . The class overrides the method TypedActionHandler.execute() , which is the callback for editor keystroke events.","title":"Implementing a Custom TypedActionHandler Class"},{"location":"tutorials/editor_basics/editor_events/#implementing-the-keystroke-event-handling-logic","text":"Override the TypedActionHandler.execute() method in MyTypedHandler to implement the logic for handling keystroke events. This method is called every time a key is pressed when the Editor Tool Window has focus. In the following example, the MyTypedHandler.execute() method inserts \"editor_basics\\n\" at the zero caret Offset position when a keystroke event occurs. As explained in Working with Text , safe modifications to the document must be in the context of a write action. So although a method on the Document interface does the String insertion, the write action ensures a stable context. class MyTypedHandler implements TypedActionHandler { @Override public void execute ( @NotNull Editor editor , char c , @NotNull DataContext dataContext ) { final Document document = editor . getDocument (); final Project project = editor . getProject (); Runnable runnable = () -> document . insertString ( 0 , \"editor_basics\\n\" ); WriteCommandAction . runWriteCommandAction ( project , runnable ); } }","title":"Implementing the Keystroke Event Handling Logic"},{"location":"tutorials/editor_basics/editor_events/#registering-a-custom-typedactionhandler","text":"A custom implementation of TypedActionHandler must be registered to replace the existing typing handler to receive editor keystroke events. The registration is done through the TypedAction class. As is shown in the snippet below, the EditorActionManager is used to get access to the TypedAction class. The method TypedAction.setupHandler() is used to register the custom MyTypedHandler class: public class EditorHandlerIllustration extends AnAction { static { final EditorActionManager actionManager = EditorActionManager . getInstance (); final TypedAction typedAction = actionManager . getTypedAction (); typedAction . setupHandler ( new MyTypedHandler ()); } } Placing the registration code in the EditorHandlerIllustration class is somewhat arbitrary in the sense that the registration of MyTypedHandler has nothing to do with the EditorHandlerIllustration class. However, the EditorHandlerIllustration class is convenient because as an action it gets instantiated at application startup. On instantiation, the static block of code in EditorHandlerIllustration gets evaluated. In the editor_basics code sample any of the AnAction derived classes would work for registering MyTypedHandler .","title":"Registering a Custom TypedActionHandler"},{"location":"tutorials/editor_basics/working_with_text/","text":"This tutorial shows how to use actions to access a caret placed in a document open in an editor. Using information about the caret, replace selected text in a document with a string. The tutorial presents the following sections: bullet list {:toc} Introduction The approach in this tutorial relies heavily on creating and registering actions. To review the fundamentals of creating and registering actions, refer to the Actions Tutorial . Multiple examples are used from the editor_basics plugin code sample from the Consulo SDK. It may be helpful to open that project in an Consulo-based IDE, build the project, run it, select some text in the editor, and invoke the Editor Replace Text menu item on the editor context menu. {:width=\"600px\"} Creating a New Menu Action In this example, we access the Editor from an action. The source code for the Java class in this example is EditorIllustrationAction . To register the action, we must add the corresponding elements to the <actions> section of the plugin configuration file plugin.xml . For more information, refer to the Registering Actions section of the Actions Tutorial. The EditorIllustrationAction action is registered in the group EditorPopupMenu so it will be available from the context menu when focus is on the editor: <action id= \"EditorBasics.EditorIllustrationAction\" class= \"org.intellij.sdk.editor.EditorIllustrationAction\" text= \"Editor Replace Text\" description= \"Replaces selected text with 'Replacement'.\" icon= \"SdkIcons.Sdk_default_icon\" > <add-to-group group-id= \"EditorPopupMenu\" anchor= \"first\" /> </action> Defining the Menu Action's Visibility To determine conditions by which the action will be visible and available requires EditorIllustrationAction to override the AnAction.update() method. For more information, refer to Extending the Update Method section of the Actions Tutorial. To work with a selected part of the text, it's reasonable to make the menu action available only when the following requirements are met: * There is a Project object, * There is an instance of Editor available, * There is a text selection in Editor . Additional steps will show how to check these conditions through obtaining instances of Project and Editor objects, and how to show or hide the action's menu items based on them. Getting an Instance of the Active Editor from an Action Event Using the AnActionEvent event passed into the update method, a reference to an instance of the Editor can be obtained by calling getData(CommonDataKeys.EDITOR) . Similarly, to obtain a project reference, we use the getProject() method. public class EditorIllustrationAction extends AnAction { @Override public void update ( @NotNull final AnActionEvent e ) { // Get required data keys final Project project = e . getProject (); final Editor editor = e . getData ( CommonDataKeys . EDITOR ); } } Note: There are other ways to access an Editor instance: * If a DataContext object is available: CommonDataKeys.EDITOR.getData(context); * If only a Project object is available, use FileEditorManager.getInstance(project).getSelectedTextEditor() Obtaining a Caret Model and Selection After making sure a project is open, and an instance of the Editor is obtained, we need to check if any selection is available. The SelectionModel interface is accessed from the Editor object. Determining whether some text is selected is accomplished by calling the SelectionModel.hasSelection() method. Here's how the EditorIllustrationAction.update(AnActionEvent e) method should look: public class EditorIllustrationAction extends AnAction { @Override public void update ( @NotNull final AnActionEvent e ) { // Get required data keys final Project project = e . getProject (); final Editor editor = e . getData ( CommonDataKeys . EDITOR ); // Set visibility only in case of existing project and editor and if a selection exists e . getPresentation (). setEnabledAndVisible ( project != null && editor != null && editor . getSelectionModel (). hasSelection () ); } } Note: Editor also allows access to different models of text representation. The model classes are located in editor , and include: * CaretModel , * FoldingModel , * IndentsModel , * ScrollingModel , * SoftWrapModel Safely Replacing Selected Text in the Document Based on the evaluation of conditions by EditorIllustrationAction.update() , the EditorIllustrationAction action menu item is visible. To make the menu item do something, the EditorIllustrationAction class must override the AnAction.actionPerformed() method. As explained below, this will require the EditorIllustrationAction.actionPerformed() method to: * Gain access to the document. * Get the character locations defining the selection. * Safely replace the contents of the selection. Modifying the selected text requires an instance of the Document object, which is accessed from the Editor object. The Document represents the contents of a text file loaded into memory and opened in an Consulo-based IDE editor. An instance of the Document will be used later when a text replacement is performed. The text replacement will also require information about where the selection is in the document, which is provided by the primary Caret object, obtained from the CaretModel . Selection information is measured in terms of Offset , the count of characters from the beginning of the document to a caret location. Text replacement could be done by calling the Document object's replaceString() method. However, safely replacing the text requires the Document to be locked and any changes performed in a write action. See the Threading Issues section to learn more about synchronization issues and changes safety on the Consulo. This example changes the document within a WriteCommandAction . The complete EditorIllustrationAction.actionPerformed() method is shown below: * Note the selection in the document is replaced by a string using a method on the Document object, but the method call is wrapped in a write action. * After the document change, the new text is de-selected by a call to the primary caret. public class EditorIllustrationAction extends AnAction { @Override public void actionPerformed ( @NotNull final AnActionEvent e ) { // Get all the required data from data keys final Editor editor = e . getRequiredData ( CommonDataKeys . EDITOR ); final Project project = e . getRequiredData ( CommonDataKeys . PROJECT ); final Document document = editor . getDocument (); // Work off of the primary caret to get the selection info Caret primaryCaret = editor . getCaretModel (). getPrimaryCaret (); int start = primaryCaret . getSelectionStart (); int end = primaryCaret . getSelectionEnd (); // Replace the selection with a fixed string. // Must do this document change in a write action context. WriteCommandAction . runWriteCommandAction ( project , () -> document . replaceString ( start , end , \"editor_basics\" ) ); // De-select the text range that was just replaced primaryCaret . removeSelection (); } }","title":"1. Working with Text"},{"location":"tutorials/editor_basics/working_with_text/#introduction","text":"The approach in this tutorial relies heavily on creating and registering actions. To review the fundamentals of creating and registering actions, refer to the Actions Tutorial . Multiple examples are used from the editor_basics plugin code sample from the Consulo SDK. It may be helpful to open that project in an Consulo-based IDE, build the project, run it, select some text in the editor, and invoke the Editor Replace Text menu item on the editor context menu. {:width=\"600px\"}","title":"Introduction"},{"location":"tutorials/editor_basics/working_with_text/#creating-a-new-menu-action","text":"In this example, we access the Editor from an action. The source code for the Java class in this example is EditorIllustrationAction . To register the action, we must add the corresponding elements to the <actions> section of the plugin configuration file plugin.xml . For more information, refer to the Registering Actions section of the Actions Tutorial. The EditorIllustrationAction action is registered in the group EditorPopupMenu so it will be available from the context menu when focus is on the editor: <action id= \"EditorBasics.EditorIllustrationAction\" class= \"org.intellij.sdk.editor.EditorIllustrationAction\" text= \"Editor Replace Text\" description= \"Replaces selected text with 'Replacement'.\" icon= \"SdkIcons.Sdk_default_icon\" > <add-to-group group-id= \"EditorPopupMenu\" anchor= \"first\" /> </action>","title":"Creating a New Menu Action"},{"location":"tutorials/editor_basics/working_with_text/#defining-the-menu-actions-visibility","text":"To determine conditions by which the action will be visible and available requires EditorIllustrationAction to override the AnAction.update() method. For more information, refer to Extending the Update Method section of the Actions Tutorial. To work with a selected part of the text, it's reasonable to make the menu action available only when the following requirements are met: * There is a Project object, * There is an instance of Editor available, * There is a text selection in Editor . Additional steps will show how to check these conditions through obtaining instances of Project and Editor objects, and how to show or hide the action's menu items based on them.","title":"Defining the Menu Action's Visibility"},{"location":"tutorials/editor_basics/working_with_text/#getting-an-instance-of-the-active-editor-from-an-action-event","text":"Using the AnActionEvent event passed into the update method, a reference to an instance of the Editor can be obtained by calling getData(CommonDataKeys.EDITOR) . Similarly, to obtain a project reference, we use the getProject() method. public class EditorIllustrationAction extends AnAction { @Override public void update ( @NotNull final AnActionEvent e ) { // Get required data keys final Project project = e . getProject (); final Editor editor = e . getData ( CommonDataKeys . EDITOR ); } } Note: There are other ways to access an Editor instance: * If a DataContext object is available: CommonDataKeys.EDITOR.getData(context); * If only a Project object is available, use FileEditorManager.getInstance(project).getSelectedTextEditor()","title":"Getting an Instance of the Active Editor from an Action Event"},{"location":"tutorials/editor_basics/working_with_text/#obtaining-a-caret-model-and-selection","text":"After making sure a project is open, and an instance of the Editor is obtained, we need to check if any selection is available. The SelectionModel interface is accessed from the Editor object. Determining whether some text is selected is accomplished by calling the SelectionModel.hasSelection() method. Here's how the EditorIllustrationAction.update(AnActionEvent e) method should look: public class EditorIllustrationAction extends AnAction { @Override public void update ( @NotNull final AnActionEvent e ) { // Get required data keys final Project project = e . getProject (); final Editor editor = e . getData ( CommonDataKeys . EDITOR ); // Set visibility only in case of existing project and editor and if a selection exists e . getPresentation (). setEnabledAndVisible ( project != null && editor != null && editor . getSelectionModel (). hasSelection () ); } } Note: Editor also allows access to different models of text representation. The model classes are located in editor , and include: * CaretModel , * FoldingModel , * IndentsModel , * ScrollingModel , * SoftWrapModel","title":"Obtaining a Caret Model and Selection"},{"location":"tutorials/editor_basics/working_with_text/#safely-replacing-selected-text-in-the-document","text":"Based on the evaluation of conditions by EditorIllustrationAction.update() , the EditorIllustrationAction action menu item is visible. To make the menu item do something, the EditorIllustrationAction class must override the AnAction.actionPerformed() method. As explained below, this will require the EditorIllustrationAction.actionPerformed() method to: * Gain access to the document. * Get the character locations defining the selection. * Safely replace the contents of the selection. Modifying the selected text requires an instance of the Document object, which is accessed from the Editor object. The Document represents the contents of a text file loaded into memory and opened in an Consulo-based IDE editor. An instance of the Document will be used later when a text replacement is performed. The text replacement will also require information about where the selection is in the document, which is provided by the primary Caret object, obtained from the CaretModel . Selection information is measured in terms of Offset , the count of characters from the beginning of the document to a caret location. Text replacement could be done by calling the Document object's replaceString() method. However, safely replacing the text requires the Document to be locked and any changes performed in a write action. See the Threading Issues section to learn more about synchronization issues and changes safety on the Consulo. This example changes the document within a WriteCommandAction . The complete EditorIllustrationAction.actionPerformed() method is shown below: * Note the selection in the document is replaced by a string using a method on the Document object, but the method call is wrapped in a write action. * After the document change, the new text is de-selected by a call to the primary caret. public class EditorIllustrationAction extends AnAction { @Override public void actionPerformed ( @NotNull final AnActionEvent e ) { // Get all the required data from data keys final Editor editor = e . getRequiredData ( CommonDataKeys . EDITOR ); final Project project = e . getRequiredData ( CommonDataKeys . PROJECT ); final Document document = editor . getDocument (); // Work off of the primary caret to get the selection info Caret primaryCaret = editor . getCaretModel (). getPrimaryCaret (); int start = primaryCaret . getSelectionStart (); int end = primaryCaret . getSelectionEnd (); // Replace the selection with a fixed string. // Must do this document change in a write action context. WriteCommandAction . runWriteCommandAction ( project , () -> document . replaceString ( start , end , \"editor_basics\" ) ); // De-select the text range that was just replaced primaryCaret . removeSelection (); } }","title":"Safely Replacing Selected Text in the Document"},{"location":"tutorials/live_templates/new_macros/","text":"The Predefined Functions are the building blocks for creating Parameterized Templates and Surround Templates . However, sometimes the Predefined Functions are not enough. This tutorial illustrates how to add custom functions to an Consulo plugin and make them available for use by Live Templates. As an example, a function is created to convert a selection to Title Case. Refer to the SDK code sample live_templates . bullet {:toc} Implementing a New Function Under the hood, the predefined functions for Live Templates are called macros . A new custom function for Live Templates is implemented in TitleCaseMacro , which extends MacroBase . Three TitleCaseMacro methods are of particular interest: * The TitleCaseMacro() constructor passes the name and description of the macro to the parent constructor. * The isAcceptableInContext() method tests whether the macro is available in the current context. The test relies on the MarkdownContext object previously defined in the live_templates plugin. * The calculateResult() method gets invoked when the titleCase function is used in a Live Template. The text to be capitalized is retrieved from the Live Template and converted to Title Case. { % include / code_samples / live_templates / src / main / java / org / intellij / sdk / liveTemplates / TitleCaseMacro . java % } Adding a Live Template Using the procedures previously discussed for Template Creation and Export the Live Template , add a Live Template to the Markdown.xml file for the plugin. The XML representation of an example Live Template using the new titleCase function is listed below. There is only one variable, TITLE . The expression for TITLE evaluates to the titleCase function provided by the plugin. The argument to the titleCase function is SELECTION , which tells the Consulo to operate on the current selection. <template name= \"mc\" value= \"$TITLE$\" description= \"SDK: Convert to title case\" toReformat= \"true\" toShortenFQNames= \"false\" > <variable name= \"TITLE\" expression= \"titleCase(SELECTION)\" defaultValue= \"the quick brown fox\" alwaysStopAt= \"true\" /> <context> <option name= \"MARKDOWN\" value= \"true\" /> </context> </template> Register Extension Point Using the com.intellij.liveTemplateMacro extension point, register the implementation with the Consulo. <extensions defaultExtensionNs= \"com.intellij\" > <liveTemplateMacro implementation= \"org.intellij.sdk.liveTemplates.TitleCaseMacro\" /> </extensions> Check Plugin Now verify the plugin is working correctly. * Run the plugin in a Development Instance. * Create a new file testing.md and enter several words in lower case. * Highlight the text and enter \u2325\u2318J to open the Select Template popup. Confirm that the SDK: Convert to title case is available in the popup, and select it. {:width=\"700px\"} Test that the Live Template works by entering m or return . The text will change to have each word capitalized: {:width=\"700px\"}","title":"Creating New Functions for Live Templates"},{"location":"tutorials/live_templates/new_macros/#implementing-a-new-function","text":"Under the hood, the predefined functions for Live Templates are called macros . A new custom function for Live Templates is implemented in TitleCaseMacro , which extends MacroBase . Three TitleCaseMacro methods are of particular interest: * The TitleCaseMacro() constructor passes the name and description of the macro to the parent constructor. * The isAcceptableInContext() method tests whether the macro is available in the current context. The test relies on the MarkdownContext object previously defined in the live_templates plugin. * The calculateResult() method gets invoked when the titleCase function is used in a Live Template. The text to be capitalized is retrieved from the Live Template and converted to Title Case. { % include / code_samples / live_templates / src / main / java / org / intellij / sdk / liveTemplates / TitleCaseMacro . java % }","title":"Implementing a New Function"},{"location":"tutorials/live_templates/new_macros/#adding-a-live-template","text":"Using the procedures previously discussed for Template Creation and Export the Live Template , add a Live Template to the Markdown.xml file for the plugin. The XML representation of an example Live Template using the new titleCase function is listed below. There is only one variable, TITLE . The expression for TITLE evaluates to the titleCase function provided by the plugin. The argument to the titleCase function is SELECTION , which tells the Consulo to operate on the current selection. <template name= \"mc\" value= \"$TITLE$\" description= \"SDK: Convert to title case\" toReformat= \"true\" toShortenFQNames= \"false\" > <variable name= \"TITLE\" expression= \"titleCase(SELECTION)\" defaultValue= \"the quick brown fox\" alwaysStopAt= \"true\" /> <context> <option name= \"MARKDOWN\" value= \"true\" /> </context> </template>","title":"Adding a Live Template"},{"location":"tutorials/live_templates/new_macros/#register-extension-point","text":"Using the com.intellij.liveTemplateMacro extension point, register the implementation with the Consulo. <extensions defaultExtensionNs= \"com.intellij\" > <liveTemplateMacro implementation= \"org.intellij.sdk.liveTemplates.TitleCaseMacro\" /> </extensions>","title":"Register Extension Point"},{"location":"tutorials/live_templates/new_macros/#check-plugin","text":"Now verify the plugin is working correctly. * Run the plugin in a Development Instance. * Create a new file testing.md and enter several words in lower case. * Highlight the text and enter \u2325\u2318J to open the Select Template popup. Confirm that the SDK: Convert to title case is available in the popup, and select it. {:width=\"700px\"} Test that the Live Template works by entering m or return . The text will change to have each word capitalized: {:width=\"700px\"}","title":"Check Plugin"},{"location":"tutorials/live_templates/template_support/","text":"This tutorial illustrates how to add default Custom Live Templates to an Consulo plugin, and assign valid contexts for these templates based on the surrounding code and file type. In addition, the tutorial discusses how to export existing Live Templates, and bundle them within a plugin. Any Live Template that can be created and exported can be added to a plugin by following the Template Creation, Export, and Extension Point Registration processes. This tutorial uses the SDK code sample live_templates . bullet {:toc} Template Creation Get started by creating a new Live Template within the Consulo-based IDE: * Add a new Template Group, \"Markdown\" and create a new Live Template under this group. * Assign the template the abbreviation \" { \". * Assign the description \" SDK: New link reference \". * Paste the following snippet into the Template text field: [$TEXT$]($LINK$)$END$ The variables $TEXT$ and $LINK$ may be further configured in the Edit variables dialogue to reorder their precedence and bind to functions that invoke auto-completion at the appropriate time. In the Edit variables dialog, set the Expression for the LINK to complete() using the combobox. There are many other predefined functions that developers should become familiar with before implementing any unique functionality in a plugin. TIP Consider iteratively testing the Live Template using the current editor and a markdown file to minimize debugging later. Export the Live Template Once the Live Template produces the expected result, export the Live Template . The export produces a file called Markdown.xml with the following contents: <templateSet group= \"Markdown\" > <template name= \"{\" value= \"[$TEXT$]($LINK$)$END$\" description= \"SDK: New link reference\" toReformat= \"false\" toShortenFQNames= \"false\" > <variable name= \"TEXT\" expression= \"\" defaultValue= \"\" alwaysStopAt= \"true\" /> <variable name= \"LINK\" expression= \"complete()\" defaultValue= \"\" alwaysStopAt= \"true\" /> </template> </templateSet> The display name can also provide localized variants by specifying key and resource-bundle attributes additionally (2020.3 and later). Copy this file into the plugin's resources folder . Implement TemplateContextType A TemplateContextType tells the Consulo where the Live Template is applicable: Markdown files. Every context must have a unique TemplateContextType defined for it, and many context types are defined by the Platform. The MarkdownContext class defines it for Markdown files. Ultimately, a file's extension determines the applicable Markdown context. { % include / code_samples / live_templates / src / main / java / org / intellij / sdk / liveTemplates / MarkdownContext . java % } NOTE Once the MarkdownContext is defined, be sure to add the new context type to the previously created Live Template settings file. Within the <template>...</template> elements in the Markdown.xml Live Template definition file , add the following context elements: <variable.../> <context> <option name= \"MARKDOWN\" value= \"true\" /> </context> </template> It is not always necessary to define your own TemplateContextType , as there are many existing template contexts already defined in the Consulo. Consider reusing one of the many existing template context types that inherit from TemplateContextType if you are augmenting language support to an existing area. Completing the Live Template Implementation Depending on the version of the Consulo, different steps are used to complete the implementation of the feature. Versions 2020.1 and Later For 2020.1 and later, follow this section to register the extension points and then proceed to the Check Plugin section. Register Extension Points Using the com.intellij.defaultLiveTemplates and com.intellij.liveTemplateContext extension points, register the implementations with the Consulo. The file attribute in the defaultLiveTemplates element specifies path/filename under the src/main/resources folder. <extensions defaultExtensionNs= \"com.intellij\" > <defaultLiveTemplates file= \"/liveTemplates/Markdown.xml\" /> <liveTemplateContext implementation= \"org.intellij.sdk.liveTemplates.MarkdownContext\" /> </extensions> Now go to the Check Plugin section to test the template. Versions 2019.3 and Earlier For older versions of the Consulo follow this section to complete the implementation and register the extension points. Then proceed to the Check Plugin section. Implement DefaultLiveTemplatesProvider The MarkdownTemplateProvider tells the Platform where to find the Live Template settings file. Make sure to include the full path to the file, relative to the src/main/resources directory, excluding the file extension. package org.intellij.sdk.liveTemplates ; import com.intellij.codeInsight.template.impl.DefaultLiveTemplatesProvider ; import org.jetbrains.annotations.Nullable ; public class MarkdownTemplateProvider implements DefaultLiveTemplatesProvider { @Override public String [] getDefaultLiveTemplateFiles () { return new String [] { \"liveTemplates/Markdown\" }; } @Nullable @Override public String [] getHiddenLiveTemplateFiles () { return null ; } } Register Extension Points Using the com.intellij.defaultLiveTemplatesProvider and com.intellij.liveTemplateContext extension points, register the implementations with the Consulo. <extensions defaultExtensionNs= \"com.intellij\" > <defaultLiveTemplatesProvider implementation= \"org.intellij.sdk.liveTemplates.MarkdownTemplateProvider\" /> <liveTemplateContext implementation= \"org.intellij.sdk.liveTemplates.MarkdownContext\" /> </extensions> Check Plugin Now verify the plugin is working correctly. Run the plugin in a Development Instance and verify there is a new entry under Settings/Preferenes | Live Templates | Markdown | { (SDK: New link reference) . Finally, create a new file test.md and confirm that the Live Template works by entering a { character and then pressing Tab .","title":"Adding Live Templates to a Plugin"},{"location":"tutorials/live_templates/template_support/#template-creation","text":"Get started by creating a new Live Template within the Consulo-based IDE: * Add a new Template Group, \"Markdown\" and create a new Live Template under this group. * Assign the template the abbreviation \" { \". * Assign the description \" SDK: New link reference \". * Paste the following snippet into the Template text field: [$TEXT$]($LINK$)$END$ The variables $TEXT$ and $LINK$ may be further configured in the Edit variables dialogue to reorder their precedence and bind to functions that invoke auto-completion at the appropriate time. In the Edit variables dialog, set the Expression for the LINK to complete() using the combobox. There are many other predefined functions that developers should become familiar with before implementing any unique functionality in a plugin. TIP Consider iteratively testing the Live Template using the current editor and a markdown file to minimize debugging later.","title":"Template Creation"},{"location":"tutorials/live_templates/template_support/#export-the-live-template","text":"Once the Live Template produces the expected result, export the Live Template . The export produces a file called Markdown.xml with the following contents: <templateSet group= \"Markdown\" > <template name= \"{\" value= \"[$TEXT$]($LINK$)$END$\" description= \"SDK: New link reference\" toReformat= \"false\" toShortenFQNames= \"false\" > <variable name= \"TEXT\" expression= \"\" defaultValue= \"\" alwaysStopAt= \"true\" /> <variable name= \"LINK\" expression= \"complete()\" defaultValue= \"\" alwaysStopAt= \"true\" /> </template> </templateSet> The display name can also provide localized variants by specifying key and resource-bundle attributes additionally (2020.3 and later). Copy this file into the plugin's resources folder .","title":"Export the Live Template"},{"location":"tutorials/live_templates/template_support/#implement-templatecontexttype","text":"A TemplateContextType tells the Consulo where the Live Template is applicable: Markdown files. Every context must have a unique TemplateContextType defined for it, and many context types are defined by the Platform. The MarkdownContext class defines it for Markdown files. Ultimately, a file's extension determines the applicable Markdown context. { % include / code_samples / live_templates / src / main / java / org / intellij / sdk / liveTemplates / MarkdownContext . java % } NOTE Once the MarkdownContext is defined, be sure to add the new context type to the previously created Live Template settings file. Within the <template>...</template> elements in the Markdown.xml Live Template definition file , add the following context elements: <variable.../> <context> <option name= \"MARKDOWN\" value= \"true\" /> </context> </template> It is not always necessary to define your own TemplateContextType , as there are many existing template contexts already defined in the Consulo. Consider reusing one of the many existing template context types that inherit from TemplateContextType if you are augmenting language support to an existing area.","title":"Implement TemplateContextType"},{"location":"tutorials/live_templates/template_support/#completing-the-live-template-implementation","text":"Depending on the version of the Consulo, different steps are used to complete the implementation of the feature.","title":"Completing the Live Template Implementation"},{"location":"tutorials/live_templates/template_support/#versions-20201-and-later","text":"For 2020.1 and later, follow this section to register the extension points and then proceed to the Check Plugin section.","title":"Versions 2020.1 and Later"},{"location":"tutorials/live_templates/template_support/#register-extension-points","text":"Using the com.intellij.defaultLiveTemplates and com.intellij.liveTemplateContext extension points, register the implementations with the Consulo. The file attribute in the defaultLiveTemplates element specifies path/filename under the src/main/resources folder. <extensions defaultExtensionNs= \"com.intellij\" > <defaultLiveTemplates file= \"/liveTemplates/Markdown.xml\" /> <liveTemplateContext implementation= \"org.intellij.sdk.liveTemplates.MarkdownContext\" /> </extensions> Now go to the Check Plugin section to test the template.","title":"Register Extension Points"},{"location":"tutorials/live_templates/template_support/#versions-20193-and-earlier","text":"For older versions of the Consulo follow this section to complete the implementation and register the extension points. Then proceed to the Check Plugin section.","title":"Versions 2019.3 and Earlier"},{"location":"tutorials/live_templates/template_support/#implement-defaultlivetemplatesprovider","text":"The MarkdownTemplateProvider tells the Platform where to find the Live Template settings file. Make sure to include the full path to the file, relative to the src/main/resources directory, excluding the file extension. package org.intellij.sdk.liveTemplates ; import com.intellij.codeInsight.template.impl.DefaultLiveTemplatesProvider ; import org.jetbrains.annotations.Nullable ; public class MarkdownTemplateProvider implements DefaultLiveTemplatesProvider { @Override public String [] getDefaultLiveTemplateFiles () { return new String [] { \"liveTemplates/Markdown\" }; } @Nullable @Override public String [] getHiddenLiveTemplateFiles () { return null ; } }","title":"Implement DefaultLiveTemplatesProvider"},{"location":"tutorials/live_templates/template_support/#register-extension-points_1","text":"Using the com.intellij.defaultLiveTemplatesProvider and com.intellij.liveTemplateContext extension points, register the implementations with the Consulo. <extensions defaultExtensionNs= \"com.intellij\" > <defaultLiveTemplatesProvider implementation= \"org.intellij.sdk.liveTemplates.MarkdownTemplateProvider\" /> <liveTemplateContext implementation= \"org.intellij.sdk.liveTemplates.MarkdownContext\" /> </extensions>","title":"Register Extension Points"},{"location":"tutorials/live_templates/template_support/#check-plugin","text":"Now verify the plugin is working correctly. Run the plugin in a Development Instance and verify there is a new entry under Settings/Preferenes | Live Templates | Markdown | { (SDK: New link reference) . Finally, create a new file test.md and confirm that the Live Template works by entering a { character and then pressing Tab .","title":"Check Plugin"},{"location":"user_interface_components/dialog_wrapper/","text":"DialogWrapper The DialogWrapper is the base class which is supposed to be used for all modal dialogs (and some non-modal dialogs) shown in Consulo . It provides the following features: Button layout (platform-specific order of OK / Cancel buttons, macOS-specific Help button) Context help Remembering the size of the dialog Non-modal validation (displaying an error message text when the data entered into the dialog is not valid) Keyboard shortcuts: Esc for closing the dialog Left/Right for switching between buttons Y / N for Yes / No actions if they exist in the dialog Optional Do not ask again checkbox When using the DialogWrapper class for a dialog, follow these steps: Call the base class constructor and provide either a project in the frame of which the dialog will be displayed, or a parent component for the dialog. Call the init() method from the constructor of the dialog class Call the setTitle() method to set the title for the dialog box Implement the createCenterPanel() method to return the component comprising the main contents of the dialog. Optional : Override the getPreferredFocusedComponent() method and return the component that should be focused when the dialog is first displayed. Optional : Override the getDimensionServiceKey() method to return the identifier which will be used for persisting the dialog dimensions. Optional : Override the getHelpId() method to return the context help topic associated with the dialog. The DialogWrapper class is often used together with GUI Designer forms . In this case, bind a GUI Designer form to the class extending DialogWrapper , bind the top-level panel of the form to a field and return that field from the createCenterPanel() method. TIP Existing dialogs can be inspected at runtime using UI Inspector , e.g., to locate the underlying implementation of UI components. To display the dialog, call the show() method and then use the getExitCode() method to check how the dialog was closed. The showAndGet() method can be used to combine these two calls. To customize the buttons displayed in the dialog (replacing the standard OK / Cancel / Help set of buttons), override either the createActions() or createLeftActions() methods. Both of these methods return an array of Swing Action objects. If a button closes the dialog, use DialogWrapperExitAction as the base class for the action. Use action.putValue(DialogWrapper.DEFAULT_ACTION, true) to set the default button. To validate the data entered into the dialog, override the doValidate() method. The method will be called automatically by timer. If the currently entered data is valid, return null . Otherwise, return a ValidationInfo object which encapsulates an error message, and an optional component associated with the invalid data. When specifying a component, an error icon will be displayed next to it, and it will be focused when the user tries to invoke the OK action. Example Simple definition of a DialogWrapper : public class SampleDialogWrapper extends DialogWrapper { public SampleDialogWrapper () { super ( true ); // use current window as parent init (); setTitle ( \"Test DialogWrapper\" ); } @Nullable @Override protected JComponent createCenterPanel () { JPanel dialogPanel = new JPanel ( new BorderLayout ()); JLabel label = new JLabel ( \"testing\" ); label . setPreferredSize ( new Dimension ( 100 , 100 )); dialogPanel . add ( label , BorderLayout . CENTER ); return dialogPanel ; } } Usage of DialogWrapper : JButton testButton = new JButton (); testButton . addActionListener ( actionEvent -> { if ( new SampleDialogWrapper (). showAndGet ()) { // user pressed OK } });","title":"Dialogs"},{"location":"user_interface_components/dialog_wrapper/#dialogwrapper","text":"The DialogWrapper is the base class which is supposed to be used for all modal dialogs (and some non-modal dialogs) shown in Consulo . It provides the following features: Button layout (platform-specific order of OK / Cancel buttons, macOS-specific Help button) Context help Remembering the size of the dialog Non-modal validation (displaying an error message text when the data entered into the dialog is not valid) Keyboard shortcuts: Esc for closing the dialog Left/Right for switching between buttons Y / N for Yes / No actions if they exist in the dialog Optional Do not ask again checkbox When using the DialogWrapper class for a dialog, follow these steps: Call the base class constructor and provide either a project in the frame of which the dialog will be displayed, or a parent component for the dialog. Call the init() method from the constructor of the dialog class Call the setTitle() method to set the title for the dialog box Implement the createCenterPanel() method to return the component comprising the main contents of the dialog. Optional : Override the getPreferredFocusedComponent() method and return the component that should be focused when the dialog is first displayed. Optional : Override the getDimensionServiceKey() method to return the identifier which will be used for persisting the dialog dimensions. Optional : Override the getHelpId() method to return the context help topic associated with the dialog. The DialogWrapper class is often used together with GUI Designer forms . In this case, bind a GUI Designer form to the class extending DialogWrapper , bind the top-level panel of the form to a field and return that field from the createCenterPanel() method. TIP Existing dialogs can be inspected at runtime using UI Inspector , e.g., to locate the underlying implementation of UI components. To display the dialog, call the show() method and then use the getExitCode() method to check how the dialog was closed. The showAndGet() method can be used to combine these two calls. To customize the buttons displayed in the dialog (replacing the standard OK / Cancel / Help set of buttons), override either the createActions() or createLeftActions() methods. Both of these methods return an array of Swing Action objects. If a button closes the dialog, use DialogWrapperExitAction as the base class for the action. Use action.putValue(DialogWrapper.DEFAULT_ACTION, true) to set the default button. To validate the data entered into the dialog, override the doValidate() method. The method will be called automatically by timer. If the currently entered data is valid, return null . Otherwise, return a ValidationInfo object which encapsulates an error message, and an optional component associated with the invalid data. When specifying a component, an error icon will be displayed next to it, and it will be focused when the user tries to invoke the OK action.","title":"DialogWrapper"},{"location":"user_interface_components/dialog_wrapper/#example","text":"Simple definition of a DialogWrapper : public class SampleDialogWrapper extends DialogWrapper { public SampleDialogWrapper () { super ( true ); // use current window as parent init (); setTitle ( \"Test DialogWrapper\" ); } @Nullable @Override protected JComponent createCenterPanel () { JPanel dialogPanel = new JPanel ( new BorderLayout ()); JLabel label = new JLabel ( \"testing\" ); label . setPreferredSize ( new Dimension ( 100 , 100 )); dialogPanel . add ( label , BorderLayout . CENTER ); return dialogPanel ; } } Usage of DialogWrapper : JButton testButton = new JButton (); testButton . addActionListener ( actionEvent -> { if ( new SampleDialogWrapper (). showAndGet ()) { // user pressed OK } });","title":"Example"},{"location":"user_interface_components/editor_components/","text":"EditorTextField Compared to Swing JTextArea , the Consulo's editor component has a ton of advantages: syntax highlighting support, code completion, code folding and much more. Editors are normally displayed in editor tabs, but they can be embedded in dialogs or tool windows, too. This is enabled by the EditorTextField component. The following attributes can be specified: The file type according to which the text in the text field is parsed; Whether the text field is read-only or editable; Whether the text field is single-line or multiline. Further customizations are possible by subclassing and overriding createEditor() . A common use case for EditorTextField is entering the name of a Java class or package. This can be accomplished with the following steps: Use JavaCodeFragmentFactory.getInstance().createReferenceCodeFragment() to create a code fragment representing the class or package name; Call PsiDocumentManager.getInstance().getDocument() to get the document corresponding to the code fragment; Pass the returned document to the EditorTextField constructor or its setDocument() method. E.g.: PsiFile psiFile = PsiDocumentManager . getInstance ( editor . getProject ()). getPsiFile ( editor . getDocument ()); PsiElement element = psiFile . findElementAt ( editor . getCaretModel (). getOffset ()); PsiExpressionCodeFragment code = JavaCodeFragmentFactory . getInstance ( editor . getProject ()) . createExpressionCodeFragment ( \"\" , element , null , true ); Document document = PsiDocumentManager . getInstance ( editor . getProject ()). getDocument ( code ); EditorTextField myInput = new EditorTextField ( document , editor . getProject (), JavaFileType . INSTANCE ); TIPS : When creating more than one field two separate documents are needed. This is accomplished by using separate instances of PsiExpressionCodeFragment . setText() no longer works for the input field. However, createExpressionCodeFragment() accepts the text for the field as an argument. The empty string can be replaced and create a new document in lieu of setText() . Instances of JTextField in the GUI builder can be replaced with a custom replacement component using the right click in your IDE. Make sure to use \"Custom Create\", so the initialization code works properly.","title":"Editor Components"},{"location":"user_interface_components/editor_components/#editortextfield","text":"Compared to Swing JTextArea , the Consulo's editor component has a ton of advantages: syntax highlighting support, code completion, code folding and much more. Editors are normally displayed in editor tabs, but they can be embedded in dialogs or tool windows, too. This is enabled by the EditorTextField component. The following attributes can be specified: The file type according to which the text in the text field is parsed; Whether the text field is read-only or editable; Whether the text field is single-line or multiline. Further customizations are possible by subclassing and overriding createEditor() . A common use case for EditorTextField is entering the name of a Java class or package. This can be accomplished with the following steps: Use JavaCodeFragmentFactory.getInstance().createReferenceCodeFragment() to create a code fragment representing the class or package name; Call PsiDocumentManager.getInstance().getDocument() to get the document corresponding to the code fragment; Pass the returned document to the EditorTextField constructor or its setDocument() method. E.g.: PsiFile psiFile = PsiDocumentManager . getInstance ( editor . getProject ()). getPsiFile ( editor . getDocument ()); PsiElement element = psiFile . findElementAt ( editor . getCaretModel (). getOffset ()); PsiExpressionCodeFragment code = JavaCodeFragmentFactory . getInstance ( editor . getProject ()) . createExpressionCodeFragment ( \"\" , element , null , true ); Document document = PsiDocumentManager . getInstance ( editor . getProject ()). getDocument ( code ); EditorTextField myInput = new EditorTextField ( document , editor . getProject (), JavaFileType . INSTANCE ); TIPS : When creating more than one field two separate documents are needed. This is accomplished by using separate instances of PsiExpressionCodeFragment . setText() no longer works for the input field. However, createExpressionCodeFragment() accepts the text for the field as an argument. The empty string can be replaced and create a new document in lieu of setText() . Instances of JTextField in the GUI builder can be replaced with a custom replacement component using the right click in your IDE. Make sure to use \"Custom Create\", so the initialization code works properly.","title":"EditorTextField"},{"location":"user_interface_components/file_and_class_choosers/","text":"File Choosers Via Dialog To let a user choose a file, directory or multiple files, use the FileChooser.chooseFiles() method. This method has multiple overloads. The best method to use is the one which returns void and takes a callback receiving the list of selected files as a parameter. This is the only overload which will display a native file open dialog on macOS. The FileChooserDescriptor class allows you to control which files can be selected. The constructor parameters specify whether files and/or directories can be selected, and whether multiple selection is allowed (see FileChooserDescriptorFactory for common variants). For more fine-grained control over the allowed selection, you can overload the isFileSelectable() method. You can also customize the presentation of files by overriding getIcon() , getName() and getComment() methods. Note that the native macOS file chooser does not support most of the customizations, so if you rely on them, you need to use an overload of chooseFiles() which displays the standard Consulo dialog. Via Textfield A very common way of using file choosers is to use a text field for entering the path with an ellipsis button (\"...\") for showing the file chooser. To create such a control, use the TextFieldWithBrowseButton component and call the addBrowseFolderListener() method on it to set up the file chooser. As an added bonus, this will enable filename completion when entering paths in the text box. Via Tree An alternative UI for selecting files, which works best when the most common way of selecting a file is by typing its name, is available through the TreeFileChooserFactory class. The dialog shown by this API has two tabs: One shows the project structure Another shows a list of files similar to the one used by the Goto File popup. To show the dialog, call showDialog() on the chooser returned from createFileChooser() , and then call getSelectedFile to retrieve the user's selection. Class and Package Choosers If you want to offer the user a possibility to select a Java class, you can use the TreeClassChooserFactory class. Its different methods allow you to specify the scope from which the classes are taken, to restrict the choice to descendants of a specific class or implementations of an interface, and to include or exclude inner classes from the list. For choosing a Java package, you can use the PackageChooserDialog class.","title":"File and Class Choosers"},{"location":"user_interface_components/file_and_class_choosers/#file-choosers","text":"","title":"File Choosers"},{"location":"user_interface_components/file_and_class_choosers/#via-dialog","text":"To let a user choose a file, directory or multiple files, use the FileChooser.chooseFiles() method. This method has multiple overloads. The best method to use is the one which returns void and takes a callback receiving the list of selected files as a parameter. This is the only overload which will display a native file open dialog on macOS. The FileChooserDescriptor class allows you to control which files can be selected. The constructor parameters specify whether files and/or directories can be selected, and whether multiple selection is allowed (see FileChooserDescriptorFactory for common variants). For more fine-grained control over the allowed selection, you can overload the isFileSelectable() method. You can also customize the presentation of files by overriding getIcon() , getName() and getComment() methods. Note that the native macOS file chooser does not support most of the customizations, so if you rely on them, you need to use an overload of chooseFiles() which displays the standard Consulo dialog.","title":"Via Dialog"},{"location":"user_interface_components/file_and_class_choosers/#via-textfield","text":"A very common way of using file choosers is to use a text field for entering the path with an ellipsis button (\"...\") for showing the file chooser. To create such a control, use the TextFieldWithBrowseButton component and call the addBrowseFolderListener() method on it to set up the file chooser. As an added bonus, this will enable filename completion when entering paths in the text box.","title":"Via Textfield"},{"location":"user_interface_components/file_and_class_choosers/#via-tree","text":"An alternative UI for selecting files, which works best when the most common way of selecting a file is by typing its name, is available through the TreeFileChooserFactory class. The dialog shown by this API has two tabs: One shows the project structure Another shows a list of files similar to the one used by the Goto File popup. To show the dialog, call showDialog() on the chooser returned from createFileChooser() , and then call getSelectedFile to retrieve the user's selection.","title":"Via Tree"},{"location":"user_interface_components/file_and_class_choosers/#class-and-package-choosers","text":"If you want to offer the user a possibility to select a Java class, you can use the TreeClassChooserFactory class. Its different methods allow you to specify the scope from which the classes are taken, to restrict the choice to descendants of a specific class or implementations of an interface, and to include or exclude inner classes from the list. For choosing a Java package, you can use the PackageChooserDialog class.","title":"Class and Package Choosers"},{"location":"user_interface_components/lists_and_trees/","text":"JBList and Tree Whenever you would normally use a standard Swing JList component, it's recommended to use the JBList class as drop-in replacement. JBList supports the following additional features on top of JList : Drawing a tooltip with complete text of an item if the item doesn't fit into the list box width. Drawing a gray text message in the middle of the list box when it contains no items. The text can be customized by calling getEmptyText().setText() . Drawing a busy icon in the top right corner of the list box to indicate that a background operation is being performed. This can be enabled by calling setPaintBusy() . Similarly, the Tree class provides a replacement for the standard JTree class. In addition to the features of JBList , it supports wide selection painting (Mac style) and auto-scroll on drag & drop. ColoredListCellRenderer and ColoredTreeCellRenderer When you need to customize the presentation of items in a list box or a tree, it's recommended to use the ColoredListCellRenderer or ColoredTreeCellRenderer classes as the cell renderer. These classes allow you to compose the presentation out of multiple text fragments with different attributes by calling append() and to set an optional icon for the item by calling setIcon . The renderer automatically takes care of setting the correct text color for selected items and of many other platform-specific rendering details. ListSpeedSearch and TreeSpeedSearch To facilitate keyboard-based selection of items in a list box or a tree, you can install a speed search handler on it using the ListSpeedSearch and TreeSpeedSearch . This can be done simply by calling new ListSpeedSearch(list) or new TreeSpeedSearch(tree) . If you need to customize the text which is used to locate the element, you can override the getElementText() method. Alternatively, you can pass a function to convert items to strings. A function needs to be passed as elementTextDelegate to the ListSpeedSearch constructor or as toString to the TreeSpeedSearch constructor. ToolbarDecorator A very common task in plugin development is showing a list or a tree where the user is allowed to add, remove, edit or reorder the items. The implementation of this task is greatly facilitated by the ToolbarDecorator class. This class provides a toolbar with actions on items and automatically enables drag & drop reordering of items in list boxes if supported by the underlying list model. The position of the toolbar above or below the list depends on the platform under which the IDE is running. To use a toolbar decorator: If you need to support removing and reordering of items in a list box, make sure the model of your list implements the EditableModel interface. CollectionListModel is a handy model class that implements this interface. Call ToolbarDecorator.createDecorator() to create a decorator instance. If you need to support adding and/or removing items, call setAddAction() and/or setRemoveAction() . If you need other buttons in additional to the standard ones, call addExtraAction() or setActionGroup() . Call createPanel() and add the component it returns to your panel.","title":"List and Tree Controls"},{"location":"user_interface_components/lists_and_trees/#jblist-and-tree","text":"Whenever you would normally use a standard Swing JList component, it's recommended to use the JBList class as drop-in replacement. JBList supports the following additional features on top of JList : Drawing a tooltip with complete text of an item if the item doesn't fit into the list box width. Drawing a gray text message in the middle of the list box when it contains no items. The text can be customized by calling getEmptyText().setText() . Drawing a busy icon in the top right corner of the list box to indicate that a background operation is being performed. This can be enabled by calling setPaintBusy() . Similarly, the Tree class provides a replacement for the standard JTree class. In addition to the features of JBList , it supports wide selection painting (Mac style) and auto-scroll on drag & drop.","title":"JBList and Tree"},{"location":"user_interface_components/lists_and_trees/#coloredlistcellrenderer-and-coloredtreecellrenderer","text":"When you need to customize the presentation of items in a list box or a tree, it's recommended to use the ColoredListCellRenderer or ColoredTreeCellRenderer classes as the cell renderer. These classes allow you to compose the presentation out of multiple text fragments with different attributes by calling append() and to set an optional icon for the item by calling setIcon . The renderer automatically takes care of setting the correct text color for selected items and of many other platform-specific rendering details.","title":"ColoredListCellRenderer and ColoredTreeCellRenderer"},{"location":"user_interface_components/lists_and_trees/#listspeedsearch-and-treespeedsearch","text":"To facilitate keyboard-based selection of items in a list box or a tree, you can install a speed search handler on it using the ListSpeedSearch and TreeSpeedSearch . This can be done simply by calling new ListSpeedSearch(list) or new TreeSpeedSearch(tree) . If you need to customize the text which is used to locate the element, you can override the getElementText() method. Alternatively, you can pass a function to convert items to strings. A function needs to be passed as elementTextDelegate to the ListSpeedSearch constructor or as toString to the TreeSpeedSearch constructor.","title":"ListSpeedSearch and TreeSpeedSearch"},{"location":"user_interface_components/lists_and_trees/#toolbardecorator","text":"A very common task in plugin development is showing a list or a tree where the user is allowed to add, remove, edit or reorder the items. The implementation of this task is greatly facilitated by the ToolbarDecorator class. This class provides a toolbar with actions on items and automatically enables drag & drop reordering of items in list boxes if supported by the underlying list model. The position of the toolbar above or below the list depends on the platform under which the IDE is running. To use a toolbar decorator: If you need to support removing and reordering of items in a list box, make sure the model of your list implements the EditableModel interface. CollectionListModel is a handy model class that implements this interface. Call ToolbarDecorator.createDecorator() to create a decorator instance. If you need to support adding and/or removing items, call setAddAction() and/or setRemoveAction() . If you need other buttons in additional to the standard ones, call addExtraAction() or setActionGroup() . Call createPanel() and add the component it returns to your panel.","title":"ToolbarDecorator"},{"location":"user_interface_components/misc_swing_components/","text":"Messages The Messages class provides a way to show simple message boxes, input dialogs (modal dialogs with a text field), and chooser dialogs (modal dialogs with a combo box). The function of different methods of the class should be clear from their names. When running on macOS, the message boxes shown by the Messages class use the native UI. The showCheckboxMessageDialog() function provides an easy way to implement a Do not show this again checkbox on messages. Note that it is recommended to use non-modal notifications instead of modal message boxes whenever it's appropriate. Please refer to the Notifications topic for more information. JBSplitter The JBSplitter class is JetBrains' replacement for the standard JSplitPane class. Unlike some other JetBrains-enhanced Swing components, it's not a drop-in replacement and has a different API. However, to achieve a consistent user experience, it's recommended to use JBSplitter instead of the standard JSplitPane . To add components to the splitter, call the setFirstComponent() and setSecondComponent() methods. JBSplitter supports automatic remembering of the split proportion. To enable it, call the setSplitterProportionKey() method and pass the ID under which the proportion will be stored. JBTabs The JBTabs class is JetBrains' implementation of the tab control, used for editor tabs and a few other components. It has a significantly different look & feel compared to the standard Swing tabs, and looks less native on the macOS platform, so it's up to the developer to choose which tab control would be more appropriate. Toolbars See Toolbar in Consulo UI Guidelines for an overview. Building UI from Actions covers creating AnAction -based toolbars.","title":"Miscellaneous Swing Components"},{"location":"user_interface_components/misc_swing_components/#messages","text":"The Messages class provides a way to show simple message boxes, input dialogs (modal dialogs with a text field), and chooser dialogs (modal dialogs with a combo box). The function of different methods of the class should be clear from their names. When running on macOS, the message boxes shown by the Messages class use the native UI. The showCheckboxMessageDialog() function provides an easy way to implement a Do not show this again checkbox on messages. Note that it is recommended to use non-modal notifications instead of modal message boxes whenever it's appropriate. Please refer to the Notifications topic for more information.","title":"Messages"},{"location":"user_interface_components/misc_swing_components/#jbsplitter","text":"The JBSplitter class is JetBrains' replacement for the standard JSplitPane class. Unlike some other JetBrains-enhanced Swing components, it's not a drop-in replacement and has a different API. However, to achieve a consistent user experience, it's recommended to use JBSplitter instead of the standard JSplitPane . To add components to the splitter, call the setFirstComponent() and setSecondComponent() methods. JBSplitter supports automatic remembering of the split proportion. To enable it, call the setSplitterProportionKey() method and pass the ID under which the proportion will be stored.","title":"JBSplitter"},{"location":"user_interface_components/misc_swing_components/#jbtabs","text":"The JBTabs class is JetBrains' implementation of the tab control, used for editor tabs and a few other components. It has a significantly different look & feel compared to the standard Swing tabs, and looks less native on the macOS platform, so it's up to the developer to choose which tab control would be more appropriate.","title":"JBTabs"},{"location":"user_interface_components/misc_swing_components/#toolbars","text":"See Toolbar in Consulo UI Guidelines for an overview. Building UI from Actions covers creating AnAction -based toolbars.","title":"Toolbars"},{"location":"user_interface_components/notifications/","text":"One of the leading design principles is avoiding the use of modal message boxes for notifying the user about errors and other situations that may warrant the user's attention. As a replacement, the Consulo provides multiple non-modal notification UI options. For an overview, refer to Notifications in Consulo UI Guidelines . Dialogs When working in dialog, instead of checking the validity of the input when the OK button is pressed and notifying the user about invalid data with a modal dialog, the recommended approach is to use DialogWrapper.doValidate() , which was described previously. Editor Hints For actions invoked from the editor (such as refactorings, navigation actions and different code insight features), the best way to notify the user about the inability to perform an action is to use the HintManager class. Its method showErrorHint() displays a floating popup above the editor which is automatically hidden when the user starts performing another action in the editor. Other HintManager methods can be used for displaying other kinds of non-modal notification hints over an editor. Top-Level Notifications The most general way to display non-modal notifications is to use the Notifications class. It has two main advantages: The user can control the way each notification type is displayed under Settings | Appearance & Behavior | Notifications All displayed notifications are gathered in the Event Log tool window and can be reviewed later For UI reference, see Balloon in Consulo UI Guidelines . The specific method used to display a notification is Notifications.Bus.notify() . If the current Project is known, please use overload with Project parameter, so the notification is shown in its associated frame. The text of the notification can include HTML tags. Use Notification.addAction(AnAction) to add links below the content, use NotificationAction for convenience. The groupId parameter of the Notification constructor specifies a notification type. The user can choose the display type corresponding to each notification type under Settings | Appearance and Behavior | Notifications . To specify the preferred display type, you need to use NotificationGroup to create notifications. Please see the following two paragraphs for setup, depending on the target platform version. NotificationGroup (2020.3 and later) NotificationGroup is registered in plugin.xml using com.intellij.notificationGroup extension point. Use key to provide a localized group display name. <extensions defaultExtensionNs= \"com.intellij\" > <notificationGroup id= \"Custom Notification Group\" displayType= \"BALLOON\" key= \"notification.group.name\" /> </extensions> Registered instances can then be obtained via their id . TIP Code insight is available for parameters expecting notification group id . public class MyNotifier { public static void notifyError ( @Nullable Project project , String content ) { NotificationGroupManager . getInstance (). getNotificationGroup ( \"Custom Notification Group\" ) . createNotification ( content , NotificationType . ERROR ) . notify ( project ); } } NotificationGroup (Pre-2020.3) NotificationGroup is registered in code. public class MyNotifier { private static final NotificationGroup NOTIFICATION_GROUP = new NotificationGroup ( \"Custom Notification Group\" , NotificationDisplayType . BALLOON , true ); public static void notifyError ( @Nullable Project project , String content ) { NOTIFICATION_GROUP . createNotification ( content , NotificationType . ERROR ) . notify ( project ); } }","title":"Notifications"},{"location":"user_interface_components/notifications/#dialogs","text":"When working in dialog, instead of checking the validity of the input when the OK button is pressed and notifying the user about invalid data with a modal dialog, the recommended approach is to use DialogWrapper.doValidate() , which was described previously.","title":"Dialogs"},{"location":"user_interface_components/notifications/#editor-hints","text":"For actions invoked from the editor (such as refactorings, navigation actions and different code insight features), the best way to notify the user about the inability to perform an action is to use the HintManager class. Its method showErrorHint() displays a floating popup above the editor which is automatically hidden when the user starts performing another action in the editor. Other HintManager methods can be used for displaying other kinds of non-modal notification hints over an editor.","title":"Editor Hints"},{"location":"user_interface_components/notifications/#top-level-notifications","text":"The most general way to display non-modal notifications is to use the Notifications class. It has two main advantages: The user can control the way each notification type is displayed under Settings | Appearance & Behavior | Notifications All displayed notifications are gathered in the Event Log tool window and can be reviewed later For UI reference, see Balloon in Consulo UI Guidelines . The specific method used to display a notification is Notifications.Bus.notify() . If the current Project is known, please use overload with Project parameter, so the notification is shown in its associated frame. The text of the notification can include HTML tags. Use Notification.addAction(AnAction) to add links below the content, use NotificationAction for convenience. The groupId parameter of the Notification constructor specifies a notification type. The user can choose the display type corresponding to each notification type under Settings | Appearance and Behavior | Notifications . To specify the preferred display type, you need to use NotificationGroup to create notifications. Please see the following two paragraphs for setup, depending on the target platform version.","title":"Top-Level Notifications"},{"location":"user_interface_components/notifications/#notificationgroup-20203-and-later","text":"NotificationGroup is registered in plugin.xml using com.intellij.notificationGroup extension point. Use key to provide a localized group display name. <extensions defaultExtensionNs= \"com.intellij\" > <notificationGroup id= \"Custom Notification Group\" displayType= \"BALLOON\" key= \"notification.group.name\" /> </extensions> Registered instances can then be obtained via their id . TIP Code insight is available for parameters expecting notification group id . public class MyNotifier { public static void notifyError ( @Nullable Project project , String content ) { NotificationGroupManager . getInstance (). getNotificationGroup ( \"Custom Notification Group\" ) . createNotification ( content , NotificationType . ERROR ) . notify ( project ); } }","title":"NotificationGroup (2020.3 and later)"},{"location":"user_interface_components/notifications/#notificationgroup-pre-20203","text":"NotificationGroup is registered in code. public class MyNotifier { private static final NotificationGroup NOTIFICATION_GROUP = new NotificationGroup ( \"Custom Notification Group\" , NotificationDisplayType . BALLOON , true ); public static void notifyError ( @Nullable Project project , String content ) { NOTIFICATION_GROUP . createNotification ( content , NotificationType . ERROR ) . notify ( project ); } }","title":"NotificationGroup (Pre-2020.3)"},{"location":"user_interface_components/popups/","text":"Popups The Consulo user interface makes extensive use of popups - semi-modal windows that have no chrome (explicit closing buttons) and disappear automatically on focus loss. Making use of these controls in your plugin ensures a consistent user experience between your plugin and the rest of the IDE. Popups can optionally display a title, are optionally movable and resizable (and support remembering their size), and can be nested (show another popup when an item is selected). The JBPopupFactory interface allows you to create popups that display different kinds of components, depending on your specific needs. The most commonly used methods are: createComponentPopupBuilder() is the most generic one, allowing you to show any Swing component in the popup. createPopupChooserBuilder() creates a popup for choosing one or more items from a plain java.util.List createConfirmation() creates a popup for choosing between two options, and performing different actions depending on which option is selected. createActionGroupPopup() creates a popup which shows the actions from an action group and executes the action selected by the user. Action group popups support different ways of choosing an action from the keyboard, in additional to the normal arrow keys. By passing one of the constants in the ActionSelectionAid enumeration, you can choose whether an action can be selected by pressing a key corresponding to its sequential number, typing part of its text (speed search) or pressing a mnemonic character. For popups with a fixed set of items, the recommended selection method is sequential numbering; for popups with a variable and potentially large number of items, speed search typically works best. If you need to create a list-like popup which is more flexible than a simple JList but don't want to represent the possible choices as actions in an action group, you can work directly with the ListPopupStep interface and the JBPopupFactory.createListPopup() method. Normally you don't need to implement the entire interface; instead, you can derive from the BaseListPopupStep class. The key methods to override are getTextFor() (returning the text to display for an item) and onChosen() (called when an item is selected). By returning a new popup step from the onChosen() method, you can implement hierarchical (nested) popups. Once you've created the popup, you need to display it by calling one of the show() methods. You can let the Consulo automatically choose the position based on the context, by calling showInBestPositionFor() , or specify the position explicitly through methods like showUnderneathOf() and showInCenterOf() . NOTE The show() methods return immediately and do not wait for the popup to be closed. If you need to perform some action when the popup is closed, you can either attach a listener to it using the addListener() method, override a method of the popup contents such as PopupStep.onChosen() , or attach an event handler to your own component within the popup.","title":"Popups"},{"location":"user_interface_components/popups/#popups","text":"The Consulo user interface makes extensive use of popups - semi-modal windows that have no chrome (explicit closing buttons) and disappear automatically on focus loss. Making use of these controls in your plugin ensures a consistent user experience between your plugin and the rest of the IDE. Popups can optionally display a title, are optionally movable and resizable (and support remembering their size), and can be nested (show another popup when an item is selected). The JBPopupFactory interface allows you to create popups that display different kinds of components, depending on your specific needs. The most commonly used methods are: createComponentPopupBuilder() is the most generic one, allowing you to show any Swing component in the popup. createPopupChooserBuilder() creates a popup for choosing one or more items from a plain java.util.List createConfirmation() creates a popup for choosing between two options, and performing different actions depending on which option is selected. createActionGroupPopup() creates a popup which shows the actions from an action group and executes the action selected by the user. Action group popups support different ways of choosing an action from the keyboard, in additional to the normal arrow keys. By passing one of the constants in the ActionSelectionAid enumeration, you can choose whether an action can be selected by pressing a key corresponding to its sequential number, typing part of its text (speed search) or pressing a mnemonic character. For popups with a fixed set of items, the recommended selection method is sequential numbering; for popups with a variable and potentially large number of items, speed search typically works best. If you need to create a list-like popup which is more flexible than a simple JList but don't want to represent the possible choices as actions in an action group, you can work directly with the ListPopupStep interface and the JBPopupFactory.createListPopup() method. Normally you don't need to implement the entire interface; instead, you can derive from the BaseListPopupStep class. The key methods to override are getTextFor() (returning the text to display for an item) and onChosen() (called when an item is selected). By returning a new popup step from the onChosen() method, you can implement hierarchical (nested) popups. Once you've created the popup, you need to display it by calling one of the show() methods. You can let the Consulo automatically choose the position based on the context, by calling showInBestPositionFor() , or specify the position explicitly through methods like showUnderneathOf() and showInCenterOf() . NOTE The show() methods return immediately and do not wait for the popup to be closed. If you need to perform some action when the popup is closed, you can either attach a listener to it using the addListener() method, override a method of the popup contents such as PopupStep.onChosen() , or attach an event handler to your own component within the popup.","title":"Popups"},{"location":"user_interface_components/tool_windows/","text":"Tool Windows Tool windows are child windows of the IDE used to display information. These windows generally have their own toolbars (referred to as tool window bars ) along the outer edges of the main window containing one or more tool window buttons , which activate panels displayed on the left, bottom and right sides of the main IDE window. For detailed information about tool windows, please see IntelliJ IDEA Web Help and Tool window topic in Consulo UI Guidelines . Each side contains two tool window groups, the primary and the secondary one, and only one tool window from each group can be active at a time. Each tool window can show multiple tabs (or \"contents\", as they are called in the API). For example, the Run tool window displays a tab for each active run configuration, and the Changes/Version Control tool window displays a fixed set of tabs depending on the version control system used in the project. There are two main scenarios for the use of tool windows in a plugin. Using declarative setup, a tool window button is always visible, and the user can activate it and interact with the plugin functionality at any time. Alternatively, using programmatic setup, the tool window is created to show the results of a specific operation, and can be closed by the user after the operation is completed. Declarative Setup The tool window is registered in plugin.xml using the com.intellij.toolWindow extension point. The extension point attributes specify all the data which is necessary to display the tool window button: The id of the tool window (corresponds to the text displayed on the tool window button) The anchor , meaning the side of the screen on which the tool window is displayed (\"left\" (default), \"right\" or \"bottom\") The secondary attribute, specifying whether the tool window is displayed in the primary or the secondary group The icon to display on the tool window button (13x13 pixels, see Working with Icons and Images ) In addition to that, specify the factoryClass attribute - the name of a class implementing the ToolWindowFactory interface. When the user clicks on the tool window button, the createToolWindowContent() method of the factory class is called, and initializes the UI of the tool window. This procedure ensures that unused tool windows don't cause any overhead in startup time or memory usage: if a user does not interact with the tool window, no plugin code will be loaded or executed. If the tool window of a plugin doesn't need to be displayed for all projects: * For versions 2020.1 and later, also implement the isApplicable(Project) method. * For versions 2019.3 and earlier, also specify the conditionClass attribute: the FQN of a class implementing Condition<Project> , which can be the same class as the tool window factory implementation. Note the condition is evaluated only once when the project is loaded; to show and hide a tool window dynamically while the user is working with the project use the second method for tool window registration. To provide a localized text for the tool window button, specify matching toolwindow.stripe.[id] message key (escape spaces with _ ) in your message bundle (code insight supported in 2020.3 and later). Programmatic Setup The second method involves simply calling ToolWindowManager.registerToolWindow() from the plugin code. The method has multiple overloads that can be used depending on the task. When using an overload that takes a component, the component becomes the first content (tab) displayed in the tool window. Contents (Tabs) Displaying the contents of many tool windows requires access to the indices. Because of that, tool windows are normally disabled while building indices unless the ToolWindowFactory implements DumbAware . For programmatic setup, parameter canWorkInDumbMode must be set to true in calls to registerToolWindow() . As mentioned previously, tool windows can contain multiple tabs, or contents. To manage the contents of a tool window, call ToolWindow.getContentManager() . To add a tab (content), first create it by calling ContentManager.getFactory().createContent() , and then to add it to the tool window using ContentManager.addContent() . A plugin can control whether the user is allowed to close tabs either globally or on a per-tab basis. The former is done by passing the canCloseContents parameter to the registerToolWindow() function, or by specifying canCloseContents=\"true\" in plugin.xml . The default value is false ; calling setClosable(true) on ContentManager content will be ignored unless canCloseContents is explicitly set. If closing tabs is enabled in general, a plugin can disable closing of specific tabs by calling Content.setCloseable(false) . Sample Plugin To clarify how to develop plugins that create tool windows, consider the toolWindow sample plugin available in the code_samples directory of the SDK documentation. This plugin creates the Sample Calendar tool window that displays the system date, time and time zone. To run the toolWindow plugin Start IntelliJ IDEA and open the tool_window project saved into the code_samples/tool_window directory. Ensure that the project settings are valid for the environment. If necessary, modify the project settings. To view or modify the project settings, open the Project Structure dialog. Run the plugin by choosing the Run | Run on the main menu. If necessary, change the Run/Debug Configurations . The plugin creates the Sample Calendar tool window. When opened, this tool window is similar to the following screen:","title":"Tool Windows"},{"location":"user_interface_components/tool_windows/#tool-windows","text":"Tool windows are child windows of the IDE used to display information. These windows generally have their own toolbars (referred to as tool window bars ) along the outer edges of the main window containing one or more tool window buttons , which activate panels displayed on the left, bottom and right sides of the main IDE window. For detailed information about tool windows, please see IntelliJ IDEA Web Help and Tool window topic in Consulo UI Guidelines . Each side contains two tool window groups, the primary and the secondary one, and only one tool window from each group can be active at a time. Each tool window can show multiple tabs (or \"contents\", as they are called in the API). For example, the Run tool window displays a tab for each active run configuration, and the Changes/Version Control tool window displays a fixed set of tabs depending on the version control system used in the project. There are two main scenarios for the use of tool windows in a plugin. Using declarative setup, a tool window button is always visible, and the user can activate it and interact with the plugin functionality at any time. Alternatively, using programmatic setup, the tool window is created to show the results of a specific operation, and can be closed by the user after the operation is completed.","title":"Tool Windows"},{"location":"user_interface_components/tool_windows/#declarative-setup","text":"The tool window is registered in plugin.xml using the com.intellij.toolWindow extension point. The extension point attributes specify all the data which is necessary to display the tool window button: The id of the tool window (corresponds to the text displayed on the tool window button) The anchor , meaning the side of the screen on which the tool window is displayed (\"left\" (default), \"right\" or \"bottom\") The secondary attribute, specifying whether the tool window is displayed in the primary or the secondary group The icon to display on the tool window button (13x13 pixels, see Working with Icons and Images ) In addition to that, specify the factoryClass attribute - the name of a class implementing the ToolWindowFactory interface. When the user clicks on the tool window button, the createToolWindowContent() method of the factory class is called, and initializes the UI of the tool window. This procedure ensures that unused tool windows don't cause any overhead in startup time or memory usage: if a user does not interact with the tool window, no plugin code will be loaded or executed. If the tool window of a plugin doesn't need to be displayed for all projects: * For versions 2020.1 and later, also implement the isApplicable(Project) method. * For versions 2019.3 and earlier, also specify the conditionClass attribute: the FQN of a class implementing Condition<Project> , which can be the same class as the tool window factory implementation. Note the condition is evaluated only once when the project is loaded; to show and hide a tool window dynamically while the user is working with the project use the second method for tool window registration. To provide a localized text for the tool window button, specify matching toolwindow.stripe.[id] message key (escape spaces with _ ) in your message bundle (code insight supported in 2020.3 and later).","title":"Declarative Setup"},{"location":"user_interface_components/tool_windows/#programmatic-setup","text":"The second method involves simply calling ToolWindowManager.registerToolWindow() from the plugin code. The method has multiple overloads that can be used depending on the task. When using an overload that takes a component, the component becomes the first content (tab) displayed in the tool window.","title":"Programmatic Setup"},{"location":"user_interface_components/tool_windows/#contents-tabs","text":"Displaying the contents of many tool windows requires access to the indices. Because of that, tool windows are normally disabled while building indices unless the ToolWindowFactory implements DumbAware . For programmatic setup, parameter canWorkInDumbMode must be set to true in calls to registerToolWindow() . As mentioned previously, tool windows can contain multiple tabs, or contents. To manage the contents of a tool window, call ToolWindow.getContentManager() . To add a tab (content), first create it by calling ContentManager.getFactory().createContent() , and then to add it to the tool window using ContentManager.addContent() . A plugin can control whether the user is allowed to close tabs either globally or on a per-tab basis. The former is done by passing the canCloseContents parameter to the registerToolWindow() function, or by specifying canCloseContents=\"true\" in plugin.xml . The default value is false ; calling setClosable(true) on ContentManager content will be ignored unless canCloseContents is explicitly set. If closing tabs is enabled in general, a plugin can disable closing of specific tabs by calling Content.setCloseable(false) .","title":"Contents (Tabs)"},{"location":"user_interface_components/tool_windows/#sample-plugin","text":"To clarify how to develop plugins that create tool windows, consider the toolWindow sample plugin available in the code_samples directory of the SDK documentation. This plugin creates the Sample Calendar tool window that displays the system date, time and time zone. To run the toolWindow plugin Start IntelliJ IDEA and open the tool_window project saved into the code_samples/tool_window directory. Ensure that the project settings are valid for the environment. If necessary, modify the project settings. To view or modify the project settings, open the Project Structure dialog. Run the plugin by choosing the Run | Run on the main menu. If necessary, change the Run/Debug Configurations . The plugin creates the Sample Calendar tool window. When opened, this tool window is similar to the following screen:","title":"Sample Plugin"},{"location":"user_interface_components/user_interface_components/","text":"The Consulo includes a large number of custom Swing components. Using those components in your plugins will ensure that your plugin looks and works consistently with the UI of the rest of the IDE, and can often reduce the code size compared to using the default Swing components. TIP Use UI Inspector to locate the underlying Swing component implementation or to inspect an existing UI at runtime. Please refer to Writing short and clear in Consulo UI Guidelines on writing UI-related texts. The following components are particularly noteworthy: Menus and toolbars are built using the Action System Tool Windows Dialogs Popups Notifications File and Class Choosers Editor Components List and Tree Controls Tables (TableView) (TBD) Drag & Drop Helpers (TBD) Miscellaneous Swing Components Messages JBSplitter JBTabs","title":"Overview"}]}