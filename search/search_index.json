{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to the consulo.dev - the primary source of documentation for extending the Consulo by creating plugins.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Creating Your First Plugin</li> </ul>"},{"location":"#open-source","title":"Open Source","text":"<p>This guide is Open Source and licensed under Apache 2.0. The source (as Markdown) is hosted on GitHub. Please see README.md for details on hosting the docs locally and contributing.</p>"},{"location":"#helpful-links","title":"Helpful Links","text":"<ul> <li>consulo.io - home page</li> <li>gihub discussing - place there you can ask questions</li> <li>hub.consulo.io - hub where you can find info about plugins, your error reports, statistics, e tc</li> <li>ci.consulo.io - jenkins</li> <li>maven.consulo.io - maven repository</li> <li>consulo.app - download page</li> <li>plugins.consulo.app - plugins repository</li> </ul>"},{"location":"basics/action_system/","title":"Action System","text":""},{"location":"basics/action_system/#introduction","title":"Introduction","text":"<p>The actions system is an extension point that allows plugins to add their items to Consulo-based IDE menus and toolbars. For example, one of the action classes is responsible for the File | Open File... menu item and the Open File toolbar button.</p> <p>Actions in the Consulo require a code implementation and must be registered. The action implementation determines the contexts in which an action is available, and its functionality when selected in the UI. Registration determines where an action appears in the IDE UI. Once implemented and registered, an action receives callbacks from the Consulo in response to user gestures.</p> <p>The Creating Actions tutorial describes the process of adding a custom action to a plugin. The Grouping Actions tutorial demonstrates three types of groups that can contain actions. The rest of this page is an overview of actions as an extension point.</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"basics/action_system/#action-implementation","title":"Action Implementation","text":"<p>An action is a class derived from the abstract class <code>AnAction</code>. The Consulo calls methods of an action when a user interacts with a menu item or toolbar button.</p> <p>WARNING Classes based on <code>AnAction</code> do not have class fields of any kind. This is because an instance of <code>AnAction</code> class exists for the entire lifetime of the application. If the <code>AnAction</code> class uses a field to store data that has a shorter lifetime and doesn't clear this data promptly, the data leaks. For example, any <code>AnAction</code> data that exists only within the context of a <code>Project</code> causes the <code>Project</code> to be kept in memory after the user has closed it.</p>"},{"location":"basics/action_system/#principal-implementation-overrides","title":"Principal Implementation Overrides","text":"<p>Every Consulo action should override <code>AnAction.update()</code> and must override <code>AnAction.actionPerformed()</code>. * An action's method <code>AnAction.update()</code> is called by the Consulo framework to update an action state.   The state (enabled, visible) of an action determines whether the action is available in the UI of an IDE.   An object of the <code>AnActionEvent</code> type is passed to this method and contains information about the current context for the action.   Actions are made available by changing state in the Presentation object associated with the event context.   As explained in Overriding the <code>AnAction.update()</code>  Method, it is vital <code>update()</code> methods execute quickly and return execution to the Consulo. * An action's method <code>AnAction.actionPerformed()</code> is called by the Consulo if available and selected by the user.   This method does the heavy lifting for the action - it contains the code executed when the action gets invoked.   The <code>actionPerformed()</code> method also receives <code>AnActionEvent</code> as a parameter, which is used to access projects, files, selection, etc.   See Overriding the <code>AnAction.actionPerformed()</code> Method for more information.</p> <p>There are other methods to override in the <code>AnAction</code> class, such as changing the default <code>Presentation</code> object for the action. There is also a use case for overriding action constructors when registering them with dynamic action groups, demonstrated in the Grouping Actions tutorial. However, the <code>update()</code> and <code>actionPerformed()</code> methods are essential to basic operation.</p>"},{"location":"basics/action_system/#overriding-the-anactionupdate-method","title":"Overriding the AnAction.update Method","text":"<p>The method <code>AnAction.update()</code> is periodically called by the Consulo in response to user gestures. The <code>update()</code> method gives an action to evaluate the current context and enable or disable its functionality.</p> <p>WARNING The <code>AnAction.update()</code> method can be called frequently and on a UI thread. This method needs to execute very quickly; no real work should be performed in this method. For example, checking selection in a tree or a list is considered valid, but working with the file system is not.</p> <p>TIP If the new state of an action cannot be determined quickly, then evaluation should be performed in the <code>AnAction.actionPerformed()</code> method, and notify the user that the action cannot be executed if the context isn't suitable.</p>"},{"location":"basics/action_system/#determining-the-action-context","title":"Determining the Action Context","text":"<p>The <code>AnActionEvent</code> object passed to <code>update()</code> carries information about the current context for the action. Context information is available from the methods of <code>AnActionEvent</code>, providing information such as the Presentation and whether the action is triggered by a Toolbar. Additional context information is available using the method <code>AnActionEvent.getData()</code>. Keys defined in <code>CommonDataKeys</code> are passed to the <code>getData()</code> method to retrieve objects such as <code>Project</code>, <code>Editor</code>, <code>PsiFile</code>, and other information. Accessing this information is relatively light-weight and is suited for <code>AnAction.update()</code>.</p>"},{"location":"basics/action_system/#enabling-and-setting-visibility-for-an-action","title":"Enabling and Setting Visibility for an Action","text":"<p>Based on information about the action context, the <code>AnAction.update()</code> method can enable, disable, or hide an action. An action's enable/disable state and visibility are set using methods of the <code>Presentation</code> object, which is accessed using <code>AnActionEvent.getPresentation()</code>.</p> <p>The default <code>Presentation</code> object is a set of descriptive information about a menu or toolbar action. Every context for an action - it might appear in multiple menus, toolbars, or Navigation search locations - has a unique presentation. Attributes such as an action's text, description, and icons and visibility and enable/disable state, are stored in the presentation. The attributes in a presentation get initialized from the action registration. However, some can be changed at runtime using the methods of the <code>Presentation</code> object associated with an action.</p> <p>The enabled/disabled state of an action is set using <code>Presentation.setEnabled()</code>. The visibility state of an action is set using <code>Presentation.setVisible()</code> If an action is enabled, the <code>AnAction.actionPerformed()</code> can be called if an action is selected in the IDE by a user. A menu action shows in the UI location specified in the registration. A toolbar action displays its enabled (or selected) icon, depending on the user interaction.</p> <p>When an action is disabled <code>AnAction.actionPerformed()</code> will not be called. Toolbar actions display their respective icons for the disabled state. The visibility of a disabled action in a menu depends on whether the host menu (e.g., \"ToolsMenu\") containing the action has the <code>compact</code> attribute set. See Grouping Actions for more information about the <code>compact</code> attribute and menu actions' visibility.</p> <p>NOTE If an action is added to a toolbar, its <code>update()</code> can be called if there was any user activity or focus transfer. If the action's availability changes in the absence of these events, then call <code>ActivityTracker.getInstance().inc()</code> to notify the action subsystem to update all toolbar actions.</p> <p>An example of enabling a menu action based on whether a project is open is demonstrated in <code>PopupDialogAction.update()</code> method.</p>"},{"location":"basics/action_system/#overriding-the-anactionactionperformed-method","title":"Overriding the AnAction.actionPerformed Method","text":"<p>When the user selects an enabled action, be it from a menu or toolbar, the action's <code>AnAction.actionPerformed()</code> method is called. This method contains the code executed to perform the action, and it is here that the real work gets done.</p> <p>By using the <code>AnActionEvent</code> methods and <code>CommonDataKeys</code>, objects such as the <code>Project</code>, <code>Editor</code>, <code>PsiFile</code>, and other information is available. For example, the <code>actionPerformed()</code> method can modify, remove, or add PSI elements to a file open in the editor.</p> <p>The code that executes in the <code>AnAction.actionPerformed()</code> method should execute efficiently, but it does not have to meet the same stringent requirements as the <code>update()</code> method.</p> <p>An example of inspecting PSI elements is demonstrated in the SDK code sample <code>action_basics</code> <code>PopupDialogAction.actionPerformed()</code> method.</p>"},{"location":"basics/action_system/#action-ids","title":"Action IDs","text":"<p>Every action and action group has a unique identifier. Basing the identifier for a custom action on the FQN of the implementation is the best practice, assuming the package incorporates the <code>&lt;id&gt;</code> of the plugin. An action must have a unique identifier for each place. It is used in the IDE UI, even though the FQN of the implementation is the same. Definitions of identifiers for the standard Consulo actions are in <code>IdeActions</code>.</p>"},{"location":"basics/action_system/#grouping-actions","title":"Grouping Actions","text":"<p>Groups organize actions into logical UI structures, which in turn can contain other groups. A group of actions can form a toolbar or a menu. Subgroups of a group can form submenus of a menu.</p> <p>Actions can be included in multiple groups, and thus appear in different places within the IDE UI. An action must have a unique identifier for each place it appears in the IDE UI. See the Action Declaration Reference section for information about how to specify locations in the IDE UI.</p>"},{"location":"basics/action_system/#presentation","title":"Presentation","text":"<p>A new <code>Presentation</code> gets created for every place where the action appears. Therefore, the same action can have different text or icons when it appears in different places of the user interface. Different presentations for the action are created by copying the Presentation returned by the <code>AnAction.getTemplatePresentation()</code> method.</p>"},{"location":"basics/action_system/#compact-attribute","title":"Compact Attribute","text":"<p>A group's \"compact\" attribute specifies whether an action within that group is visible when disabled. See Registering Actions in plugin.xml for an explanation of how the <code>compact</code> attribute is set for a group. If the <code>compact</code> attribute is <code>true</code> for a menu group, an action in the menu only appears if its state is both enabled and visible. In contrast, if the <code>compact</code> attribute is <code>false</code>, an action in the menu appears if its state is disabled but visible. Some menus like Tools have the <code>compact</code> attribute set, so there isn't a way to show an action on the tools menu if it is not enabled.</p> Host Menu<code>compact</code> Setting Action Enabled Visibility Enabled Menu Item Visible? Menu Item Appears Gray? T F T F N/A T T T T F F F T T T F T T T F <p>All other combinations of <code>compact</code>, visibility, and enablement produce N/A for gray appearance because the menu item isn't visible.</p> <p>See the Grouping Actions tutorial for examples of creating action groups.</p>"},{"location":"basics/action_system/#registering-actions","title":"Registering Actions","text":"<p>There are two main ways to register an action: either by listing it in the <code>&lt;actions&gt;</code> section of a plugin's <code>plugin.xml</code> file or through code.</p>"},{"location":"basics/action_system/#registering-actions-in-pluginxml","title":"Registering Actions in plugin.xml","text":"<p>Registering actions in <code>plugin.xml</code> is demonstrated in the following reference examples, which document all elements and attributes used in the <code>&lt;actions&gt;</code> section and describe each element's meaning.</p>"},{"location":"basics/action_system/#setting-the-override-text-element","title":"Setting the Override-Text Element","text":"<p>Beginning in 2020.1, an alternate version of an action's menu text can be declared for use depending on where an action appears. Using the <code>&lt;override-text&gt;</code> element, the menu text for an action can be different depending on context: menu location, toolbar, etc. This is also available for groups in 2020.3 and later.</p> <p>In the <code>action</code> element reference example (below) with <code>id</code> attribute <code>VssIntegration.GarbageCollection</code>, the default is to use the menu text \"Garbage Collector: Collect _Garbage.\" The <code>add-to-group</code> element declares the action is added to the Tools Menu.</p> <p>However, the <code>override-text</code> element declares that text for <code>VssIntegration.GarbageCollection</code> displayed anywhere in the Main Menu system should be the alternate text \"Collect _Garbage.\" The Tools Menu is part of the Main Menu, so the displayed menu text is \"Collect _Garbage.\" A different context, such as searching for the action using Help | Find Action...,  displays the default text \"Garbage Collector: Collect _Garbage\" to give the user additional information about the action.</p> <p>A second <code>override-text</code> element uses <code>place</code> and <code>use-text-of-place</code> attributes to declare the same version of the text used in the Main Menu is also used in the Editor Popup Menu. Additional <code>override-text</code> elements could be used to specify other places where the Main Menu text should be used.</p> <p>An example of using <code>&lt;override-text&gt;</code> is demonstrated in the Creating Actions tutorial.</p>"},{"location":"basics/action_system/#setting-the-synonym-element","title":"Setting the Synonym Element","text":"<p>2020.3 Users can locate actions via their name by invoking Help | Find Action.</p> <p>To allow using alternative names in search, add one or more <code>&lt;synonym&gt;</code> elements inside <code>&lt;action&gt;</code> or <code>&lt;reference&gt;</code>:</p> <pre><code>  &lt;action id=\"MyAction\" text=\"My Action Name\" ...&gt;\n    &lt;synonym text=\"Another Search Term\"/&gt; \n  &lt;/action&gt;\n</code></pre> <p>To provide a localized synonym, specify <code>key</code> instead of <code>text</code> attribute.</p>"},{"location":"basics/action_system/#disabling-search-for-group","title":"Disabling Search for Group","text":"<p>2020.3 To exclude a group from appearing in Help | Find Action results (e.g., New... popup), specify <code>searchable=\"false\"</code>.</p>"},{"location":"basics/action_system/#localizing-actions-and-groups","title":"Localizing Actions and Groups","text":"<p>Action and group localization use resource bundles containing property files named <code>*Bundle.properties</code>, each file consisting of <code>key=value</code> pairs. The <code>action_basics</code> plugin demonstrates using a resource bundle to localize the group and action entries added to the Editor Popup Menu.</p> <p>When localizing actions and groups, the <code>text</code> and <code>description</code> attributes are not declared in <code>plugin.xml</code>. Instead, those attribute values vary depending on the locale and get declared in a resource bundle.</p> <p>The name and location of the resource bundle must be declared in the <code>plugin.xml</code> file. In the case of <code>action_basics</code>, only a default localization resource bundle (<code>/resources/messages/BasicActionsBundle.properties</code>) is provided:</p> <pre><code>  &lt;resource-bundle&gt;messages.BasicActionsBundle&lt;/resource-bundle&gt;\n</code></pre> <p>2020.1 If necessary, a dedicated resource bundle to use for actions and groups can be defined on <code>&lt;actions&gt;</code>:</p> <pre><code>  &lt;actions resource-bundle=\"messages.MyActionsBundle\"&gt;\n    &lt;!-- action/group defined here will use keys from MyActionsBundle.properties --&gt;\n  &lt;/actions&gt;\n</code></pre>"},{"location":"basics/action_system/#actions","title":"Actions","text":"<p>For Actions, the key in property files incorporates the action <code>id</code> in this specific structure: * <code>action.&lt;action-id&gt;.text=Translated Action Text</code> * <code>action.&lt;action-id&gt;.description=Translated Action Description</code></p> <p>2020.1 If <code>&lt;override-text&gt;</code> is used for an action <code>id</code>, the key includes the <code>&lt;place&gt;</code> attribute: * <code>action.&lt;action-id&gt;.&lt;place&gt;.text=Place-dependent Translated Action Text</code></p>"},{"location":"basics/action_system/#groups","title":"Groups","text":"<p>For Groups, the <code>key</code> in the property files incorporates the group <code>id</code> in this specific structure: * <code>group.&lt;group-id&gt;.text=Translated Group Text</code> * <code>group.&lt;group-id&gt;.description=Translated Group Description</code></p> <p>2020.3  If <code>&lt;override-text&gt;</code> is used for an group <code>id</code>, the key includes the <code>&lt;place&gt;</code> attribute: * <code>group.&lt;group-id&gt;.&lt;place&gt;.text=Place-dependent Translated Group Text</code></p> <p>See Extending DefaultActionGroup for a tutorial of localizing Actions and Groups.</p>"},{"location":"basics/action_system/#action-declaration-reference","title":"Action Declaration Reference","text":"<p>The places where actions can appear are defined by constants in <code>ActionPlaces</code>. Group IDs for the Consulo are defined in <code>PlatformActions.xml</code>.</p> <p>This, and additional information can also be found by using the Code Completion, Quick Definition and Quick Documentation features.</p> <p>TIP To lookup existing Action ID (e.g. for use in <code>relative-to-action</code>), UI Inspector can be used.</p> <pre><code>&lt;!-- Actions --&gt;\n&lt;actions&gt;\n  &lt;!-- The &lt;action&gt; element defines an action to register.\n       The mandatory \"id\" attribute specifies a unique\n       identifier for the action.\n       The mandatory \"class\" attribute specifies the\n       FQN of the class implementing the action.\n       The mandatory \"text\" attribute specifies the default long-version text to be displayed for the\n       action (tooltip for toolbar button or text for menu item).\n       The optional \"use-shortcut-of\" attribute specifies the ID\n       of the action whose keyboard shortcut this action will use.\n       The optional \"description\" attribute specifies the text\n       which is displayed in the status bar when the action is focused.\n       The optional \"icon\" attribute specifies the icon which is\n       displayed on the toolbar button or next to the menu item. --&gt;\n  &lt;action id=\"VssIntegration.GarbageCollection\" class=\"com.foo.impl.CollectGarbage\" text=\"Garbage Collector: Collect _Garbage\"\n                description=\"Run garbage collector\" icon=\"icons/garbage.png\"&gt;\n    &lt;!-- The &lt;override-text&gt; element defines an alternate version of the text for the menu action.\n         The mandatory \"text\" attribute defines the text to be displayed for the action.\n         The mandatory \"place\" attribute declares where the alternate text should be used. In this example,\n         any time the action is displayed in the IDE Main Menu (and submenus) the override-text\n         version should be used.\n         The second &lt;override-text&gt; element uses the alternate attribute \"use-text-of-place\" to define\n         a location (EditorPopup) to use the same text as is used in MainMenu. It is a way to specify\n         use of alternate menu text in multiple discrete menu groups. --&gt;\n    &lt;override-text place=\"MainMenu\" text=\"Collect _Garbage\"/&gt;\n    &lt;override-text place=\"EditorPopup\" use-text-of-place=\"MainMenu\"/&gt;\n    &lt;!-- Provide alternative names for searching action by name --&gt;\n    &lt;synonym text=\"GC\"/&gt;\n    &lt;!-- The &lt;add-to-group&gt; node specifies that the action should be added\n         to an existing group. An action can be added to several groups.\n         The mandatory \"group-id\" attribute specifies the ID of the group\n         to which the action is added.\n         The group must be implemented by an instance of the DefaultActionGroup class.\n         The mandatory \"anchor\" attribute specifies the position of the\n         action in the relative to other actions. It can have the values\n         \"first\", \"last\", \"before\" and \"after\".\n         The \"relative-to-action\" attribute is mandatory if the anchor\n         is set to \"before\" and \"after\", and specifies the action before or after which\n         the current action is inserted. --&gt;\n    &lt;add-to-group group-id=\"ToolsMenu\" relative-to-action=\"GenerateJavadoc\" anchor=\"after\"/&gt;\n      &lt;!-- The &lt;keyboard-shortcut&gt; node specifies the keyboard shortcut\n           for the action. An action can have several keyboard shortcuts.\n           The mandatory \"first-keystroke\" attribute specifies the first\n           keystroke of the action. The keystrokes are specified according\n           to the regular Swing rules.\n           The optional \"second-keystroke\" attribute specifies the second\n           keystroke of the action.\n           The mandatory \"keymap\" attribute specifies the keymap for which\n           the action is active. IDs of the standard keymaps are defined as\n           constants in the com.intellij.openapi.keymap.KeymapManager class.\n           The optional \"remove\" attribute in the second &lt;keyboard-shortcut&gt;\n           element below means the specified shortcut should be removed from\n           the specified action.\n           The optional \"replace-all\" attribute in the third &lt;keyboard-shortcut&gt;\n           element below means remove all keyboard and mouse shortcuts from the specified\n           action before adding the specified shortcut.  --&gt;\n    &lt;!-- Add the first and second keystrokes to all keymaps  --&gt;\n    &lt;keyboard-shortcut keymap=\"$default\" first-keystroke=\"control alt G\" second-keystroke=\"C\"/&gt;\n    &lt;!-- Except to the \"Mac OS X\" keymap and its children --&gt;\n    &lt;keyboard-shortcut keymap=\"Mac OS X\" first-keystroke=\"control alt G\" second-keystroke=\"C\" remove=\"true\"/&gt;\n    &lt;!-- The \"Mac OS X 10.5+\" keymap and its children will have only this keyboard shortcut for this action.  --&gt;\n    &lt;keyboard-shortcut keymap=\"Mac OS X 10.5+\" first-keystroke=\"control alt G\" second-keystroke=\"C\" replace-all=\"true\"/&gt;\n    &lt;!-- The &lt;mouse-shortcut&gt; node specifies the mouse shortcut for the\n           action. An action can have several mouse shortcuts.\n           The mandatory \"keystroke\" attribute specifies the clicks and\n           modifiers for the action. It is defined as a sequence of words\n           separated by spaces:\n           \"button1\", \"button2\", \"button3\" for the mouse buttons;\n           \"shift\", \"control\", \"meta\", \"alt\", \"altGraph\" for the modifier keys;\n           \"doubleClick\" if the action is activated by a double-click of the button.\n           The mandatory \"keymap\" attribute specifies the keymap for which\n           the action is active. IDs of the standard keymaps are defined as\n           constants in the com.intellij.openapi.keymap.KeymapManager class.\n           The \"remove\" and \"replace-all\" attributes can also be used in\n           a &lt;mouse-shortcut&gt; element. See &lt;keyboard-shortcut&gt; for documentation.  --&gt;\n    &lt;mouse-shortcut keymap=\"$default\" keystroke=\"control button3 doubleClick\"/&gt;\n  &lt;/action&gt;\n  &lt;!--  This action declares neither a text nor description attribute. If it has\n        a resource bundle declared the text and descriptions will be retrieved\n        based on the action-id incorporated in the key for a translated string --&gt;\n  &lt;action id=\"sdk.action.PopupDialogAction\" class=\"sdk.action.PopupDialogAction\"\n        icon=\"SdkIcons.Sdk_default_icon\"&gt;\n  &lt;/action&gt;\n  &lt;!-- The &lt;group&gt; element defines an action group. &lt;action&gt;, &lt;group&gt; and\n       &lt;separator&gt; elements defined within it are automatically included in the group.\n       The mandatory \"id\" attribute specifies a unique identifier for the group.\n       The optional \"class\" attribute specifies the FQN of\n       the class implementing the group. If not specified,\n       com.intellij.openapi.actionSystem.DefaultActionGroup is used.\n       The optional \"text\" attribute specifies the text of the group (text\n       for the menu item showing the submenu).\n       The optional \"description\" attribute specifies the text which is displayed\n       in the status bar when the group has focus.\n       The optional \"icon\" attribute specifies the icon which is displayed on\n       the toolbar button or next to the menu group.\n       The optional \"popup\" attribute specifies how the group is presented in\n       the menu. If a group has popup=\"true\", actions in it are placed in a\n       submenu; for popup=\"false\", actions are displayed as a section of the\n       same menu delimited by separators.\n       The optional \"compact\" attribute specifies whether an action within that group is visible when disabled.\n       Setting compact=\"true\" specifies an action in the group isn't visible unless the action is enabled.        --&gt;\n  &lt;group class=\"com.foo.impl.MyActionGroup\" id=\"TestActionGroup\" text=\"Test Group\" description=\"Group with test actions\" icon=\"icons/testgroup.png\" popup=\"true\" compact=\"true\"&gt;\n    &lt;action id=\"VssIntegration.TestAction\" class=\"com.foo.impl.TestAction\" text=\"My Test Action\" description=\"My test action\"/&gt;\n    &lt;!-- The &lt;separator&gt; element defines a separator between actions.\n         It can also have an &lt;add-to-group&gt; child element. --&gt;\n    &lt;separator/&gt;\n    &lt;group id=\"TestActionSubGroup\"/&gt;\n    &lt;!-- The &lt;reference&gt; element allows to add an existing action to the group.\n         The mandatory \"ref\" attribute specifies the ID of the action to add. --&gt;\n    &lt;reference ref=\"EditorCopy\"/&gt;\n    &lt;add-to-group group-id=\"MainMenu\" relative-to-action=\"HelpMenu\" anchor=\"before\"/&gt;\n  &lt;/group&gt;\n&lt;/actions&gt;\n</code></pre>"},{"location":"basics/action_system/#registering-actions-from-code","title":"Registering Actions from Code","text":"<p>Two steps are required to register an action from code: * First, an instance of the class derived from <code>AnAction</code> must be passed to the <code>registerAction()</code> method of <code>ActionManager</code>, to associate the action with an ID. * Second, the action needs to be added to one or more groups.   To get an instance of an action group by ID, it is necessary to call <code>ActionManager.getAction()</code> and cast the returned value to <code>DefaultActionGroup</code>.</p>"},{"location":"basics/action_system/#building-ui-from-actions","title":"Building UI from Actions","text":"<p>If a plugin needs to include a toolbar or popup menu built from a group of actions in its user interface, that is accomplished through <code>ActionPopupMenu</code> and <code>ActionToolbar</code>. These objects can be created through calls to the <code>ActionManager.createActionPopupMenu()</code> and <code>createActionToolbar()</code> methods. To get a Swing component from such an object, call the respective <code>getComponent()</code> method.</p> <p>If an action toolbar is attached to a specific component (for example, a panel in a tool window), call <code>ActionToolbar.setTargetComponent()</code> and pass the related component's instance as a parameter. Setting the target ensures that the toolbar buttons' state depends on the state of the related component, not on the current focus location within the IDE frame.</p> <p>See Toolbar in Consulo UI Guidelines for an overview.</p>"},{"location":"basics/basics/","title":"Quick Start Guide","text":"<p>This section covers the basics of working with the Consulo. It will familiarize you with the working environment, project structure, and frequently used API components.</p> <ul> <li>Main Types of Consulo Plugins</li> <li>Creating Your First Plugin</li> <li>Plugin Structure</li> <li>IDE Development Instances</li> </ul>"},{"location":"basics/disposers/","title":"Disposer and Disposable","text":"<p>The Consulo's <code>Disposer</code> facilitates resource cleanup. If a subsystem keeps a set of resources alive coincident with a parent object's lifetime, the subsystem's resources should be registered with the <code>Disposer</code> to be released before or at the same time as the parent object.</p> <p>The most common resource type managed by <code>Disposer</code> is listeners, but there are other possible types: * File handles, and database connections, * Caches and other significant data structures.</p> <p>The <code>Disposer</code> is a singleton that manages a tree of <code>Disposable</code> instances. A <code>Disposable</code> is an interface for any object providing a <code>Disposable.dispose()</code> method to release heavyweight resources after a specific lifetime.</p> <p>The <code>Disposer</code> supports chaining <code>Disposables</code> in parent-child relationships.</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"basics/disposers/#automatically-disposed-objects","title":"Automatically Disposed Objects","text":"<p>Many objects are disposed automatically by the platform if they implement the <code>Disposable</code> interface. The most important type of such objects is services. Application-level services are automatically disposed by the platform when the IDE is closed or the plugin providing the service is unloaded. Project-level services are disposed when the project is closed, or the plugin is unloaded.</p> <p>Note that extensions registered in <code>plugin.xml</code> are not automatically disposed. If an extension requires executing some code to dispose it, you need to define a service and to put the code in its <code>dispose()</code> method or use it as a parent disposable.</p>"},{"location":"basics/disposers/#the-disposer-singleton","title":"The Disposer Singleton","text":"<p>The primary purpose of the <code>Disposer</code> singleton is to enforce the rule that a child <code>Disposable</code> never outlives its parent.</p> <p>The <code>Disposer</code> organizes <code>Disposable</code> objects in a tree of parent-child relationships. The tree of <code>Disposable</code> objects ensures the <code>Disposer</code> releases children of a parent first.</p> <p>See The Disposable Interface for more information about creating <code>Disposable</code> classes.</p> <p>Registering a disposable is performed by calling <code>Disposer.register()</code>:</p> <pre><code>  Disposer.register(parentDisposable, childDisposable);\n</code></pre>"},{"location":"basics/disposers/#choosing-a-disposable-parent","title":"Choosing a Disposable Parent","text":"<p>To register a child <code>Disposable</code>, a parent <code>Disposable</code> of a suitable lifetime is used to establish the parent-child relationship. One of the parent <code>Disposables</code> provided by the Consulo can be chosen, or it can be another <code>Disposable</code>.</p> <p>Use the following guidelines to choose the correct parent:</p> <ul> <li>For resources required for a plugin's entire lifetime, use an application or project level service.</li> <li>For resources required while a dialog is displayed, use <code>DialogWrapper.getDisposable()</code>.</li> <li>For resources required while a tool window tab is displayed, pass your instance implementing <code>Disposable</code> to <code>Content.setDisposer()</code>.</li> <li>For resources with a shorter lifetime, create a disposable using <code>Disposer.newDisposable()</code> and dispose it manually using <code>Disposable.dispose()</code>.   Note that it's always best to specify a parent for such a disposable (e.g., a project-level service), so that there is no memory leak if the <code>Disposable.dispose()</code> call is not reached because of an exception or a programming error.</li> </ul> <p>WARNING Even though <code>Application</code> and <code>Project</code> implement <code>Disposable</code>, they must NEVER be used as parent disposables in plugin code. Disposables registered using those objects as parents will not be disposed when the plugin is unloaded, leading to memory leaks.</p> <p>The <code>Disposer</code> API's flexibility means that if the parent instance is chosen unwisely, the child may consume resources for longer than required. Continuing to use resources when they are no longer needed can be a severe source of contention due to leaving some zombie objects behind due to each invocation. An additional challenge is that these kinds of issues won't be reported by the regular leak checker utilities, because technically, it's not a memory leak from the test suite perspective.</p> <p>For example, suppose a UI component created for a specific operation uses a project-level service as a parent disposable. In that case, the entire component will remain in memory after the operation is complete. This creates memory pressure and can waste CPU cycles on processing events that are no longer relevant.</p>"},{"location":"basics/disposers/#registering-listeners-with-parent-disposable","title":"Registering Listeners with Parent Disposable","text":"<p>Many Consulo APIs for registering listeners either require passing a parent disposable or have overloads that take a parent disposable. For example:</p> <pre><code>public abstract class EditorFactory {\n  // ...\n  public abstract void addEditorFactoryListener(@NotNull EditorFactoryListener listener);\n  public abstract void addEditorFactoryListener(@NotNull EditorFactoryListener listener, @NotNull Disposable parentDisposable);\n  public abstract void removeEditorFactoryListener(@NotNull EditorFactoryListener listener);\n}\n</code></pre> <p>Methods with a <code>parentDisposable</code> parameter automatically unsubscribe the listener when the corresponding parent disposable is disposed. Using such methods is always preferable to removing listeners explicitly from the <code>dispose</code> method because it requires less code and is easier to verify for correctness.</p> <p>To choose the correct parent disposable, use the guidelines from the previous section.</p> <p>The same rules apply to message bus connections. Always pass a parent disposable to <code>MessageBus.connect()</code>, and make sure it has the shortest possible lifetime.</p>"},{"location":"basics/disposers/#determining-disposal-status","title":"Determining Disposal Status","text":"<p>You can use <code>Disposer.isDisposed()</code> to check whether a <code>Disposable</code> has already been disposed. This check is useful, for example, for an asynchronous callback to a  <code>Disposable</code> that may be disposed before the callback is executed. In such a case, the best strategy is usually to do nothing and return early.</p> <p>WARNING Non-disposed objects shouldn't hold onto references to disposed objects, as this constitutes a memory leak. Once a <code>Disposable</code> is released, it should be completely inactive, and there's no reason to refer to it anymore.</p>"},{"location":"basics/disposers/#ending-a-disposable-lifecycle","title":"Ending a Disposable Lifecycle","text":"<p>A plugin can manually end a <code>Disposable</code> lifecycle by calling <code>Disposer.dispose(Disposable)</code>. This method handles recursively disposing of all the <code>Disposable</code> child descendants as well.</p>"},{"location":"basics/disposers/#implementing-the-disposable-interface","title":"Implementing the Disposable Interface","text":"<p>Creating a class requires implementing the <code>Disposable</code> interface and defining the <code>dispose()</code> method.</p> <p>In many cases, when the object implements <code>Disposable</code> only to be used as a parent disposable, the method's implementation will be completely empty.</p> <p>An example of a non-trivial <code>dispose</code> implementation is shown below:</p> <pre><code>  public class Foo&lt;T&gt; extends JBFoo implements Disposable {\n      public Foo(@NotNull Project project, @NotNull String name, @Nullable FileEditor fileEditor, @NotNull Disposable parentDisposable) {\n        this(project, name, fileEditor, InitParams.createParams(project), DetachedToolWindowManager.getInstance(project));\n        Disposer.register(parentDisposable, this);\n      }\n\n     @Override\n     public void dispose() {\n       myFooManager.unregister(this);\n       myDetachedToolWindowManager.unregister(myFileEditor);\n       KeyboardFocusManager.getCurrentKeyboardFocusManager().removePropertyChangeListener(\"focusOwner\", myMyPropertyChangeListener);\n       setToolContext(null);\n     }\n  }\n</code></pre> <p>A lot of code setting-up all the conditions requiring release in <code>dispose()</code> has been omitted for simplicity.</p> <p>Regardless, it illustrates the basic pattern, which is: * In this case, the parent disposable is passed into the constructor, * The <code>Foo</code> disposable is registered as a child of <code>parentDisposable</code> in the constructor. * The <code>dispose()</code> method consolidates the necessary release actions and will be called by the <code>Disposer</code>.</p> <p>WARNING Never call <code>Disposable.dispose()</code> directly because it bypasses the parent-child relationships established in <code>Disposer</code>. Always call <code>Disposer.dispose(Disposable)</code> instead.</p>"},{"location":"basics/disposers/#diagnosing-disposer-leaks","title":"Diagnosing Disposer Leaks","text":"<p>When the application exits, it performs a final sanity check to verify everything was disposed. If something was registered with the <code>Disposer</code> but remains undisposed, the Consulo reports it before shutting down.</p> <p>In test and Debug mode (<code>idea.disposer.debug</code> is set to <code>on</code>), registering a <code>Disposable</code> with the <code>Disposer</code> also registers a stack trace for the object's allocation path. The <code>Disposer</code> accomplishes this by creating a dummy <code>Throwable</code> at the time of registration.</p> <p>The following snippet represents the sort of \"memory leak detected\" error encountered in practice:</p> <pre><code>    java.lang.RuntimeException:\n    Memory leak detected: &lt;Instance&gt; of class &lt;com.example.classtype&gt;\n    See the cause for the corresponding Disposer.register() stacktrace:\n        at ObjectTree.assertIsEmpty(ObjectTree.java:209)\n        at Disposer.assertIsEmpty(Disposer.java:125)\n        at Disposer.assertIsEmpty(Disposer.java:121)\n        at ApplicationImpl.disposeSelf(ApplicationImpl.java:323)\n        at ApplicationImpl.doExit(ApplicationImpl.java:780)\n        \u2026\n    Caused by: java.lang.Throwable\n        at ObjectTree.getOrCreateNodeFor(ObjectTree.java:101)\n        at ObjectTree.register(ObjectTree.java:62)\n        at Disposer.register(Disposer.java:81)\n        at Disposer.register(Disposer.java:75)\n        \u2026\n        at ProjectManagerEx.createProject(ProjectManagerEx.java:69)\n        at NewProjectWizardDynamic.doFinish(NewProjectWizardDynamic.java:235)\n        at DynamicWizard$1.run(DynamicWizard.java:433)\n        at CoreProgressManager$5.run(CoreProgressManager.java:237)\n        at CoreProgressManager$TaskRunnable.run(CoreProgressManager.java:563)\n        \u2026\n</code></pre> <p>TIP The first part of the callstack is unrelated to diagnosing the memory leak. Instead, pay attention to the second part of the call stack, after <code>Caused by: java.lang.Throwable</code>.</p> <p>In this specific case, the Consulo (<code>CoreProgressManager</code>) started a task that contained the <code>DynamicWizard</code> code. In turn, that code allocated a <code>Project</code> that was never disposed by the time the application exited. That is a promising place to start digging.</p> <p>The above memory leak was ultimately caused by failing to pass a <code>Project</code> instance to a function responsible for registering it for disposal. Often the fix for a memory leak is as simple as understanding the memory scope of the object being allocated - usually a UI container, project, or application - and making sure a <code>Disposer.register()</code> call is made appropriately for it.</p>"},{"location":"basics/editing/","title":"Editing","text":"<ul> <li>Code Completion</li> <li>Templates</li> <li>QuickDoc</li> <li>Intentions</li> </ul>"},{"location":"basics/getting_started/","title":"Creating Your First Plugin","text":"<p>This documentation section will help you get started with developing plugins for the Consulo. You can use either IntelliJ IDEA Community Edition or IntelliJ IDEA Ultimate as your IDE (it is highly recommended to use the latest available version). Both include the complete set of plugin development tools. To become more familiar with IntelliJ IDEA, please refer to the IntelliJ IDEA Web Help.</p> <p>There are three supported workflows available for building plugins. The recommended workflow for new projects is to use GitHub Template or to use Gradle to create everything from scratch. The old Plugin DevKit workflow still supports existing projects.</p> <p>NOTE If a new plugin will be Scala-based, a dedicated SBT plugin sbt-idea-plugin is available.</p> <p>The Gradle workflow offers several advantages:   * Representations of source sets, modules, and projects are portable,   * Projects of any size or complexity usually require scripts for build management, which Gradle handles natively,   * Training, documentation, and community help for general Gradle topics are widely available.</p> <p>Specific to development of Consulo plugins with the Gradle plugin for IntelliJ IDEA:   * Changing plugin targets is more comfortable because it is all done in <code>build.gradle</code>:       * Switching the version of the target Consulo (IDE),       * Changing the target Consulo-based IDE, e.g., from IntelliJ IDEA to PyCharm,       * Running a plugin against alternate versions of the JetBrains runtime.   * Gradle is fully integrated with Continuous Integration systems and JetBrains Plugin Repository, so it is easy to customize and extend the build and publishing processes.   * Built-in verification task for <code>plugin.xml</code> and plugin distribution structure.   * Built-in integration with IntelliJ Plugin Verifier tool used for running the compatibility checks as performed on JetBrains Plugin Repository.</p>"},{"location":"basics/getting_started/#using-github-template","title":"Using GitHub Template","text":"<ul> <li>Developing plugins using GitHub Template</li> </ul>"},{"location":"basics/getting_started/#using-gradle","title":"Using Gradle","text":"<ul> <li>Developing plugins using Gradle<ul> <li>Getting Started with Gradle</li> <li>Configuring Gradle Projects</li> <li>Publishing Plugins with Gradle</li> </ul> </li> </ul>"},{"location":"basics/getting_started/#using-devkit","title":"Using DevKit","text":"<ul> <li>Developing plugins using DevKit<ul> <li>Setting Up a Development Environment</li> <li>Creating a Plugin Project</li> <li>Creating Actions</li> <li>Running and Debugging a Plugin</li> <li>Deploying a Plugin</li> <li>Publishing a Plugin</li> </ul> </li> </ul>"},{"location":"basics/ide_development_instance/","title":"IDE Development Instances","text":"<p>A JetBrains feature for developing plugins is running or debugging a plugin project from within an Consulo-based IDE such as IntelliJ IDEA. Selecting the runIde task for a Gradle-based project (or Run menu for a DevKit-based project) will launch a Development Instance of the IDE with the plugin enabled. This page describes how to control some of the settings for the Development Instance.</p> <p>TIP Please see also Advanced Configuration for general VM options and properties.</p>"},{"location":"basics/ide_development_instance/#using-a-jetbrains-runtime-for-the-development-instance","title":"Using a JetBrains Runtime for the Development Instance","text":"<p>An everyday use case is to develop (build) a plugin project against a JDK, e.g., Java 8, and then run or debug the plugin in a Development Instance of the IDE. In such a situation, Development Instance must use a JetBrains Runtime (JBR) rather than the JDK used to build the plugin project.</p> <p>The JetBrains Runtime is an environment for running Consulo-based IDEs on Windows, macOS, and Linux. It has some modifications by JetBrains, such as fixes for native crashes not present in official JDK builds. A version of the JetBrains Runtime is bundled with all Consulo-based IDEs. To produce accurate results while running or debugging a plugin project in a Development Instance, follow the procedures below to ensure the Development Instance uses a JetBrains Runtime.</p>"},{"location":"basics/ide_development_instance/#determining-a-jetbrains-runtime-version","title":"Determining a JetBrains Runtime Version","text":"<p>The JetBrains Runtime is determined from the JDK version used to build the plugin project, regardless of whether it is built on macOS, Windows, or Linux. For example, if a plugin is developed against the Java 8 SE Development Kit 8 for macOS (<code>jdk-8u212-macosx-x64.dmg</code>) to acquire the compatible JetBrains Runtime:</p> <ul> <li>Go to the JetBrains Runtime Site for general information and the latest build.</li> <li>Open the Release notes page to access all releases.</li> <li>Select the package name corresponding to the platform and SDK version.   In this case, the package name is <code>jbrsdk8-osx-x64</code> for JetBrains Runtime SDK version 8, macOS x64 hardware.</li> <li>On the macOS package page of the JetBrains Bintray site, select the Files menu.</li> <li>In the list of files, find the name that satisfies:</li> <li>The version and build number match the JDK used to build the plugin project.     For example, <code>jbrx-8u252-osx-x64</code> matches the Java 8 JDK, build 252: <code>jdk-8u252-macosx-x64</code>.</li> <li>Pick the highest JetBrains Runtime build number available.     For example, the file is <code>jbrx-8u252-osx-x64-b1649.2.tar.gz</code>, meaning build 1649.2 for this JetBrains Runtime matching Java 8 JDK build 252.</li> </ul>"},{"location":"basics/ide_development_instance/#setting-a-jetbrains-runtime-for-gradle-based-plugin-projects","title":"Setting a JetBrains Runtime for Gradle-Based Plugin Projects","text":"<p>By default, the Gradle plugin will fetch and use the version of the JetBrains Runtime for the Development Instance corresponding to the version of the Consulo used for building the plugin project. If required, an alternative version can be specified using <code>jbrVersion</code> attribute of <code>runIde</code> task.</p>"},{"location":"basics/ide_development_instance/#setting-a-jetbrains-runtime-for-devkit-based-plugin-projects","title":"Setting a JetBrains Runtime for DevKit-Based Plugin Projects","text":"<p>The Run Configuration for a DevKit-based plugin project controls the JDK used to run and debug a plugin project in a Development Instance. The default Run Configuration uses the same JDK for building the plugin project and running the plugin in a Development Instance. To change the runtime for the Development Instance, set the JRE field in the Run Configuration edit dialog to download a JetBrains Runtime.</p>"},{"location":"basics/ide_development_instance/#gradle-plugin-0422-and-later","title":"Gradle plugin 0.4.22 and Later","text":"<p>Enabled by default for target platform 2020.2 or later. Set <code>autoReloadPlugins = true</code> in runIde task to enable it for earlier platform versions or <code>autoReloadPlugins = false</code> to disable it explicitly.</p>"},{"location":"basics/ide_development_instance/#gradle-plugin-0421-and-earlierdevkit","title":"Gradle plugin 0.4.21 and Earlier/DevKit","text":"<p>Add system property <code>idea.auto.reload.plugins</code> in the run configuration (DevKit-based) or runIde task (Gradle-based). For Gradle-based plugins using <code>gradle-intellij-plugin</code> 0.4.17 or later, this property is set automatically.</p> <p>To disable auto-reload, set <code>idea.auto.reload.plugins</code> to <code>false</code> explicitly (2020.1.2+).</p>"},{"location":"basics/ide_development_instance/#the-development-instance-sandbox-directory","title":"The Development Instance Sandbox Directory","text":"<p>The Sandbox Home directory contains the settings, caches, logs, and plugins for a Development Instance of the IDE. This information is stored in a different location than for the installed IDE itself.</p>"},{"location":"basics/ide_development_instance/#sandbox-home-location-for-gradle-based-plugin-projects","title":"Sandbox Home Location for Gradle-Based Plugin Projects","text":"<p>For Gradle-based plugins, the default Sandbox Home location is defined by the Consulo <code>gradle-intellij-plugin</code>. See Configuring a Gradle Plugin Project for more information about specifying a Sandbox Home location. The default Sandbox Home location for Gradle-based plugin projects is: * Windows <code>&lt;Project Dir&gt;\\build\\idea-sandbox</code> * Linux or macOS <code>&lt;Project Dir&gt;/build/idea-sandbox</code></p>"},{"location":"basics/ide_development_instance/#sandbox-home-location-for-devkit-based-plugin-projects","title":"Sandbox Home Location for DevKit-Based Plugin Projects","text":"<p>For DevKit-based plugins, the default Sandbox Home location is defined in the Consulo Plugin SDK. See specifying the Sandbox Home for DevKit Projects for more information. The default Sandbox Home directory location for DevKit-based plugin projects is: * Windows: <code>&lt;User home&gt;\\.&lt;product_system_name&gt;&lt;product_version&gt;\\system\\plugins-sandbox\\</code> * Linux: <code>~/.&lt;product_system_name&gt;&lt;product_version&gt;/system/plugins-sandbox/</code> * macOS <code>~/Library/Caches/&lt;product_system_name&gt;&lt;product_version&gt;/plugins-sandbox/</code></p>"},{"location":"basics/ide_development_instance/#development-instance-settings-caches-logs-and-plugins","title":"Development Instance Settings, Caches, Logs, and Plugins","text":"<p>Within the Sandbox Home directory are subdirectories of the Development Instance: * <code>config</code> contains settings for the IDE instance. * <code>plugins</code> contains folders for each plugin being run in the IDE instance. * <code>system/caches</code> or <code>system\\caches</code> holds the IDE instance data. * <code>system/log</code> or <code>system\\log</code> contains the <code>idea.log</code> file for the IDE instance.</p> <p>Each of these Sandbox Home subdirectories can be manually cleared to reset the IDE Development Instance. At the next launch of a Development Instance, the subdirectories will be repopulated with the appropriate information.</p>"},{"location":"basics/indexing_and_psi_stubs/","title":"Indexing and PSI Stubs","text":""},{"location":"basics/indexing_and_psi_stubs/#indices","title":"Indices","text":"<p>The indexing framework provides a quick way to locate specific elements, e.g., files containing a certain word or methods with a particular name, in large codebases. Plugin developers can use the existing indexes built by the IDE itself and build and use their own indexes.</p> <p>It supports two main types of indexes:</p> <ul> <li>File-based indices</li> <li>Stub indices</li> </ul> <p>File-based indexes are built directly over the content of files. Stub indexes are built over serialized stub trees. A stub tree for a source file is a subset of its PSI tree, which contains only externally visible declarations and is serialized in a compact binary format.</p> <p>Querying a file-based index gets you the set of files matching a specific condition. Querying a stub index gets you the set of matching PSI elements. Therefore, custom language plugin developers should typically use stub indexes in their plugin implementations.</p> <p>TIP Indices Viewer is a plugin that helps to inspect indices' contents and properties. Please see also Improving indexing performance.</p>"},{"location":"basics/indexing_and_psi_stubs/#dumb-mode","title":"Dumb Mode","text":"<p>Indexing is a potentially lengthy process. It's performed in the background, and during this time, IDE's features are restricted to the ones that don't require index: basic text editing, version control, etc. This restriction is managed by <code>DumbService</code>. Violations are reported via <code>IndexNotReadyException</code>, please see its javadoc on how to adapt callers.                                                         </p> <p><code>DumbService</code> provides API to query whether the IDE is currently in \"dumb\" mode (where index access is not allowed) or \"smart\" mode (with all index built and ready to use). It also provides ways of delaying code execution until indices are ready. Please see its JavaDoc for more details.</p>"},{"location":"basics/indexing_and_psi_stubs/#gists","title":"Gists","text":"<p>Sometimes, the following conditions hold:</p> <ul> <li>the aggregation functionality of file-based indices is not needed.   One just needs to calculate some data based on a particular file's contents and cache it on disk.</li> <li>eagerly calculating the data for the entire project during indexing isn't needed (e.g., it slows down the indexing, and/or this data probably will ever be required for a minor subset of all project files).</li> <li>the data can be recalculated lazily on request without significant performance penalties.</li> </ul> <p>A file-based index can be used in such cases, but file gists provide a way to perform data calculation lazily, caching on disk, and a more lightweight API. Please see <code>VirtualFileGist</code> and <code>PsiFileGist</code> documentation.</p> <p>Example: - <code>ImageInfoIndex</code> calculating image dimensions/bit depth needed to be displayed in specific parts of UI.  </p>"},{"location":"basics/intellij.to.consulo.api/","title":"Migration from Consulo to Consulo","text":""},{"location":"basics/intellij.to.consulo.api/#platform-changes","title":"Platform changes","text":"<ul> <li>Plugins removed from platform. They plugin ids:<ul> <li>Java &gt; consulo.java (and removed his old id, com.intellij.modules.java )</li> <li>Xml &gt; com.intellij.xml</li> <li>RegExp &gt; com.intellij.regexp</li> <li>Images &gt; com.intellij.images</li> </ul> </li> <li>Added plugin named Platform: base have id com.intellij. It holder for all extensions/actions/extensionPoints for platform</li> <li>IDEA build number != Consulo build number.</li> <li>Now some Consulo plugins ids is not working anymore<ul> <li>com.intellij.modules.lang &gt; not need to write. It will throw 'plugin not found'</li> <li>com.intellij.modules.platform &gt; not need to write. It will throw 'plugin not found'</li> <li>com.intellij.modules.vcs &gt; not need to write. It will throw 'plugin not found'</li> <li>com.intellij.modules.xdebugger &gt; not need to write. It will throw 'plugin not found'</li> <li>com.intellij.modules.ultimate &gt; obsolete (we don't have Ultimate version)</li> <li>com.intellij.modules.ruby &gt; obsolete. Use consulo.ruby. See plugin repo</li> <li>com.intellij.modules.python &gt; obsolete. Use consulo.python. See plugin repo</li> <li>com.intellij.modules.objc &gt; obsolete (we don't have ObjC implementation)</li> </ul> </li> </ul>"},{"location":"basics/intellij.to.consulo.api/#api-changes","title":"API changes","text":"<ul> <li>Parsing API changes:<ul> <li>language version api.<ul> <li><code>ParserDefinition#createLexer(Project)</code> -&gt; <code>ParserDefinition#createLexer(LanguageVersion)</code></li> <li><code>ParserDefinition#createParser(Project)</code> -&gt; <code>ParserDefinition#createParser(LanguageVersion)</code></li> <li><code>ParserDefinition#getWhitespaceTokens()</code> -&gt; <code>ParserDefinition#createParser(LanguageVersion)</code></li> <li><code>ParserDefinition#getCommentTokens()</code> -&gt; <code>ParserDefinition#getCommentTokens(LanguageVersion)</code></li> <li><code>ParserDefinition#getStringLiteralElements()</code> -&gt; <code>ParserDefinition#getStringLiteralElements(LanguageVersion)</code></li> </ul> </li> </ul> </li> <li>Injections<ul> <li><code>com.intellij.lang.injection.MultiHostInjector</code> changes:<ul> <li><code>getLanguagesToInject</code> renamed to <code>injectLanguages</code></li> <li><code>elementsToInjectIn</code> removed</li> <li>Declaration changed  from <code>&lt;multiHostInjector implementation=\"org.intellij.plugins.intelliLang.inject.xml.XmlLanguageInjector\"/&gt;</code> to <code>&lt;multiHostInjector forClass=\"com.intellij.psi.xml.XmlAttributeValue\" implementationClass=\"org.intellij.plugins.intelliLang.inject.xml.XmlLanguageInjector\"/&gt;</code>  Attribute <code>forClass</code> is value of <code>elementsToInjectIn</code> method</li> </ul> </li> </ul> </li> <li>Module Facets &amp; Module Types was replaced by Module Extensions</li> <li>JPS support was dropped, that why external build is not supported for now</li> <li><code>com.intellij.openapi.module.Module.getModuleFilePath</code> dropped due, Consulo dont have module files, all info stored in .consulo dir.    Use <code>com.intellij.openapi.module.Module#getModuleDirPath</code> for it</li> <li>.impl &amp; .ipr files are not supported anymore. Now all module info stored in <code>.consulo</code> dir</li> </ul>"},{"location":"basics/intellij_coding_guidelines/","title":"Consulo Coding Guidelines","text":"<p>If you are writing code that you would like to contribute to the Consulo (either as a patch or as a plugin), following these guidelines will make it easier for the JetBrains development team to review and accept your changes.</p>"},{"location":"basics/intellij_coding_guidelines/#following-the-latest-source-code","title":"Following the Latest Source Code","text":"<p>If you submit patches, we strongly recommend building your patches against the latest version of the code from the Git repository. The easiest way to do so is to clone the JetBrains Git repository, track your work in Git, and create patches using the \"git format-patch\" command.</p>"},{"location":"basics/intellij_coding_guidelines/#general-architectural-principles","title":"General Architectural Principles","text":"<p>Please do your best to follow common Java architectural principles. \"Effective Java\" by Joshua Bloch is the right place to start.</p>"},{"location":"basics/intellij_coding_guidelines/#tests","title":"Tests","text":"<p>Functional tests cover most of the existing functionality of IntelliJ IDEA. If tests cover the area you're modifying, you must run the tests and make sure that your changes do not introduce any new test failures. It's also strongly recommended that you provide new functional tests that cover the bugs you fix or the new features that you add.</p>"},{"location":"basics/intellij_coding_guidelines/#code-formatting","title":"Code Formatting","text":"<p>We're generally pretty lax about code formatting, but at least the following conventions must be observed:</p> <ul> <li>2 space indents in source files</li> <li>my prefix for instance variables and our prefix for class variables</li> <li>new source code files must include a copyright statement with the Apache 2 license and the name of the contributor.</li> </ul> <p>The easiest way to follow our code formatting guidelines is to reformat your code submissions using the shared code style, which is included in the IntelliJ IDEA Community Edition project directory.</p>"},{"location":"basics/intellij_coding_guidelines/#inspections","title":"Inspections","text":"<p>The IntelliJ IDEA Community Edition project includes a shared inspection profile. We strongly recommend making sure that the code you submit does not contain any warnings highlighted by the inspections configured in that inspection profile.</p>"},{"location":"basics/intellij_coding_guidelines/#javadoc-comments","title":"JavaDoc Comments","text":"<p>If your code adds new OpenAPI interfaces, classes, methods, or extension points, you must provide JavaDoc comments describing the parameters and intended usage of the APIs. Providing JavaDoc or other comments for other parts of the code is a good idea but isn't required.</p>"},{"location":"basics/intellij_coding_guidelines/#commits","title":"Commits","text":"<p>To avoid unnecessary work when reviewing your changes, please follow these guidelines:</p> <ul> <li>Look through all of your changes in your patch or pull request before you submit it to us.   Make sure that everything you've changed is there for a reason.</li> <li>Please don't include unfinished work to the patch.   Make sure that it doesn't contain any TODO comments.   If you added some code and ended up not needing it, please make sure that you delete it before you submit your patch.</li> <li>Please don't include any changes that affect formatting, fixing \"yellow code\" (warnings), or code style along with actual changes that fix a bug or implement a feature.   No one likes to leave poor code, but remember that having these changes mixed complicates the process of review.</li> <li>Please don't fix multiple problems within a single patch or pull request.</li> <li>Please don't commit your changes to configuration files (runConfigurations/IDEA.xml, codeStyleSettings.xml, misc.xml, etc.) unless it is essential for the fix itself.</li> <li>Please avoid moving or renaming classes unless it is necessary for the fix.</li> </ul> <p>The ideal pull request would contain one commit with everything needed to fix the bug or implement a feature, but nothing else. \"Commit early, commit often\" perfectly applies only to local commits, but such \"public commits\" are hard to review (the reviewer needs either to go commit by commit spending more time to review work-in-progress, or to review all changes at once thus losing valuable information stored in commit messages).</p> <p>The best would be to commit early, but then to squash all commits into one with a descriptive commit message.</p> <p>Sometimes several commits for a single issue are also acceptable, but each of these should be self-contained \"steps\" to solve the problem.</p>"},{"location":"basics/persistence/","title":"Persistence Model","text":"<p>The Consulo Persistence Model is used to store a variety of information. For example, Run Configurations and Settings are stored using the Persistence Model.</p> <p>There are two distinct approaches, depending on the type of data being persisted: * Persisting State of Components * Persisting Sensitive Data</p>"},{"location":"basics/persisting_sensitive_data/","title":"Persisting Sensitive Data","text":"<p>The Credentials Store API allows you to store sensitive user data securely, like passwords, server URLs, etc.</p>"},{"location":"basics/persisting_sensitive_data/#how-to-use","title":"How to Use","text":"<p>Use <code>PasswordSafe</code> to work with credentials.</p>"},{"location":"basics/persisting_sensitive_data/#retrieve-stored-credentials","title":"Retrieve Stored Credentials","text":"<pre><code>    String key = null; // e.g. serverURL, accountID\n    CredentialAttributes credentialAttributes = createCredentialAttributes(key);\n\n    Credentials credentials = PasswordSafe.getInstance().get(credentialAttributes);\n    if (credentials != null) {\n      String password = credentials.getPasswordAsString();\n    }\n\n    // or get password only\n    String password = PasswordSafe.getInstance().getPassword(credentialAttributes);\n\n    private CredentialAttributes createCredentialAttributes(String key) {\n        return new CredentialAttributes(CredentialAttributesKt.generateServiceName(\"MySystem\", key));\n    }\n</code></pre>"},{"location":"basics/persisting_sensitive_data/#store-credentials","title":"Store Credentials","text":"<pre><code>    CredentialAttributes credentialAttributes = createCredentialAttributes(serverId); // see previous sample\n    Credentials credentials = new Credentials(username, password);\n    PasswordSafe.getInstance().set(credentialAttributes, credentials);\n</code></pre> <p>To remove stored credentials, pass <code>null</code> for the <code>credentials</code> parameter.</p>"},{"location":"basics/persisting_sensitive_data/#storage","title":"Storage","text":"<p>The default storage format depends on the OS.</p> OS Storage Windows File in KeePass format macOS Keychain using Security Framework Linux Secret Service API using [libsecret][linux2] <p>Users can override the default behavior in Preferences | Appearance &amp; Behavior | System Settings | Passwords.</p>"},{"location":"basics/persisting_state_of_components/","title":"Persisting State of Components","text":"<p>The Consulo provides an API that allows components or services to persist their state between restarts of the IDE. You can use either a simple API to persist a few values or persist the state of more complicated components using the <code>PersistentStateComponent</code> interface.</p> <p>WARNING If you need to persist sensitive data like passwords, please see Persisting Sensitive Data.</p>"},{"location":"basics/persisting_state_of_components/#using-propertiescomponent-for-simple-non-roamable-persistence","title":"Using PropertiesComponent for Simple Non-Roamable Persistence","text":"<p>If the plugin needs to persist just a few simple values, the easiest way to do so is to use the <code>com.intellij.ide.util.PropertiesComponent</code> service. It can save both application-level values and project-level values in the workspace file. Roaming is disabled for <code>PropertiesComponent</code>, so use it only for temporary, non-roamable properties.</p> <p>Use the <code>PropertiesComponent.getInstance()</code> method for storing application-level values, and the <code>PropertiesComponent.getInstance(Project)</code> method for storing project-level values.</p> <p>Since all plugins share the same namespace, it is highly recommended to prefix key names (e.g., using plugin ID <code>com.myplugin.myCustomSetting</code>).</p>"},{"location":"basics/persisting_state_of_components/#using-persistentstatecomponent","title":"Using PersistentStateComponent","text":"<p>The <code>com.intellij.openapi.components.PersistentStateComponent</code> interface gives you the most flexibility for defining the values to be persisted, their format, and storage location.</p> <p>To use it: - mark a service as implementing the <code>PersistentStateComponent</code> interface - define the state class - specify the storage location using <code>@com.intellij.openapi.components.State</code></p> <p>Note that instances of extensions cannot persist their state by implementing <code>PersistentStateComponent</code>. If your extension needs to have a persistent state, you need to define a separate service responsible for managing that state.</p>"},{"location":"basics/persisting_state_of_components/#implementing-the-persistentstatecomponent-interface","title":"Implementing the PersistentStateComponent Interface","text":"<p>The implementation of <code>PersistentStateComponent</code> needs to be parameterized with the type of state class. The state class can either be a separate JavaBean class, or the class implementing <code>PersistentStateComponent</code>.</p> <p>In the former case, the state class instance is typically stored as a field in the <code>PersistentStateComponent</code> class:</p> <pre><code>@State(...)\nclass MyService implements PersistentStateComponent&lt;MyService.State&gt; {\n\n  static class State {\n    public String value;\n  }\n\n  private State myState = new State();\n\n  public State getState() {\n    return myState;\n  }\n\n  public void loadState(State state) {\n    myState = state;\n  }\n}\n</code></pre> <p>In the latter case, you can use the following pattern to implement <code>getState()</code> and <code>loadState()</code> methods:</p> <pre><code>@State(...)\nclass MyService implements PersistentStateComponent&lt;MyService&gt; {\n  public String stateValue;\n\n  public MyService getState() {\n    return this;\n  }\n\n  public void loadState(MyService state) {\n    XmlSerializerUtil.copyBean(state, this);\n  }\n}\n</code></pre>"},{"location":"basics/persisting_state_of_components/#implementing-the-state-class","title":"Implementing the State Class","text":"<p>The implementation of <code>PersistentStateComponent</code> works by serializing public fields, annotated private fields (see also Customizing the XML format of persisted values), and bean properties into an XML format.</p> <p>To exclude a public field or bean property from serialization, annotate the field or getter with <code>@com.intellij.util.xmlb.annotations.Transient</code>.</p> <p>Note that the state class must have a default constructor. It should return the component's default state: the one used if there is nothing persisted in the XML files yet.</p> <p>State class should have an <code>equals()</code> method, but state objects are compared by fields if it is not implemented. When using Kotlin, use Data Classes.</p> <p>The following types of values can be persisted:</p> <ul> <li>numbers (both primitive types, such as <code>int</code>, and boxed types, such as <code>Integer</code>)</li> <li>booleans</li> <li>strings</li> <li>collections</li> <li>maps</li> <li>enums</li> </ul> <p>For other types, extend <code>com.intellij.util.xmlb.Converter</code>:</p> <pre><code>class LocalDateTimeConverter extends Converter&lt;LocalDateTime&gt; {\n  public LocalDateTime fromString(String value) {\n    final long epochMilli = Long.parseLong(value);\n    final ZoneId zoneId = ZoneId.systemDefault();\n    return Instant.ofEpochMilli(epochMilli).atZone(zoneId).toLocalDateTime();\n  }\n\n  public String toString(LocalDateTime value) {\n    final ZoneId zoneId = ZoneId.systemDefault();\n    final long toEpochMilli = value.atZone(zoneId).toInstant().toEpochMilli();\n    return Long.toString(toEpochMilli);\n  }\n}\n</code></pre> <p>Define the converter above in <code>@com.intellij.util.xmlb.annotations.OptionTag</code> or <code>@com.intellij.util.xmlb.annotations.Attribute</code>:</p> <pre><code>class State {\n  @OptionTag(converter = LocalDateTimeConverter.class)\n  public LocalDateTime dateTime;\n}\n</code></pre>"},{"location":"basics/persisting_state_of_components/#defining-the-storage-location","title":"Defining the Storage Location","text":"<p>To specify where precisely the persisted values are stored, add <code>@State</code> annotation to the <code>PersistentStateComponent</code> class.</p> <p>It has the following fields: * <code>name</code> (required) \u2014 specifies the name of the state (name of the root tag in XML). * <code>storages</code> \u2014 one or more of <code>@com.intellij.openapi.components.Storage</code> annotations to specify the storage locations.   Optional for project-level values \u2014 standard project file is used in this case. * <code>reloadable</code> (optional) \u2014 if set to false, complete project (or application) reload is required when the XML file is changed externally, and the state has changed.</p> <p>The simplest ways of specifying the <code>@Storage</code> annotation are as follows (since 2016.x; for previous versions, please see old version of this document):</p> <ul> <li> <p><code>@Storage(\"yourName.xml\")</code> If a component is project-level \u2014 for <code>.ipr</code> based projects standard project file is used automatically - no need to specify anything.</p> </li> <li> <p><code>@Storage(StoragePathMacros.WORKSPACE_FILE)</code> for values stored in the workspace file.</p> </li> </ul> <p>The state is persisted in a separate file by specifying a different setting for the <code>value</code> parameter, which was the <code>file</code> parameter before 2016.x.</p> <p>NOTE For application-level components, it is strongly recommended to use a custom file, using of <code>other.xml</code> is deprecated.</p> <p>The <code>roamingType</code> parameter of the <code>@Storage</code> annotation specifies the roaming type when the Settings Repository plugin is used.</p>"},{"location":"basics/persisting_state_of_components/#customizing-the-xml-format-of-persisted-values","title":"Customizing the XML Format of Persisted Values","text":"<p>NOTE Please consider using annotation parameters only to achieve backward compatibility. Otherwise, please feel free to file issues about serialization cosmetics.</p> <p>If you want to use the default bean serialization but need to customize the storage format in XML (for example, for compatibility with previous versions of your plugin or externally defined XML formats), you can use the <code>@Tag</code>, <code>@Attribute</code>, <code>@Property</code>, <code>@MapAnnotation</code>, <code>@AbstractCollection</code> annotations.</p> <p>Please see <code>com.intellij.util.xmlb.annotations</code>'s <code>package.html</code> for more information.</p> <p>If the state you need to serialize doesn't map cleanly to a JavaBean, you can use <code>org.jdom.Element</code> as the state class. In that case, you can use the <code>getState()</code> method to build an XML element with an arbitrary structure, which then is saved directly in the state XML file. In the <code>loadState()</code> method, you can deserialize the JDOM element tree using any custom logic. Please note this is not recommended and should be avoided whenever possible.</p>"},{"location":"basics/persisting_state_of_components/#migrating-persisted-values","title":"Migrating Persisted Values","text":"<p>If the underlying persistence model or storage format has changed, a <code>ConverterProvider</code> can provide <code>ProjectConverter</code> whose <code>getAdditionalAffectedFiles()</code> method returns affected files to migrate and performs programmatic migration of stored values.</p>"},{"location":"basics/persisting_state_of_components/#persistent-component-lifecycle","title":"Persistent Component Lifecycle","text":"<p>The <code>loadState()</code> method is called after the component has been created (only if there is some non-default state persisted for the component), and after the XML file with the persisted state is changed externally (for example, if the project file was updated from the version control system). In the latter case, the component is responsible for updating the UI and other related components according to the changed state.</p> <p>The <code>getState()</code> method is called every time the settings are saved (for example, on frame deactivation or when closing the IDE). If the state returned from <code>getState()</code> is equal to the default state (obtained by creating the state class with a default constructor), nothing is persisted in the XML. Otherwise, the returned state is serialized in XML and stored.</p>"},{"location":"basics/persisting_state_of_components/#legacy-api-jdomexternalizable","title":"Legacy API (JDOMExternalizable)","text":"<p>Older components use the <code>JDOMExternalizable</code> interface for persisting state. It uses the <code>readExternal()</code> method for reading the state from a JDOM element, and <code>writeExternal()</code> to write the state.</p> <p>Implementations can manually store the state in attributes and sub-elements or use the <code>DefaultJDOMExternalizer</code> class to store the values of all public fields automatically.</p> <p>Components save their state in the following files:</p> <ul> <li>Project-level: project (<code>.ipr</code>) file.   However, if the workspace option in the <code>plugin.xml</code> file is set to <code>true</code>, then the workspace (<code>.iws</code>) file is used instead.</li> <li>Module-level: module (<code>.iml</code>) file.</li> </ul>"},{"location":"basics/platform_contributions/","title":"Contributing to the Consulo","text":"<p>Please make sure to read the Code of Conduct.</p>"},{"location":"basics/platform_contributions/#participate-in-the-community","title":"Participate in the Community","text":""},{"location":"basics/platform_contributions/#participate-in-newsgroups-and-forums","title":"Participate in Newsgroups and Forums","text":"<p>There are several community forums and newsgroups you can join to discuss the Consulo. The forums are an excellent source for users and contributors interested in having technical discussions, answering questions, or resolving potential issues for newcomers.</p>"},{"location":"basics/platform_contributions/#link-to-jetbrainsorg","title":"Link to jetbrains.org","text":"<p>The success of any open-source project depends on the number of people who use the product and contribute back to the project. By linking to jetbrains.org, you can increase the chances of a new user or contributor finding out about the project and joining the community.</p> <p>If you're as excited about IntelliJ IDEA Community Edition as we are, you can show it by linking to us. Project logos and other assets are also available.</p>"},{"location":"basics/platform_contributions/#promote-consulo-and-intellij-idea-community-edition","title":"Promote Consulo and IntelliJ IDEA Community Edition","text":"<p>Help promote the platform and IDE by using your blog, Twitter, Facebook, or submitting an article to your favorite local magazine. If you are a member of a different open-source community, why not mention IntelliJ IDEA on their discussion forums or at conferences? If you love IntelliJ IDEA, don't hold back - speak up! The more developers use IntelliJ IDEA, the more bugs will be caught, the more plugins will be written, the more visible the project, and the more benefits the community will get!</p>"},{"location":"basics/platform_contributions/#help-others-learn","title":"Help Others Learn","text":""},{"location":"basics/platform_contributions/#write-documents","title":"Write Documents","text":"<p>We're always looking for new articles about IntelliJ IDEA features as well as documentation for the Consulo. You can write tutorials, how-tos, sample applications, or share your experience with the Consulo. You can publish your documentation on a website or blog, or submit a pull request to the SDK Docs.</p>"},{"location":"basics/platform_contributions/#produce-screencasts","title":"Produce Screencasts","text":"<p>Screencasts have recently become very popular as a way to show other developers how to use the tool effectively. You can record a screencast about a particular feature or use case you discovered and would like to share it with the community.</p>"},{"location":"basics/platform_contributions/#contribute-code","title":"Contribute Code","text":""},{"location":"basics/platform_contributions/#file-a-bug-report","title":"File a Bug Report","text":"<p>Bug reports take little time to file and are very helpful to developers. This is one of the easiest contributions you can make. When you discover a problem with the IDE or the platform, please report it. Make sure you provide information about your environment (OS, JDK version), steps to reproduce the issue, as well as a written description of the problem. You can file a bug in our YouTrack issue tracker. Before submitting an issue, please search for already submitted ones describing the same problem - and if you find one, feel free to vote for it.</p>"},{"location":"basics/platform_contributions/#help-triage-existing-bug-reports","title":"Help Triage Existing Bug Reports","text":"<p>Over the years, users have submitted thousands of issues to the IntelliJ issue tracker. Many of the unresolved issues are no longer applicable to the latest version of IntelliJ IDEA, are duplicates, or require additional information to be resolved. Leaving comments notifying about the status of such issues helps the team keep the issue tracker clean and useful for everyone.</p>"},{"location":"basics/platform_contributions/#write-a-plugin","title":"Write a Plugin","text":"<p>One of the best ways to contribute a larger piece of code, adding extra functionality to IntelliJ IDEA or any of the other Consulo-based IDEs, is by writing a plugin. You can submit a plugin to the JetBrains Plugins Repository, making it available for all users. When writing a plugin, you have control over the code and don't need to sign the contribution agreement.</p>"},{"location":"basics/platform_contributions/#submit-a-patch","title":"Submit a Patch","text":"<p>If you would like to improve the code in the Consulo or the core functionality of IntelliJ IDEA, you can submit a patch in the YouTrack bug database. You can either file a new issue with the patch attached or attach a patch to an issue submitted by another user. When writing a patch, please make sure to follow the Consulo Coding Guidelines.</p> <p>Alternatively, you can fork the IntelliJ IDEA Community Edition repository on GitHub, make the changes in your fork and send us a pull request. A developer will review your patch and, if it meets the quality criteria and fits well with the rest of the code, you'll be notified about the acceptance of the patch. You will also need to sign the JetBrains Contributor License Agreement (CLA) to complete your contribution.</p>"},{"location":"basics/platform_contributions/#become-a-committer","title":"Become a Committer","text":"<p>Developers with a long history of submitting high-quality patches can gain direct commit rights.</p>"},{"location":"basics/plugin_structure/","title":"Plugin Structure","text":"<p>Click the following topics to learn more about the plugin system structure and plugin lifecycles:</p> <ul> <li>Plugin Content</li> <li>Plugin Class Loaders</li> <li>Plugin Actions</li> <li>Plugin Extensions</li> <li>Plugin Services</li> <li>Plugin Listeners</li> <li>Plugin Extension Points</li> <li>Plugin Components</li> <li>Plugin Configuration File</li> <li>Plugin Logo (Icon)</li> <li>Plugin Dependencies</li> </ul>"},{"location":"basics/project_structure/","title":"Project Structure","text":"<p>This topic considers the concept of projects based on the Consulo and related subjects, such as modules, libraries, and SDK.</p>"},{"location":"basics/project_structure/#project-and-its-components","title":"Project and Its Components","text":"<p>This section briefly discusses the Consulo project structure, project components, and related terms. For more information about projects and their components, refer to Project, Module, Library, Facet in the IntelliJ IDEA Web Help.</p>"},{"location":"basics/project_structure/#project","title":"Project","text":"<p>In the Consulo, a project encapsulates all of a project's source code, libraries, and build instructions into a single organizational unit. Everything done using the Consulo SDK is done within the context of a project. A project defines collections referred to as modules and libraries. Depending on the project's logical and functional requirements, you can create a single-module or a multi-module project.</p>"},{"location":"basics/project_structure/#module","title":"Module","text":"<p>A module is a discrete unit of functionality that can be run, tested, and debugged independently. Modules include such things as source code, build scripts, unit tests, deployment descriptors, etc. In a project, each module can use a specific SDK or inherit the SDK defined at the project level (see the SDK section below in this document). A module can depend on other modules of the project.</p>"},{"location":"basics/project_structure/#library","title":"Library","text":"<p>A library is an archive of compiled code (such as JAR files) on which modules depend. The Consulo supports three types of libraries: * Module Library: the library classes are visible only in this module, and the library information is recorded in the module's <code>.iml</code> file. * Project Library: the library classes are visible within the project, and the library information is recorded in the project's <code>.ipr</code> file or in <code>.idea/libraries</code>.</p> <p>For more information about libraries, refer to Library.</p>"},{"location":"basics/project_structure/#sdk","title":"SDK","text":"<p>Every project uses a Software Development Kit (SDK). For Java projects, SDK is referred to as JDK (Java Development Kit).</p> <p>The SDK determines which API library is used to build the project. If a project is multi-module, the project SDK is common for all modules within the project by default. Optionally, a project can configure an individual SDK for each module.</p> <p>For more information about SDKs, see Working with SDKs in the IntelliJ IDEA Web Help.</p>"},{"location":"basics/project_structure/#facet","title":"Facet","text":"<p>A facet represents a certain configuration, specific for a particular framework/technology associated with a module. A module can have multiple facets. E.g., Spring-specific configuration is stored in a Spring facet.</p> <p>Facets are documented under Facet and Language and Framework Specific Guidelines in the IntelliJ IDEA Web Help.</p>"},{"location":"basics/project_structure/#additional-information","title":"Additional Information","text":"<p>For more information on each of these entities, see:</p> <ul> <li>Project</li> <li>Module</li> <li>SDK</li> <li>Library</li> <li>External system integration (for projects imported from Gradle or similar build systems)</li> </ul>"},{"location":"basics/project_view/","title":"Project View","text":"<ul> <li>Modifying Project View Structure</li> </ul>"},{"location":"basics/psi_cookbook/","title":"PSI Cookbook","text":"<p>This page gives recipes for the most common operations for working with the PSI (Program Structure Interface). Unlike Developing Custom Language Plugins, it talks about working with the PSI of existing languages (such as Java).</p> <p>TIP Please see also Working with PSI efficiently.</p>"},{"location":"basics/psi_cookbook/#how-do-i-find-a-file-if-i-know-its-name-but-dont-know-the-path","title":"How do I find a file if I know its name but don't know the path?","text":"<p><code>FilenameIndex.getFilesByName()</code></p>"},{"location":"basics/psi_cookbook/#how-do-i-find-where-a-particular-psi-element-is-used","title":"How do I find where a particular PSI element is used?","text":"<p><code>ReferencesSearch.search()</code></p>"},{"location":"basics/psi_cookbook/#how-do-i-rename-a-psi-element","title":"How do I rename a PSI element?","text":"<p><code>RefactoringFactory.createRename()</code></p>"},{"location":"basics/psi_cookbook/#how-can-i-cause-the-psi-for-a-virtual-file-to-be-rebuilt","title":"How can I cause the PSI for a virtual file to be rebuilt?","text":"<p><code>FileContentUtil.reparseFiles()</code></p>"},{"location":"basics/psi_cookbook/#java-specific","title":"Java Specific","text":""},{"location":"basics/psi_cookbook/#how-do-i-find-all-inheritors-of-a-class","title":"How do I find all inheritors of a class?","text":"<p><code>ClassInheritorsSearch.search()</code></p>"},{"location":"basics/psi_cookbook/#how-do-i-find-a-class-by-qualified-name","title":"How do I find a class by qualified name?","text":"<p><code>JavaPsiFacade.findClass()</code></p>"},{"location":"basics/psi_cookbook/#how-do-i-find-a-class-by-short-name","title":"How do I find a class by short name?","text":"<p><code>PsiShortNamesCache.getInstance().getClassesByName()</code></p>"},{"location":"basics/psi_cookbook/#how-do-i-find-a-superclass-of-a-java-class","title":"How do I find a superclass of a Java class?","text":"<p><code>PsiClass.getSuperClass()</code></p>"},{"location":"basics/psi_cookbook/#how-do-i-get-a-reference-to-the-containing-package-of-a-java-class","title":"How do I get a reference to the containing package of a Java class?","text":"<pre><code>PsiJavaFile javaFile = (PsiJavaFile) psiClass.getContainingFile();\nPsiPackage pkg = JavaPsiFacade.getInstance(project).findPackage(javaFile.getPackageName());\n</code></pre> <p>or</p> <p><code>com.intellij.psi.util.PsiUtil.getPackageName()</code></p>"},{"location":"basics/psi_cookbook/#how-do-i-find-the-methods-overriding-a-specific-method","title":"How do I find the methods overriding a specific method?","text":"<p><code>OverridingMethodsSearch.search()</code></p>"},{"location":"basics/run_configurations/","title":"Run Configurations","text":"<p>Run Configurations allow users to run specific external processes from within the IDE, e.g., a script, an application, a server, etc.  You can provide the UI for the user to specify execution options, and an option to create a run configuration based on a specific location in the source code.</p>"},{"location":"basics/run_configurations/#architectural-overview","title":"Architectural Overview","text":"<p>Classes used to manipulate run configurations can be split into the following groups:</p> <ul> <li>Run configuration management.   This includes creation, persistence, and modification.</li> <li>Execution.</li> </ul> <p>This diagram shows the main classes:</p> <p></p> <p>See Run Configurations Tutorial for a fully working sample.</p>"},{"location":"basics/settings/","title":"Settings","text":""},{"location":"basics/settings/#introduction-to-settings","title":"Introduction to Settings","text":"<p>Settings are but one application of the Consulo Persistence Model. For more information, see: * Settings Guide for information about Settings Extension Points and implementations. * Custom Settings Groups for information about creating custom Settings groups and parent-child relationships. * Settings Tutorial for step-by-step instructions for creating a simple set of custom Settings.</p>"},{"location":"basics/templates/","title":"Templates","text":"<ul> <li>Live Templates<ul> <li>Adding Live Templates to a Plugin</li> <li>Creating New Functions for Live Templates</li> <li>Surround Templates</li> </ul> </li> <li>File Templates</li> </ul>"},{"location":"basics/types_of_plugins/","title":"Main Types of Plugins","text":"<p>Products based on the Consulo can be modified and adjusted for custom purposes by adding plugins. All downloadable plugins are available at the JetBrains Plugins Repository.</p> <p>The most common types of plugins include:</p> <ul> <li>UI Themes</li> <li>Custom language support</li> <li>Framework integration</li> <li>Tool integration</li> <li>User interface add-ons</li> </ul>"},{"location":"basics/types_of_plugins/#ui-themes","title":"UI Themes","text":"<p>UI Themes give designers the ability to customize the appearance of built-in IDE UI elements. Custom UI Themes can:</p> <ul> <li>substitute icons,</li> <li>change the colors of icons and UI controls,</li> <li>alter the borders and insets of UI controls,</li> <li>provide custom editor schemes,</li> <li>add background images.</li> </ul> <p>The UI Themes available for download illustrate the creative possibilities.</p>"},{"location":"basics/types_of_plugins/#custom-language-support","title":"Custom Language Support","text":"<p>Custom language support provides basic functionality for working with a particular programming language, that includes:</p> <ul> <li>File type recognition</li> <li>Lexical analysis</li> <li>Syntax highlighting</li> <li>Formatting</li> <li>Code insight and code completion</li> <li>Inspections and quick-fixes</li> <li>Intention actions</li> </ul> <p>Plugins can also augment existing (bundled) custom languages, e.g., by providing additional inspections, intentions, or any other features.</p> <p>Refer to the Custom Language Support Tutorial to learn more about the topic.</p>"},{"location":"basics/types_of_plugins/#framework-integration","title":"Framework Integration","text":"<p>Framework integration consists of improved code insight features, which are typical for a given framework, as well as the option to use framework-specific functionality directly from the IDE. Sometimes it also includes language support elements for a custom syntax or DSL.</p> <ul> <li>Specific code insight</li> <li>Direct access to framework-specific functionality</li> </ul> <p>Refer to the Struts 2 plugin as an example of framework integration. More reference plugins can be found on JetBrains Plugins Repository.</p>"},{"location":"basics/types_of_plugins/#tool-integration","title":"Tool Integration","text":"<p>Tool integration makes it possible to manipulate third-party tools and components directly from the IDE without switching contexts, that implies:</p> <ul> <li>Implementation of additional actions</li> <li>Related UI components</li> <li>Access to external resources</li> </ul> <p>Refer to the Gerrit integration plugin as an example.</p>"},{"location":"basics/types_of_plugins/#user-interface-add-ons","title":"User Interface Add-Ons","text":"<p>Plugins in this category apply various changes to the standard user interface of the IDE. Some newly added components are interactive and provide new functionality, while others are limited to visual modifications only. The Random Background plugin may serve as an example.</p>"},{"location":"basics/virtual_file_system/","title":"Virtual File System","text":"<p>The virtual file system (VFS) is a component of the Consulo that encapsulates most of its activity for working with files represented as Virtual File.</p> <p>It serves the following main purposes:</p> <ul> <li>Providing a universal API for working with files regardless of their actual location (on disk, in an archive, on an HTTP server, etc.)</li> <li>Tracking file modifications and providing both old and new versions of the file content when a change is detected.</li> <li>Providing a possibility to associate additional persistent data with a file in the VFS.</li> </ul> <p>To provide the last two features, the VFS manages a persistent snapshot of some of the user's hard disk contents. The snapshot stores only those files which have been requested at least once through the VFS API, and is asynchronously updated to match the changes happening on the disk.</p> <p>The snapshot is application level, not project level - so, if some file (for example, a class in the JDK) is referenced by multiple projects, only one copy of its contents will be stored in the VFS.</p> <p>All VFS access operations go through the snapshot.</p> <p>If some information is requested through the VFS APIs and is not available in the snapshot, it is loaded from disk and stored into the snapshot. If the information is available in the snapshot, the snapshot data is returned. The contents of files and the lists of files in directories are stored in the snapshot only if that specific information was accessed. Otherwise, only file metadata like name, length, timestamp, attributes are stored.</p> <p>NOTE This means that the state of the file system and the file contents displayed in the Consulo UI comes from the snapshot, which may not always match the disk's actual contents. For example, in some cases, deleted files can still be visible in the UI for some time before the deletion is picked up by the Consulo.</p> <p>The snapshot is updated from disk during refresh operations, which generally happen asynchronously. All write operations made through the VFS are synchronous - i.e., the contents are saved to disk immediately.</p> <p>A refresh operation synchronizes the state of a part of the VFS with the actual disk contents. Refresh operations are explicitly invoked by the Consulo or plugin code - i.e., when a file is changed on disk while the IDE is running, the change will not be immediately picked up by the VFS. The VFS will be updated during the next refresh operation, which includes the file in its scope.</p> <p>Consulo refreshes the entire project contents asynchronously on startup. By default, it performs a refresh operation when the user switches to it from another app. Still, users can turn this off via Settings | Appearance &amp; Behavior | System Settings | Synchronize external changes [...].</p> <p>On Windows, Mac, and Linux, a native file watcher process is started that receives file change notifications from the file system and reports them to the Consulo. If a file watcher is available, a refresh operation looks only at the files that have been reported as changed by the file watcher. If no file watcher is present, a refresh operation walks through all directories and files in the refresh scope.</p> <p>Refresh operations are based on file timestamps. If a file's contents were changed, but its timestamp remained the same, the Consulo will not pick up the updated contents.</p> <p>There is currently no facility for removing files from the snapshot. If a file was loaded there once, it remains there forever unless it was deleted from the disk, and a refresh operation was called on one of its parent directories.</p> <p>The VFS itself does not honor ignored files listed in Settings | Editor | File Types and folders to ignore and excluded folders listed in Project Structure | Modules | Sources | Excluded. If the application code accesses them, the VFS will load and return their contents. In most cases, the ignored files and excluded folders must be skipped from processing by higher-level code.</p> <p>During the lifetime of a running instance of an Consulo IDE, multiple <code>VirtualFile</code> instances may correspond to the same disk file. They are equal, have the same <code>hashCode</code>, and share the user data.</p>"},{"location":"basics/virtual_file_system/#synchronous-and-asynchronous-refreshes","title":"Synchronous and Asynchronous Refreshes","text":"<p>From the point of view of the caller, refresh operations can be either synchronous or asynchronous. In fact, the refresh operations are executed according to their own threading policy. The synchronous flag simply means that the calling thread will be blocked until the refresh operation (which will most likely run on a different thread) is completed.</p> <p>Both synchronous and asynchronous refreshes can be initiated from any thread. If a refresh is initiated from a background thread, the calling thread must not hold a read action, because otherwise, a deadlock would occur. See Consulo Architectural Overview for more details on the threading model and read/write actions.</p> <p>The same threading requirements also apply to functions like <code>LocalFileSystem.refreshAndFindFileByPath()</code>, which perform a partial refresh if the file with the specified path is not found in the snapshot.</p> <p>In nearly all cases, using asynchronous refreshes is strongly preferred. If there is some code that needs to be executed after the refresh is complete, the code should be passed as a <code>postRunnable</code> parameter to one of the refresh methods:</p> <ul> <li><code>RefreshQueue.createSession()</code></li> <li><code>VirtualFile.refresh()</code></li> </ul> <p>In some cases, synchronous refreshes can cause deadlocks, depending on which locks are held by the thread invoking the refresh operation.</p>"},{"location":"basics/virtual_file_system/#virtual-file-system-events","title":"Virtual File System Events","text":"<p>All changes happening in the virtual file system, either due to refresh operations or caused by user actions, are reported as virtual file system events. VFS events are always fired in the event dispatch thread and in a write action.</p> <p>The most efficient way to listen to VFS events is to implement <code>BulkFileListener</code> and to subscribe with it to the <code>VirtualFileManager.VFS_CHANGES</code> topic. A non-blocking variant <code>AsyncFileListener</code> is also available in 2019.2 or later. See How do I get notified when VFS changes? for implementation details.</p> <p>WARNING VFS listeners are application level and will receive events for changes happening in all the projects opened by the user. You may need to filter out events that aren't relevant to your task (e.g., via <code>ProjectFileIndex.isInContent()</code>).</p> <p>VFS events are sent both before and after each change, and you can access the old contents of the file in the before event. Note that events caused by a refresh are sent after the changes have already occurred on disk. So when you process the <code>beforeFileDeletion</code> event, for example, the file has already been deleted from disk. However, it is still present in the VFS snapshot, and you can access its last contents using the VFS API.</p> <p>Note that a refresh operation fires events only for changes in files that have been loaded in the snapshot. For example, if you accessed a <code>VirtualFile</code> for a directory but never loaded its contents using <code>VirtualFile.getChildren()</code>, you may not get <code>fileCreated</code> notifications when files are created in that directory.</p> <p>If you loaded only a single file in a directory using <code>VirtualFile.findChild()</code>, you will get notifications for changes to that file, but you may not get created/deleted notifications for other files in the same directory.</p>"},{"location":"basics/architectural_overview/documents/","title":"Documents","text":"<p>A <code>Document</code> is an editable sequence of Unicode characters, typically corresponding to the text contents of a virtual file.</p> <p>Line breaks in a document are always normalized to <code>\\n</code>. The Consulo handles encoding and line break conversions when loading and saving documents transparently.</p>"},{"location":"basics/architectural_overview/documents/#how-do-i-get-a-document","title":"How do I get a document?","text":"<p>From an action : <code>e.getData(PlatformDataKeys.EDITOR).getDocument()</code></p> <p>From a virtual file : <code>FileDocumentManager.getDocument()</code>. This call forces the document content to be loaded from disk if it wasn't loaded previously. If only open documents or documents which may have been modified are considered relevant, use <code>FileDocumentManager.getCachedDocument()</code> instead.</p> <p>From a PSI file : <code>PsiDocumentManager.getInstance().getDocument()</code> or <code>PsiDocumentManager.getInstance().getCachedDocument()</code></p>"},{"location":"basics/architectural_overview/documents/#what-can-i-do-with-a-document","title":"What can I do with a Document?","text":"<p>You may perform any operations that access or modify the file contents on the \"plain text\" level (as a sequence of characters, not as a tree of PSI elements).</p>"},{"location":"basics/architectural_overview/documents/#where-does-a-document-come-from","title":"Where does a Document come from?","text":"<p>Document instances are created when some operation needs to access the text contents of a file (in particular, this is necessary to build the PSI for a file). Also, document instances not linked to any virtual files can be created temporarily, for example, representing the contents of a text editor field in a dialog.</p>"},{"location":"basics/architectural_overview/documents/#how-long-does-a-document-persist","title":"How long does a Document persist?","text":"<p>Document instances are weakly referenced from <code>VirtualFile</code> instances. Thus, an unmodified <code>Document</code> instance can be garbage-collected if no one references it, and a new instance is created if the document contents are reaccessed later.</p> <p>WARNING Storing <code>Document</code> references in long-term data structures of a plugin will cause memory leaks.</p>"},{"location":"basics/architectural_overview/documents/#how-do-i-create-a-document","title":"How do I create a Document?","text":"<p>For creating a new file on disk, please do not create a <code>Document</code> but a PSI file and get its <code>Document</code>. To create a <code>Document</code> instance that isn't bound to anything, use <code>EditorFactory.createDocument()</code>.</p>"},{"location":"basics/architectural_overview/documents/#how-do-i-get-notified-when-documents-change","title":"How do I get notified when Documents change?","text":"<ul> <li><code>Document.addDocumentListener()</code> allows receiving notifications about changes in a particular <code>Document</code> instance.</li> <li><code>EditorFactory.getEventMulticaster().addDocumentListener()</code> allows receiving notifications about changes in all open documents.</li> <li>Subscribe to <code>AppTopics.FILE_DOCUMENT_SYNC</code> on any level bus to receive notifications when a <code>Document</code> is saved or reloaded from disk.</li> </ul>"},{"location":"basics/architectural_overview/documents/#what-are-the-rules-of-working-with-documents","title":"What are the rules of working with Documents?","text":"<p>The general read/write action rules are in effect. Besides, any operations which modify the contents of the document must be wrapped in a command (<code>CommandProcessor.getInstance().executeCommand()</code>). <code>executeCommand()</code> calls can be nested, and the outermost <code>executeCommand()</code> call is added to the undo stack. If multiple documents are modified within a command, undoing this command will, by default, show a confirmation dialog to the user.</p> <p>If the file corresponding to a <code>Document</code> is read-only (for example, not checked out from the version control system), document modifications will fail. Thus, before modifying the <code>Document</code>, it is necessary to call <code>ReadonlyStatusHandler.getInstance(project).ensureFilesWritable()</code> to check out the file.</p> <p>All text strings passed to <code>Document</code> modification methods (<code>setText()</code>, <code>insertString()</code>, <code>replaceString()</code>) must use only <code>\\n</code> as line separators.</p>"},{"location":"basics/architectural_overview/documents/#are-there-any-utilities-available-for-working-with-documents","title":"Are there any utilities available for working with Documents?","text":"<p><code>DocumentUtil</code> contains utility methods for <code>Document</code> processing. This allows you to get information like the text offsets of particular lines. This is particularly useful when you need text location/offset information about a given <code>PsiElement</code>.</p>"},{"location":"basics/architectural_overview/file_view_providers/","title":"File View Providers","text":"<p>A file view provider (<code>FileViewProvider</code>) manages access to multiple PSI trees within a single file.</p> <p>For example, a JSPX page has a separate PSI tree for the Java code in it (<code>PsiJavaFile</code>), a separate tree for the XML code (<code>XmlFile</code>), and a separate tree for JSP as a whole (<code>JspFile</code>).</p> <p>Each of the PSI trees covers the entire contents of the file and contains special \"outer language elements\" in the places where contents in a different language can be found.</p> <p>A <code>FileViewProvider</code> instance corresponds to a single <code>VirtualFile</code>, a single <code>Document</code>, and can retrieve multiple <code>PsiFile</code> instances.</p>"},{"location":"basics/architectural_overview/file_view_providers/#how-do-i-get-a-fileviewprovider","title":"How do I get a FileViewProvider?","text":"<ul> <li>From a <code>VirtualFile</code>: <code>PsiManager.getInstance(project).findViewProvider()</code></li> <li>From a <code>PsiFile</code>: <code>psiFile.getViewProvider()</code></li> </ul>"},{"location":"basics/architectural_overview/file_view_providers/#what-can-i-do-with-a-fileviewprovider","title":"What can I do with a FileViewProvider?","text":"<ul> <li>To get the set of all languages for which PSI trees exist in a file: <code>fileViewProvider.getLanguages()</code></li> <li>To get the PSI tree for a particular language: <code>fileViewProvider.getPsi(language)</code>.   For example, to get the PSI tree for XML, use <code>fileViewProvider.getPsi(XMLLanguage.INSTANCE)</code>.</li> <li>To find an element of a particular language at the specified offset in the file: <code>fileViewProvider.findElementAt(offset, language)</code></li> </ul>"},{"location":"basics/architectural_overview/file_view_providers/#how-do-i-extend-the-fileviewprovider","title":"How do I extend the FileViewProvider?","text":"<p>To create a file type that has multiple interspersing trees for different languages, a plugin must contain an extension to the <code>com.intellij.fileType.fileViewProviderFactory</code> extension point.</p> <p>Implement <code>FileViewProviderFactory</code> and return your <code>FileViewProvider</code> implementation from <code>createFileViewProvider()</code> method.</p> <p>Register as follows in <code>plugin.xml</code>:</p> <pre><code>&lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n  &lt;fileType.fileViewProviderFactory filetype=\"%file_type%\" implementationClass=\"com.plugin.MyFileViewProviderFactory\" /&gt;\n&lt;/extensions&gt;\n</code></pre> <p>Where <code>%file_type%</code> refers to the type of the file being created (for example, \"JFS\").</p>"},{"location":"basics/architectural_overview/files/","title":"Files","text":"<ul> <li>Virtual File System</li> <li>Virtual Files</li> </ul>"},{"location":"basics/architectural_overview/general_threading_rules/","title":"General Threading Rules","text":""},{"location":"basics/architectural_overview/general_threading_rules/#readwrite-lock","title":"Read/Write Lock","text":"<p>In general, code-related data structures in the Consulo are covered by a single reader/writer lock.</p> <p>You must not access the model outside a read or write action for the following subsystems: - Program Structure Interface (PSI) - Virtual File System (VFS) - Project root model.</p> <p>Reading data is allowed from any thread. Reading data from the UI thread does not require any special effort. However, read operations performed from any other thread need to be wrapped in a read action by using <code>ApplicationManager.getApplication().runReadAction()</code> or, shorter, <code>ReadAction</code> <code>run()</code>/<code>compute()</code>. The corresponding objects are not guaranteed to survive between several consecutive read actions. As a rule of thumb, whenever starting a read action, check if the PSI/VFS/project/module is still valid.</p> <p>Writing data is only allowed from the UI thread, and write operations always need to be wrapped in a write action with <code>ApplicationManager.getApplication().runWriteAction()</code> or, shorter, <code>WriteAction</code> <code>run()</code>/<code>compute()</code>. Modifying the model is only allowed from write-safe contexts, including user actions and <code>invokeLater()</code> calls from them (see the next section). You may not modify PSI, VFS, or project model from inside UI renderers or <code>SwingUtilities.invokeLater()</code> calls.</p>"},{"location":"basics/architectural_overview/general_threading_rules/#modality-and-invokelater","title":"Modality and <code>invokeLater()</code>","text":"<p>To pass control from a background thread to the Event Dispatch Thread (EDT), instead of the standard <code>SwingUtilities.invokeLater()</code>, plugins should use <code>ApplicationManager.getApplication().invokeLater()</code>. The latter API allows specifying the modality state (<code>ModalityState</code>) for the call, i.e., the stack of modal dialogs under which the call is allowed to execute:</p> <p><code>ModalityState.NON_MODAL</code> : The operation will be executed after all modal dialogs are closed. If any of the open (unrelated) project displays a per-project modal dialog, the action will be performed after the dialog is closed.</p> <p><code>ModalityState.stateForComponent()</code> : The operation can be executed when the topmost shown dialog is the one that contains the specified component or is one of its parent dialogs.</p> <p>None specified : <code>ModalityState.defaultModalityState()</code> will be used. This is the optimal choice in most cases that uses the current modality state when invoked from UI thread. It has special handling for background processes started with <code>ProgressManager</code>: <code>invokeLater()</code> from such a process may run in the same dialog that the process started.</p> <p><code>ModalityState.any()</code> : The operation will be executed as soon as possible regardless of modal dialogs. Please note that modifying PSI, VFS, or project model is prohibited from such runnables.</p> <p>If a UI thread activity needs to access file-based index (e.g., it's doing any project-wide PSI analysis, resolves references, etc.), please use <code>DumbService.smartInvokeLater()</code>. That way, it is run after all possible indexing processes have been completed.</p>"},{"location":"basics/architectural_overview/general_threading_rules/#background-processes-and-processcanceledexception","title":"Background processes and <code>ProcessCanceledException</code>","text":"<p>Background progresses are managed by <code>ProgressManager</code> class,  which has plenty of methods to execute the given code with a modal (dialog), non-modal (visible in the status bar), or invisible progress. In all cases, the code is executed on a background thread, which is associated with a <code>ProgressIndicator</code> object. The current thread's indicator can be retrieved any time via <code>ProgressIndicatorProvider.getGlobalProgressIndicator()</code>.</p> <p>For visible progresses, threads can use <code>ProgressIndicator</code> to notify the user about current status: e.g., set text or visual fraction of the work done.</p> <p>Progress indicators also provide means to handle cancellation of background processes, either by the user (pressing the Cancel button) or from code (e.g., when the current operation becomes obsolete due to some changes in the project). The progress can be marked as canceled by calling <code>ProgressIndicator.cancel()</code>. The process reacts to this by calling <code>ProgressIndicator.checkCanceled()</code> (or <code>ProgressManager.checkCanceled()</code> if no indicator instance at hand). This call throws a special unchecked <code>ProcessCanceledException</code> if the background process has been canceled.</p> <p>All code working with PSI, or in other kinds of background processes, must be prepared for <code>ProcessCanceledException</code> being thrown from any point. This exception should never be logged but rethrown, and it'll be handled in the infrastructure that started the process.</p> <p>The <code>checkCanceled()</code> should be called often enough to guarantee the process's smooth cancellation. PSI internals have a lot of <code>checkCanceled()</code> calls inside. If a process does lengthy non-PSI activity, insert explicit <code>checkCanceled()</code> calls so that it happens frequently, e.g., on each Nth loop iteration.</p>"},{"location":"basics/architectural_overview/general_threading_rules/#read-action-cancellability","title":"Read Action Cancellability","text":"<p>Background threads shouldn't take plain read actions for a long time. The reason is that if the UI thread needs a write action (e.g., the user types something), it must be acquired as soon as possible. Otherwise, the UI will freeze until all background threads have released their read actions.</p> <p>The best-known approach is to cancel background read actions whenever there's a write action about to occur, and restart that background read action later from scratch. Editor highlighting, code completion, Goto Class/File/... actions all work like this.</p> <p>To achieve that, the lengthy background operation is started with a <code>ProgressIndicator</code>, and a dedicated listener cancels that indicator when write action is initiated. The next time the background thread calls <code>checkCanceled()</code>, a <code>ProcessCanceledException</code> is thrown, and the thread should stop its operation (and finish the read action) as soon as possible.</p> <p>There are two recommended ways of doing this:</p> <ul> <li>If on UI thread, call <code>ReadAction.nonBlocking()</code> which returns <code>NonBlockingReadAction</code></li> <li>If already in a background thread, use <code>ProgressManager.getInstance().runInReadActionWithWriteActionPriority()</code> in a loop, until it passes or the whole activity becomes obsolete.</li> </ul> <p>In both approaches, always check at the start of each read action, if the objects are still valid, and if the whole operation still makes sense (i.e., not canceled by the user, the project isn't closed, etc.). With <code>ReadAction.nonBlocking()</code>, use <code>expireWith()</code> or <code>expireWhen()</code> for that.</p> <p>If the activity has to access file-based index (e.g., it's doing any project-wide PSI analysis, resolves references, etc.), use <code>ReadAction.nonBlocking(...).inSmartMode()</code>.</p>"},{"location":"basics/architectural_overview/modifying_psi/","title":"Modifying the PSI","text":"<p>The PSI is a read-write representation of the source code as a tree of elements corresponding to a source file's structure. You can modify the PSI by adding, replacing, and deleting PSI elements.</p> <p>To perform these operations, you use methods such as <code>PsiElement.add()</code>, <code>PsiElement.delete()</code>, and <code>PsiElement.replace()</code>, as well as other methods defined in the <code>PsiElement</code> interface that let you process multiple elements in a single operation, or to specify the exact location in the tree where an element needs to be added.</p> <p>Like document operations, PSI modifications need to be wrapped in a write action and in command (and can only be performed in the event dispatch thread). See the Documents article for more information on commands and write actions.</p>"},{"location":"basics/architectural_overview/modifying_psi/#creating-the-new-psi","title":"Creating the New PSI","text":"<p>The PSI elements to add to the tree or replace existing PSI elements are usually created from text. In the most general case, you use the <code>createFileFromText()</code> method of <code>PsiFileFactory</code> to create a new file that contains the code construct which you need to add to the tree or to use as a replacement for an existing element, traverse the resulting tree to locate the specific part that you need, and then pass that element to <code>add()</code> or <code>replace()</code>.</p> <p>Most languages provide factory methods that let you create specific code constructs more easily. For example, the <code>PsiJavaParserFacade</code> class contains methods such as <code>createMethodFromText()</code>, which creates a Java method from the given text.</p> <p>When you're implementing refactorings, intentions, or inspection quickfixes that work with existing code, the text that you pass to the various <code>createFromText()</code> methods will combine hard-coded fragments and fragments of code taken from the existing file. For small code fragments (individual identifiers), you can simply append the text from the existing code to the text of the code fragment you're building. In that case, you need to make sure that the resulting text is syntactically correct. Otherwise the <code>createFromText()</code> method will throw an exception.</p> <p>For larger code fragments, it's best to perform the modification in several steps:</p> <ul> <li>create a replacement tree fragment from the text, leaving placeholders for the user code fragments;</li> <li>replace the placeholders with the user code fragments;</li> <li>replace the element in the original source file with the replacement tree.</li> </ul> <p>This ensures that the user code's formatting is preserved and that the modification doesn't introduce any unwanted whitespace changes.</p> <p>As an example of this approach, see the quickfix in the <code>ComparingReferencesInspection</code> example:</p> <pre><code>// binaryExpression holds a PSI expression of the form \"x == y\", which needs to be replaced with \"x.equals(y)\"\nPsiBinaryExpression binaryExpression = (PsiBinaryExpression) descriptor.getPsiElement();\nIElementType opSign = binaryExpression.getOperationTokenType();\nPsiExpression lExpr = binaryExpression.getLOperand();\nPsiExpression rExpr = binaryExpression.getROperand();\n\n// Step 1: Create a replacement fragment from text, with \"a\" and \"b\" as placeholders\nPsiElementFactory factory = JavaPsiFacade.getInstance(project).getElementFactory();\nPsiMethodCallExpression equalsCall =\n    (PsiMethodCallExpression) factory.createExpressionFromText(\"a.equals(b)\", null);\n\n// Step 2: replace \"a\" and \"b\" with elements from the original file\nequalsCall.getMethodExpression().getQualifierExpression().replace(lExpr);\nequalsCall.getArgumentList().getExpressions()[0].replace(rExpr);\n\n// Step 3: replace a larger element in the original file with the replacement tree\nPsiExpression result = (PsiExpression) binaryExpression.replace(equalsCall);\n</code></pre> <p>Just as everywhere else in the Consulo API, the text passed to <code>createFileFromText()</code> and other <code>createFromText()</code> methods must use only <code>\\n</code> as line separators.</p>"},{"location":"basics/architectural_overview/modifying_psi/#maintaining-tree-structure-consistency","title":"Maintaining Tree Structure Consistency","text":"<p>The PSI modification methods do not restrict you in the way you can build the resulting tree structure. For example, when working with a Java class, you can add a <code>for</code> statement as a direct child of a <code>PsiMethod</code> element, even though the Java parser will never produce such a structure (the <code>for</code> statement will always be a child of the <code>PsiCodeBlock</code>) representing the method body). Modifications that produce incorrect tree structures may appear to work, but they will lead to problems and exceptions later. Therefore, you always need to ensure that the structure you built with PSI modification operations is the same as what the parser would produce when parsing the code that you've created.</p> <p>To make sure you're not introducing inconsistencies, you can call <code>PsiTestUtil.checkFileStructure()</code> in the tests for your action that modifies the PSI. This method ensures that the structure you've built is the same as what the parser produces.</p>"},{"location":"basics/architectural_overview/modifying_psi/#whitespaces-and-imports","title":"Whitespaces and Imports","text":"<p>When working with PSI modification functions, you should never create individual whitespace nodes (spaces or line breaks) from the text. Instead, all whitespace modifications are performed by the formatter, which follows the code style settings selected by the user. Formatting is automatically performed at the end of every command, and if you need, you can also perform it manually using the <code>reformat(PsiElement)</code> method in the <code>CodeStyleManager</code> class.</p> <p>Also, when working with Java code (or with code in other languages with a similar import mechanism such as Groovy or Python), you should never create imports manually. Instead, you should insert fully-qualified names into the code you're generating, and then call the <code>shortenClassReferences()</code> method in the  <code>JavaCodeStyleManager</code> (or the equivalent API for the language you're working with). This ensures that the imports are created according to the user's code style settings and inserted into the file's correct place.</p>"},{"location":"basics/architectural_overview/modifying_psi/#combining-psi-and-document-modifications","title":"Combining PSI and Document Modifications","text":"<p>In some cases, you need to perform a PSI modification and then to perform an operation on the document you've just modified through the PSI (for example, start a live template). In this case, you need to call a special method that completes the PSI-based post-processing (such as formatting) and commits the changes to the document. The method you need to call is called <code>doPostponedOperationsAndUnblockDocument()</code>, and it's defined in the <code>PsiDocumentManager</code> class.</p>"},{"location":"basics/architectural_overview/navigating_psi/","title":"Navigating the PSI","text":"<p>There are three main ways to navigate the PSI: top-down, bottom-up, and references. In the first scenario,  you have a PSI file or another higher-level element (for example, a method). You need to find all elements that match a specified condition (for example, all variable declarations). In the second scenario, you have a specific point in the PSI tree (for example, the element at caret) and need to find out something about its context (for example, the element in which it has been declared). Finally, references allow you to navigate from the usages of an element (e.g., a method call) to the declaration (the method being called) and back. References are described in a separate topic.</p>"},{"location":"basics/architectural_overview/navigating_psi/#top-down-navigation","title":"Top-Down Navigation","text":"<p>The most common way to perform top-down navigation is to use a visitor. To use a visitor, you create a class (usually an anonymous inner class) that extends the base visitor class, overrides the methods that handle the elements you're interested in, and passes the visitor instance to <code>PsiElement.accept()</code>.</p> <p>The base classes for visitors are language-specific. For example, if you need to process elements in a Java file, you extend <code>JavaRecursiveElementVisitor</code> and override the methods corresponding to the Java element types you're interested in.</p> <p>The following snippet shows the use of a visitor to find all Java local variable declarations:</p> <pre><code>file.accept(new JavaRecursiveElementVisitor() {\n  @Override\n  public void visitLocalVariable(PsiLocalVariable variable) {\n    super.visitLocalVariable(variable);\n    System.out.println(\"Found a variable at offset \" + variable.getTextRange().getStartOffset());\n  }\n});\n</code></pre> <p>In many cases, you can also use more specific APIs for top-down navigation. For example, if you need to get a list of all methods in a Java class, you can use a visitor, but a much easier way to do that is calling <code>PsiClass.getMethods()</code>.</p> <p><code>PsiTreeUtil</code> contains a number of general-purpose, language-independent functions for PSI tree navigation, some of which (for example, <code>findChildrenOfType()</code>) perform top-down navigation.</p>"},{"location":"basics/architectural_overview/navigating_psi/#bottom-up-navigation","title":"Bottom-Up Navigation","text":"<p>The starting point for bottom-up navigation is either a specific element in the PSI tree (for example, the result of resolving a reference) or an offset. If you have an offset, you can find the corresponding PSI element by calling <code>PsiFile.findElementAt()</code>. This method returns the element at the lowest level of the tree (for example, an identifier), and you need to navigate the tree up if you want to determine the broader context.</p> <p>In most cases, bottom-up navigation is performed by calling <code>PsiTreeUtil.getParentOfType()</code>. This method goes up the tree until it finds the element of the type you've specified. For example, to find the containing method, you call <code>PsiTreeUtil.getParentOfType(element, PsiMethod.class)</code>.</p> <p>In some cases, you can also use specific navigation methods. For example, to find the class where a method is contained, you call <code>PsiMethod.getContainingClass()</code>.</p> <p>The following snippet shows how these calls can be used together:</p> <pre><code>PsiFile psiFile = anActionEvent.getData(CommonDataKeys.PSI_FILE);\nPsiElement element = psiFile.findElementAt(offset);\nPsiMethod containingMethod = PsiTreeUtil.getParentOfType(element, PsiMethod.class);\nPsiClass containingClass = containingMethod.getContainingClass();\n</code></pre> <p>To see how the navigation works in practice, please refer to the code sample.</p>"},{"location":"basics/architectural_overview/psi/","title":"Program Structure Interface (PSI)","text":"<p>The Program Structure Interface, commonly referred to as just PSI, is the layer in the Consulo responsible for parsing files and creating the syntactic and semantic code model that powers so many of the platform's features.</p> <ul> <li>PSI Files</li> <li>File View Providers</li> <li>PSI Elements</li> </ul> <p>TIP A useful tool for debugging the PSI implementation is the PsiViewer plugin. It can show you the PSI tree structure, the properties of every PSI element, and highlight its text range.</p>"},{"location":"basics/architectural_overview/psi_elements/","title":"PSI Elements","text":"<p>A PSI (Program Structure Interface) file represents a hierarchy of PSI elements (so-called PSI trees). A single PSI file (itself being a PSI element) may contain several PSI trees in specific programming languages. A PSI element, in its turn, can have child PSI elements.</p> <p>PSI elements and operations at the level of individual PSI elements are used to explore the source code's internal structure as it is interpreted by the Consulo. For example, you can use PSI elements to perform code analysis, such as code inspections or intention actions.</p> <p>The <code>PsiElement</code> class is the common base class for PSI elements.</p>"},{"location":"basics/architectural_overview/psi_elements/#how-do-i-get-a-psi-element","title":"How do I get a PSI element?","text":"<ul> <li>From an action: <code>e.getData(LangDataKeys.PSI_ELEMENT)</code>.   Note: if an editor is currently open and the element under caret is a reference, this will return the result of resolving the reference.   This may or may not be what you need.</li> <li>From a file by offset: <code>PsiFile.findElementAt()</code>.   Note: this returns the lowest level element  (\"leaf\") at the specified offset, normally a lexer token.   Most likely, you should use <code>PsiTreeUtil.getParentOfType()</code> to find the element you really need.</li> <li>By iterating through a PSI file: using a <code>PsiRecursiveElementWalkingVisitor</code>.</li> <li>By resolving a reference: <code>PsiReference.resolve()</code></li> </ul>"},{"location":"basics/architectural_overview/psi_elements/#what-can-i-do-with-psi-elements","title":"What can I do with PSI elements?","text":"<p>See PSI Cook Book</p>"},{"location":"basics/architectural_overview/psi_files/","title":"PSI Files","text":"<p>A PSI (Program Structure Interface) file is the root of a structure representing a file's contents as a hierarchy of elements in a particular programming language.</p> <p>The <code>PsiFile</code> class is the common base class for all PSI files, while files in a specific language are usually represented by its subclasses.  For example, the <code>PsiJavaFile</code> class represents a Java file, and the <code>XmlFile</code> class represents an XML file.</p> <p>Unlike <code>VirtualFile</code> and <code>Document</code>, which have application scope (even if multiple projects are open, each file is represented by the same <code>VirtualFile</code> instance). A PSI has project scope. The same file is represented by one <code>PsiFile</code> instance for each open project to which the file belongs. In contrast, <code>VirtualFile</code> and Document have application scope; files are represented by the same VirtualFile instance, even if multiple projects are open.</p>"},{"location":"basics/architectural_overview/psi_files/#how-do-i-get-a-psi-file","title":"How do I get a PSI file?","text":"<ul> <li>From an action: <code>e.getData(LangDataKeys.PSI_FILE)</code>.</li> <li>From a VirtualFile: <code>PsiManager.getInstance(project).findFile()</code></li> <li>From a Document: <code>PsiDocumentManager.getInstance(project).getPsiFile()</code></li> <li>From an element inside the file: <code>psiElement.getContainingFile()</code></li> <li>To find files with a specific name anywhere in the project, use <code>FilenameIndex.getFilesByName(project, name, scope)</code></li> </ul>"},{"location":"basics/architectural_overview/psi_files/#what-can-i-do-with-a-psi-file","title":"What can I do with a PSI file?","text":"<p>Most interesting modification operations are performed on the level of individual PSI elements, not files as a whole.</p> <p>To iterate over the elements in a file, use <code>psiFile.accept(new PsiRecursiveElementWalkingVisitor()...);</code></p>"},{"location":"basics/architectural_overview/psi_files/#where-does-a-psi-file-come-from","title":"Where does a PSI file come from?","text":"<p>As PSI is language-dependent, PSI files are created through the <code>Language</code> object, by using the <code>LanguageParserDefinitions.INSTANCE.forLanguage(language).createFile(fileViewProvider)</code> method.</p> <p>Like documents, PSI files are created on-demand when the PSI is accessed for a particular file.</p>"},{"location":"basics/architectural_overview/psi_files/#how-long-do-psi-files-persist","title":"How long do PSI files persist?","text":"<p>Like documents, PSI files are weakly referenced from the corresponding <code>VirtualFile</code> instances and can be garbage-collected if not referenced by anyone.</p>"},{"location":"basics/architectural_overview/psi_files/#how-do-i-create-a-psi-file","title":"How do I create a PSI file?","text":"<p>The <code>PsiFileFactory</code> <code>createFileFromText()</code> method creates an in-memory PSI file with the specified contents.</p> <p>To save the PSI file to disk, use the <code>PsiDirectory</code> <code>add()</code> method.</p>"},{"location":"basics/architectural_overview/psi_files/#how-do-i-get-notified-when-psi-files-change","title":"How do I get notified when PSI files change?","text":"<p><code>PsiManager.getInstance(project).addPsiTreeChangeListener()</code> allows you to receive notifications about all changes to the PSI tree of a project.</p>"},{"location":"basics/architectural_overview/psi_files/#how-do-i-extend-psi","title":"How do I extend PSI?","text":"<p>PSI can be extended to support additional languages through custom language plugins. For more details on developing custom language plugins, see the Custom Language Support reference guide.</p>"},{"location":"basics/architectural_overview/psi_files/#what-are-the-rules-for-working-with-psi","title":"What are the rules for working with PSI?","text":"<p>Any changes done to the content of PSI files are reflected in documents, so all rules for working with documents (read/write actions, commands, read-only status handling) are in effect.</p>"},{"location":"basics/architectural_overview/psi_references/","title":"PSI References","text":"<p>A reference in a PSI tree is an object that represents a link from a usage of a particular element in the code to the corresponding declaration. Resolving a reference means locating the declaration to which a specific usage refers.</p> <p>The most common type of reference is defined by language semantics. For example, consider a simple Java method:</p> <pre><code>public void hello(String message) {\n    System.out.println(message);\n}\n</code></pre> <p>This simple code fragment contains five references. The references created by the identifiers <code>String</code>, <code>System</code>, <code>out</code>, and <code>println</code> can be resolved to the corresponding declarations in the JDK: the <code>String</code> and <code>System</code> classes, the <code>out</code> field, and the <code>println</code> method. The reference created by the second occurrence of the <code>message</code> identifier in <code>println(message)</code> can be resolved to the <code>message</code> parameter, declared by <code>String message</code> in the method header.</p> <p>Note that <code>String message</code> is not a reference and cannot be resolved. Instead, it's a declaration. It does not refer to any name defined elsewhere; instead, it defines a name by itself.</p> <p>A reference is an instance of a class implementing the <code>PsiReference</code> interface. Note that references are distinct from PSI elements. References created by a PSI element are returned from <code>PsiElement.getReferences()</code>, the underlying PSI element of a reference can be obtained from <code>PsiReference.getElement()</code>.</p> <p>To resolve the reference - to locate the declaration being referenced - call <code>PsiReference.resolve()</code>. It's very important to understand the difference between <code>PsiReference.getElement()</code> and <code>PsiReference.resolve()</code>. The former method returns the source of a reference, while the latter returns its target. In the example above, for the <code>message</code> reference, <code>getElement()</code> will return the <code>message</code> identifier on the second line of the snippet, and <code>resolve()</code> will return the <code>message</code> identifier on the first line (inside the parameter list).</p> <p>The process of resolving references is distinct from parsing and is not performed at the same time. Moreover, it is not always successful. If the code currently open in the IDE does not compile, or in other situations, it's normal for <code>PsiReference.resolve()</code> to return <code>null</code> - all code working with references must be prepared to handle that.</p> <p>TIP Please see also Cache results of heavy computations in Working with PSI efficiently.</p>"},{"location":"basics/architectural_overview/psi_references/#contributed-references","title":"Contributed References","text":"<p>In addition to references defined by the semantics of the programming language, the IDE recognizes many references determined by the semantics of the APIs and frameworks used in code. Consider the following example:</p> <pre><code>File f = new File(\"foo.txt\");\n</code></pre> <p>Here, \"foo.txt\" has no special meaning from the point of view of the Java syntax - it's just a string literal. However, opening this example in IntelliJ IDEA and having a file called \"foo.txt\" in the same directory, one can Ctrl/Cmd-Click on \"foo.txt\" and navigate to the file. This works because the IDE recognizes the semantics of <code>new File(...)</code> and contributes a reference into the string literal passed as a parameter to the method.</p> <p>Typically, references can be contributed to elements that don't have their own references, such as string literals and comments. References are also often contributed to non-code files, such as XML or JSON.</p> <p>Contributing references is one of the most common ways to extend an existing language. For example, your plugin can contribute references to Java code, even though the Java PSI is part of the platform and not defined in your plugin.</p> <p>To contribute references, see the reference contributor tutorial.</p>"},{"location":"basics/architectural_overview/psi_references/#references-with-optional-or-multiple-resolve-results","title":"References with Optional or Multiple Resolve Results","text":"<p>In the simplest case, a reference resolves to a single element, and if resolving fails, the code is incorrect, and the IDE needs to highlight it as an error. However, there are cases when the situation is different.</p> <p>The first case is soft references. Consider the <code>new File(\"foo.txt\")</code> example above. If the IDE can't find the file \"foo.txt\", it doesn't mean that an error needs to be highlighted - maybe the file is only available at runtime. Such references return <code>true</code> from the <code>PsiReference.isSoft()</code> method.</p> <p>The second case is polyvariant references. Consider the case of a JavaScript program. JavaScript is a dynamically typed language, so the IDE cannot always precisely determine which method is being called at a particular location. To handle this, it provides a reference that can be resolved to multiple possible elements. Such references implement the <code>PsiPolyVariantReference</code> interface.</p> <p>For resolving a <code>PsiPolyVariantReference</code>, you call its <code>multiResolve()</code> method. The call returns an array of <code>ResolveResult</code> objects. Each of the objects identifies a PSI element and also specifies whether the result is valid. For example, suppose you have multiple Java method overloads and a call with arguments not matching any of the overloads. In that case, you will get back <code>ResolveResult</code> objects for all of the overloads, and <code>isValidResult()</code> returns <code>false</code> for all of them.</p>"},{"location":"basics/architectural_overview/psi_references/#searching-for-references","title":"Searching for References","text":"<p>As you already know, resolving a reference means going from usage to the corresponding declaration. To perform the navigation in the opposite direction - from a declaration to its usages - perform a references search.</p> <p>To perform a search using <code>ReferencesSearch</code>, specify the element to search for, and optionally other parameters such as the scope in which the reference needs to be searched. The created <code>Query</code> allows obtaining all results at once or iterating over the results one by one. The latter allows stopping processing as soon as the first (matching) result has been found.</p>"},{"location":"basics/architectural_overview/psi_references/#implementing-references","title":"Implementing References","text":"<p>Please refer to the guide and corresponding tutorial for more information.</p>"},{"location":"basics/architectural_overview/virtual_file/","title":"Virtual Files","text":"<p>A <code>VirtualFile</code> (VF) is the Consulo's representation of a file in a Virtual File System (VFS).</p> <p>Most commonly, a virtual file is a file in a local file system. However, the Consulo supports multiple pluggable file system implementations, so virtual files can also represent classes in a JAR file, old revisions of files loaded from a version control repository, and so on.</p> <p>The VFS level deals only with binary content. Contents of a <code>VirtualFile</code> are treated as a stream of bytes, but concepts like encodings and line separators are handled on higher system levels.</p>"},{"location":"basics/architectural_overview/virtual_file/#how-do-i-get-a-virtual-file","title":"How do I get a virtual file?","text":"<p>From an action : <code>e.getData(PlatformDataKeys.VIRTUAL_FILE)</code> or <code>e.getData(PlatformDataKeys.VIRTUAL_FILE_ARRAY)</code> for multiple selection</p> <p>From a path in the local file system: :  - <code>LocalFileSystem.getInstance().findFileByIoFile()</code> - <code>VirtualFileManager.findFileByNioPath()</code>/<code>refreshAndFindFileByNioPath()</code> (2020.2 and later)</p> <p>From a PSI file : <code>psiFile.getVirtualFile()</code> (may return <code>null</code> if the PSI file exists only in memory)</p> <p>From a document : <code>FileDocumentManager.getInstance().getFile()</code></p>"},{"location":"basics/architectural_overview/virtual_file/#what-can-i-do-with-it","title":"What can I do with it?","text":"<p>Typical file operations are available, such as traverse the file system, get file contents, rename, move, or delete. Recursive iteration should be performed using <code>VfsUtilCore.iterateChildrenRecursively()</code> to prevent endless loops caused by recursive symlinks.</p>"},{"location":"basics/architectural_overview/virtual_file/#where-does-it-come-from","title":"Where does it come from?","text":"<p>The VFS is built incrementally by scanning the file system up and down, starting from the project root. VFS refreshes detect new files appearing in the file system. A refresh operation can be initiated programmatically using <code>VirtualFileManager.syncRefresh()</code>/<code>asyncRefresh()</code> or <code>VirtualFile.refresh()</code>. VFS refreshes are also triggered whenever file system watchers receive file system change notifications.</p> <p>Invoking a VFS refresh might be necessary for accessing a file that has just been created by an external tool through the Consulo APIs.</p>"},{"location":"basics/architectural_overview/virtual_file/#how-long-does-a-virtual-file-persist","title":"How long does a virtual file persist?","text":"<p>A particular file on disk is represented by equal <code>VirtualFile</code> instances for the IDE process's entire lifetime. There may be several instances corresponding to the same file, and they can be garbage-collected. The file is a <code>UserDataHolder</code>, and the user data is shared between those equal instances. If a file is deleted, its corresponding VirtualFile instance becomes invalid (<code>isValid()</code> returns <code>false</code>), and operations cause exceptions.</p>"},{"location":"basics/architectural_overview/virtual_file/#how-do-i-create-a-virtual-file","title":"How do I create a virtual file?","text":"<p>Usually, you don't. As a general rule, files are created either through the PSI API or through the regular <code>java.io.File</code> API.</p> <p>If one needs to create a file through VFS, use <code>VirtualFile.createChildData()</code> to create a <code>VirtualFile</code> instance and <code>VirtualFile.setBinaryContent()</code> to write some data to the file.</p>"},{"location":"basics/architectural_overview/virtual_file/#how-do-i-get-notified-when-vfs-changes","title":"How do I get notified when VFS changes?","text":"<p>NOTE See Virtual file system events for important details.</p> <p>Implement <code>BulkFileListener</code> and subscribe to the message bus topic <code>VirtualFileManager.VFS_CHANGES</code>. For example:</p> <pre><code>project.getMessageBus().connect().subscribe(VirtualFileManager.VFS_CHANGES, new BulkFileListener() {\n    @Override\n    public void after(@NotNull List&lt;? extends VFileEvent&gt; events) {\n        // handle the events\n    }\n});\n</code></pre> <p>See Message Infrastructure and Plugin Listeners for more details.</p> <p>For a non-blocking alternative, starting with version 2019.2 of the platform, see <code>AsyncFileListener</code>.</p> <p>Plugins targeting versions 2017.2 or older of the platform can use the now deprecated <code>VirtualFileManager.addVirtualFileListener()</code> method, which allows you to receive notifications about all changes in the VFS.</p>"},{"location":"basics/architectural_overview/virtual_file/#are-there-any-utilities-for-analyzing-and-manipulating-virtual-files","title":"Are there any utilities for analyzing and manipulating virtual files?","text":"<p><code>VfsUtil</code> and <code>VfsUtilCore</code> provide utility methods for analyzing files in the Virtual File System.</p> <p>Use <code>ProjectLocator</code> to find the projects that contain a given virtual file.</p>"},{"location":"basics/architectural_overview/virtual_file/#how-do-i-extend-vfs","title":"How do I extend VFS?","text":"<p>To provide an alternative file system implementation (for example, an FTP file system), implement the <code>VirtualFileSystem</code> class (most likely you'll also need to implement <code>VirtualFile</code>), and register your implementation via <code>com.intellij.virtualFileSystem</code> extension point (2019.2 and later) or application component for earlier versions.</p> <p>To hook into operations performed in the local file system (for example, when developing a version control system integration that needs custom rename/move handling), implement <code>LocalFileOperationsHandler</code> and register it via <code>LocalFileSystem.registerAuxiliaryFileOperationsHandler()</code>.</p>"},{"location":"basics/architectural_overview/virtual_file/#what-are-the-rules-for-working-with-vfs","title":"What are the rules for working with VFS?","text":"<p>See Virtual File System for a detailed description of the VFS architecture and usage guidelines.</p>"},{"location":"basics/boot/boot.directories/","title":"Boot Directories","text":""},{"location":"basics/boot/boot.directories/#windows","title":"Windows","text":"<ul> <li>Windows Vista, 7, 8, 8.1, 10:<ul> <li><code>${system-drive}/Users/${user-name}/AppData/Roaming/Consulo</code> - configuration directory</li> <li><code>${system-drive}/Users/${user-name}/AppData/Roaming/Consulo Platorm</code> - platform directory</li> <li><code>${system-drive}/Users/${user-name}/AppData/Roaming/Consulo/plugins</code> - plugin directory</li> <li><code>${system-drive}/Users/${user-name}/AppData/Local/Consulo/log</code> - log directory</li> </ul> </li> <li>Windows XP:<ul> <li><code>${system-drive}/Users/${user-name}/Application Data/Consulo/</code> - configuration directory</li> <li><code>${system-drive}/Users/${user-name}/Application Data/Consulo Platform</code> - platform directory</li> <li><code>${system-drive}/Users/${user-name}/Application Data/Consulo/plugins</code> - plugin directory</li> <li><code>${system-drive}/Users/${user-name}/Local Settings/Application Data/Consulo/log</code> - log directory</li> </ul> </li> </ul>"},{"location":"basics/boot/boot.directories/#linux","title":"Linux","text":"<ul> <li>Any:<ul> <li><code>${home-directory}/.consulo_settings</code><ul> <li>config - configuration directory</li> <li>config/plugins - plugin directory</li> <li>system/log - log directory</li> </ul> </li> </ul> </li> </ul>"},{"location":"basics/boot/boot.directories/#mac-os","title":"Mac OS","text":"<ul> <li>Any<ul> <li><code>~/Library/Preferences/Consulo</code> - configuration directory</li> <li><code>~/Library/Application Support/Consulo Platform</code> - platform directory</li> <li><code>~/Library/Application Support/Consulo</code> - plugin directory</li> <li><code>~/Library/Logs/Consulo</code> - log directory</li> </ul> </li> </ul>"},{"location":"basics/boot/overview/","title":"Consulo Boot Information","text":"<ul> <li>Boot Directories - Paths to system directories</li> </ul>"},{"location":"basics/boot/overview/#major-boot-changes","title":"Major boot changes","text":"<p>Consulo consists of two parts:   * boot part (not updatable)       * .exe files on windows       * macOS launcher       * sh script on linux   * platform part (updatable)</p> <p>Sometimes (not often) major issues reported, which required changes in boot part. For update boot part - need only re-download Consulo, and replace it by new build.</p> <p>All settings will be not changed.</p> <p>List of major boot issues: * Platform not updated without admin rights, when Consulo placed under Program Files directory * After update consulo can't start happen second time</p>"},{"location":"basics/getting_started/build_number_ranges/","title":"Build Number Ranges","text":"<p>Use this reference of build number ranges to specify the correct <code>since-build</code> and <code>until-build</code> values in your plugin descriptor.</p> <p>When using Gradle, setting the actual values in <code>plugin.xml</code> is usually managed by the <code>patchPluginXml</code> task, see Patching the Plugin Configuration File for details.</p> <p>NOTE Compatibility with specified version range (and compatible products) should always be verified using Plugin Verifier to ensure binary compatibility.</p> <p>Starting with IntelliJ IDEA 9 beta, a multi-part build number is used, such as <code>IU-162.94</code>.</p> <p>The number consists of the following parts:</p> <ul> <li>Product ID (<code>IC</code> for IDEA Community, <code>IU</code> for IDEA Ultimate, <code>RM</code> for RubyMine, <code>PY</code> for PyCharm, etc.)</li> <li>Branch number (<code>162</code>)</li> <li>Build number in the branch (<code>94</code>)</li> </ul> <p>Since version 2016.2 of the Consulo, branch numbers are based on the <code>YYYY.R</code> IDE release version numbers. The branch number takes the last two digits of the year and the <code>R</code> release number. For example, <code>162</code> for 2016.2, <code>163</code> for 2016.3, <code>171</code> for 2017.1. In this scheme, <code>IU-162.94</code> corresponds to the 2016.2 release.</p> <p>Starting with 2016.2, the build number may also have multiple components: <code>IU-162.94</code>, <code>IU-162.94.11</code>, <code>IU-162.94.11.256.42</code>. This gives more flexibility for third-party plugins and IDE developers. Plugins may specify compatibility versions more precisely; IDE vendors may have build numbers based on a specific Consulo version and specify additional internal version (e.g. <code>256.42</code> in <code>XX-162.94.11.256.42</code>) to allow plugin developers for their IDE to specify compatibility.</p> <p>Multi-part build numbers can also be used in the <code>since-build</code> and <code>until-build</code> attributes of <code>idea-version</code>. Usually you should omit the product ID and use only the branch number and build number, for example:</p> <pre><code>&lt;idea-version since-build=\"94.539\"/&gt;\n&lt;idea-version since-build=\"162.539.11\"/&gt;\n&lt;idea-version until-build=\"162\"/&gt; &lt;!-- any build until 162, not inclusive!--&gt;\n&lt;idea-version since-build=\"162\" until-build=\"162.*\"/&gt; &lt;!-- any 162-based version, 162.94, 162.94.11, etc.--&gt;\n</code></pre> <p>NOTE Specific build numbers and their corresponding release version are available via Previous Releases on the corresponding product's download page, e.g. Previous IntelliJ IDEA Releases.</p>"},{"location":"basics/getting_started/build_number_ranges/#consulo-based-products-of-recent-ide-versions","title":"Consulo Based Products of Recent IDE Versions","text":"<p>TIP Which versions should your plugin support? We've collected some insights based on download statistics in Statistics: Product Versions in Use.</p> Branch number Consulo version 203 2020.3 NOTE Java 11 is now required (blog post) 202 2020.2 201 2020.1 193 2019.3 192 2019.2 191 2019.1 183 2018.3 182 2018.2 181 2018.1 173 2017.3 172 2017.2 171 2017.1 163 2016.3 162 2016.2 <p>Note that there is no <code>170</code>. In the <code>YYYY.R</code> versioning scheme, the <code>R</code> part starts at 1.</p>"},{"location":"basics/getting_started/build_number_ranges/#consulo-based-products-of-pre-20162-ide-versions","title":"Consulo Based Products of Pre-2016.2 IDE Versions","text":"Branch number Product version 145 IntelliJ IDEA 2016.1, AppCode 2016.1, CLion 2016.1, DataGrip 2016.1, PhpStorm 2016.1, PyCharm 2016.1, RubyMine 2016.1, WebStorm 2016.1 143 IntelliJ IDEA 15, AppCode 3.3, CLion 1.2, DataGrip 1.0, PhpStorm 10, PyCharm 5, RubyMine 8, WebStorm 11 141 IntelliJ IDEA 14.1, Android Studio 1.3, PyCharm 4.1, WebStorm 10 139 IntelliJ IDEA 14, PhpStorm 8, PyCharm 4, RubyMine 7, WebStorm 9 135 IntelliJ IDEA 13.1, WebStorm 8 133 IntelliJ IDEA 13, PhpStorm 7, PyCharm 3.1, WebStorm 7 131 PhpStorm 7, PyCharm 3.0, WebStorm 7 129 IntelliJ IDEA 12.1, bug-fix updates for PyCharm 2.7 and PhpStorm/WebStorm 6.0 127 AppCode 2.0, PhpStorm/WebStorm 6.0 125 PyCharm 2.7, RubyMine 5.0 123 IntelliJ IDEA 12 121 AppCode 1.6, PyCharm 2.6, PhpStorm/WebStorm 5.0 119 RubyMine 4.5 117 IntelliJ IDEA 11.1, AppCode 1.5, PyCharm 2.5, RubyMine 4.0.x, PhpStorm/WebStorm 4.0 111 IntelliJ IDEA 11.0 107 IntelliJ IDEA 10.5 103 IntelliJ IDEA 10.0.2+ 99 IntelliJ IDEA 10.0+ 95 IntelliJ IDEA 9.0.2+ 93 IntelliJ IDEA 9.0"},{"location":"basics/getting_started/build_number_ranges/#history","title":"History","text":""},{"location":"basics/getting_started/build_number_ranges/#build-numbers-for-intellij-idea-versions","title":"Build Numbers for IntelliJ IDEA Versions","text":"IntelliJ IDEA version Build number 12.0 123.72 11.1.3 117.798 11.1.2 117.418 11.1.1 117.117 11.1 117.105 11.0.2 111.277 11.0.1 111.167 11.0 111.69 10.5.2 107.587 10.5.1 107.322 10.5 107.105 10.0.3 103.255 10.0.2 103.72 10.0.1 99.32 10.0 99.18 9.0.4 95.627 9.0.3 95.429 9.0.2 95.66 9.0.1 93.94 9.0 93.13"},{"location":"basics/getting_started/build_number_ranges/#build-numbers-for-intellij-idea-pre-90","title":"Build Numbers for IntelliJ IDEA Pre-9.0","text":"<p>Before IntelliJ IDEA 9.0, linear build numbers were used, with the following ranges:</p> IntelliJ IDEA version Build number range 8.1.x 9500-9999 8.0.x 9100-9499 8.0 8000-9099 7.0.2+ 7500-7999 7.0 final 7200-7499 7.0 pre-M2 6900-7199 7.0 pre-M1 6500-6899 6.0.2 branch 6000-6499 6.0 branch 5000-5999 5.1 branch 4000-4999 <p>The build number for each release:</p> IntelliJ IDEA version Build number 8.1 9732 8.0.1 9164 8.0 9013 8.0M1 8664 7.0.5 7971 7.0.3 7757 7.0.2 7590 7.0 final 7361 7.0 M2 7126 7.0 M1 6813 6.0.6 6197 6.0.5 6180 6.0.1 5784 5.1.2 4267"},{"location":"basics/getting_started/creating_plugin_project/","title":"Creating a Plugin Project","text":"<p>NOTE For new projects, it is highly recommended to use Gradle.</p> <p>This section explains how you can create a new plugin project from scratch using the New Project wizard. Optionally, you can import an existing project or import a project from external models. You can also add a new plugin module to a current Consulo project. For more information, refer to the IntelliJ IDEA Web Help.</p>"},{"location":"basics/getting_started/creating_plugin_project/#to-create-an-consulo-plugin-project","title":"To Create an Consulo Plugin Project:","text":"<ul> <li>On the main menu, choose File | New | Project.   The New Project wizard starts.   </li> <li>Set Consulo Plugin project type.</li> <li>Click Next.</li> <li>Set the desired project name.</li> <li>Click Finish to generate project structure files.</li> <li>Go to File | Project Structure to customize project settings if required.</li> </ul>"},{"location":"basics/getting_started/creating_plugin_project/#to-create-an-consulo-plugin-module","title":"To Create an Consulo Plugin Module","text":"<ul> <li>Select File | New | Module and choose the Consulo Plugin module type    </li> <li>Enter your desired plugin name.</li> <li>Go to File | Project Structure and select the newly created Consulo SDK as the default SDK for the plugin module:   </li> </ul>"},{"location":"basics/getting_started/creating_plugin_project/#adding-code-to-the-project","title":"Adding Code to the Project","text":"<p>Before running the new project, add some code to provide simple functionality. See the Creating Actions tutorial for step-by-step instructions for adding a menu action.</p>"},{"location":"basics/getting_started/deploying_plugin/","title":"Deploying a Plugin","text":"<p>Before your custom plugin can be used, it must be deployed: built, installed, and then enabled using Plugin Manager.</p> <p>To deploy a plugin:</p> <ul> <li>Make your project by invoking Build | Build Project or Build | Build Module \\&lt;module name&gt;.</li> <li>Prepare your plugin for deployment.   In the main menu, select Build | Prepare Plugin Module \\&lt;module name&gt; for Deployment.</li> </ul> <p></p> <ul> <li>If the plugin module does not depend on any libraries, a <code>.jar</code> archive will be created.   Otherwise, a <code>.zip</code> archive will be created, including all the plugin libraries specified in the project settings.</li> </ul> <p></p> <ul> <li>Install   the newly created archive/jar file from disk.   The <code>editor_basics</code> code sample builds the plugin archive/jar into the <code>editor_basics</code> project folder:</li> </ul> <p></p> <ul> <li>Restart your IDE so the changes will take effect.</li> </ul>"},{"location":"basics/getting_started/plugin_compatibility/","title":"Plugin Compatibility with Consulo Products","text":""},{"location":"basics/getting_started/plugin_compatibility/#introduction","title":"Introduction","text":"<p>All products based on the Consulo are built on the same underlying API. Some of these products share features built on top of the platform, such as Java support in IntelliJ IDEA and Android Studio. Underlying those shared features are shared components. When authoring a plugin for the Consulo, it is important to understand and declare dependencies on these components. Otherwise, it may not be possible to load or run the plugin in a product because the components on which it depends aren't available.</p> <p>TIP Qualifying Open Source projects can apply for free licenses of JetBrains products.</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"basics/getting_started/plugin_compatibility/#declaring-plugin-dependencies","title":"Declaring Plugin Dependencies","text":"<p>For the purposes of dependencies, a module can be thought of like a built-in plugin that ships as a non-removable part of a product. A working definition of a dependency is that a plugin project cannot be run without the module present in an Consulo-based product. Declaring a dependency on a module also expresses a plugin's compatibility with a product in that the Consulo determines whether a product contains the correct modules to support a plugin before loading it.</p> <p>Part I of this document describes the syntax for declaring plugin dependencies and optional plugin dependencies. Part II of this document (below) describes the Consulo modules' functionality to aid in determining the dependencies of a plugin.</p> <p>The way dependency declarations are handled by the Consulo is determined by the contents of the <code>plugin.xml</code> file: * If a plugin does not declare any dependencies in its <code>plugin.xml</code> file, or if it declares dependencies only on other plugins but not modules, it's assumed to be a legacy plugin and is loaded only in IntelliJ IDEA.   This configuration of the dependency declaration is deprecated; do not use it for new plugin projects. * If a plugin declares at least one module dependency in its <code>plugin.xml</code> file, the plugin is loaded if an Consulo-based product contains all the modules and plugins on which the plugin has declared a dependency.</p>"},{"location":"basics/getting_started/plugin_compatibility/#modules","title":"Modules","text":"<p>A module represents a built-in plugin that is a non-removable part of a product. Some modules are available in all products, and some modules are available only in some, or even just one product. This section identifies and discusses modules of both types.</p>"},{"location":"basics/getting_started/plugin_compatibility/#declaring-incompatibility-with-module","title":"Declaring Incompatibility with Module","text":"<p>Starting in 2020.2, a plugin can declare incompatibility with an arbitrary module by specifying <code>&lt;incompatible-with&gt;</code> containing module ID in its <code>plugin.xml</code>.</p>"},{"location":"basics/getting_started/plugin_compatibility/#modules-available-in-all-products","title":"Modules Available in All Products","text":"<p>A core set of modules are available in all products based on the Consulo. These modules provide a set of shared functionality. The following table lists modules that are currently available in all products.</p> <p>NOTE All plugins should declare a dependency on <code>com.intellij.modules.platform</code> to indicate dependence on shared functionality.</p> Module for <code>&lt;depends&gt;</code> ElementDeclaration in <code>plugin.xml</code> File Functionality <code>com.intellij.modules.platform</code> Messaging, UI Themes, UI Components, Files, Documents, Actions, Components, Services, Extensions, Editors <code>com.intellij.modules.lang</code> File Type, Lexer, Parser, Highlighting, References, Code Completion, Find, Rename, Formatter, Code Navigation <code>com.intellij.modules.xml</code> XML, XML DOM, XSD/DTD, DOM Model <code>com.intellij.modules.vcs</code> VCS Revision Numbers, File Status, Change Lists, File History, Annotations <code>com.intellij.modules.xdebugger</code> Debug Session, Stack Frames, Break Points, Source Positions, Memory Views, Tracked Instances <p>As of this writing, if a plugin: A) is dependent only on one or more of the modules in the table above, and B) declares those module dependencies in <code>plugin.xml</code>, then any product developed by JetBrains based on the Consulo will load it.</p>"},{"location":"basics/getting_started/plugin_compatibility/#modules-specific-to-functionality","title":"Modules Specific to Functionality","text":"<p>More specialized functionality is also delivered via modules and plugins in Consulo-based products. For example, the <code>com.intellij.modules.python</code> module supports the Python language-specific functionality. If a plugin uses this module's functionality, such as Python-specific inspections and refactoring, it must declare a dependency on this module.</p> <p>Note that not all products define and declare modules. For example, PhpStorm does not have its own module, but the product itself depends on (and ships with) the PHP language plugin.  A plugin project is compatible with PHP functionality if it declares a dependency on this PHP language plugin.</p> <p>The following table lists (1) modules or built-in plugins that provide specific functionality, and the products currently shipping with them.</p> Module or Plugin for <code>&lt;depends&gt;</code> ElementDeclaration in <code>plugin.xml</code> File Functionality Consulo-BasedProduct Compatibility <code>com.intellij.modules.java</code> See (2) below. <code>com.intellij.java</code> Java language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework IntelliJ IDEA, Android Studio <code>com.intellij.modules.androidstudio</code> Android SDK Platform, Build Tools, Platform Tools, SDK Tools Android Studio <code>com.intellij.modules.appcode</code> CocoaPods, Core Data Objects, Device &amp; Simulator Support AppCode <code>com.intellij.modules.cidr.lang</code> C, C++, Objective-C/C++ language PSI Model, Swift/Objective-C Interaction, Inspections, Intentions, Completion, Refactoring, Test Framework AppCode, CLion <code>com.intellij.modules.cidr.debugger</code> Debugger Watches, Evaluations, Breakpoints, Inline Debugging AppCode, CLion, RubyMine <code>com.intellij.modules.clion</code> CMake, Profiler, Embedded Development, Remote Development, Remote Debug, Disassembly CLion <code>com.intellij.database</code> Database Tools and SQL language PSI Model, Inspections, Completion, Refactoring, Queries DataGrip, IntelliJ IDEA Ultimate, AppCode, PhpStorm, PyCharm Professional, RubyMine, CLion, GoLand, Rider, and WebStorm if the Database Tools and SQL plugin is installed. <code>com.intellij.modules.go</code> Go language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework GoLand <code>com.intellij.modules.python</code> Python language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework PyCharm, and other products if the Python plugin is installed. <code>com.intellij.modules.rider</code> Connection to ReSharper Process in Background Rider <code>com.intellij.modules.ruby</code> Ruby language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework RubyMine, and IntelliJ IDEA Ultimate if the Ruby plugin is installed. <code>com.intellij.modules.ultimate</code> Licensing All commercial IDEs (IntelliJ IDEA Ultimate, PhpStorm, DataGrip, ...) <code>com.jetbrains.php</code> PHP language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework PhpStorm, and other products if the PHP plugin is installed. <code>JavaScript</code> JavaScript language PSI Model, Inspections, Intentions, Completion, Refactoring, Test Framework WebStorm, and other products if the JavaScript plugin is installed. <p>Notes about Module and Plugin Dependency:</p> <p>(1) This table is not exhaustive; other modules are currently available in JetBrains' Consulo-based IDEs. To see a list of modules, invoke the code completion feature for the <code>&lt;depends&gt;</code> element contents while editing the <code>plugin.xml</code> file.</p> <p>(2) The Java language functionality was extracted as a plugin in version 2019.2 of the Consulo. This refactoring separated the Java implementation from the other, non-language portions of the platform. Consequently, dependencies on Java functionality are expressed differently in <code>plugin.xml</code> depending on the version of the Consulo being targeted:</p> <ul> <li>Syntax for 2019.2 and later releases:</li> <li><code>plugin.xml</code> allowable alternative add <code>&lt;depends&gt;com.intellij.java&lt;/depends&gt;</code></li> <li><code>build.gradle</code> required define dependency on Java plugin <code>intellij { plugins = ['com.intellij.java'] }</code></li> <li>Syntax required for releases prior to 2019.2, allowable in all releases:</li> <li><code>plugin.xml</code> add <code>&lt;depends&gt;com.intellij.modules.java&lt;/depends&gt;</code></li> </ul>"},{"location":"basics/getting_started/plugin_compatibility/#exploring-module-and-plugin-apis","title":"Exploring Module and Plugin APIs","text":"<p>Once the dependency on a module or plugin is declared in <code>plugin.xml</code>, it's useful to explore the packages and classes available in that dependency. The section below gives some recommended procedures for discovering what's available in a module or plugin on which a project depends. These procedures assume a project has the <code>build.gradle</code> and <code>plugin.xml</code> dependencies configured correctly.</p>"},{"location":"basics/getting_started/plugin_compatibility/#exploring-apis-as-a-consumer","title":"Exploring APIs as a Consumer","text":"<p>Exploring the available packages and classes in a plugin or module utilizes features in the IntelliJ IDEA IDE.</p> <p>If the project is not up to date, Reimport the Gradle project as a first step. Reimporting the project will automatically update the dependencies.</p> <p>In the Project Window, select Project View and scroll to the bottom to see External Libraries. Look for the library <code>Gradle:unzipped.com.jetbrains.plugins:foo:</code>, where \"foo\" matches, or is similar to the contents of the <code>&lt;depends&gt;</code> tags in <code>plugin.xml</code> or the <code>intellij.plugins</code> declaration in <code>build.gradle</code>. The image below shows the External Libraries for the example plugin project configuration explained in Configuring build.gradle and Configuring plugin.xml.</p> <p>{:width=\"700px\"}</p> <p>Expand the External Library (as shown) to reveal the JAR files contained in the library. Drill down into the JAR files to expose the packages and (decompiled) classes.</p>"},{"location":"basics/getting_started/plugin_compatibility/#exploring-apis-as-an-extender","title":"Exploring APIs as an Extender","text":"<p>If a project is dependent on a plugin or module, in some cases, the project can also extend the functionality available from the plugin or module.</p> <p>To browse the opportunities for extension, start by placing the cursor on the contents of the <code>&lt;depends&gt;</code> elements in the project's <code>plugin.xml</code> file. Use the Go to Declaration IDE feature to navigate to the <code>plugin.xml</code> file for the plugin on which the project depends.</p> <p>For example, performing this procedure on the <code>&lt;depends&gt;com.jetbrains.php&lt;/depends&gt;</code> declaration in a project's <code>plugin.xml</code> file will navigate to the <code>plugin.xml</code> file for the <code>com.jetbrains.php</code> (PHP) project. A common, but not universal, pattern in the Consulo is for a plugin (like PHP) to declare <code>&lt;extensionPoints&gt;</code> and then implement each one as <code>&lt;extensions&gt;</code>. Continuing the example, search the PHP plugin's <code>plugin.xml</code> file for: * <code>&lt;extensionPoints&gt;</code> to find the opportunities for extending the PHP plugin's functionality. * <code>&lt;extensions defaultExtensionNs=\"com.jetbrains.php\"&gt;</code> to find where the PHP plugin extends functionality.   The extension namespace (in this example <code>com.jetbrains.php</code>) will match the <code>&lt;id&gt;</code> defined in the <code>plugin.xml</code> file.</p>"},{"location":"basics/getting_started/plugin_compatibility/#verifying-dependency","title":"Verifying Dependency","text":"<p>Before marking a plugin project as dependent only on modules in a target product in addition to <code>com.intellij.modules.platform</code>, verify the plugin isn't implicitly dependent on any APIs that are specific to IntelliJ IDEA.</p> <p>For Gradle-based projects, Plugin Verifier can be used to ensure compatibility with all specified target IDEs.</p> <p>For DevKit-based projects, create an SDK pointing to an installation of the intended target Consulo-based product, e.g., PhpStorm, rather than IntelliJ IDEA. Use the same development version of the Consulo as the targeted product.</p> <p>Based on the tables above, the JetBrains Plugins Repository automatically detects the JetBrains products with which a plugin is compatible, and makes the compatibility information available to plugin authors. The compatibility information determines if plugins are available at the plugin repository to users of a particular JetBrains product.</p>"},{"location":"basics/getting_started/plugin_compatibility/#platform-api-version-compatibility","title":"Platform API Version Compatibility","text":"<p>The API of Consulo and bundled plugins may change between releases. The significant changes that may break plugins are listed on Incompatible Changes in Consulo and Plugins API page.</p>"},{"location":"basics/getting_started/publishing_plugin/","title":"Publishing a Plugin","text":"<p>When your plugin is ready, you can publish it to a plugin repository so that other users can install it. You can choose to publish it on the JetBrains Plugins Repository or a custom plugin repository.</p> <p>TIP Please see Marketing for remarks on how to prepare your plugin for optimal presentation.</p>"},{"location":"basics/getting_started/publishing_plugin/#publishing-to-the-jetbrains-plugins-repository","title":"Publishing to the JetBrains Plugins Repository","text":"<p>To upload your plugin to the JetBrains Plugins Repository,  you must log in with your personal JetBrains Account.</p> <p>To get your JetBrains account:</p> <ol> <li>Open the JetBrains Account Center and click Create Account.</li> <li>Fill in all fields in the Create JetBrains Account form that opens and click Register.</li> </ol> <p>To upload your plugin to JetBrains Plugins Repository:</p> <ol> <li>Log in to JetBrains Plugins Repository with your personal JetBrains account.</li> <li>On your Profile page that opens, click Add new plugin.</li> <li>Fill in the Add new plugin form that opens and click the Add the plugin button to upload your plugin.</li> </ol>"},{"location":"basics/getting_started/publishing_plugin/#publishing-a-plugin-to-a-custom-plugin-repository","title":"Publishing a Plugin to a Custom Plugin Repository","text":"<p>If you plan to publish your plugin to a repository other than the JetBrains Plugins Repository, please refer to the Publishing to Custom Plugin Repositories documentation.</p>"},{"location":"basics/getting_started/running_and_debugging_a_plugin/","title":"Running and Debugging a Plugin","text":"<p>It's possible to run and debug a plugin directly from the IntelliJ IDEA. You need a configured special profile (a Plugin Run/Debug configuration) that specifies the plugin module, VM parameters, and other specific options. When you run such a profile, it launches the IDE with your plugin installed.</p> <p>See IDE Development Instances for more information about configuration and advanced settings.</p> <p>For information on how to change the Run/Debug configuration profile, refer to Run/Debug Configuration and Run/Debug Configuration: Plugin in IntelliJ IDEA Web Help.</p> <p>Using IntelliJ IDEA's debugger, you can find out the origin of the run-time errors and exceptions.</p> <p>To debug a plugin</p> <ul> <li>Select Run | Debug in the main menu, or press Shift + F9.</li> </ul> <p>To run a plugin</p> <ul> <li>Select Run | Run in the main menu, or press Shift + F10.</li> </ul>"},{"location":"basics/getting_started/setting_up_environment/","title":"Setting Up a Development Environment","text":"<p>NOTE For new projects, it is highly recommended to use Gradle.</p>"},{"location":"basics/getting_started/setting_up_environment/#preliminary-steps","title":"Preliminary Steps","text":"<p>Use the following checklist to ensure that you are ready to develop your custom plugins.</p> <ul> <li>Get IntelliJ IDEA CE source code on your local computer.   Getting IntelliJ IDEA CE source code is not a requirement for plugin development, but having it makes debugging your plugins much more straightforward.   For detailed instructions, refer to the Getting IntelliJ IDEA Community Edition Source Code section of Check Out And Build Community Edition.   Note that building IntelliJ IDEA CE from source code is not required for plugin development.</li> <li>Plugin DevKit plugin must be enabled in IntelliJ IDEA.</li> <li>Consulo SDK must be configured for your IDEA project.   For more information, see below.</li> </ul>"},{"location":"basics/getting_started/setting_up_environment/#configuring-consulo-sdk","title":"Configuring Consulo SDK","text":"<p>To set up your plugin development environment:</p> <ul> <li>Create a new Consulo SDK under File | Project Structure:    </li> <li>Specify the installation folder of the IntelliJ IDEA Community Edition as the home directory. <p>WARNING You may use IntelliJ IDEA Ultimate as an alternative, but debugging the core code will only work with the Community Edition.    </p> </li> <li>Select 1.8 as the default Java SDK.   See the IntelliJ Build Configuration section of Check Out And Build Community Edition for instructions about creating 1.8 Java SDK.    </li> <li>In the Sourcepath tab of the SDK settings, click the Add button:    </li> <li>Specify the source code directory for the IntelliJ IDEA Community Edition:    </li> <li>Specify the Sandbox Home directory.   The Sandbox Home directory stores the settings of the IDE development instance launched from a Plugin Project's Run configuration.   Shown below is the default Sandbox Home directory for a user on Mac OS X.   Any directory can be chosen as the Sandbox Home location.   Use the ellipsis button (shown below) to define a custom location.</li> </ul> <p>See the IDE Development Instances page for more information about default Sandbox Home directory locations and contents.</p> <p></p>"},{"location":"basics/getting_started/update_plugins_format/","title":"Publishing a Plugin to a Custom Plugin Repository","text":"<p>If you intend to use a plugin repository other than the JetBrains Plugins Repository, you will need to: * Create and maintain an <code>updatePlugins.xml</code> file on the HTTPS web server you are using for your custom repository.   This file describes all the plugins available in your custom repository and each plugin's download URL. * Upload your plugin JAR/ZIP file to an HTTPS web server.   This can be the same web server you are using for the custom repository or a different HTTPS web server. * Add the URL for the custom repository to the JetBrains IDE Repository Settings/Preferences.</p> <p>TIP Gradle plugin IntelliJ plugin uploader can be used to automate deployment.</p>"},{"location":"basics/getting_started/update_plugins_format/#describing-your-plugins-in-updatepluginsxml-file","title":"Describing Your Plugins in updatePlugins.xml File","text":"<p>Every custom plugin repository must have at least one <code>updatePlugins.xml</code> file to describe every hosted plugin's latest available version. The description in <code>updatePlugins.xml</code> is used by JetBrains IDEs to locate plugins by attributes such as id, IDE version, and plugin version. These attributes are displayed by JetBrains IDEs to help users select or upgrade plugins. The description also tells the JetBrains IDE where to download the plugin itself.</p> <p>A custom plugin repository's <code>updatePlugins.xml</code> file is constructed and maintained by the repository administrator. More than one <code>updatePlugins.xml</code> file may be required if the custom repository consumers are using more than one version of a JetBrains IDE. For example, <code>updatePlugins-182.xml</code>, <code>updatePlugins-183.xml</code> for IntelliJ IDEA 2018.2 and 2018.3, respectively. Each <code>updatePlugins-*.xml</code> file will have a unique URL that is added to the JetBrains IDE Repository Settings/Preferences.</p>"},{"location":"basics/getting_started/update_plugins_format/#format-of-updatepluginsxml-file","title":"Format of updatePlugins.xml File","text":"<p>The format of an <code>updatePlugins.xml</code> file is simply a list of sequential elements that describe each plugin:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!--\n  The &lt;plugins&gt; element contains the description of the plugins available at this repository. Required.\n--&gt;\n&lt;plugins&gt;\n  &lt;!--\n    Each &lt;plugin&gt; element describes one plugin in the repository. Required.\n    id - used by JetBrains IDEs to uniquely identify a plugin. Required. Must match &lt;id&gt; in plugin.xml\n    url - path to download the plugin JAR/ZIP file. Required. Must be HTTPS\n    version - version of this plugin. Required. Must match &lt;version&gt; in plugin.xml\n  --&gt;\n  &lt;plugin id=\"fully.qualified.id.of.this.plugin\" url=\"https://www.mycompany.com/my_repository/mypluginname.jar\" version=\"major.minor.update\"&gt;\n    &lt;!--\n      The &lt;idea-version&gt; element must match the same element in plugin.xml. Required.\n    --&gt;\n    &lt;idea-version since-build=\"181.3\" until-build=\"191.*\" /&gt;\n  &lt;/plugin&gt;\n  &lt;plugin id=\"id.of.different.plugin\" url=\"https://www.otherserver.com/other_repository/differentplugin.jar\" version=\"major.minor\"&gt;\n    &lt;idea-version since-build=\"181.3\" until-build=\"191.*\" /&gt;\n  &lt;/plugin&gt;\n  &lt;plugin&gt;\n    &lt;!-- And so on for other plugins... --&gt;\n  &lt;/plugin&gt;\n&lt;/plugins&gt;\n</code></pre> <p>Note: * An <code>updatePlugins.xml</code> file must contain at least one set of <code>&lt;plugin&gt;&lt;/plugin&gt;</code> elements. * A plugin <code>id</code> may be listed only once in an <code>updatePlugins.xml</code> file. * Multiple plugins with the same <code>id</code> but different <code>idea-version</code> attributes must be split into separate <code>updatePlugins-*.xml</code> files. The requesting IDE's version is passed as <code>build</code> parameter and can be used for server-side filtering.</p>"},{"location":"basics/getting_started/update_plugins_format/#optional-updatepluginxml-elements","title":"Optional updatePlugin.xml Elements","text":"<p>Can additional elements be added to <code>updatePlugins.xml</code>? Yes, but it's advisable only if needed. The additional elements will have to be synchronized with each plugin's <code>plugin.xml</code> file.</p> <p>During plugin installation the IDE reads the plugin JAR/ZIP file, and thereafter displays more information about the plugin. What additional information might help a user select a plugin when browsing the custom plugin repository before installation? The answer depends on the plugins and repository consumers. Here are the candidate elements:</p> Element Effects &amp; Requirements <code>&lt;name&gt;</code>My Plugin Name<code>&lt;/name&gt;</code> By default the name of the plugin JAR/ZIP file is displayed before installation. Using the <code>&lt;name&gt;</code> element displays the name of the plugin. Contents should match the <code>&lt;name&gt;</code> element contents in the plugins's <code>plugin.xml</code> file to avoid confusion. <code>&lt;description&gt;</code>My plugin is awesome<code>&lt;/description&gt;</code> By default no description for the plugin is displayed before installation. Using the <code>&lt;description&gt;</code> element will cause a description to be displayed before installation. Contents should match the <code>&lt;description&gt;</code> element contents in the plugins's <code>plugin.xml</code> file to avoid confusion. Optionally, an enclosing <code>&lt;![CDATA[ ]]&gt;</code> element can be used if the description needs to contain HTML tags. <code>&lt;change-notes&gt;</code>Added cool feature<code>&lt;/change-notes&gt;</code> By default no change notes for the plugin are displayed before installation. Using the <code>&lt;change-notes&gt;</code> element will cause a description of changes to be displayed before installation. Contents should match the <code>&lt;change-notes&gt;</code> element contents in the plugin's <code>plugin.xml</code> file to avoid confusion. Optionally, an enclosing <code>&lt;![CDATA[ ]]&gt;</code> element can be used if the change notes need to contain HTML tags."},{"location":"basics/getting_started/using_dev_kit/","title":"Using DevKit","text":"<p>NOTE For new projects, it is highly recommended to use Gradle.</p> <p>Plugin DevKit is a bundled IntelliJ IDEA plugin for developing plugins for the Consulo using IntelliJ IDEA's build system. It provides its custom SDK type and a set of actions for building plugins within the IDE.</p> <p>In this section:</p> <ul> <li>Setting Up a Development Environment</li> <li>Creating a Plugin Project</li> <li>Creating Actions</li> <li>Running and Debugging a Plugin</li> <li>Deploying a Plugin</li> <li>Publishing a Plugin</li> </ul>"},{"location":"basics/indexing_and_psi_stubs/file_based_indexes/","title":"File-Based Indexes","text":"<p>File-based indexes are based on a Map/Reduce architecture. Each index has a specific type of key and a particular type of value.</p> <p>The key is what's later used to retrieve data from the index.</p> <p>Example: in the word index, the key is the word itself.</p> <p>The value is arbitrary data, which is associated with the key in the index.</p> <p>Example: in the word index, the value is a mask indicating in which context the word occurs (code, string literal, or comment).</p> <p>In the simplest case, when we only need to know in what files some data is present, the value has type <code>Void</code> and is not stored in the index.</p> <p>When the index implementation indexes a file, it receives a file's content and returns a map from the keys found in the file to the associated values.</p> <p>When you access the index, you specify the key you're interested in and get back the list of files in which the key occurs, and the value associated with each file.</p>"},{"location":"basics/indexing_and_psi_stubs/file_based_indexes/#implementing-a-file-based-index","title":"Implementing a File-Based Index","text":"<p>A relatively simple file-based index implementation is the UI Designer bound forms index. Refer to it as an example to understand this topic better.</p> <p>Each specific index implementation is a class extending <code>FileBasedIndexExtension</code>. A file-based index should be registered in the <code>com.intellij.fileBasedIndex</code> extension point.</p> <p>An implementation of a file-based index consists of the following main parts:</p> <ul> <li><code>getIndexer()</code> returns the indexer class actually responsible for building a set of key/value pairs based on file content.</li> <li><code>getKeyDescriptor()</code> returns the key descriptor responsible for comparing keys and storing them in a serialized binary format.</li> </ul> <p>Probably the most commonly used <code>KeyDescriptor</code> implementation is <code>EnumeratorStringDescriptor</code>, which is designed for storing efficiently storing identifiers. * <code>getValueExternalizer()</code> returns the value serializer responsible for storing values in a serialized binary format. * <code>getInputFilter()</code> allows restricting the indexing only to a certain set of files. * <code>getVersion()</code> returns the version of the index implementation.   The index is automatically rebuilt if the current version differs from the version of the index implementation used to build it.</p> <p>If you don't need to associate any value with the files (i.e., your value type is <code>Void</code>), you can simplify the implementation by using <code>ScalarIndexExtension</code> as the base class.</p> <p>WARNING The data returned by <code>DataIndexer.map()</code> must depend only on input data passed to the method, and must not depend on any external files. Otherwise, your index will not be correctly updated when the external data changes, and you will have stale data in your index.</p> <p>NOTE Please see <code>com.intellij.util.indexing.DebugAssertions</code> on how to enable additional debugging assertions during development to assert correct index implementation.</p>"},{"location":"basics/indexing_and_psi_stubs/file_based_indexes/#accessing-a-file-based-index","title":"Accessing a File-Based Index","text":"<p>Access to file-based indexes is performed through the <code>FileBasedIndex</code> class.</p> <p>The following primary operations are supported:</p> <ul> <li><code>getAllKeys()</code> and <code>processAllKeys()</code> allow obtaining the list of all keys found in files, which are a part of the specified project.</li> </ul> <p>NOTE The returned data is guaranteed to contain all keys found in up-to-date project content, but may also include additional keys not currently found in the project.</p> <ul> <li><code>getValues()</code> allows to get all values associated with a specific key but not the files in which they were found.</li> <li><code>getContainingFiles()</code> allows collecting all files in which a particular key was encountered.</li> <li><code>processValues()</code> allows iterating through all files in which a specific key was encountered and accessing the associated values simultaneously.</li> </ul> <p>WARNING Nested index access is forbidden as it might lead to a deadlock. Collect all necessary data from index A first, then process results while accessing index B.</p>"},{"location":"basics/indexing_and_psi_stubs/file_based_indexes/#standard-indexes","title":"Standard Indexes","text":"<p>The Consulo contains several standard file-based indexes. The most useful indexes for plugin developers are:</p>"},{"location":"basics/indexing_and_psi_stubs/file_based_indexes/#word-index","title":"Word Index","text":"<p>Generally, the word index should be accessed indirectly by using helper methods of the <code>PsiSearchHelper</code> class.</p>"},{"location":"basics/indexing_and_psi_stubs/file_based_indexes/#file-name-index","title":"File Name Index","text":"<p><code>FilenameIndex</code> provides a quick way to find all files matching a specific file name.</p>"},{"location":"basics/indexing_and_psi_stubs/file_based_indexes/#file-type-index","title":"File Type Index","text":"<p><code>FileTypeIndex</code> serves a similar goal: it allows to find all files of a particular <code>FileType</code> quickly.</p>"},{"location":"basics/indexing_and_psi_stubs/stub_indexes/","title":"Stub Indexes","text":""},{"location":"basics/indexing_and_psi_stubs/stub_indexes/#stub-trees","title":"Stub Trees","text":"<p>A stub tree is a subset of the PSI tree for a file; it is stored in a compact serialized binary format. The PSI tree for a file can be backed either by the AST (built by parsing the file) or by the stub tree deserialized from disk. Switching between the two is transparent.</p> <p>The stub tree contains only a subset of the nodes. Typically, it contains only the nodes needed to resolve the declarations contained in this file from external files. Trying to access any node that is not part of the stub tree or perform any operation that cannot be satisfied by the stub tree, e.g., accessing the text of a PSI element, causes file parsing to switch from the PSI to AST backing.</p> <p>Each stub in the stub tree is simply a bean class with no behavior. A stub stores a subset of the corresponding PSI element's state, like the element's name, modifier flags like public or final, etc. The stub also holds a pointer to its parent in the tree and a list of its children's stubs.</p> <p>To support stubs for your custom language, you first need to decide which of your PSI tree elements should be stored as stubs. Typically, you need to have stubs for things like methods or fields visible from other files. You usually don't need to have stubs for things like statements or local variables, which are not visible externally.</p> <p>For each element type that you want to store in the stub tree, you need to perform the following steps:</p> <ul> <li>Define an interface for the stub, derived from the <code>StubElement</code> interface (example).</li> <li>Provide an implementation for the interface (example).</li> <li>Make sure the interface for the PSI element extends <code>StubBasedPsiElement</code> parameterized by the type of the stub interface (example).</li> <li>Make sure the implementation class for the PSI element extends <code>StubBasedPsiElementBase</code> parameterized by the type of the stub interface (example).   Provide both a constructor that accepts an <code>ASTNode</code> and a constructor that accepts a stub.</li> <li>Create a class that implements <code>IStubElementType</code> and is parameterized with the stub interface and the actual PSI element interface (example).   Implement the <code>createPsi()</code> and <code>createStub()</code> methods for creating PSI from a stub and vice versa.   Implement the <code>serialize()</code> and <code>deserialize()</code> methods for storing the data in a binary stream.</li> <li>Use the class implementing <code>IStubElementType</code> as the element type constant when parsing (example).</li> <li>Make sure all methods in the PSI element interface access the stub data rather than the PSI tree when appropriate (example: <code>Property.getKey()</code> implementation).</li> </ul> <p>The following steps need to be performed only once for each language that supports stubs:</p> <ul> <li>Change the file element type for your language (the element type that you return from <code>ParserDefinition.getFileNodeType()</code>) to a class that extends <code>IStubFileElementType</code>.</li> <li>In your <code>plugin.xml</code>, define the <code>com.intellij.stubElementTypeHolder</code> extension and specify the interface which contains the <code>IElementType</code> constants used by your language's parser as well as <code>externalIdPrefix</code> if possible (example).</li> </ul> <p>For serializing string data, e.g. element names, in stubs, we recommend to use <code>StubOutputStream.writeName()</code> and <code>StubInputStream.readName()</code> methods. These methods ensure that each unique identifier is stored only once in the data stream. This reduces the size of the serialized stub tree data.</p> <p>If you need to change the stored binary format for the stubs (for example, if you want to store some additional data or some new elements), make sure you advance the stub version returned from <code>IStubFileElementType.getStubVersion()</code> for your language. This will cause the stubs and stub indices to be rebuilt, and will avoid mismatches between the stored data format, and the code trying to load it.</p> <p>By default, if a PSI element extends <code>StubBasedPsiElement</code>, all elements of that type will be stored in the stub tree. If you need more precise control over which elements are stored, override <code>IStubElementType.shouldCreateStub()</code> and return <code>false</code> for elements that should not be included in the stub tree.</p> <p>NOTE The exclusion is not recursive: if some elements of the element for which you returned false are also stub-based PSI elements, they will be included in the stub tree.</p> <p>It's essential to ensure that all information stored in the stub tree depends only on the contents of the file for which stubs are being built, and does not depend on any external files. Otherwise, the stub tree will not be rebuilt when external dependency changes, and you will have stale and incorrect data in the stub tree.</p> <p>TIP Please see also Improving indexing performance.</p>"},{"location":"basics/indexing_and_psi_stubs/stub_indexes/#stub-indexes","title":"Stub Indexes","text":"<p>When building the stub tree, you can, at the same time, put some data about the stub elements into a number of indexes, which then can be used to find the PSI elements by the corresponding key. Unlike file-based indexes, stub indexes do not support storing custom data as values; the value is always a PSI element. Keys in stub indexes are typically strings (such as class names); other data types are also supported if desired.</p> <p>A stub index is a class which extends <code>AbstractStubIndex</code>. In the most common case, when the key type is <code>String</code>, you use a more specific base class, namely <code>StringStubIndexExtension</code>. Stub index implementation classes are registered in the <code>com.intellij.stubIndex</code> extension point.</p> <p>To put data into an index, you implement the method <code>IStubElementType.indexStub()</code> (example: <code>JavaClassElementType.indexStub()</code>). This method accepts an <code>IndexSink</code> as a parameter and puts in the index ID and the key for each index in which the element should be stored.</p> <p>To access the data from an index, the following two methods are used:</p> <ul> <li><code>AbstractStubIndex.getAllKeys()</code> returns the list of all keys in the specified index for the specified project (for example, the list of all class names found in the project).</li> <li><code>AbstractStubIndex.get()</code> returns the collection of PSI elements corresponding to a certain key (for example, classes with the specified short name) in the specified scope.</li> </ul>"},{"location":"basics/indexing_and_psi_stubs/stub_indexes/#related-forum-discussions","title":"Related Forum Discussions","text":"<ul> <li>Lifecycle of stub creation</li> </ul>"},{"location":"basics/plugin_structure/plugin_actions/","title":"Plugin Actions","text":"<p>The Consulo provides the concept of actions. An action is a class derived from <code>AnAction</code>, whose <code>actionPerformed()</code> method is called when its menu item or toolbar button is selected.</p> <p>Actions are the most common way for a user to invoke the functionality of your plugin. An action can be invoked from a menu or a toolbar, using a keyboard shortcut or the Help | Find Action... lookup.</p> <p>Actions are organized into groups, which, in turn, can contain other groups. A group of actions can form a toolbar or a menu. Subgroups of the group can form submenus of a menu.</p> <p>The user can customize all registered actions via Menus and Toolbars settings.</p> <p>Please see Action System on how to create and register actions in the IDE.</p>"},{"location":"basics/plugin_structure/plugin_class_loaders/","title":"Plugin Class Loaders","text":"<p>A separate class loader is used to load the classes of each plugin. This allows each plugin to use a different library version, even if the same library is used by the IDE itself or by another plugin.</p> <p>By default, the main IDE class loader loads classes that are not found in the plugin class loader. However, in the <code>plugin.xml</code> file, you may use the <code>&lt;depends&gt;</code> element to specify that a plugin depends on one or more other plugins. In this case, the class loaders of those plugins will be used for classes not found in the current plugin. This allows a plugin to reference classes from other plugins.</p>"},{"location":"basics/plugin_structure/plugin_class_loaders/#using-serviceloader","title":"Using ServiceLoader","text":"<p>Some libraries use <code>ServiceLoader</code> to detect and load implementations. For this to work in a plugin, the context class loader must be set to the plugin's classloader and restored afterwards with original one around initialization code:</p> <pre><code>    ClassLoader current = Thread.currentThread().getContextClassLoader();\n    try {\n        Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());\n        // code working with ServiceLoader here\n    } finally {\n        Thread.currentThread().setContextClassLoader(current);\n    }\n</code></pre>"},{"location":"basics/plugin_structure/plugin_components/","title":"Plugin Components","text":"<p>WARNING When writing new plugins, creating Components should be avoided. Any existing Components should be migrated to services, extensions, or listeners (see below).</p> <p>Plugin Components are a legacy feature supported for compatibility with plugins created for older versions of the Consulo.</p> <p>Plugin Components are defined in the <code>&lt;application-components&gt;</code>, <code>&lt;project-components&gt;</code>, and <code>&lt;module-components&gt;</code> sections in a Plugin Configuration File.</p>"},{"location":"basics/plugin_structure/plugin_components/#migration","title":"Migration","text":"<p>To migrate existing code from Components to more modern APIs, please see the following guidelines.</p>"},{"location":"basics/plugin_structure/plugin_components/#manage-state","title":"Manage State","text":"<p>To manage some state or logic that is only needed when the user performs a specific operation, use a Service.</p>"},{"location":"basics/plugin_structure/plugin_components/#persisting-state","title":"Persisting State","text":"<p>To store the state of your plugin at the application or project level, use a Service, and implement the <code>PersistentStateComponent</code> interface. See Persisting State of Components for details.</p>"},{"location":"basics/plugin_structure/plugin_components/#subscribing-to-events","title":"Subscribing to Events","text":"<p>To subscribe to events, use a listener or create an extension for a dedicated extension point (for example, <code>com.intellij.editorFactoryListener</code>) if one exists for the event to subscribe to.</p>"},{"location":"basics/plugin_structure/plugin_components/#application-startup","title":"Application Startup","text":"<p>Executing code on application startup should be avoided whenever possible because it slows down startup. Plugin code should only be executed when projects are opened (see Project Open) or when the user invokes an action of a plugin. If this cannot be avoided, add a listener subscribing to the AppLifecycleListener topic.</p> <p>To execute an activity in background on IDE startup (e.g., to warm up caches), use <code>PreloadingActivity</code>.</p>"},{"location":"basics/plugin_structure/plugin_components/#project-open","title":"Project Open","text":"<p>To execute code when a project is being opened, use one of these two extensions:</p> <p><code>com.intellij.postStartupActivity</code> : StartupActivity for immediate execution on EDT. Implement <code>DumbAware</code> to indicate activity can run in background thread (in parallel with other such tasks). </p> <p><code>com.intellij.backgroundPostStartupActivity</code> : StartupActivity.Background for execution with 5 seconds delay in background thread (2019.3 or later).</p> <p>Any long-running or CPU intensive tasks should be made visible to users by using <code>ProgressManager.run(Task.Backgroundable)</code>. Access to indices must be wrapped with <code>DumbService</code>, see also General Threading Rules.  </p>"},{"location":"basics/plugin_structure/plugin_components/#applicationproject-close","title":"Application/Project Close","text":"<p>To execute code on project closing or application shutdown, implement the <code>Disposable</code> interface in a Service and place the code in the <code>dispose()</code> method. Alternatively, use <code>Disposer.register()</code> passing a <code>Project</code> or <code>Application</code> service instance as the <code>parent</code> argument (see Choosing a Disposable Parent).</p>"},{"location":"basics/plugin_structure/plugin_configuration_file/","title":"Plugin Configuration File - plugin.xml","text":"<p>The following is a sample plugin configuration file. This sample showcases and describes all elements that can be used in the <code>plugin.xml</code> file. Additional information about configuring <code>&lt;actions&gt;</code> is available in the Actions section in Part II.</p> <p>Limited HTML elements are allowed within <code>&lt;description&gt;</code> and <code>&lt;change-notes&gt;</code> elements. However, content containing HTML elements must be surrounded by <code>&lt;![CDATA[  ]]&gt;</code> tags. Allowed HTML elements include text formatting, paragraphs, and lists.</p> <p>When using Gradle, a number of metadata elements will be provided at build time by <code>patchPluginXml</code> task.</p> <pre><code>&lt;!-- `url` specifies the URL of the plugin homepage (can be opened from \"Plugins\" settings dialog) --&gt;\n&lt;idea-plugin url=\"https://www.jetbrains.com/idea\"&gt;\n\n  &lt;!-- Plugin name. It should be short and descriptive and in Title Case.\n       Displayed in the \"Plugins\" settings dialog and the plugin repository Web interface. --&gt;\n  &lt;name&gt;Vss Integration&lt;/name&gt;\n\n  &lt;!-- Unique identifier of the plugin. It should be FQN.\n       It cannot be changed between the plugin versions.\n       If not specified, &lt;name&gt; will be used (not recommended). --&gt;\n  &lt;id&gt;com.jetbrains.vssintegration&lt;/id&gt;\n\n  &lt;!-- Description of the plugin.\n       Should be short and to the point.\n       Start the description with a verb in a present simple form such as\n       \"integrates\", \"synchronizes\", \"adds support for\" or \"lets you view\".\n       Don't use marketing adjectives like \"simple\", \"lightweight\", or \"professional\".\n       Don't repeat the name of the plugin.\n       For plugins that add language/platform/framework support, the description MUST specify\n       the version of the corresponding language/platform/framework.\n       Don't mention the IDE compatibility. E.g., don't say \"Adds support to IntelliJ IDEA for...\"\n       Displayed in the \"Plugins\" settings dialog and the plugin repository Web interface.\n       Simple HTML elements can be included between &lt;![CDATA[  ]]&gt; tags.  --&gt;\n  &lt;description&gt;Integrates Volume Snapshot Service W10&lt;/description&gt;\n\n  &lt;!-- Description of changes in the latest version of the plugin.\n       Displayed in the \"Plugins\" settings dialog and the plugin repository Web interface.\n       Simple HTML elements can be included between &lt;![CDATA[  ]]&gt; tags.  --&gt;\n  &lt;change-notes&gt;Initial release of the plugin.&lt;/change-notes&gt;\n\n  &lt;!-- Plugin version\n       Recommended format is BRANCH.BUILD.FIX (MAJOR.MINOR.FIX)\n       Displayed in the \"Plugins\" settings dialog and the plugin repository Web interface.  --&gt;\n  &lt;version&gt;1.0.0&lt;/version&gt;\n\n  &lt;!-- The vendor of the plugin.\n       The optional \"url\" attribute specifies the URL of the vendor homepage.\n       The optional \"email\" attribute specifies the e-mail address of the vendor.\n       Displayed in the \"Plugins\" settings dialog and the plugin repository Web interface. --&gt;\n  &lt;vendor url=\"https://www.company.com\" email=\"support@company.com\"&gt;A Company Inc.&lt;/vendor&gt;\n\n  &lt;!-- Mandatory dependencies on plugins or modules.\n       The FQN module names in &lt;depends&gt; elements are used to determine IDE compatibility for the plugin.\n       Include at least the module shown below to indicate compatibility with Consulo-based products.\n       Also, include dependencies on other plugins as needed.\n       See \"Compatibility with Multiple Products\" and \"Plugin Dependencies\" for more information.  --&gt;\n  &lt;depends&gt;com.intellij.modules.platform&lt;/depends&gt;\n  &lt;depends&gt;com.third.party.plugin&lt;/depends&gt;\n\n  &lt;!-- Optional dependency on another plugin.\n       If the plugin with the \"com.MySecondPlugin\" ID is installed, the contents of mysecondplugin.xml\n       (the format of this file conforms to the format of plugin.xml) will be loaded. --&gt;\n  &lt;depends optional=\"true\" config-file=\"mysecondplugin.xml\"&gt;com.MySecondPlugin&lt;/depends&gt;\n\n  &lt;!-- Minimum and maximum build of IDE compatible with the plugin --&gt;\n  &lt;idea-version since-build=\"193\" until-build=\"193.*\"/&gt;\n\n  &lt;!-- Resource bundle (/messages/MyPluginBundle.properties) to be used\n       with `key` attributes in extension points and implicit keys like\n       `action.[ActionID].text|description` --&gt;\n  &lt;resource-bundle&gt;messages.MyPluginBundle&lt;/resource-bundle&gt;\n\n  &lt;!-- Plugin's application components / DEPRECATED - do not use in new plugins\n       See https://www.jetbrains.org/intellij/sdk/docs/basics/plugin_structure/plugin_components.html for migration steps\n  --&gt;\n  &lt;application-components&gt;\n    &lt;component&gt;\n      &lt;!-- Component's interface class --&gt;\n      &lt;interface-class&gt;com.foo.Component1Interface&lt;/interface-class&gt;\n\n      &lt;!-- Component's implementation class --&gt;\n      &lt;implementation-class&gt;com.foo.impl.Component1Impl&lt;/implementation-class&gt;\n    &lt;/component&gt;\n  &lt;/application-components&gt;\n\n  &lt;!-- Plugin's project components / DEPRECATED - do not use in new plugins\n       See https://www.jetbrains.org/intellij/sdk/docs/basics/plugin_structure/plugin_components.html for migration steps\n  --&gt;\n  &lt;project-components&gt;\n    &lt;component&gt;\n      &lt;!-- Interface and implementation classes are the same --&gt;\n      &lt;implementation-class&gt;com.foo.Component2&lt;/implementation-class&gt;\n\n      &lt;!-- If the \"workspace\" option is set \"true\", the component\n           saves its state to the .iws file instead of the .ipr file.\n           Note that the &lt;option&gt; element is used only if the component\n           implements the JDOMExternalizable interface. Otherwise, the\n           use of the &lt;option&gt; element takes no effect.  --&gt;\n      &lt;option name=\"workspace\" value=\"true\" /&gt;\n\n      &lt;!-- If the \"loadForDefaultProject\" tag is present, the project component is instantiated also for the default project. --&gt;\n      &lt;loadForDefaultProject/&gt;\n    &lt;/component&gt;\n  &lt;/project-components&gt;\n\n  &lt;!-- Plugin's module components / DEPRECATED - do not use in new plugins\n       See https://www.jetbrains.org/intellij/sdk/docs/basics/plugin_structure/plugin_components.html for migration steps\n  --&gt;\n  &lt;module-components&gt;\n    &lt;component&gt;\n      &lt;implementation-class&gt;com.foo.Component3&lt;/implementation-class&gt;\n    &lt;/component&gt;\n  &lt;/module-components&gt;\n\n  &lt;!-- Actions --&gt;\n  &lt;actions&gt;\n    &lt;action id=\"VssIntegration.GarbageCollection\" class=\"com.foo.impl.CollectGarbage\" text=\"Collect _Garbage\" description=\"Run garbage collector\"&gt;\n      &lt;keyboard-shortcut first-keystroke=\"control alt G\" second-keystroke=\"C\" keymap=\"$default\"/&gt;\n    &lt;/action&gt;\n  &lt;/actions&gt;\n\n  &lt;!-- Extension points defined by the plugin.\n       Extension points are registered by a plugin so that other\n       plugins can provide this plugin with certain data.\n  --&gt;\n  &lt;extensionPoints&gt;\n    &lt;extensionPoint name=\"testExtensionPoint\" beanClass=\"com.foo.impl.MyExtensionBean\"/&gt;\n  &lt;/extensionPoints&gt;\n\n  &lt;!-- Extensions which the plugin adds to extension points\n       defined by the Consulo or by other plugins.\n       The \"defaultExtensionNs\" attribute must be set to the\n       ID of the plugin defining the extension point, or to\n       \"com.intellij\" if the extension point is defined by the\n       Consulo. The name of the tag within the &lt;extensions&gt;\n       tag matches the name of the extension point, and the\n       \"implementation\" class specifies the name of the class\n       added to the extension point. --&gt;\n  &lt;extensions defaultExtensionNs=\"VssIntegration\"&gt;\n    &lt;testExtensionPoint implementation=\"com.foo.impl.MyExtensionImpl\"/&gt;\n  &lt;/extensions&gt;\n\n  &lt;!-- Application-level listeners --&gt;\n  &lt;applicationListeners&gt;\n    &lt;listener class=\"com.foo.impl.MyListener\" topic=\"com.intellij.openapi.vfs.newvfs.BulkFileListener\"/&gt;\n  &lt;/applicationListeners&gt;\n\n  &lt;!-- Project-level listeners --&gt;\n  &lt;projectListeners&gt;\n    &lt;listener class=\"com.foo.impl.MyToolwindowListener\" topic=\"com.intellij.openapi.wm.ex.ToolWindowManagerListener\"/&gt;\n  &lt;/projectListeners&gt;\n&lt;/idea-plugin&gt;\n</code></pre>"},{"location":"basics/plugin_structure/plugin_content/","title":"Plugin Content","text":"<p>The plugin <code>jar</code> file must contain: - the configuration file (<code>META-INF/plugin.xml</code>) (Plugin Configuration File) - the classes that implement the plugin functionality - recommended: plugin logo file(s) (<code>META-INF/pluginIcon*.svg</code>) (Plugin Logo)</p>"},{"location":"basics/plugin_structure/plugin_content/#plugin-without-dependencies","title":"Plugin Without Dependencies","text":"<p>A plugin consisting of a single <code>.jar</code> file is placed in the <code>/plugins</code> directory.</p> <pre><code>.IntelliJIDEAx0/\n\u2514\u2500\u2500 plugins\n    \u2514\u2500\u2500 sample.jar\n        \u251c\u2500\u2500 com/foo/...\n        \u2502   ...\n        \u2502   ...\n        \u2514\u2500\u2500 META-INF\n            \u251c\u2500\u2500 plugin.xml\n            \u251c\u2500\u2500 pluginIcon.svg\n            \u2514\u2500\u2500 pluginIcon_dark.svg\n</code></pre>"},{"location":"basics/plugin_structure/plugin_content/#plugin-with-dependencies","title":"Plugin With Dependencies","text":"<p>The plugin <code>.jar</code> file is placed in the <code>/lib</code> folder under the plugin's \"root\" folder, together with all required bundled libraries.</p> <p>All jars from the <code>/lib</code> folder are automatically added to the classpath (see also Plugin Class Loaders).</p> <pre><code>   .IntelliJIDEAx0/\n   \u2514\u2500\u2500 plugins\n       \u2514\u2500\u2500 sample\n           \u2514\u2500\u2500 lib\n               \u251c\u2500\u2500 lib_foo.jar\n               \u251c\u2500\u2500 lib_bar.jar\n               \u2502   ...\n               \u2502   ...\n               \u2514\u2500\u2500 sample.jar\n                   \u251c\u2500\u2500 com/foo/...\n                   \u2502   ...\n                   \u2502   ...\n                   \u2514\u2500\u2500 META-INF\n                       \u251c\u2500\u2500 plugin.xml\n                       \u251c\u2500\u2500 pluginIcon.svg\n                       \u2514\u2500\u2500 pluginIcon_dark.svg\n</code></pre>"},{"location":"basics/plugin_structure/plugin_dependencies/","title":"Plugin Dependencies","text":"<p>A plugin may depend on classes from other plugins, either bundled, third-party, or by the same author. This document describes the syntax for declaring plugin dependencies and optional plugin dependencies. For more information about dependencies on the Consulo modules, see Part II of this document: Plugin Compatibility with Consulo Products.</p> <p>NOTE It is impossible to specify the minimum/maximum version for the dependent plugin. (Issue)</p> <p>To express dependencies on classes from other plugins or modules, perform the following three required steps:</p>"},{"location":"basics/plugin_structure/plugin_dependencies/#1-locating-plugin-id-and-preparing-sandbox","title":"1. Locating Plugin ID and Preparing Sandbox","text":"<p>A compatible version must be chosen carefully according to the plugin's compatibility. </p> <p>For plugins published on JetBrains Plugins Repository - open plugin's detail page - select Versions tab - open detail page for the desired version, displaying the Compatibility Range and Plugin ID</p> <p>For bundled and non-public plugins, locate the plugin's main JAR file containing <code>META-INF/plugin.xml</code> descriptor with <code>&lt;id&gt;</code> tag (or <code>&lt;name&gt;</code> if not specified).</p> <p>If the plugin is not bundled with the target IDE, run the (sandbox) IDE Development Instance of your target IDE and install the plugin there.</p>"},{"location":"basics/plugin_structure/plugin_dependencies/#2-project-setup","title":"2. Project Setup","text":"<p>Depending on the chosen development workflow (Gradle or DevKit), one of the two following steps is necessary.</p>"},{"location":"basics/plugin_structure/plugin_dependencies/#21-gradle","title":"2.1 Gradle","text":"<p>NOTE Please see the <code>plugins</code> attribute gradle-intellij-plugin: Configuration for acceptable values.</p> <p>If the project uses Gradle with a Groovy build script to build the plugin, add the dependency to the <code>plugins</code> parameter of the <code>intellij</code> block in your <code>build.gradle</code>, for example:</p> <pre><code>intellij {\n    plugins 'org.another.plugin:1.0'\n}\n</code></pre> <p>When using Kotlin build script, use <code>setPlugins()</code> within the <code>intellij</code> block, for example:</p> <pre><code>intellij {\n    setPlugins(\"org.another.plugin:1.0\")\n}\n</code></pre> <p>NOTE Transitive dependencies required for tests must currently be specified explicitly.</p>"},{"location":"basics/plugin_structure/plugin_dependencies/#22-devkit","title":"2.2 DevKit","text":"<p>TIP Existing DevKit-based projects can be converted to use Gradle setup where managing dependencies is fully automated.</p> <p>If the project uses DevKit, add the JARs of the plugin on which the project depends to the classpath of the Consulo SDK.</p> <p>WARNING Do not add the plugin JARs as a library: this will fail at runtime because the Consulo will load two separate copies of the dependency plugin classes.</p> <p>To do that, open the Project Structure dialog, select the SDK used in the project, press the + button in the Classpath tab, and select the plugin JAR file or files: * For bundled plugins, the plugin JAR files are located in <code>plugins/&lt;pluginname&gt;</code> or <code>plugins/&lt;pluginname&gt;/lib</code> under the main installation directory.   If you're not sure which JAR to add, you can add all of them. * For non-bundled plugins, the plugin JAR files are located in <code>config/plugins/&lt;pluginname&gt;</code> or <code>config/plugins/&lt;pluginname&gt;/lib</code> under the directory specified as \"Sandbox Home\" in the Consulo Plugin SDK settings.</p>"},{"location":"basics/plugin_structure/plugin_dependencies/#3-dependency-declaration-in-pluginxml","title":"3. Dependency Declaration in plugin.xml","text":"<p>Regardless of whether a plugin project uses Modules Available in All Products, or Modules Specific to Functionality, the correct module must be listed as a dependency in <code>plugin.xml</code>. If a project depends on another plugin, the dependency must be declared like a module. If only general Consulo features (APIs) are used, then a default dependency on <code>com.intellij.modules.platform</code> must be declared.</p> <p>To display a list of available Consulo modules, invoke the code completion feature for the <code>&lt;depends&gt;</code> element contents while editing the plugin project's <code>plugin.xml</code> file.</p>"},{"location":"basics/plugin_structure/plugin_dependencies/#31-configuring-pluginxml","title":"3.1 Configuring plugin.xml","text":"<p>In the <code>plugin.xml</code>, add a <code>&lt;depends&gt;</code> tag with the dependency plugin's ID as its content. Continuing with the example from Section 2 above, the dependency declaration in <code>plugin.xml</code> would be:</p> <pre><code>&lt;depends&gt;org.another.plugin&lt;/depends&gt;\n</code></pre>"},{"location":"basics/plugin_structure/plugin_dependencies/#optional-plugin-dependencies","title":"Optional Plugin Dependencies","text":"<p>A project can also specify an optional plugin dependency. In this case, the plugin will load even if the plugin it depends on is not installed or enabled, but part of the plugin's functionality will not be available.</p> <p>Declare additional <code>optional=\"true\"</code> and <code>config-file</code> attribute pointing to optional plugin descriptor file:</p> <pre><code>  &lt;depends optional=\"true\" config-file=\"myPluginId-optionalPluginName.xml\"&gt;dependency.plugin.id&lt;/depends&gt; \n</code></pre> <p>NOTE Additional plugin descriptor files must follow the naming pattern <code>myPluginId-$NAME$.xml</code> resulting in unique filenames to prevent problems with classloaders in tests (Details).</p> <p>For example, if a plugin adds additional highlighting for Java and Kotlin files, use the following setup. The main <code>plugin.xml</code> will define an annotator for Java and specify an optional dependency on the Kotlin plugin (<code>org.jetbrains.kotlin</code>):</p> <p>plugin.xml</p> <pre><code>&lt;idea-plugin&gt;\n   ...\n   &lt;depends optional=\"true\" config-file=\"myPluginId-withKotlin.xml\"&gt;org.jetbrains.kotlin&lt;/depends&gt;\n\n   &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n      &lt;annotator language=\"JAVA\" implementationClass=\"com.example.MyJavaAnnotator\"/&gt;\n   &lt;/extensions&gt;\n&lt;/idea-plugin&gt;\n</code></pre> <p>Then create a file called <code>myPluginId-withKotlin.xml</code>, in the same directory as the main <code>plugin.xml</code> file. In that file, define an annotator for Kotlin:</p> <p>myPluginId-withKotlin.xml</p> <pre><code>&lt;idea-plugin&gt;\n   &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n      &lt;annotator language=\"kotlin\" implementationClass=\"com.example.MyKotlinAnnotator\"/&gt;\n   &lt;/extensions&gt;\n&lt;/idea-plugin&gt;\n</code></pre>"},{"location":"basics/plugin_structure/plugin_extension_points/","title":"Plugin Extension Points","text":"<p>NOTE See Plugin Extensions for using extension points in your plugin.</p> <p>By defining extension points in your plugin, you can allow other plugins to extend your plugin's functionality. There are two types of extension points:</p> <ul> <li>Interface extension points allow other plugins to extend your plugins with code.   When you define an interface extension point, you specify an interface, and other plugins will provide classes implementing that interface.   You'll then be able to invoke methods on those interfaces.</li> <li>Bean extension points allow other plugins to extend your plugins with data.   You specify the fully qualified name of an extension class, and other plugins will provide data that will be turned into instances of that class.</li> </ul>"},{"location":"basics/plugin_structure/plugin_extension_points/#declaring-extension-points","title":"Declaring Extension Points","text":"<p>You can declare extensions and extension points in the plugin configuration file <code>plugin.xml</code>, within the <code>&lt;extensions&gt;</code> and <code>&lt;extensionPoints&gt;</code> sections.</p> <p>To declare extension points in your plugin, add an <code>&lt;extensionPoints&gt;</code> section to your <code>plugin.xml</code>. Then insert a child element <code>&lt;extensionPoint&gt;</code> that defines the extension point name and the name of a bean class or an interface that is allowed to extend the plugin functionality in the <code>name</code>, <code>beanClass</code> and <code>interface</code> attributes, respectively.</p> <p>myPlugin/META-INF/plugin.xml</p> <pre><code>&lt;idea-plugin&gt;\n  &lt;id&gt;my.plugin&lt;/id&gt;\n\n  &lt;extensionPoints&gt;\n    &lt;extensionPoint name=\"myExtensionPoint1\"\n                    beanClass=\"com.myplugin.MyBeanClass\"/&gt;\n\n    &lt;extensionPoint name=\"myExtensionPoint2\"\n                    interface=\"com.myplugin.MyInterface\"/&gt;\n  &lt;/extensionPoints&gt;\n\n&lt;/idea-plugin&gt;\n</code></pre> <p>The <code>name</code> attribute assigns a unique name for this extension point.  It will be prefixed with the plugin's <code>&lt;id&gt;</code> automatically.</p> <p>The <code>beanClass</code> attribute sets a bean class that specifies one or several properties annotated with the <code>@Attribute</code> annotation. The <code>interface</code> attribute sets an interface the plugin that contributes to the extension point must implement.</p> <p>The <code>area</code> attribute determines the scope in which the extension will be instantiated. As extensions should be stateless, it is not recommended to use non-default. Must be one of <code>IDEA_APPLICATION</code> for Application (default), <code>IDEA_PROJECT</code> for Project, or <code>IDEA_MODULE</code> for Module scope.</p> <p>The plugin that contributes to the extension point will read those properties from the <code>plugin.xml</code> file.</p>"},{"location":"basics/plugin_structure/plugin_extension_points/#sample","title":"Sample","text":"<p>To clarify this, consider the following sample <code>MyBeanClass</code> bean class used in the above <code>plugin.xml</code> file:</p> <p>myPlugin/src/com/myplugin/MyBeanClass.java</p> <pre><code>public class MyBeanClass extends AbstractExtensionPointBean {\n\n  @Attribute(\"key\")\n  public String key;\n\n  @Attribute(\"implementationClass\")\n  public String implementationClass;\n\n  public String getKey() {\n    return key;\n  }\n\n  public String getClass() {\n    return implementationClass;\n  }\n}\n</code></pre> <p>TIP See Extension properties code insight on how to provide smart completion/validation.</p> <p>For above extension points usage in anotherPlugin would look like this (see also Declaring Extensions):</p> <p>anotherPlugin/META-INF/plugin.xml</p> <pre><code>&lt;idea-plugin&gt;\n  &lt;id&gt;another.plugin&lt;/id&gt;\n\n  &lt;!-- declare dependency on plugin defining extension point --&gt;\n  &lt;depends&gt;my.plugin&lt;/depends&gt;\n\n  &lt;!-- use \"my.plugin\" namespace --&gt;\n  &lt;extensions defaultExtensionNs=\"my.plugin\"&gt;\n    &lt;myExtensionPoint1 key=\"someKey\"\n                       implementationClass=\"another.some.implementation.class\"/&gt;\n\n    &lt;myExtensionPoint2 implementation=\"another.MyInterfaceImpl\"/&gt;\n  &lt;/extension&gt;\n\n&lt;/idea-plugin&gt;\n</code></pre>"},{"location":"basics/plugin_structure/plugin_extension_points/#using-extension-points","title":"Using Extension Points","text":"<p>To refer to all registered extension instances at runtime, declare an <code>ExtensionPointName</code> passing in the fully-qualified name matching its declaration in <code>plugin.xml</code>.</p> <p>myPlugin/src/com/myplugin/MyExtensionUsingService.java</p> <pre><code>public class MyExtensionUsingService {\n\n    private static final ExtensionPointName&lt;MyBeanClass&gt; EP_NAME =\n      ExtensionPointName.create(\"my.plugin.myExtensionPoint1\");\n\n    public void useExtensions() {\n      for (MyBeanClass extension : EP_NAME.getExtensionList()) {\n        String key = extension.getKey();\n        String clazz = extension.getClass();\n        // ...\n      }\n    }\n}\n</code></pre> <p>A gutter icon for the <code>ExtensionPointName</code> declaration allows navigating to the corresponding <code>&lt;extensionPoint&gt;</code> declaration in <code>plugin.xml</code>.</p>"},{"location":"basics/plugin_structure/plugin_extensions/","title":"Plugin Extensions","text":"<p>Extensions are the most common way for a plugin to extend the Consulo's functionality in a way that is not as straightforward as adding an action to a menu or toolbar.</p> <p>The following are some of the most common tasks accomplished using extensions:</p> <ul> <li>The <code>com.intellij.toolWindow</code> extension point allows plugins to add tool windows   (panels displayed at the sides of the IDE user interface);</li> <li>The <code>com.intellij.applicationConfigurable</code> and <code>com.intellij.projectConfigurable</code> extension points allow plugins to add pages to the     Settings/Preferences dialog;</li> <li>Custom language plugins use many extension points     to extend various language support features in the IDE.</li> </ul> <p>There are more than 1000 extension points available in the platform and the bundled plugins, allowing to customize different parts of the IDE behavior.</p>"},{"location":"basics/plugin_structure/plugin_extensions/#declaring-extensions","title":"Declaring Extensions","text":"<p>TIP Auto-completion, Quick Documentation, and other code insight features are available on extension point tags and attributes.</p> <ol> <li>Add an <code>&lt;extensions&gt;</code> element to your <code>plugin.xml</code> if it's not yet present there.    Set the <code>defaultExtensionNs</code> attribute to one of the following values:<ul> <li><code>com.intellij</code>, if your plugin extends the Consulo core functionality.</li> <li><code>{ID of a plugin}</code>, if your plugin extends the functionality of another plugin (must configure Plugin Dependencies).</li> </ul> </li> <li>Add a new child element to the <code>&lt;extensions&gt;</code> element.    The child element name must match the name of the extension point you want the extension to access.</li> <li>Depending on the type of the extension point, do one of the following:<ul> <li>If the extension point was declared using the <code>interface</code> attribute, for newly added child element, set the <code>implementation</code> attribute to the name of the class that implements the specified interface.</li> <li>If the extension point was declared using the <code>beanClass</code> attribute, for newly added child element, set all attributes annotated with the <code>@Attribute</code> annotations in the specified bean class.</li> </ul> </li> </ol> <p>To clarify this procedure, consider the following sample section of the <code>plugin.xml</code> file that defines two extensions designed to access the <code>com.intellij.appStarter</code> and <code>com.intellij.projectTemplatesFactory</code> extension points in the Consulo and one extension to access the <code>another.plugin.myExtensionPoint</code> extension point in another plugin <code>another.plugin</code>:</p> <pre><code>&lt;!-- Declare extensions to access extension points in the Consulo.\n     These extension points have been declared using \"interface\".\n --&gt;\n  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;appStarter implementation=\"com.myplugin.MyAppStarter\" /&gt;\n    &lt;projectTemplatesFactory implementation=\"com.myplugin.MyProjectTemplatesFactory\" /&gt;\n  &lt;/extensions&gt;\n\n&lt;!-- Declare extensions to access extension points in a custom plugin \"another.plugin\"\n     The \"myExtensionPoint\" extension point has been declared using \"beanClass\"\n     and exposes custom properties \"key\" and \"implementationClass\".\n--&gt;\n  &lt;extensions defaultExtensionNs=\"another.plugin\"&gt;\n     &lt;myExtensionPoint key=\"keyValue\"\n                       implementationClass=\"com.myplugin.MyExtensionPointImpl\" /&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"basics/plugin_structure/plugin_extensions/#extension-default-properties","title":"Extension Default Properties","text":"<p>The following properties are available always:</p> <ul> <li><code>id</code> - unique ID</li> <li><code>order</code> - allows to order all defined extensions using <code>first</code>, <code>last</code> or <code>before|after [id]</code> respectively</li> <li><code>os</code> - allows restricting extension to given OS, e.g., <code>os=\"windows\"</code> registers the extension on Windows only</li> </ul> <p>If an extension instance needs to \"opt out\" in certain scenarios, it can throw <code>ExtensionNotApplicableException</code> in its constructor.</p>"},{"location":"basics/plugin_structure/plugin_extensions/#extension-properties-code-insight","title":"Extension Properties Code Insight","text":"<p>Several tooling features are available to help configure bean class extension points in <code>plugin.xml</code>.</p> <p>Properties annotated with <code>@RequiredElement</code> are inserted automatically and validated (2019.3 and later). If the given property is allowed to have an explicit empty value, set <code>allowEmpty</code> to <code>true</code> (2020.3 and later).</p> <p>Property names matching the following list will resolve to FQN: - <code>implementation</code> - <code>className</code> - <code>serviceInterface</code> / <code>serviceImplementation</code> - ending with <code>Class</code> (case-sensitive)</p> <p>A required parent type can be specified in the extension point declaration via nested <code>&lt;with&gt;</code>:</p> <pre><code>    &lt;extensionPoint name=\"myExtension\" beanClass=\"MyExtensionBean\"&gt;\n      &lt;with attribute=\"psiElementClass\" implements=\"com.intellij.psi.PsiElement\"/&gt;\n    &lt;/extensionPoint&gt;\n</code></pre> <p>Property name <code>language</code> (or ending in <code>*Language</code>, 2020.2+) resolves to all present <code>Language</code> IDs.</p> <p>Similarly, <code>action</code> resolves to all registered <code>&lt;action&gt;</code> IDs.</p> <p>Specifying <code>@org.jetbrains.annotations.Nls</code> validates a UI <code>String</code> capitalization according to the text property <code>Capitalization</code> enum value (2019.2 and later).</p> <p>Attributes with <code>Enum</code> type support code insight with lowerSnakeCased notation (2020.1 and later).</p>"},{"location":"basics/plugin_structure/plugin_extensions/#how-to-get-the-extension-points-list","title":"How to get the extension points list?","text":"<p>Extension Point List contains all available in Consulo and from bundled plugins in IntelliJ IDEA.</p> <p>Alternatively (or when using 3rd party extension points), all available extension points for the specified namespace can be listed using auto-completion inside the <code>&lt;extensions&gt;</code> block. Use View | Quick Documentation in the lookup list to access more information about the extension point and implementation (if applicable).</p>"},{"location":"basics/plugin_structure/plugin_icon_file/","title":"Plugin Logo","text":"<p>Beginning in version 2019.1, the Consulo supports representing a plugin with a logo. A Plugin Logo is intended to be a unique representation of a plugin's functionality, technology, or company. Previously this page referred to Plugin Logos as Plugin Icons.</p> <p>Note: icons and images used within a plugin have different requirements. See Working with Icons and Images for more information.</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"basics/plugin_structure/plugin_icon_file/#introduction","title":"Introduction","text":"<p>Plugin Logos are shown in the JetBrains Plugins Repository. They also appear in the Settings/Preferences Plugin Manager UI in Consulo-based IDEs. Whether online or in the product UI, a Plugin Logo helps users to identify a plugin more quickly in a list, as shown below:</p> <p>{:width=\"800px\"}</p> <p>NOTE When browsing custom plugin repositories, there is no support for showing logos for plugins hosted there but not yet installed.</p>"},{"location":"basics/plugin_structure/plugin_icon_file/#plugin-logo-requirements","title":"Plugin Logo Requirements","text":"<p>For a Plugin Logo to be displayed correctly within an Consulo-based IDE, it must: * Follow the best practices design guidelines, * Be in the correct file format, * Conform to file name conventions, * Be in the <code>META-INF</code> folder of the plugin distribution file.</p>"},{"location":"basics/plugin_structure/plugin_icon_file/#plugin-logo-size","title":"Plugin Logo Size","text":"<p>The Plugin Logo should be provided in one size: 40px by 40px.</p> <p>A Plugin Logo is displayed in two sizes, and scales automatically in each context: * 40px by 40px in the plugins list in the Plugin Manager UI. * 80px by 80px in the plugin details screen in the Plugin Manager UI, on the plugin's page in the Plugins Repository, and on MarketPlace.</p> <p>Verify that Plugin Logo designs are effective in both sizes and all display contexts.</p>"},{"location":"basics/plugin_structure/plugin_icon_file/#plugin-logo-shape","title":"Plugin Logo Shape","text":"<p>Plugin Logo designs should leave at least 2px transparent padding around the perimeter, as shown below:</p> <p>{:width=\"225px\"}</p> <p>Make sure Plugin Logos have the same visual weight as the logos in the examples below. The more filled a Plugin Logo design is, the less actual space it needs. See more examples of visual weight compensation in the Consulo UI Guidelines for Icons.</p> <p>For basic shapes, use the following sizes. Note the different areas of transparent padding used for each shape:</p> {:width=\"225px\"} {:width=\"225px\"} Square logo 32px by 32px Circular logo 36px in diameter {:width=\"225px\"} {:width=\"225px\"} Horizontal rectangular logo 36px by 26px Vertical rectangular logo 26px by 36px <p></p>"},{"location":"basics/plugin_structure/plugin_icon_file/#plugin-logo-colors","title":"Plugin Logo Colors","text":"<p>If the plugin's technology already has a logo, use its colors. Check the license terms before using the logo. If there is no existing logo, or its use is prohibited, create a custom logo based on the Action Colors Palette in the Consulo UI Guidelines for Icons.</p> {:height=\"200px\" width=\"200px\"} {:height=\"200px\" width=\"200px\"} The YouTrack Plugin Logo usesthe YouTrack product logo The Keymap Plugin Logo uses a colorfrom the Action Colors Palette <p>Ensure a Plugin Logo is visible on both light and dark backgrounds. If one Plugin Logo design does not work on both light and dark backgrounds, create separate light and dark versions of the Plugin Logo. The examples below illustrate how a Plugin Logo design may work well for a light background but not for a dark background. Consequently, a separate Plugin Logo for dark backgrounds is needed.</p> {:width=\"225px\"} {:width=\"225px\"} {:width=\"225px\"} The light Plugin Logo designworks well on light UI Theme The light Plugin Logo design doesnot work well on a dark UI Theme A separate, dark Plugin Logo designworks well on dark UI Theme"},{"location":"basics/plugin_structure/plugin_icon_file/#plugin-logo-file-format","title":"Plugin Logo File Format","text":"<p>All Plugin Logo images must be SVG format. This vector image format is required because the Plugin Logo file must be small, and the image must scale without any loss of quality.</p>"},{"location":"basics/plugin_structure/plugin_icon_file/#plugin-logo-file-naming-convention","title":"Plugin Logo File Naming Convention","text":"<p>Name the Plugin Logo files according to the following conventions: * <code>pluginIcon.svg</code> is the default Plugin Logo.   If a separate Logo file for dark UI Themes exists in the plugin, then this file is used solely for light UI Themes, * <code>pluginIcon_dark.svg</code> is an optional, alternative Plugin Logo for use solely with dark IDE UI Themes.</p>"},{"location":"basics/plugin_structure/plugin_icon_file/#adding-plugin-logo-files-to-a-plugin-project","title":"Adding Plugin Logo Files to a Plugin Project","text":"<p>The Plugin Logo files must be in the <code>META-INF</code> folder of the plugin distribution file, i.e., the <code>*.jar</code> or <code>*.zip</code> file you upload to the plugin repository and install into a JetBrains IDE.</p> <p>To include Plugin Logo files in your distribution file, place the Plugin Logo files into a plugin project's <code>resources/META-INF</code> folder. Note that this requirement is the same regardless of using DevKit or Gradle for developing a plugin. For example:</p> <p>{:width=\"450px\"}</p>"},{"location":"basics/plugin_structure/plugin_listeners/","title":"Plugin Listeners","text":"<p>NOTE Defining listeners in <code>plugin.xml</code> is supported starting with version 2019.3 of the platform.</p> <p>NOTE Listener implementations must be stateless and may not implement life-cycle (e.g., <code>Disposable</code>).</p> <p>Listeners allow plugins to declaratively subscribe to events delivered through the message bus (see Messaging infrastructure for details).</p> <p>You can define both application- and project-level listeners.</p> <p>Declarative registration of listeners allows you to achieve better performance than registering listeners from code.  The advantage is because listener instances get created lazily - the first time an event is sent to the topic - and not during application startup or project opening.</p>"},{"location":"basics/plugin_structure/plugin_listeners/#defining-application-level-listeners","title":"Defining Application-Level Listeners","text":"<p>To define an application-level listener, add the following section to your <code>plugin.xml</code>:</p> <pre><code>&lt;applicationListeners&gt;\n  &lt;listener class=\"myPlugin.MyListenerClass\" topic=\"BaseListenerInterface\"/&gt;\n&lt;/applicationListeners&gt;\n</code></pre> <p>The <code>topic</code> attribute specifies the listener interface corresponding to the type of events you want to receive. Usually, this is the interface used as the type parameter of the <code>Topic</code> instance for the type of events. The <code>class</code> attribute specifies the class in your plugin that implements the listener interface and receives the events.</p> <p>As a specific example, if you want to receive events about all virtual file system changes, you need to implement the <code>BulkFileListener</code> interface, corresponding to the topic <code>VirtualFileManager.VFS_CHANGES</code>. To subscribe to this topic from code, you could use something like the following snippet:</p> <pre><code>messageBus.connect().subscribe(VirtualFileManager.VFS_CHANGES, new BulkFileListener() {\n    @Override\n    public void after(@NotNull List&lt;? extends VFileEvent&gt; events) {\n        // handle the events\n    }\n});\n</code></pre> <p>To use declarative registration, you no longer need to reference the <code>Topic</code> instance. Instead, you refer directly to the listener interface class:</p> <pre><code>&lt;applicationListeners&gt;\n  &lt;listener class=\"myPlugin.MyVfsListener\"\n            topic=\"com.intellij.openapi.vfs.newvfs.BulkFileListener\"/&gt;\n&lt;/applicationListeners&gt;\n</code></pre> <p>Then you provide the listener implementation as a top-level class:</p> <pre><code>public class MyVfsListener implements BulkFileListener {\n    @Override\n    public void after(@NotNull List&lt;? extends VFileEvent&gt; events) {\n        // handle the events\n    }\n}\n</code></pre>"},{"location":"basics/plugin_structure/plugin_listeners/#defining-project-level-listeners","title":"Defining Project-Level Listeners","text":"<p>Project-level listeners are registered in the same way, except that the top-level tag is <code>&lt;projectListeners&gt;</code>. They can be used to listen to project-level events, for example, tool window operations:</p> <pre><code>&lt;projectListeners&gt;\n    &lt;listener class=\"MyToolwindowListener\"\n              topic=\"com.intellij.openapi.wm.ex.ToolWindowManagerListener\" /&gt;\n&lt;/projectListeners&gt;\n</code></pre> <p>The class implementing the listener interface can define a one-argument constructor accepting a <code>Project</code>, and it will receive the instance of the project for which the listener is created:</p> <pre><code>public class MyToolwindowListener implements ToolWindowManagerListener {\n    private final Project project;\n\n    public MyToolwindowListener(Project project) {\n        this.project = project;\n    }\n\n    @Override\n    public void stateChanged() {\n        // handle the state change\n    }\n}\n</code></pre>"},{"location":"basics/plugin_structure/plugin_listeners/#additional-attributes","title":"Additional Attributes","text":"<p>Registration of listeners can be restricted using the following attributes:</p> <ul> <li><code>os</code> - allows to restrict listener to given OS, e.g., <code>os=\"windows\"</code> for Windows only (2020.1 and later)</li> <li><code>activeInTestMode</code> - set to <code>false</code> to disable listener if <code>com.intellij.openapi.application.Application.isUnitTestMode()</code>==<code>true</code></li> <li><code>activeInHeadlessMode</code> - set to <code>false</code> to disable listener if <code>com.intellij.openapi.application.Application.isHeadlessEnvironment()</code>==<code>true</code>.   Also, covers <code>activeInTestMode</code> as test mode implies headless mode.</li> </ul>"},{"location":"basics/plugin_structure/plugin_services/","title":"Plugin Services","text":"<p>A service is a plugin component loaded on demand when your plugin calls the <code>getService()</code> method of <code>ServiceManager</code>.</p> <p>The Consulo ensures that only one instance of a service is loaded even though it is called several times.</p> <p>A service must have an implementation class that is used for service instantiation. A service may also have an interface class used to obtain the service instance and provide the service's API.</p> <p>A service needing a shutdown hook/cleanup routine can implement <code>Disposable</code> and perform necessary work in <code>dispose()</code> (see Automatically Disposed Objects).</p>"},{"location":"basics/plugin_structure/plugin_services/#types","title":"Types","text":"<p>The Consulo offers three types of services: application level services (global singleton), project level services, and module level services. For the latter two, a separate instance of the service is created for each instance of its corresponding scope, see Project Model Introduction.</p> <p>NOTE Please consider not using module-level services because it can increase memory usage for projects with many modules.</p>"},{"location":"basics/plugin_structure/plugin_services/#constructor","title":"Constructor","text":"<p>Project/Module level service constructors can have a <code>Project</code>/<code>Module</code> argument. To improve startup performance, avoid any heavy initializations in the constructor.</p> <p>NOTE Please note that using constructor injection is deprecated (and not supported in Light Services) for performance reasons. Other dependencies should be acquired only when needed in all corresponding methods (see <code>someServiceMethod()</code> in Project Service Sample).</p>"},{"location":"basics/plugin_structure/plugin_services/#light-services","title":"Light Services","text":"<p>NOTE Light Services are available since Consulo 2019.3.</p> <p>A service not going to be overridden does not need to be registered in <code>plugin.xml</code> (see Declaring a Service). Instead, annotate service class with <code>@Service</code>. The service instance will be created in scope according to the caller (see Retrieving a Service).</p> <p>Restrictions:</p> <ul> <li>Service class must be <code>final</code>.</li> <li>Constructor injection is not supported (since it is deprecated).</li> <li>If service is a PersistentStateComponent, roaming must be disabled (<code>roamingType = RoamingType.DISABLED</code>).</li> </ul> <p>See Project Level Service below for a sample.</p>"},{"location":"basics/plugin_structure/plugin_services/#declaring-a-service","title":"Declaring a Service","text":"<p>To register a non-Light Service, distinct extension points are provided for each type:</p> <ul> <li><code>com.intellij.applicationService</code> - application level service</li> <li><code>com.intellij.projectService</code> - project level service</li> <li><code>com.intellij.moduleService</code> - module level service (not recommended, see Note above)</li> </ul> <p>To expose service API, create separate class for <code>serviceInterface</code> and extend it in corresponding class registered in <code>serviceImplementation</code>. If <code>serviceInterface</code> isn't specified, it's supposed to have the same value as <code>serviceImplementation</code>.</p> <p>To provide custom implementation for test/headless environment, specify <code>testServiceImplementation</code>/<code>headlessImplementation</code> additionally.</p> <p>plugin.xml</p> <pre><code>&lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n  &lt;!-- Declare the application level service --&gt;\n  &lt;applicationService serviceInterface=\"mypackage.MyApplicationService\"\n                      serviceImplementation=\"mypackage.MyApplicationServiceImpl\" /&gt;\n\n  &lt;!-- Declare the project level service --&gt;\n  &lt;projectService serviceInterface=\"mypackage.MyProjectService\"\n                  serviceImplementation=\"mypackage.MyProjectServiceImpl\" /&gt;\n&lt;/extensions&gt;\n</code></pre>"},{"location":"basics/plugin_structure/plugin_services/#retrieving-a-service","title":"Retrieving a Service","text":"<p>Getting service doesn't need a read action and can be performed from any thread. If service is requested from several threads, it will be initialized in the first thread, and other threads will be blocked until service is fully initialized.</p> <p>To retrieve a service in Java code:</p> <pre><code>MyApplicationService applicationService = ServiceManager.getService(MyApplicationService.class);\n\nMyProjectService projectService = project.getService(MyProjectService.class)\n</code></pre> <p>In Kotlin code, use convenience methods:</p> <pre><code>val applicationService = service&lt;MyApplicationService&gt;()\n\nval projectService = project.service&lt;MyProjectService&gt;()\n</code></pre>"},{"location":"basics/plugin_structure/plugin_services/#project-service-sample","title":"Project Service Sample","text":"<p>This minimal sample shows Light Service <code>ProjectService</code> interacting with another project level service <code>AnotherService</code> (not shown here).</p> <p>ProjectService.java</p> <pre><code>  @Service\n  public final class ProjectService {\n\n     private final Project myProject;\n\n     public ProjectService(Project project) {\n       myProject = project;\n     }\n\n     public void someServiceMethod(String parameter) {\n       AnotherService anotherService = myProject.getService(AnotherService.class);\n       String result = anotherService.anotherServiceMethod(parameter, false);\n       // do some more stuff\n     }\n  }\n</code></pre>"},{"location":"basics/plugin_structure/plugin_services/#sample-plugin","title":"Sample Plugin","text":"<p>This sample plugin illustrates how to create and use a plugin service. This plugin has an application service counting the number of currently opened projects in the IDE. If this number exceeds the maximum number of simultaneously opened projects allowed by the plugin, it displays a warning message.</p> <p>To install and run the sample plugin</p> <ul> <li>Download the included sample plugin project located here.</li> <li>Start IntelliJ IDEA, on the starting page, click Open Project, and then use the Open Project dialog box to open the project.</li> <li>On the main menu, choose Run | Run or press Shift+F10.</li> <li>If necessary, change the Run/Debug Configurations.</li> </ul>"},{"location":"basics/run_configurations/run_configuration_execution/","title":"Execution","text":"<p>The standard execution of a run action goes through the following steps:</p> <ul> <li>The user selects a run configuration (for example, by choosing one from the run configurations combobox) and an executor  (for example, by pressing a toolbar button created by the executor).</li> <li>The program runner that will actually execute the process is selected by polling all registered program runners and asking whether they can run the specified run profile with the specified executor ID.</li> <li>The <code>ExecutionEnvironment</code> object is created.   This object aggregates all the settings required to execute the process and the selected <code>ProgramRunner</code>.</li> <li><code>ProgramRunner.execute()</code> is called, receiving the executor and the execution environment.</li> </ul> <p>Implementations of <code>ProgramRunner.execute()</code> go through the following steps to execute the process:</p> <ul> <li><code>RunProfile.getState()</code> method is called to create a <code>RunProfileState</code> object, describing a process about to be started.   At this stage, the command line parameters, environment variables, and other information required to start the process are initialized.</li> <li><code>RunProfileState.execute()</code> is called.   It starts the process, attaches a <code>ProcessHandler</code> to its input and output streams, creates a console to display the process output, and returns an <code>ExecutionResult</code> object aggregating the console and the process handler.</li> <li>The <code>RunContentBuilder</code> object is created and invoked to display the execution console in a tab of the Run or Debug tool window.</li> </ul>"},{"location":"basics/run_configurations/run_configuration_execution/#executor","title":"Executor","text":"<p>The <code>Executor</code> interface describes a specific way of executing any possible run configuration.</p> <p>The three default executors provided by the Consulo by default are Run, Debug, and Run with Coverage.  Each executor gets its own toolbar button, which starts the selected run configuration using this executor, and its own context menu item for starting a configuration using this executor.</p> <p>As a plugin developer, you usually don't need to implement the <code>Executor</code> interface. However, it can be useful, for example, if you're implementing a profiler integration and want to provide the possibility to execute any configuration with profiling.</p>"},{"location":"basics/run_configurations/run_configuration_execution/#running-a-process","title":"Running a Process","text":"<p>The <code>RunProfileState</code> interface comes up in every run configuration implementation as the return value <code>RunProfile.getState()</code>. It describes a process that is ready to be started and holds information like the command line, current working directory, and environment variables for the process to be started. (The existence of <code>RunProfileState</code> as a separate step in the execution flow allows run configuration extensions and other components to patch the configuration and modify the parameters before it gets executed.)</p> <p>The standard base class used as implementation of <code>RunProfileState</code> is <code>CommandLineState</code>. It contains the logic for putting together a running process and a console into an <code>ExecutionResult</code>, but doesn't know anything how the process is actually started. For starting the process, it's best to use the <code>GeneralCommandLine</code> class, which takes care of setting up the command line parameters and executing the process.</p> <p>Alternatively, if the process you need to run is a JVM-based one, you can use the <code>JavaCommandLineState</code> base class. It knows about the JVM command line parameters and can take care of details like calculating the classpath for the JVM.</p> <p>To monitor the execution of a process and capture its output, the <code>OSProcessHandler</code> class is usually used. Once you've created an instance of <code>OSProcessHandler</code> from either a command line or a Process object, you need to call the <code>startNotify()</code> method to capture its output. You may also want to attach a <code>ProcessTerminatedListener</code> to the <code>OSProcessHandler</code> so that the exit status of the process will be displayed in the console.</p>"},{"location":"basics/run_configurations/run_configuration_execution/#displaying-process-output","title":"Displaying Process Output","text":"<p>If you're using <code>CommandLineState</code>, a console view will be automatically created and attached to the process's output. Alternatively, you can arrange this yourself:</p> <ul> <li><code>TextConsoleBuilderFactory.createBuilder(project).getConsole()</code> creates a <code>ConsoleView</code> instance</li> <li><code>ConsoleView.attachToProcess()</code> attaches it to the output of a process.</li> </ul> <p>If the running process uses ANSI escape codes to color its output, the <code>ColoredProcessHandler</code> class will parse it and display the colors in the IntelliJ console.</p> <p>Console filters allow you to convert certain strings found in the process output to clickable hyperlinks. To attach a filter to the console, use <code>CommandLineState.addConsoleFilters()</code> or, if you're creating a console manually, <code>TextConsoleBuilder.addFilter()</code>.</p> <p>Two common filter implementations you may want to reuse are <code>RegexpFilter</code> and <code>UrlFilter</code>.</p>"},{"location":"basics/run_configurations/run_configuration_execution/#starting-a-run-configuration-from-code","title":"Starting a Run Configuration from Code","text":"<p>If you have an existing run configuration that you need to execute, the easiest way to do so is to use <code>ProgramRunnerUtil.executeConfiguration()</code>. The method takes a <code>Project</code>, a <code>RunnerAndConfigurationSettings</code>, as well as an <code>Executor</code>. To get the <code>RunnerAndConfigurationSettings</code> for an existing configuration, you can use, for example, <code>RunManager.getConfigurationSettings(ConfigurationType)</code>. As the last parameter, you normally pass either <code>DefaultRunExecutor.getRunExecutorInstance()</code> or <code>DefaultDebugExecutor.getDebugExecutorInstance()</code>.</p>"},{"location":"basics/run_configurations/run_configuration_management/","title":"Run Configuration Management","text":"<p>This document describes the primary classes to work with run configurations and everyday use cases.</p> <ul> <li>Dummy table of contents {:toc}</li> </ul>"},{"location":"basics/run_configurations/run_configuration_management/#configuration-type","title":"Configuration Type","text":"<p>The starting point for implementing any run configuration type is the <code>ConfigurationType</code> interface. The list of available configuration types is shown when a user opens the 'Edit run configurations' dialog and executes 'Add' action:</p> <p></p> <p>Every type there is represented as an instance of <code>ConfigurationType</code> and registered like below:</p> <pre><code>&lt;configurationType implementation=\"org.jetbrains.plugins.gradle.service.execution.GradleExternalTaskConfigurationType\" /&gt;\n</code></pre> <p>The easiest way to implement this interface is to use the <code>ConfigurationTypeBase</code> base class. To use it, you need to inherit from it and to provide the configuration type parameters (ID, name, description, and icon) as constructor parameters. In addition to that, you need to call the <code>addFactory()</code> method to add a configuration factory.</p>"},{"location":"basics/run_configurations/run_configuration_management/#configuration-factory","title":"Configuration Factory","text":"<p>All run configurations are created by the <code>ConfigurationFactory</code> registered for a particular <code>ConfigurationType</code>. It's possible that one <code>ConfigurationType</code> has more than one <code>ConfigurationFactory</code>:</p> <p></p> <p>The key API of <code>ConfigurationFactory</code>, and the only method that you're required to implement, is the <code>createTemplateConfiguration</code> method. This method is called once per project to create the template run configuration.</p> <p>All real run configurations (loaded from the workspace or created by the user) are called by cloning the template through the <code>createConfiguration</code> method.</p> <p>You can customize additional aspects of your configuration factory by overriding the <code>getIcon</code>, <code>getAddIcon</code>, <code>getName</code> and the default settings methods. These additional overrides are optional.</p>"},{"location":"basics/run_configurations/run_configuration_management/#run-configuration","title":"Run Configuration","text":"<p>The run configuration itself is represented by the <code>RunConfiguration</code> interface. A 'run configuration' here is some named profile which can be executed, e.g., the application started via <code>main()</code> class, test, remote debug to particular machine/port, etc.</p> <p>Here is an example of a Java run configuration defined for a particular project:</p> <p></p> <p>When implementing a run configuration, you may want to use one of the common base classes:</p> <ul> <li><code>RunConfigurationBase</code> is a general-purpose superclass that contains the most basic implementation of a run configuration.</li> <li><code>LocatableConfigurationBase</code> is a common base class that should be used for configurations that can be created from context by a <code>RunConfigurationProducer</code>.   It supports automatically generating a name for a configuration from its settings and keeping track of whether the name was changed by the user.</li> <li><code>ModuleBasedConfiguration</code> is a base class for a configuration that is associated with a specific module (for example, Java run configurations use the selected module to determine the run classpath).</li> </ul>"},{"location":"basics/run_configurations/run_configuration_management/#settings-editor","title":"Settings Editor","text":"<p>That common run configuration settings might be modified via:</p> <p><code>RunConfiguration</code>-specific UI. That is handled by <code>SettingsEditor</code>:</p> <ul> <li><code>getComponent()</code> method is called by the IDE and shows run configuration specific UI.</li> <li><code>resetFrom()</code> is called to discard all non-confirmed user changes made via that UI.</li> <li><code>applyTo()</code> is called to confirm the changes, i.e. copy current UI state into the target settings object.</li> </ul>"},{"location":"basics/run_configurations/run_configuration_management/#persistence","title":"Persistence","text":"<p>That run configuration settings are persistent, i.e., they are stored at the file system and loaded back on the IDE startup. That is performed via <code>writeExternal()</code> and <code>readExternal()</code> methods of <code>RunConfiguration</code> class correspondingly.</p> <p>The actual configurations stored by the Consulo are represented by instances of the <code>RunnerAndConfigurationSettings</code> class, which combines a run configuration with runner-specific settings, as well as keeping track of certain run configuration flags such as \"temporary\" or \"singleton\".</p> <p>Dealing with instances of this class becomes necessary when you need to create run configurations from code. This is accomplished with the following two steps:</p> <ul> <li><code>RunManager.createConfiguration()</code> creates an instance of <code>RunnerAndConfigurationSettings</code>.</li> <li><code>RunManager.addConfiguration()</code> makes it persistent by adding it to either the list of shared configurations stored in a project or to the list of local configurations stored in the workspace file.</li> </ul>"},{"location":"basics/run_configurations/run_configuration_management/#refactoring-support","title":"Refactoring Support","text":"<p>Most run configurations contain references to classes, files, or directories in their settings, and these settings usually need to be updated when the corresponding element is renamed or moved.</p> <p>To support that, your run configuration needs to implement the <code>RefactoringListenerProvider</code> interface.</p> <p>In your implementation of <code>getRefactoringElementListener()</code>, you need to check whether the refactored element is the one that your run configuration refers to.  If it is, you return a <code>RefactoringElementListener</code> that updates your configuration according to the new name and location of the element.</p>"},{"location":"basics/run_configurations/run_configuration_management/#creating-configurations-from-context","title":"Creating Configurations from Context","text":"<p>Many plugins support automatic creation of run configurations from context so that the user can click, for example, on an application or test class and automatically run it using the correct run configuration type. To support that, you need to provide an implementation of the <code>RunConfigurationProducer</code> interface and to register it as <code>&lt;runConfigurationProducer&gt;</code> in your <code>plugin.xml</code>.  This API was redesigned in IntelliJ IDEA 13; the previous <code>RuntimeConfigurationProducer</code> is a much more confusing version of the same API.</p> <p>The two main methods that you need to implement are:</p> <ul> <li><code>setupConfigurationFromContext()</code> receives a blank configuration of your type and a <code>ConfigurationContext</code> containing information about a source code location (accessible by calling <code>getLocation()</code> or <code>getPsiLocation()</code>).   Your implementation needs to check whether the location is applicable for your configuration type (for example, if it's in a file of the language you're supporting).   If not, you need to return false, and if it is, you need to put the correct context-specific settings into the run configuration and return true.</li> <li><code>isConfigurationFromContext()</code> checks if your type's specified configuration was created from the specified context.   Implementing this method allows you to reuse an existing run configuration, which applies to the current context instead of creating a new one and possibly ignoring the user's customizations in the existing one.</li> </ul> <p>Note that, to support the automatic naming of configurations created from context, your configuration should use <code>LocatableConfigurationBase</code> as the base class.</p>"},{"location":"basics/run_configurations/run_configuration_management/#running-from-the-gutter","title":"Running from the Gutter","text":"<p>Take a look at <code>RunLineMarkerContributor</code> and its implementations.</p>"},{"location":"organization/overview/","title":"Not documented yet","text":""},{"location":"organization/repository_list/","title":"Repositiries by category","text":""},{"location":"organization/repository_list/#uncategoried","title":"Uncategoried","text":"<ul> <li>consulo.github.io - contains consulo.io sources</li> <li>consulo-dev.github.io - contains consulo.dev sources</li> <li>consulo-app.github.io - contains consulo.app sources</li> </ul>"},{"location":"organization/repository_list/#core","title":"Core","text":"<ul> <li>consulo - main repository of Consulo organization on github. It contains Consulo platform code without any language implementations.</li> <li>consulo-spellchecker - contains spellchecker implementation.</li> <li>consulo-images - contains image support.</li> </ul>"},{"location":"organization/repository_list/#jvm-platform","title":"JVM Platform","text":"<ul> <li> <p>consulo-java - contains Java language implementation. Here you can report any problem with Java language, JVM debugger, etc.</p> <ul> <li>consulo-groovy - contains Groovy implementation.</li> <li>consulo-junit - contains JUnit implementation.</li> <li>consulo-testng - contains TestNG implementation.</li> </ul> </li> </ul>"},{"location":"organization/repository_list/#net-platform","title":".NET Platform","text":"<ul> <li> <p>consulo-dotnet - contains base api implementation for .NET platform. Here you can report problems with MSIL language, debugger, etc.</p> <ul> <li> <p>consulo-csharp - contains C# language implementation. Here you can report:</p> <ul> <li>any problem with C# language</li> <li>.NET debugger evaluation (but not problem with .NET debugger itself)</li> </ul> </li> <li> <p>consulo-unity - contains Unity framework implementation. Here you can report:</p> </li> <li>any problem with Unity related functional</li> <li> <p>UnityScript language</p> </li> <li> <p>UnityEditorConsuloPlugin - here you can found Consulo plugin for UnityEditor written in C#</p> </li> <li> <p>consulo-nunit - contains NUnit implementation.</p> </li> </ul> </li> </ul>"},{"location":"organization/repository_list/#javascript-platform","title":"JavaScript Platform","text":"<ul> <li>consulo-javascript - contains JavaScript, ECMAScript, JSON language implementation. Here you can report problems with JavaScript language, debugger, etc.<ul> <li>consulo-nodejs - contains NodeJS, Mocha framework implementations.</li> </ul> </li> </ul>"},{"location":"organization/repository_list/#python-platform","title":"Python Platform","text":"<ul> <li>consulo-python - contains Python language implementation, and Jython, IronPython frameworks. Here you can report problems with Python language, debugger, etc.</li> </ul>"},{"location":"organization/repository_list/#go-platform","title":"Go Platform","text":"<ul> <li>consulo-google-go - contains Go language implementation. Here you can report problems with Go language,debugger, etc.</li> </ul>"},{"location":"platform/fundamentals/","title":"Fundamentals","text":"<p>This section describes the low-level fundamental building blocks of the Consulo:</p> <ul> <li>The component model - how the application is hosted and composed. Lifetime and dependency management.</li> <li>Disposers - managing object lifetimes and resource cleanup</li> <li>Threading models</li> <li>Messaging</li> </ul>"},{"location":"platform/internal_libraries/","title":"Java libraries","text":"<ul> <li>dotnet-asm - library which read .dll/.netmodule files (compiled by .NET)</li> </ul>"},{"location":"platform/permissions/","title":"Overview","text":"<p>For restricting illegal actions from 3rd-party plugins, permissions control some major access to system resources.</p>"},{"location":"platform/permissions/#permission-types","title":"Permission Types","text":"<ul> <li>PROCESS_CREATE - running any process in OS (and destroy if need)</li> <li>PROCESS_MANAGE - list all processes in OS, and destroy them (protected by user space)</li> <li>NATIVE_LIBRARY - loading native libraries in Consulo process</li> <li>SOCKET_BIND - binding any TCP/UDP socket</li> <li>SOCKET_CONNECT - connecting to any TCP/UDP socket</li> <li> <p>INTERNET_URL_ACCESS - permission for control access to internet by url(http, https), by plain implementation.</p> <p>Warning: some clients can implement own socket handling, and they will require #SOCKET_CONNECT permission, and don't checked it by this permission</p> </li> </ul>"},{"location":"platform/restriction/","title":"Code restrition","text":"<p>While coding platform, there some rules, about code/library usage</p>"},{"location":"platform/restriction/#consuloplatformbase-module","title":"'consulo.platform.base' module","text":"<ul> <li>No usage of java.desktop module. It's mean you can't use classes from java.awt &amp; javax.swing. Also since java.beans package in desktop module, you can't use it too (see kava.beans).</li> <li>No usage of java.lang.System class, use \"consulo.platform.Platform#current()\" - system class, can return different values for each platform</li> </ul>"},{"location":"platform/restriction/#consuloplatformdesktop","title":"'consulo.platform.desktop'","text":"<ul> <li>AWT &amp; Swing allowed - but preferer use consulo.ui, since AWT&lt;&gt;Consulo UI, conversion not allowed</li> </ul>"},{"location":"platform/restriction/#consuloplatformweb","title":"'consulo.platform.web'","text":"<ul> <li>AWT &amp; Swing not allowed</li> </ul>"},{"location":"platform/update_channels/","title":"Update Channels","text":"<p>Consulo has four public update channels, and one internal (in parentheses iteration information):</p> <ul> <li>release (every monday new builds come at 00:00)</li> <li>beta (every day new builds come at 00:00)</li> <li>alpha (by hand on my own will (@VISTALL))</li> <li>nightly (after each commit to platform or plugin)</li> </ul>"},{"location":"platform/update_channels/#channel-settings","title":"Channel settings","text":"<p>You can always change channel in settings</p> <p></p> <p>And then click About -&gt; Check for updates</p>"},{"location":"platform/update_channels/#warning","title":"WARNING","text":"<p>In nightly / alpha channel sometimes plugins don't have builds for new platform (for example compilation failed)</p> <p>Keep calm - Consulo do not allow update, if some plugins missed, you will get warning about it.</p>"},{"location":"platform/desktop/spi.impl/","title":"Desktop SPI implementations","text":"<p>Consulo provide some SPI implementations, for extending JRE</p>"},{"location":"platform/desktop/spi.impl/#audio-stack","title":"Audio Stack","text":"<p>Consulo have some forks of Sound libraries for extending javax.sound implementation via SPI</p> <ul> <li>JavaZoom JLayer</li> <li>JavaZoom Mp3</li> <li>jvorbis<ul> <li>jogg</li> </ul> </li> </ul>"},{"location":"platform/project_model/project/startupactivity/","title":"Startup Activity","text":""},{"location":"platform/project_model/project/startupactivity/#preloading-activity","title":"Preloading Activity","text":"<p>An activity to be executed in background on startup (regardless if some project was opened or not).</p> <p>See PreloadingActivity.</p> <p>To register:</p> <pre><code>&lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n  &lt;preloadingActivity implementation=\"com.example.CatPreloadingActivity\"/&gt;\n&lt;/extensions&gt;\n</code></pre>"},{"location":"platform/project_model/project/startupactivity/#startup-activity","title":"Startup Activity","text":"<p>An activity to be executed as part of project opening, under 'Loading Project' dialog. Can't be registered by plugins.</p> <p>To register: <code>StartupManager.registerStartupActivity</code> or</p> <pre><code>&lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n  &lt;startupActivity implementation=\"com.example.CatStartupActivity\"/&gt;\n&lt;/extensions&gt;\n</code></pre>"},{"location":"platform/project_model/project/startupactivity/#post-startup-activity","title":"Post Startup Activity","text":"<p>An activity to be executed after project opening.</p> <p>If activity implements DumbAware, it is executed after project is opened on a background thread with no visible progress indicator and regardless of the current indexing mode. Otherwise, it is executed on EDT and when indexes are ready.</p> <p>To register: <code>StartupManager.registerPostStartupActivity</code> or</p> <pre><code>&lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n  &lt;postStartupActivity implementation=\"com.example.CatStartupActivity\"/&gt;\n&lt;/extensions&gt;\n</code></pre> <p>See also <code>backgroundPostStartupActivity</code> that acts as <code>postStartupActivity</code> but is executed with 5 seconds delay after project opening.</p> <ul> <li>Use ProgressManager.run(Task.Backgroundable) to execute work that needs to be visible to users. Including work that consumes CPU over a noticeable period. Using of <code>Application.executeOnPooledThread</code> is not needed if you use the <code>ProgressManager</code> API.</li> <li>Use AppUiUtil.invokeLaterIfProjectAlive to execute work that needs to be performed in the UI thread.</li> <li>Use DumbService to execute work that requires access to indices.</li> </ul>"},{"location":"platform/ui/image/","title":"File Tree","text":"<p>icon</p> <p>icon/marker.txt</p> <p>icon/_light/</p> <p>icon/_light/consulo.plugin.PluginIconGroup/</p> <p>icon/_dark/</p> <p>icon/_dark/consulo.plugin.PluginIconGroup/</p>"},{"location":"platform/ui/image/#tree-info","title":"Tree info","text":"<ul> <li>marker.txt just marker - file must exists (text ignored)</li> <li>_light / _dark - is id for Image Library. _light and _dark is bundled image libraries</li> <li>consulo.plugin.PluginIconGroup - icon group. Directory must endsWith IconGroup</li> </ul>"},{"location":"platform/ui/image/#require-maven-plugin-and-configuration","title":"Require maven plugin and configuration","text":"<pre><code>&lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;consulo.maven&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-consulo-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2-SNAPSHOT&lt;/version&gt;\n                &lt;extensions&gt;true&lt;/extensions&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;id&gt;gen&lt;/id&gt;\n                        &lt;phase&gt;generate-sources&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;generate-icon&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n</code></pre>"},{"location":"platform/ui/localization/","title":"File Tree","text":"<p>localize</p> <p>localize/id.txt</p> <p>package1/</p> <p>package1/package2/</p> <p>package1/package2/package3/</p> <p>package1/package2/package3/PluginLocalize.yaml</p>"},{"location":"platform/ui/localization/#text-of-idtxt-file","title":"Text of 'id.txt' file","text":"<p>Default value of english localize is en</p>"},{"location":"platform/ui/localization/#require-maven-plugin-and-configuration","title":"Require maven plugin and configuration","text":"<pre><code>&lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;consulo.maven&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-consulo-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2-SNAPSHOT&lt;/version&gt;\n                &lt;extensions&gt;true&lt;/extensions&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;id&gt;gen&lt;/id&gt;\n                        &lt;phase&gt;generate-sources&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;generate-localize&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n</code></pre>"},{"location":"platform/ui/localization/#localization-plugins","title":"Localization plugins","text":"<p>Plugin must have yaml file an different locale. Like ru</p>"},{"location":"platform/ui/overview/","title":"Consulo Unified UI","text":"<p>Consulo provide UI API - implementation will be work at Desktop &amp; Web Browsers.</p> <p>Desktop implementation based on Swing, and Web on GWT (with Vaadin as transport + ui system)</p> <p>For default - any plugins don't known about Swing or GWT</p> <p>Classes:</p> <ul> <li><code>consulo.ui.UIAccess</code> - class provide access to UI Thread, and allow get current thread status</li> <li><code>#isUIThread()</code> - will return true if we inside UI Thread</li> <li><code>#give(Runnable)</code> - run task inside UI Thread</li> <li><code>#get()</code> - will return UIAccess instance if call inside UI thread, otherwise throw exception</li> </ul>"},{"location":"reference_guide/color_scheme_management/","title":"Color Scheme Management","text":""},{"location":"reference_guide/color_scheme_management/#preface","title":"Preface","text":"<p>Color scheme management in IntelliJ IDEA 12.1 was changed to ease scheme designers' work and make schemes look equally well for different programming languages even if not designed specifically for these languages. Previously language plug-ins were using fixed default colors incompatible, for example, with dark schemes.</p> <p>The new implementation allows specifying a dependency on a set of standard text attributes linked to a scheme but not to any specific language. Language-specific attributes still can be set by a scheme designer if needed, but it's optional. New color schemes have got a new <code>.icls</code> (Idea CoLor Scheme) extension to avoid confusion about compatibility problems with older platform versions: if only standard attributes are set, they will not be used by the version before 12.1, resulting in different highlighting colors.</p>"},{"location":"reference_guide/color_scheme_management/#plug-in-developers","title":"Plug-in Developers","text":""},{"location":"reference_guide/color_scheme_management/#text-attribute-key-dependency","title":"Text Attribute Key Dependency","text":"<p>The easiest and the best way to specify highlighting text attributes is to specify a dependency on one of standard keys defined in <code>DefaultLanguageHighlighterColors</code>:</p> <pre><code>static final TextAttributesKey MY_KEYWORD =\n  TextAttributesKey.createTextAttributesKey(\"MY_KEYWORD\", DefaultLanguageHighlighterColors.KEYWORD);\n</code></pre> <p>The color scheme manager will search first for text attributes specified by the <code>MY_KEYWORD</code> key. If those are not defined explicitly or if all the attributes are empty (undefined), it will search them using the <code>DEFAULT_KEYWORD</code> key. If neither is defined, it will further fall back to a default scheme.</p> <p>Text attribute keys can be chained, for example you can define another key as:</p> <pre><code>static final TextAttributesKey MY_PREDEFINED_SYMBOL =\n  TextAttributesKey.createTextAttributesKey(\"MY_PREDEFINED_SYMBOL\", MY_KEYWORD);\n</code></pre> <p>The rule is the same: if text attributes can not be found by the <code>MY_PREDEFINED_SYMBOL</code> key or are empty, the color scheme manager will search for <code>MY_KEYWORD</code> and if not found (empty) will further look for <code>DEFAULT_KEYWORD</code>.</p> <p>NOTE A use of fixed default attributes is strongly discouraged.</p> <p>If you are unsure which base key to use, it's better to pick the most generic one, for example, <code>DefaultLanguageHighlighterColors.IDENTIFIER</code>. Remember that using fixed default attributes will force  a scheme designer to explicitly set up a color for this element. Otherwise, its default colors may visually conflict with a color scheme. If the scheme designer doesn't have a language plug-in, he will not be able to fix this at all.</p>"},{"location":"reference_guide/color_scheme_management/#providing-attributes-for-specific-schemes","title":"Providing Attributes for Specific Schemes","text":"<p>A language plug-in may provide default text attributes for \"Default\" and \"Darcula\" bundled schemes or basically for any other scheme if the scheme's name is known. This can be done in <code>plugin.xml</code> by adding an <code>com.intellij.additionalTextAttributes</code> extension providing the name of the file containing desired text attributes, for example:</p> <pre><code>&lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n..\n  &lt;additionalTextAttributes scheme=\"Default\" file=\"colorSchemes/MyLangDefault.xml\"/&gt;\n..\n&lt;/extensions&gt;\n</code></pre> <p>It tells the IDE that the file <code>MyLangDefault.xml</code> must be searched in resources under <code>colorSchemes</code>. Note that the path should not start with a backslash and its fully qualified name (in our case <code>colorSchemes/MyLangDefault.xml</code>) MUST BE UNIQUE to avoid naming collisions between different providers. Thus adding a language prefix, for example, \"MyLang\", is highly recommended.</p> <p>The file itself is an extract from a color scheme with required attributes, for example:</p> <pre><code>&lt;?xml version='1.0'?&gt;\n&lt;list&gt;\n  &lt;option name=\"MY_VAR\"&gt;\n    &lt;value&gt;\n      &lt;option name=\"FOREGROUND\" value=\"660000\"/&gt;\n    &lt;/value&gt;\n  &lt;/option&gt;\n  &lt;option name=\"MY_SPECIAL_CHAR\"&gt;\n    &lt;value&gt;\n      &lt;option name=\"FOREGROUND\" value=\"008000\"/&gt;\n      &lt;option name=\"BACKGROUND\" value=\"e3fcff\"/&gt;\n      &lt;option name=\"FONT_TYPE\" value=\"1\"/&gt;\n    &lt;/value&gt;\n  &lt;/option&gt;\n&lt;/list&gt;\n</code></pre> <p>Note:  When the scheme is copied via \"Save as...\" all its attributes, including the ones defined in the extension, will be copied to the new scheme. A scheme designer may need to check that these copied attributes do not conflict with his/her color scheme, although in this case the plug-in is installed, and it should not cause any problems. Anyway, try to stick with a simple key dependency if possible (note that it works well for \"Darcula\") and provide explicit attributes only if necessary.</p>"},{"location":"reference_guide/color_scheme_management/#scheme-designers","title":"Scheme Designers","text":""},{"location":"reference_guide/color_scheme_management/#a-typical-workflow-for-a-new-scheme-creation","title":"A Typical Workflow for a New Scheme Creation","text":"<ul> <li>Choose a scheme which will be used as a base, for example, \"Default\"</li> <li>Click \"Save As..\" and give a name for the new scheme</li> <li>First set attributes in General  section and proceed with Language Defaults</li> <li> <p>Check all the languages and adjust language-specific text attributes if necessary.   In most cases this may not be needed, but two cases may require an extra action:</p> <ul> <li>There is an obsolete plug-in which does not use the new color scheme management API and therefore does not utilize the attributes set in \"Language Defaults\".   Ideally, a report must be created for the language plug-in so that its author will fix it eventually.</li> <li>A plug-in intentionally sets some default colors and, if the scheme was created from a default one, the colors are copied to the newly created scheme.   This can be fixed either by resetting all the attributes to restore the inheritance from Language Defaults (see below) or by setting other colors suitable for the scheme.   The first way is preferable since it will require less effort to change the color scheme later.</li> </ul> </li> </ul>"},{"location":"reference_guide/color_scheme_management/#text-attributes-inheritance","title":"Text Attributes Inheritance","text":"<p>For many language text attributes that do not have any values, there will be a line indicating that the attributes are inherited from a specific section/attributes, such as \"Keyword (Language Defaults)\". If an element has any  attributes set, only these attributes are used. All attributes from the base element are ignored. To restore  the inheritance, unchecks all the boxes, and click Apply.</p>"},{"location":"reference_guide/custom_language_support/","title":"Custom Language Support","text":"<p>Consulo is a powerful platform for building development tools targeting any language. Most of the IDE features consist of language-independent (provided by the platform) and language-specific parts. Supporting a particular feature for a new language can be achieved with a small amount of effort: a plugin must implement only the language-specific part.</p> <p>This part of the documentation explains the main concepts of the Language API and guides you through the sequence of steps that are usually required to develop a custom language plugin. You can obtain additional information about the Language API from the JavaDoc comments for the Language API classes and from the Properties language support source code, which is part of the IntelliJ IDEA Community Edition source code.</p> <p>If you prefer a full example to the detailed descriptions offered in this section, please check out a step-by-step tutorial on how to create custom language support for Simple Language: Custom Language Support Tutorial. Corresponding steps from the tutorial are linked under the \"Examples\" section on each page of this reference.</p> <p>The webinar How We Built Comma, the Raku IDE, on the Consulo offers an excellent introduction as well.</p> <p>Providing custom language support includes the following major steps:</p> <ul> <li>Registering File Type</li> <li>Implementing Lexer</li> <li>Implementing Parser and PSI</li> <li>Syntax Highlighting and Error Highlighting</li> <li>References and Resolve</li> <li>Symbols</li> <li>Declarations and References</li> <li>Navigation</li> <li>Code Completion</li> <li>Find Usages</li> <li>Rename Refactoring</li> <li>Safe Delete Refactoring</li> <li>Code Formatter</li> <li>Code Inspections and Intentions</li> <li>Structure View</li> <li>Surround With</li> <li>Go to Class and Go to Symbol</li> <li>Documentation</li> <li>Additional Minor Features</li> </ul>"},{"location":"reference_guide/editors/","title":"Editors","text":"<p>This section covers working with text in the Consulo editor. It is presented in two major sections: * Editor basics tutorial   * Using the action system to access a caret placed in a document open in an editor.   * Accessing position information about a caret in an editor: coordinate systems and offsets.   * Handling actions activated by keystroke events in the editor. * Multiple carets   * Working with multiple, independent, carets in one editor.   * How multiple carets affect core functionality, editor actions, typing actions, and code insight actions.</p>"},{"location":"reference_guide/intellij_artifacts/","title":"Consulo Artifacts Repositories","text":"<p>WARNING When using additional repositories, make sure to use HTTPS always.</p> <p>JetBrains maintains public repositories that host artifacts related to the Consulo, such as binaries and source code. These repositories make artifacts more accessible for plugin developers.</p> <p>The Consulo artifacts repositories are: * Releases repository for release versions by build number. * Snapshots repository for BRANCH#-EAP-SNAPSHOT, EAP-CANDIDATE-SNAPSHOT, LATEST-EAP-SNAPSHOT, and the EAP-SNAPSHOT.</p> <p>See the Maven coordinates section for details about specifying these artifacts.</p> <p>Both the Releases and Snapshots repositories have two types of content: * Binary and source code artifacts for cross-platform, ZIP distributions of Consulo-based IDEs, such as IntelliJ IDEA, CLion, Rider, and MPS.   These artifacts are not intended to be accessed directly from a plugin project's <code>build.gradle</code> file.   The <code>gradle-intellij-plugin</code> will access them as-needed for a plugin project. * Artifacts for individual modules from the Consulo. These may be downloaded, or accessed directly from a <code>build.gradle</code> file, as explained below.</p> <p>Artifacts for Consulo third-party dependencies are hosted at the Bintray repository. A link to this repository should be added to <code>pom.xml</code>/<code>build.gradle</code> files when individual modules from an Consulo artifacts repository are used.</p>"},{"location":"reference_guide/intellij_artifacts/#using-consulo-module-artifacts","title":"Using Consulo Module Artifacts","text":"<p>Consulo module artifacts are utilized by adding information to a project's <code>build.gradle</code> file. More information about Gradle support is available in the IntelliJ IDEA Help documentation.</p> <p>To setup dependencies on a module there are two types of information needed: 1. Specify the corresponding repository URL for the artifact. 2. Specify the Maven coordinates for the artifact.</p>"},{"location":"reference_guide/intellij_artifacts/#specify-the-repository-url","title":"Specify the Repository URL","text":"<p>The URL for the desired artifact needs to be added to a Maven or Gradle script: * For release versions, use <code>https://www.jetbrains.com/intellij-repository/releases</code> * For EAP snapshots, use <code>https://www.jetbrains.com/intellij-repository/snapshots</code> * For dependencies on individual modules from the Consulo, also use <code>https://jetbrains.bintray.com/intellij-third-party-dependencies</code></p>"},{"location":"reference_guide/intellij_artifacts/#specify-the-maven-coordinates-for-the-artifact","title":"Specify the Maven Coordinates for the Artifact","text":"<p>Describing a desired Consulo module artifact is done with Maven coordinates: groupId, artifactId, and version. The Maven coordinates are based on the names of modules.</p> <p>The groupId for a module is the prefix <code>com.jetbrains.</code> concatenated with the first two parts of the module name. For example, the module <code>intellij.xml</code> would have the groupId <code>com.jetbrains.intellij.xml</code>.</p> <p>The artifactId is the second..n parts of the module name separated by \"-\" characters. For example, the module <code>intellij.xml</code> would have the artifactId <code>xml</code>. There are some special cases to artifactId names. If the second part of the module name is a common group like <code>platform</code>, <code>vcs</code>, or <code>cloud</code>, the second part of the module name is dropped, and the artifactId becomes the third..n parts of the module name, separated by \"-\" characters. Portions of the module name expressed in <code>camelCase</code> format are divided and used in the artifactId as (all lower case) <code>camel-case</code>.</p> <p>The table below shows some example module names and their corresponding groupId and artifactId.</p> Module Name groupId artifactId intellij.java.compiler.antTasks com.jetbrains.intellij.java java-compiler-ant-tasks intellij.java.debugger com.jetbrains.intellij.java java-debugger intellij.platform.util com.jetbrains.intellij.platform util intellij.platform.vcs.log com.jetbrains.intellij.platform vcs-log intellij.spring com.jetbrains.intellij.spring spring intellij.xml.impl com.jetbrains.intellij.xml xml-impl <p>The artifact version can be specified in one of several ways because each artifact at the Repository URLs has multiple versions available: * Specify release build versions as MAJOR[.MINOR][.FIX]. For example <code>14</code>, or <code>14.1</code>, or <code>14.1.1</code> * Snapshot versions are specified as:   * The snapshot of the most recent branch build is specified as BRANCH-EAP-SNAPSHOT. For example, <code>193-EAP-SNAPSHOT</code>.     There is only one of this type of build for each branch of each product.   * The snapshot of the branch from which the next EAP/release build might be produced is specified as BRANCH.BUILD-EAP-CANDIDATE-SNAPSHOT. For example <code>193.4386-EAP-CANDIDATE-SNAPSHOT</code>.     There are multiple builds of this type, one for each build in each branch of every product.   * The latest snapshot of a product is always specified as LATEST-EAP-SNAPSHOT.     There is only one build of this type per product, and it is always the same as the BRANCH-EAP-SNAPSHOT for the newest branch of the product.   * A snapshot of a branch is specified as BRANCH.BUILD.FIX-EAP-SNAPSHOT. For example, <code>193.4386.10-EAP-SNAPSHOT</code>.     There are many builds of this type for each branch of each product.</p>"},{"location":"reference_guide/intellij_artifacts/#example-artifact-specification","title":"Example Artifact Specification","text":"<p>For example, to specify the <code>jps-model-serialization</code> module:   * groupId = <code>com.jetbrains.intellij.platform</code>   * artifactId = <code>jps-model-serialization</code>   * classifier = <code>\"\"</code>   * packaging = <code>jar</code></p>"},{"location":"reference_guide/intellij_artifacts/#gradle-example-for-an-individual-module-from-the-consulo","title":"Gradle Example for an Individual Module from the Consulo","text":"<p>This section presents an example of using a Gradle script to incorporate an Consulo module and repository in a <code>build.gradle</code> file. The example illustrates declaring the artifact URL, Maven coordinates, and version for the <code>jps-model-serialization</code> module artifact. There are two parts to the example: the repository and the dependency sections.</p>"},{"location":"reference_guide/intellij_artifacts/#repositories-section","title":"Repositories Section","text":"<p>This code snippet selects the release repository with the first URL, and repository of Consulo dependencies with the second URL. The second URL is needed because this example selects individual modules.</p> <pre><code>repositories {\n    maven { url \"https://www.jetbrains.com/intellij-repository/releases\" }\n    maven { url \"https://jetbrains.bintray.com/intellij-third-party-dependencies\" }\n}\n</code></pre>"},{"location":"reference_guide/intellij_artifacts/#dependencies-section","title":"Dependencies Section","text":"<p>This code snippet specifies the desired module artifacts.</p> <pre><code>dependencies {\n    compile \"com.jetbrains.intellij.platform:jps-model-serialization:182.2949.4\"\n    compile \"com.jetbrains.intellij.platform:jps-model-impl:182.2949.4\"\n}\n</code></pre> <p>Note:  * The artifact version (<code>182.2949.4</code>) must match in both statements.  * In this example <code>jps-model-serialization</code> declares the APIs and <code>jps-model-impl</code> provides the implementation, so both are required dependencies.</p>"},{"location":"reference_guide/messaging_infrastructure/","title":"Messaging Infrastructure","text":""},{"location":"reference_guide/messaging_infrastructure/#purpose","title":"Purpose","text":"<p>The purpose of this document is to introduce the messaging infrastructure available in the Consulo to developers and plugin writers. It is intended to answer why, when and how to use it.</p>"},{"location":"reference_guide/messaging_infrastructure/#rationale","title":"Rationale","text":"<p>So, what is messaging in the Consulo and why do we need it? Basically, its implementation of Observer pattern that provides additional features like broadcasting on hierarchy and special nested events processing (nested event here is a situation when new event is fired (directly or indirectly) from the callback of another event).</p>"},{"location":"reference_guide/messaging_infrastructure/#design","title":"Design","text":"<p>Here are the main components of the messaging API.</p>"},{"location":"reference_guide/messaging_infrastructure/#topic","title":"Topic","text":"<p>This class serves as an endpoint at the messaging infrastructure. I.e., clients are allowed to subscribe to a specific topic within a bus and send messages to that topic within that particular bus.</p> <p></p> <ul> <li>display name just a human-readable name used for logging/monitoring purposes;</li> <li>broadcast direction will be explained in details at Broadcasting. Default value is TO_CHILDREN;</li> <li>listener class that is a business interface for particular topic.   Subscribers register an implementation of this interface at the messaging infrastructure.   Publishers later retrieve objects that conform to the interface (IS-A) and call any methods defined on those implementations.   The messaging infrastructure takes care of dispatching the message to all subscribers of the topic by calling the same method with the same arguments on the registered implementation callbacks;</li> </ul>"},{"location":"reference_guide/messaging_infrastructure/#message-bus","title":"Message Bus","text":"<p>Is the core of the messaging system. Is used at the following scenarios:</p> <p></p>"},{"location":"reference_guide/messaging_infrastructure/#connection","title":"Connection","text":"<p>Manages all subscriptions for particular client within particular bus.</p> <p></p> <ul> <li>keeps number of topic handler mappings (callbacks to invoke when message for the target topic is received)   Note: not more than one handler per-topic within the same connection is allowed;</li> <li>it's possible to specify default handler and subscribe to the target topic without explicitly provided callback.   Connection will use that default handler when storing (topic-handler) mapping;</li> <li>it's possible to explicitly release acquired resources (disconnect() method).   Also it can be plugged to standard semi-automatic disposing (<code>Disposable</code>);</li> </ul>"},{"location":"reference_guide/messaging_infrastructure/#putting-altogether","title":"Putting Altogether","text":"<p>Defining business interface and topic</p> <pre><code>public interface ChangeActionNotifier {\n\n    Topic&lt;ChangeActionNotifier&gt; CHANGE_ACTION_TOPIC = Topic.create(\"custom name\", ChangeActionNotifier.class)\n\n    void beforeAction(Context context);\n    void afterAction(Context context);\n}\n</code></pre> <p>Subscribing</p> <p></p> <p>NOTE If targeting 2019.3 or later, use declarative registration if possible.</p> <pre><code>public void init(MessageBus bus) {\n    bus.connect().subscribe(ActionTopics.CHANGE_ACTION_TOPIC, new ChangeActionNotifier() {\n        @Override\n        public void beforeAction(Context context) {\n            // Process 'before action' event.\n        }\n        @Override\n        public void afterAction(Context context) {\n            // Process 'after action' event.\n        }\n    });\n}\n</code></pre> <p>Publishing</p> <p></p> <pre><code>public void doChange(Context context) {\n    ChangeActionNotifier publisher = myBus.syncPublisher(ActionTopics.CHANGE_ACTION_TOPIC);\n    publisher.beforeAction(context);\n    try {\n        // Do action\n        // ...\n    } finally {\n        publisher.afterAction(context)\n    }\n}\n</code></pre> <p>Existing resources</p> <ul> <li>MessageBus instances are available via <code>ComponentManager.getMessageBus()</code>   Many standard interfaces implement a message bus, e.g., <code>Application</code> and <code>Project</code>.</li> <li>A number of public topics are used by the Consulo, e.g., <code>AppTopics</code>, <code>ProjectTopics</code>, etc.   So, it's possible to subscribe to them in order to receive information about the processing;</li> </ul>"},{"location":"reference_guide/messaging_infrastructure/#broadcasting","title":"Broadcasting","text":"<p>Message buses can be organised into hierarchies. Moreover, the Consulo has them already:</p> <p></p> <p>That allows to notify subscribers registered in one message bus on messages sent to another message bus.</p> <p>Example:</p> <p></p> <p>Here we have a simple hierarchy (application bus is a parent of project bus) with three subscribers for the same topic.</p> <p>We get the following if topic1 defines broadcast direction as TO_CHILDREN: 1. A message is sent to topic1 via application bus; 2. handler1 is notified about the message; 3. The message is delivered to the subscribers of the same topic within project bus (handler2 and handler3);</p> <p>Benefits</p> <p>We don't need to bother with memory management of subscribers that are bound to child buses but interested in parent bus-level events.</p> <p>Consider the example above we may want to have project-specific functionality that reacts to the application-level events. All we need to do is to subscribe to the target topic within the project bus. No hard reference to the project-level subscriber will be stored at application-level then, i.e., we just avoided memory leak on project re-opening.</p> <p>Options</p> <p>Broadcast configuration is defined per-topic. The following options are available:</p> <ul> <li>TO_CHILDREN_ (default);</li> <li>NONE;</li> <li>TO_PARENT;</li> </ul>"},{"location":"reference_guide/messaging_infrastructure/#nested-messages","title":"Nested Messages","text":"<p>Nested message is a message sent (directly or indirectly) during another message processing. The Consulo's Messaging infrastructure guarantees that all messages sent to particular topic will be delivered at the sending order.</p> <p>Example:</p> <p>Suppose we have the following configuration:</p> <p></p> <p>Let's see what happens if someone sends a message to the target topic:</p> <ul> <li>message1 is sent;</li> <li>handler1 receives message1 and sends message2 to the same topic;</li> <li>handler2 receives message1;</li> <li>handler2 receives message2;</li> <li>handler1 receives message2;</li> </ul>"},{"location":"reference_guide/messaging_infrastructure/#tipsntricks","title":"Tips'n'tricks","text":""},{"location":"reference_guide/messaging_infrastructure/#relief-listeners-management","title":"Relief Listeners Management","text":"<p>Messaging infrastructure is very light-weight, so, it's possible to reuse it at local sub-systems in order to relieve Observers construction. Let's see what is necessary to do then:</p> <ol> <li>Define business interface to work with;</li> <li>Create shared message bus and topic that uses the interface above (shared here means that either subject or observers know about them);</li> </ol> <p>Let's compare that with a manual implementation:</p> <ol> <li>Define listener interface (business interface);</li> <li>Provide reference to the subject to all interested listeners;</li> <li>Add listeners storage and listeners management methods (add/remove) to the subject;</li> <li>Manually iterate all listeners and call target callback in all places where new event is fired;</li> </ol>"},{"location":"reference_guide/messaging_infrastructure/#avoid-shared-data-modification-from-subscribers","title":"Avoid Shared Data Modification from Subscribers","text":"<p>We had a problem in a situation when two subscribers tried to modify the same document (IDEA-71701).</p> <p>The thing is that every document change is performed by the following scenario:</p> <ol> <li>before change event is sent to all document listeners and some of them publish new messages during that;</li> <li>actual change is performed;</li> <li>after change event is sent to all document listeners;</li> </ol> <p>We had the following then:</p> <ol> <li>message1 is sent to the topic with two subscribers;</li> <li>message1 is queued for both subscribers;</li> <li>message1 delivery starts;</li> <li>subscriber1 receives message1;</li> <li>subscriber1 issues document modification request at particular range (e.g. document.delete(startOffset, endOffset));</li> <li>before change notification is sent to the document listeners;</li> <li>message2 is sent by one of the standard document listeners to another topic within the same message bus during before change processing;</li> <li>the bus tries to deliver all pending messages before queuing message2;</li> <li>subscriber2 receives message1 and also modifies a document;</li> <li>the call stack is unwinded and actual change phase of document modification operation requested by subscriber1 begins;</li> </ol> <p>The problem  is that document range used by subscriber1 for initial modification request is invalid if subscriber2 has changed document's range before it.</p>"},{"location":"reference_guide/multiple_carets/","title":"Supporting Multiple Carets","text":""},{"location":"reference_guide/multiple_carets/#introduction","title":"Introduction","text":"<p>Support for multiple independent carets has been added to editor implementation in IDEA 13.1. Most editor actions (keyboard navigation, text insertion and deletion, etc.) will be applied to each caret independently. Each caret has its own associated selection, which is a continuous range of document characters (can be empty). When after some action two or more carets end up in the same visual position, they are merged into a single caret with their associated selections merged into a single one. A similar thing will happen when selections for several carets become overlapped: only one of the carets will remain, and the selections will be merged. There's a concept of 'primary' caret \u2014 the one on which non-multi-caret-aware actions and the actions which need a single-point document context (like code completion) will operate. Currently, the most recent caret is considered the primary one.</p>"},{"location":"reference_guide/multiple_carets/#core-functionality","title":"Core Functionality","text":"<p>Core logic related to multi-caret implementation such as accessing currently existing carets, adding and removing carets, is available via <code>CaretModel</code> interface, some changes also have been made in <code>SelectionModel</code> interface. Check Javadoc of those interfaces for details.</p> <p>Notable changes from old behaviour:</p> <ul> <li> <p>Previously existing methods in <code>CaretModel</code> and <code>SelectionModel</code> to query and modify caret and selection positions work by default on the primary caret now.   In the context of <code>CaretModel.runForEachCaret</code> method though, they operate on the current caret.   So the behaviour of legacy code (not using Caret interface) will depend on the context of its invocation.</p> </li> <li> <p>Block selection doesn't exist as a separate concept anymore.   Correspondingly, block-selection-related methods in SelectionModel interface have changed behaviour \u2014 <code>hasBlockSelection()</code> will always return false, <code>setBlockSelection()</code> will create a multi-caret selection equivalent to the requested block selection.   <code>getBlockSelectionStarts()</code> and <code>getBlockSelectionEnds()</code> methods work in multi-caret state, returning all selected regions.</p> </li> </ul>"},{"location":"reference_guide/multiple_carets/#editor-actions","title":"Editor Actions","text":""},{"location":"reference_guide/multiple_carets/#editoraction-and-editoractionhandler","title":"EditorAction and EditorActionHandler","text":"<p>When <code>EditorActionHandler</code> is invoked, an additional parameter will be passed to it \u2014 a caret instance on which it should operate, or <code>null</code> if it's invoked without any caret context. If the handler invokes another handler (delegate handler for the same <code>actionId</code> or a completely unrelated handler), that parameter should normally be passed to the delegate unchanged (unless no context caret has been provided to the handler, but it needs to invoke another handler on a specific caret). Of course, the handler can just ignore the caret parameter if its functionality is not related to caret/selection position.</p> <p>If the handler needs to implement multi-caret functionality it can do so explicitly in the overridden <code>doExecute</code> method, but if it just needs that method to be invoked for each caret, it suffices to pass a parameter to <code>EditorActionHandler</code> constructor to make <code>doExecute</code> called for each caret when the handler is invoked without a specific caret context.</p>"},{"location":"reference_guide/multiple_carets/#editor-action-delegates","title":"Editor Action Delegates","text":"<p>The following delegates are available:</p> <ul> <li><code>EnterHandlerDelegate</code></li> <li><code>BackspaceHandlerDelegate</code></li> <li><code>JoinLinesHandlerDelegate</code></li> <li><code>EditorNavigationDelegate</code></li> <li><code>SmartEnterProcessor</code></li> <li><code>CommentCompleteHandler</code></li> <li><code>StatementUpDownMover</code></li> <li><code>CodeBlockProvider</code></li> </ul> <p>At the moment there's no need to make any changes in the handlers to support multiple carets \u2014 they are already invoked for each caret.</p>"},{"location":"reference_guide/multiple_carets/#typing-actions","title":"Typing Actions","text":""},{"location":"reference_guide/multiple_carets/#typedactionhandler-typedhandlerdelegate","title":"TypedActionHandler, TypedHandlerDelegate","text":"<p><code>TypedActionHandler</code> and <code>TypedHandlerDelegate</code> implementations are invoked only once for each typed character. If those handlers need to support multiple carets, they will need to implement that explicitly.</p> <p><code>EditorModificationUtil</code>. <code>typeInStringAtCaretHonorMultipleCarets()</code> method is available to do the most common task in this case \u2014 inserting the same text into all caret positions and/or moving all carets relatively to their current position. Examples of its usage:</p> <ul> <li><code>TypedAction</code>.</li> <li><code>XmlGtTypedHandler</code>.</li> </ul> <p>NOTE Starting from version 14, <code>TypedHandlerDelegate</code> implementations are invoked automatically for each caret. If one wants to implement custom multicaret behaviour on typing, <code>TypedActionHandler</code> needs to be provided instead.</p>"},{"location":"reference_guide/multiple_carets/#code-insight-actions","title":"Code Insight Actions","text":"<p>Existing actions inheriting from <code>CodeInsightAction</code> will work for primary caret only. To support multiple carets, one should subclass <code>MultiCaretCodeInsightAction</code> instead.  Each caret might have a different editor and PSI instance, so using the old API is not possible.</p>"},{"location":"reference_guide/settings_groups/","title":"Custom Settings Groups","text":"<p>As described in Extension Points for Settings, custom Settings can be declared as children of existing parent groups such as <code>tools</code>. These parent groups are the existing categories of Settings in the Consulo-based IDE.</p> <p>However, suppose the custom Settings are rich enough to require multiple levels? For example, a custom Setting implementation has multiple sub-Settings implementations. Extension Point declarations can create this kind of multilayer Settings hierarchy.</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"reference_guide/settings_groups/#extension-points-for-parent-child-settings-relationships","title":"Extension Points for Parent-Child Settings Relationships","text":"<p>There are multiple ways of creating parent-child relationships in groups of Settings: in implementations, or Extension Point declarations. However, there are performance penalties for creating these relationships in implementations because the objects must be instantiated to determine the relationships. This section describes the syntax for declaring more complex parent-child relationships in <code>com.intellij.projectConfigurable</code> or <code>com.intellij.applicationConfigurable</code> EPs.</p> <p>NOTE An application configurable can be a parent of a project configurable.</p> <p>There are two ways of declaring parent-child relationships using the <code>com.intellij.projectConfigurable</code> or <code>com.intellij.applicationConfigurable</code> EPs. The first is to use separate EP declarations that are tied together by the value of one attribute. The second method is to use nested declarations.</p>"},{"location":"reference_guide/settings_groups/#parent-child-settings-using-separate-eps","title":"Parent-Child Settings Using Separate EPs","text":"<p>One way of declaring a parent-child relationship is by using two separate declarations. This form can be used regardless of whether the parent Settings declaration is in the same plugin. If the <code>id</code> attribute of the parent is known, a plugin can add Settings as a child of that parent.</p> <p>For example, below are two declarations for project Settings. The first gets added to the <code>tools</code> group, and the second gets added to the <code>id</code> of the parent. The <code>id</code> of the second, child <code>&lt;projectConfigurable&gt;</code> adds a suffix (<code>servers</code>) to the <code>id</code> of the parent.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;projectConfigurable parentId=\"tools\" id=\"com.intellij.sdk.tasks\" displayName=\"Tasks\"\n                         nonDefaultProject=\"true\"\n                         instance=\"com.intellij.sdk.TaskConfigurable\"/&gt;\n\n    &lt;projectConfigurable parentId=\"com.intellij.sdk.tasks\" id=\"com.intellij.sdk.tasks.servers\" displayName=\"Servers\"\n                         nonDefaultProject=\"true\"\n                         instance=\"com.intellij.sdk.TaskRepositoriesConfigurable\"/&gt;\n  &lt;/extensions&gt;\n</code></pre> <p>See the Attributes for Parent-Child Settings EPs section for details about the suffix <code>id</code>.</p>"},{"location":"reference_guide/settings_groups/#parent-child-settings-using-nested-eps","title":"Parent-Child Settings Using Nested EPs","text":"<p>A shorthand for the separate declaration approach is using the <code>com.intellij.configurable</code> EP. This approach nests the child's Settings declaration within the <code>com.intellij.projectConfigurable</code> or <code>com.intellij.applicationConfigurable</code> EP. Using <code>&lt;configurable&gt;</code> EP would not be possible if the parent Settings were declared in another plugin or file. In that case, Parent-Child Settings Using Separate EPs would be used.</p> <p>When using <code>&lt;configurable&gt;</code> EP there isn't a <code>parentId</code> for the child because the nesting implies it. As with using separate EP declarations, formatting restrictions are placed on the child's <code>id</code> attribute - the suffix (<code>servers</code>) gets added. See the Attributes for Parent-Child Settings EPs section.</p> <p>The example below demonstrates a <code>&lt;configurable&gt;</code> EP declaration:</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;projectConfigurable parentId=\"tools\" id=\"com.intellij.sdk.tasks\" displayName=\"Tasks\" nonDefaultProject=\"true\"\n                         instance=\"com.intellij.sdk.TaskConfigurable\"/&gt;\n      &lt;configurable id=\"com.intellij.sdk.tasks.servers\" displayName=\"Servers\" nonDefaultProject=\"true\"\n                         instance=\"com.intellij.sdk.TaskRepositoriesConfigurable\"/&gt;\n    &lt;/projectConfigurable&gt;\n  &lt;/extensions&gt;\n</code></pre> <p>Within the parent <code>&lt;projectConfigurable&gt;</code> EP declaration above, more <code>&lt;configurable&gt;</code> declarations could be added as sibling Settings.</p>"},{"location":"reference_guide/settings_groups/#attributes-for-parent-child-settings-eps","title":"Attributes for Parent-Child Settings EPs","text":"<p>There is only one unique attribute when declaring a child Settings EP. The other attributes are the same as discussed in Settings EP Attributes.</p> <p>For the child of a parent, the <code>id</code> attribute becomes compound:</p> Attribute Required Value <code>id</code> Y Compound FQN of implementation based on <code>com.intellij.openapi.options.Configurable</code> in the form: <code>XX.YY</code> where:<code>XX</code> is the parent Settings component FQN-based id.<code>YY</code> is unique to the child among other siblings. <p>TIP All children share the parent's <code>id</code> as the basis of their own <code>id</code>. All children have an <code>id</code> suffix that is unique among their siblings.</p>"},{"location":"reference_guide/settings_groups/#implementations-for-parent-child-settings","title":"Implementations for Parent-Child Settings","text":"<p>Implementations can be based on <code>Configurable</code>, <code>ConfigurableProvider</code> or one of their subtypes. For more information about creating Settings implementations, see Implementations for Settings Extension Points.</p>"},{"location":"reference_guide/settings_groups/#configurable-marker-interfaces","title":"Configurable Marker Interfaces","text":"<p>The <code>Configurable.Composite</code> interface indicates a configurable component has child components. The preferred approach is to specify child components in the EP declaration. Using the <code>Composite</code> interface incurs the penalty of loading child classes while building the tree of Settings Swing components.</p>"},{"location":"reference_guide/settings_guide/","title":"Settings Guide","text":"<p>Settings persistently store states that control the behavior and appearance of Consulo-based IDEs. On this page, the term \"Settings\" means the same as \"Preferences\" on some platforms.</p> <p>Plugins can create and store Settings to capture their configuration in a way that uses the Consulo Persistence Model. The User Interface (UI) for these custom Settings can be added to the IDE Settings dialog.</p> <p>Settings can affect different levels of scope. This document describes adding custom Settings at the Project and Application (or Global, IDE) levels.</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"reference_guide/settings_guide/#extension-points-for-settings","title":"Extension Points for Settings","text":"<p>Custom Settings implementations are declared in a plugin's configuration (<code>plugin.xml</code>) file using one of two Extension Points (EPs), depending on the level of the Settings. Many attributes are shared between the EP declarations.</p> <p>Application and Project Settings typically provide an implementation based on the <code>Configurable</code> interface because they do not have runtime dependencies. See Implementations for Settings Extension Points for more information.</p> <p>NOTE For performance reasons, the recommended approach is to declare as much information as possible about a Settings' implementation using attributes in the Extension Point. If it is not declared, the component must be loaded to retrieve it from the implementation, degrading UI responsiveness.</p>"},{"location":"reference_guide/settings_guide/#declaring-application-settings","title":"Declaring Application Settings","text":"<p>Settings at the Application level use the <code>com.intellij.applicationConfigurable</code> EP.</p> <p>An example <code>&lt;applicationConfigurable&gt;</code> EP declaration is shown below. The declaration indicates the settings are a child of the <code>tools</code> settings group, the implementation FQN is <code>org.company.ApplicationSettingsConfigurable</code>, the unique ID is the same as the implementation FQN, and the (non-localized) title displayed to users is \"My Application Settings\". See Settings Declaration Attributes for more information. <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;applicationConfigurable parentId=\"tools\" instance=\"org.company.ApplicationSettingsConfigurable\"\n            id=\"org.company.ApplicationSettingsConfigurable\" displayName=\"My Application Settings\"/&gt;\n  &lt;/extensions&gt;\n</code></pre></p>"},{"location":"reference_guide/settings_guide/#declaring-project-settings","title":"Declaring Project Settings","text":"<p>Project level Settings use the <code>com.intellij.projectConfigurable</code> EP.</p> <p>An example <code>&lt;projectConfigurable&gt;</code> EP declaration is shown below. Similar to the application setting example above, but it includes the additional attribute <code>nonDefaultProject</code> indicating these settings do not apply to the default project. See Settings Declaration Attributes for details. <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;projectConfigurable parentId=\"tools\" instance=\"org.company.ProjectSettingsConfigurable\"\n            id=\"org.company.ProjectSettingsConfigurable\" displayName=\"My Project Settings\"\n            nonDefaultProject=\"true\"/&gt;\n  &lt;/extensions&gt;\n</code></pre></p>"},{"location":"reference_guide/settings_guide/#settings-declaration-attributes","title":"Settings Declaration Attributes","text":"<p>Readers are encouraged to review the Javadoc comments for <code>Configurable</code> because the attribute information applies to <code>ConfigurableProvider</code> as well as <code>Configurable</code>, as noted. This section provides some additional clarification of those comments.</p>"},{"location":"reference_guide/settings_guide/#table-of-attributes","title":"Table of Attributes","text":"<p>The attributes supported by <code>com.intellij.applicationConfigurable</code> and <code>com.intellij.projectConfigurable</code> EPs are in the table below:</p> Attribute ImplementationBasis Required\u2002\u2002 AttributeValue <code>instance</code> <code>Configurable</code> (1) FQN of implementation. See The Configurable Interface for more information. <code>provider</code> <code>ConfigurableProvider</code> (1) FQN of implementation. See The ConfigurableProvider Class for more information. <code>nonDefaultProject</code> <code>Configurable</code> Y Applicable only to the <code>com.intellij.projectConfigurable</code> (project Settings) EP.<code>true</code> = show Settings for all projects except the default project.<code>false</code> = show Settings for all projects. <code>displayName</code> <code>Configurable</code><code>ConfigurableProvider</code> (2) The non-localized Settings name visible to users, which is needed for the Settings dialog left-side menu.For a localized visible name omit <code>displayName</code> and use the <code>key</code> and <code>bundle</code> attributes. <code>key</code> and<code>bundle</code> <code>Configurable</code><code>ConfigurableProvider</code> (2) The localization key and bundle for the Settings name visible to users.For non-localized visible names omit <code>key</code> and <code>bundle</code> and use <code>displayName</code>. <code>id</code> <code>Configurable</code><code>ConfigurableProvider</code> Y The unique, FQN identifier for this implementation.The FQN should be based on the plugin <code>id</code> to ensure uniqueness. <code>parentId</code> <code>Configurable</code><code>ConfigurableProvider</code> Y This attribute is used to create a hierarchy of Settings. This component is declared one of the specified <code>parentId</code> component's children. Typically used for placing a Settings panel within the Settings Dialog menu. Acceptable values for <code>parentId</code> are given in Values for Parent ID Attribute.<code>groupId</code> is deprecated.(3) <code>groupWeight</code> <code>Configurable</code><code>ConfigurableProvider</code> N Specifies the weight (stacking order) of this component within the group of a parent configurable component. The default weight is 0, meaning lowest in the order.If one child in a group or a parent component has non-zero weight, all children will be sorted descending by their weight. If the weights are equal, the components will be sorted ascending by their display name. <code>dynamic</code> <code>Configurable.Composite</code> N This component's children are dynamically calculated by calling the <code>getConfigurables()</code> method.Not recommended because it requires loading additional classes while building a Settings tree. If possible, use XML attributes instead. <code>childrenEPName</code> <code>Configurable</code> N Specifies the FQN name of the Extension Point that will be used to calculate the children of this component. <p>Attribute Notes: 1) Either <code>instance</code> or <code>provider</code> must be specified depending on the implementation. 2) One of these attribute sets must be specified depending on whether the displayed Settings name is localized. 3) If both <code>groupId</code> and <code>parentId</code> are specified, a warning is logged. Also, see default entry in Values for Parent ID Attribute.</p>"},{"location":"reference_guide/settings_guide/#values-for-parent-id-attribute","title":"Values for Parent ID Attribute","text":"<p>The table below shows the allowed values for the <code>parentId</code> attribute. See the previous section for all supported attributes.</p> <code>parentId</code> Value Group Details default <code>other</code> If neither <code>parentId</code> nor <code>groupId</code> attribute is set, the component is added to the <code>other</code> Settings group. This is undesirable; see <code>other</code> group description. <code>appearance</code> Appearance &amp; Behavior This child group contains Settings to personalize IDE appearance, such as: changing themes and font size. Also, it covers Settings to customize behavior such as keymaps, configuring plugins, and system Settings such as password policies, HTTP proxy, updates, and more. <code>build</code> Build, Execution, Deployment Child group containing Settings to configure project integration with different build tools, modify the default compiler Settings, manage server access configurations, customize the debugger behavior, etc. <code>build.tools</code> Build Integration A subgroup of <code>build</code>. This subgroup configures project integration with build tools such as Maven, Gradle, or Gant. <code>editor</code> Editor Child group containing Settings to personalize source code appearance, such as fonts, highlighting styles, indents, etc. It also contains Settings to customize the editor's appearance, such as line numbers, caret placement, tabs, source code inspections, setting up templates, and file encodings. <code>language</code> Languages and Frameworks Child group containing Settings related to specific language frameworks and technologies used in the project. <code>tools</code> 3rd Party Settings Child group containing Settings to configure integration with third-party applications, specify the SSH Terminal connection Settings, manage server certificates and tasks, configure diagrams layout, etc. <code>root</code> Super Parent The invisible parent of all existing groups. Not used except for IDEs built on top of the Consulo, or extensive suites of Settings. You should not place settings in this group. <code>other</code> Catch-all The Consulo no longer uses this group. Do not use this group. Use the <code>tools</code> group instead. <code>project</code> Project-related Settings The Consulo no longer uses this group. It was intended to store some project-related settings. Do not use this group."},{"location":"reference_guide/settings_guide/#implementations-for-settings-extension-points","title":"Implementations for Settings Extension Points","text":"<p>Implementations for <code>com.intellij.projectConfigurable</code> and <code>com.intellij.applicationConfigurable</code> EPs can have one of two bases: * The <code>Configurable</code> interface, which provides a named configurable component with a Swing form.   Most Settings providers are based on the <code>Configurable</code> interface or one of its sub- or supertypes. * The <code>ConfigurableProvider</code> class, which can hide a configurable component from the Settings dialog based on runtime conditions.</p>"},{"location":"reference_guide/settings_guide/#the-configurable-interface","title":"The Configurable Interface","text":"<p>Many Settings in the <code>intellij-community</code> code base implement <code>Configurable</code> or one of its subtypes, such as <code>SearchableConfigurable</code>. Readers are encouraged to review the Javadoc comments for <code>Configurable</code>.</p>"},{"location":"reference_guide/settings_guide/#constructors","title":"Constructors","text":"<p>Implementations must meet several requirements for constructors. * Application Settings implementations, declared using the <code>applicationConfiguration</code> EP, must have a default constructor with no arguments. * Project Settings implementations, declared using the <code>projectSettings</code> EP, must declare a constructor with a single argument of type <code>Project</code>. * Beginning in 2020.2, constructor injection (other than for <code>Project</code>) is not allowed.</p> <p>For a <code>Configurable</code> implementation correctly declared using an EP, the implementation's constructor is not invoked by the Consulo until a user chooses the corresponding Settings <code>displayName</code> in the Settings Dialog menu.</p> <p>WARNING The Consulo may instantiate a <code>Configurable</code> implementation on a background thread, so creating Swing components in a constructor can degrade UI responsiveness.</p>"},{"location":"reference_guide/settings_guide/#consulo-interactions-with-configurable","title":"Consulo Interactions with Configurable","text":"<p>The instantiation of a generic <code>Configurable</code> implementation is documented in the interface file. A few high-level points are reviewed here: * The <code>Configurable.reset()</code> method is invoked immediately after <code>Configurable.createComponent()</code>.   Initialization of Setting values in the constructor or <code>createComponent()</code> is unnecessary. * See the Constructors section for information about when a Settings object is instantiated. * Once instantiated, a <code>Configurable</code> instance's lifetime continues regardless of whether the implementation's Settings are changed, or the user chooses a different entry on the Settings Dialog menu. * A <code>Configurable</code> instance's lifetime ends when OK or Cancel is selected in the Settings Dialog.   An instance's <code>Configurable.disposeUIResources()</code> is called when the Settings Dialog is closing.</p> <p>To open Settings dialog or show specific <code>Configurable</code>, see <code>ShowSettingsUtil</code>.</p>"},{"location":"reference_guide/settings_guide/#configurable-marker-interfaces","title":"Configurable Marker Interfaces","text":"<p>Implementations based on <code>Configurable</code> can implement marker interfaces, which provide additional flexibility in the implementation.</p> <p>The following nested interfaces are markers, which convey information about the form to the Consulo:   * <code>Configurable.NoScroll</code> - Notifies the Settings dialog not to add scroll bars to the form.     By default, a plugin's Settings component is put into a scrollable pane.     However, a Settings panel can have a <code>JTree</code>, which requires its own <code>JScrollPane</code>.     So <code>NoScroll</code> interface should be used to remove the outer <code>JScrollPane</code>.   * <code>Configurable.NoMargin</code> - Notifies the Settings dialog not to add an empty border to the form.     By default, an empty border is added for a plugin's Settings component.</p>"},{"location":"reference_guide/settings_guide/#additional-interfaces-based-on-configurable","title":"Additional Interfaces Based on Configurable","text":"<p>There are classes in the Consulo specialized for particular types of Settings. These subtypes are based on <code>com.intellij.openapi.options.ConfigurableEP</code>. For example, Settings/Preferences | Editor | General |Appearance allows adding Settings via <code>EditorSmartKeysConfigurableEP</code> and <code>com.intellij.editorSmartKeysConfigurable</code> EP.</p>"},{"location":"reference_guide/settings_guide/#the-configurableprovider-class","title":"The ConfigurableProvider Class","text":"<p>The <code>ConfigurableProvider</code> class only provides a <code>Configurable</code> implementation if its runtime conditions are met. The Consulo first calls the <code>ConfigurableProvider.canCreateConfigurable()</code>, which evaluates runtime conditions to determine if Settings changes make sense in the current context. If the Settings make sense to display, <code>canCreateConfigurable()</code> returns <code>true</code>. In that case the Consulo calls <code>ConfigurableProvider.createConfigurable()</code>, which returns the <code>Configurable</code> object for its Settings implementation.</p> <p>By choosing not to provide a <code>Configuration</code> implementation in some circumstances, the <code>ConfigurableProvider</code> opts out of the Settings display and modification process. The use of <code>ConfigurableProvider</code> as a basis for a Settings implementation is declared using attributes in the EP declaration.</p>"},{"location":"reference_guide/tomcat_integration/","title":"Tomcat Integration","text":"<p>The source code of the Tomcat plugin included in IntelliJ IDEA Ultimate is available as a sample for implementing application server integration plugins. You can find the code under lib\\src\\src_tomcat.zip in the main IntelliJ IDEA Ultimate distribution.</p>"},{"location":"reference_guide/vcs_integration_for_plugins/","title":"Version Control Systems","text":"<p>This page gives an overview of the Version Control Integration API.</p>"},{"location":"reference_guide/vcs_integration_for_plugins/#key-concepts","title":"Key Concepts","text":""},{"location":"reference_guide/vcs_integration_for_plugins/#filepath","title":"FilePath","text":"<p>A <code>FilePath</code> represents a path to a file or directory on disk or in the VCS repository. Unlike a <code>VirtualFile</code>, a <code>FilePath</code> can represent a path to a file which doesn't exist on disk. The main difference between a <code>FilePath</code> and a <code>java.io.File</code> is that a <code>FilePath</code> caches the <code>VirtualFile</code> corresponding to the path, so it can be retrieved without doing a VFS search.</p> <p>To create instances of <code>FilePath</code>, the <code>VcsContextFactory</code> API is used. It can be accessed as<code>PeerFactory.getInstance().getVcsContextFactory()</code></p> <p><code>FilePath</code> representing paths in a VCS repository, rather than local paths, are created using <code>VcsContextFactory.createFilePathOnNonLocal()</code>. The <code>FilePath.isNonLocal()</code> method returns <code>true</code> for such files.</p>"},{"location":"reference_guide/vcs_integration_for_plugins/#revision-number","title":"Revision Number","text":"<p>A <code>VcsRevisionNumber</code> represents a revision number of the file. If the VCS stores revision numbers as simple integers, the standard <code>VcsRevisionNumber</code> <code>Int</code> implementation can be used. If the VCS has a more complex format of revision numbers (like CVS, which uses a series of numbers delimited with dots), the plugin can provide a custom implementation.</p>"},{"location":"reference_guide/vcs_integration_for_plugins/#contentrevision","title":"ContentRevision","text":"<p>A <code>ContentRevision</code> represents a particular revision of a file, which exists either locally or in a VCS repository. It has three main attributes:</p> <ul> <li><code>FilePath</code> specifying the file of which this is a revision.   If some version of the file exists locally, this should be a local path.</li> <li><code>VcsRevisionNumber</code> specifying the revision number of the revision, or <code>VcsRevisionNumber.NULL</code> if the revision exists only locally.</li> <li>Content of the revision.</li> </ul> <p>The content is returned as string, and the VCS plugin is responsible for converting the binary file content to correct encoding. To detect the encoding automatically based on the IDE settings and the byte order mark, the method <code>CharsetToolkit.bytesToString()</code> can be used (this API is new in IDEA 7.0.2). Revisions of binary files can also be represented as BinaryContentRevision, which is a subclass of ContentRevision. For binary revisions, the result of getContent() is undefined, and getBinaryContent() can be used to retrieve the contents as a byte array.</p> <p>A useful class which can be used to represent the current on-disk version of a particular file is <code>CurrentContentRevision</code>.</p>"},{"location":"reference_guide/vcs_integration_for_plugins/#filestatus","title":"FileStatus","text":"<p>A <code>FileStatus</code> represents a status of a file in regard to VCS (unversioned, not changed, added, modified and so on). It determines the color used to render the name of the file in the UI.</p>"},{"location":"reference_guide/vcs_integration_for_plugins/#change","title":"Change","text":"<p>A <code>Change</code> represents a single file operation (creation, modification, move/rename or deletion) from a VCS point of view. A Change can represent either a modification which the user has performed locally and not yet committed, a committed modification, or some other type of modification (for example, a shelved change or a difference between two arbitrary revisions).</p> <p>A <code>Change</code> essentially consists of two content revisions:</p> <ul> <li>before revision (<code>null</code> if the Change represents file creation)</li> <li>after revision (<code>null</code> if the Change represents file deletion)</li> </ul> <p>A move or rename is represented by a Change where the before revision and the after revision have different file paths. A custom file status can be specified for a <code>Change</code> if it represents a non-standard modification of the file (for example, a file which has been merged with conflicts). If a custom file status has not been specified, the status is calculated automatically from the change type.</p>"},{"location":"reference_guide/vcs_integration_for_plugins/#changelist","title":"ChangeList","text":"<p>A <code>ChangeList</code> represents a named group of related changes. There are two main kinds of changelists:</p> <ul> <li><code>LocalChangeList</code> represents a group of modifications done by a user locally.   If the VCS also supports the concept of changelists (like Perforce does), the VCS plugin can synchronize IDEA's local changelist structure with that of the VCS.   Otherwise, a local changelist is simply a subset of the files checked out or modified by the user.</li> <li><code>CommittedChangeList</code> represents a set of modifications checked in to the VCS repository.   For VCSes which support atomic commit, every committed revision is represented by a CommittedChangeList.   For VCSes which use per-file commit (like CVS), the plugin can use heuristics to group a sequence of individual file commits into a   <code>CommittedChangeList</code></li> </ul> <p>NOTE The Unversioned Files, Locally Deleted Files, etc., nodes in the Changes view are not actually change lists, and files under those nodes are not represented by <code>ChangeList</code> objects.</p>"},{"location":"reference_guide/vcs_integration_for_plugins/#plugin-components","title":"Plugin Components","text":"<p>This section describes the different components which comprise a VCS integration plugin, roughly in the same order as they should be implemented.</p>"},{"location":"reference_guide/vcs_integration_for_plugins/#abstractvcs","title":"AbstractVcs","text":"<p>This is the main entry point for a VCS plugin, which is used by the Consulo to retrieve all other services provided by the plugin. The recommended way to register an AbstractVcs implementation is to add an extension declaration to plugin.xml, as shown in the following example:</p> <pre><code>&lt;idea-plugin&gt;\n  ...\n  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;vcs name=\"svn\" vcsClass=\"org.jetbrains.idea.svn.SvnVcs\"/&gt;\n  &lt;/extensions&gt;\n&lt;/idea-plugin&gt;\n</code></pre> <p>Here <code>name</code> is the unique name of the VCS (this must match the string returned by your implementation of <code>AbstractVcs.getName()</code>), and vcsClass is your implementation class.</p>"},{"location":"reference_guide/vcs_integration_for_plugins/#changeprovider","title":"ChangeProvider","text":"<p>This component is responsible for tracking user changes to the working copy, and reporting these changes to the Consulo core. An implementation of this class is returned from <code>AbstractVcs.getChangeProvider()</code>.</p> <p>The ChangeProvider works in tandem with <code>VcsDirtyScopeManager</code>, which is a component in Consulo core. <code>VcsDirtyScopeManager</code> keeps track of the 'dirty scope' - the set of files for which the VCS file status may be out of date. Files are added to the dirty scope either when they are modified on disk, or when their VCS status is invalidated by an explicit call to <code>VcsDirtyScopeManager.fileDirty()</code> or <code>VcsDirtyScopeManager.dirDirtyRecursively()</code>.</p> <p>After some files have been added to the dirty scope, the dirty scope is passed to <code>ChangeProvider.getChanges()</code>, along with a <code>ChangelistBuilder</code> instance, which serves as a sink to which the <code>ChangeProvider</code> feeds the data about the changed files. This processing happens asynchronously in a background thread.</p> <p>The <code>ChangeProvider</code> can either iterate all files under the dirty scope using <code>VcsDirtyScope.iterate()</code>, or retrieve information about its contents using the <code>getDirtyFiles()</code> and <code>getDirtyDirectoriesRecursively()</code> methods. If it is possible to retrieve the information about the local changes from the VCS in batch, it's strongly preferable to use the second method, as it scales much better for large working copies.</p> <p>The <code>ChangeProvider</code> reports data to ChangelistBuilder using the following methods:</p> <ul> <li><code>processChange()</code> is called for files which have been checked out (or modified if the VCS doesn't use an explicit checkout model), scheduled for addition or deletion, moved or renamed.</li> <li><code>processUnversionedFile()</code> is called for files which exist on disk, but are not managed by the VCS, not scheduled for addition, and not ignored through .cvsignore or a similar mechanism.</li> <li><code>processLocallyDeletedFile()</code> is called for files which exist in the VCS repository, but do not exist on disk and are not scheduled for deletion.</li> <li><code>processIgnoredFile()</code> is called for files which are not managed by the VCS but are ignored through .cvsignore or a similar mechanism.</li> <li><code>processSwitchedFile()</code> is called for files or directories for which the working copy corresponds to a different branch compared to the working copy of their parent directory.   This can be called for the same files for which processSwitchedFile() has already been called.</li> </ul>"},{"location":"reference_guide/work_with_icons_and_images/","title":"Working with Icons and Images","text":"<p>Icons and images are used widely by Consulo plugins. Plugins need icons mostly for actions, custom components renderers, tool windows, and so on.</p> <p>NOTE Plugin Icons, which represent a plugin itself, have different requirements than icons and images used within a plugin. For more information see the Plugin Icon page.</p> <p>TIP Plugins should reuse existing platform icons whenever possible, see Icons list and <code>AllIcons</code>. A detailed design guideline is available for creating custom icons.</p>"},{"location":"reference_guide/work_with_icons_and_images/#how-to-organize-and-how-to-use-icons","title":"How to organize and how to use icons?","text":"<p>The best way to deal with icons and other image resources is to put them to a dedicated source root marked as Resources Root, say <code>icons</code> or <code>resources</code>.</p> <p>The <code>getIcon()</code> method of <code>IconLoader</code> can be used to access the icons.</p> <p>NOTE The path to the icon passed in as argument to <code>IconLoader.getIcon()</code> must start with leading <code>/</code></p> <p>Then define a class/interface in a top-level package called <code>icons</code> holding icon constants as static fields:</p> <pre><code>package icons;\n\npublic interface DemoPluginIcons {\n  Icon DemoAction = IconLoader.getIcon(\"/icons/demoAction.png\", DemoPluginIcons.class);\n  Icon StructureToolWindow = IconLoader.getIcon(\"/icons/toolWindowStructure.png\", DemoPluginIcons.class);\n  Icon FileType = IconLoader.getIcon(\"/icons/myLangFileType.png\", DemoPluginIcons.class);\n}\n</code></pre> <p>When using Kotlin, fields must be annotated with <code>@JvmField</code>:</p> <pre><code>package icons\n\nobject DemoPluginIcons {\n\n  @JvmField\n  val DemoAction = IconLoader.getIcon(\"/icons/demoAction.png\", javaClass)\n\n  // ...\n}\n</code></pre> <p>Use these constants inside <code>plugin.xml</code> as well when specifying <code>icon</code> attribute for <code>&lt;action&gt;</code> or extension points. Note that the package name <code>icons</code> will be automatically prefixed and must not be added manually.</p> <pre><code>&lt;actions&gt;\n    &lt;action id=\"DemoPlugin.DemoAction\"\n            icon=\"DemoPluginIcons.DemoAction\" [...] /&gt;\n&lt;/actions&gt;\n\n&lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;toolWindow id=\"CustomStructure\"\n                icon=\"DemoPluginIcons.StructureToolWindow\" [...] /&gt;\n&lt;/extensions&gt;\n</code></pre>"},{"location":"reference_guide/work_with_icons_and_images/#image-formats","title":"Image Formats","text":"<p>Consulo supports Retina displays and has dark theme called Darcula. Thus, every icon should have a dedicated variant for Retina devices and Darcula theme. In some cases, you can skip dark variants if the original icon looks good under Darcula.</p> <p>Required icon sizes depend on the usage as listed in the following table:</p> Usage Icon Size (pixels) Node, Action, Filetype 16x16 Tool window 13x13 Editor gutter 12x12"},{"location":"reference_guide/work_with_icons_and_images/#svg-format","title":"SVG Format","text":"<p>NOTE SVG icons are supported since 2018.2.</p> <p>As SVG icons can be scaled arbitrarily, they provide better results on HiDPI environments or when used in combination with bigger screen fonts (e.g., in presentation mode).</p> <p>A base size denoting the size (in the user space) of the rendered image in 1x scale should be provided. The size is set via the <code>width</code> and <code>height</code> attributes omitting the size units. If unspecified, it defaults to 16x16 pixels.</p> <p>A minimal SVG icon file:</p> <pre><code>&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\"&gt;\n &lt;rect width=\"100%\" height=\"100%\" fill=\"green\"/&gt;\n&lt;/svg&gt;\n</code></pre> <p>The naming notation used for PNG icons (see below) is still relevant. However, the <code>@2x</code> version of an SVG icon should still provide the same base size. The icon graphics of such an icon can be expressed in more details via double precision. If the icon graphics are simple enough so that it renders perfectly in every scale, then the <code>@2x</code> version can be omitted.</p>"},{"location":"reference_guide/work_with_icons_and_images/#png-format","title":"PNG Format","text":"<p>NOTE Please consider using SVG icons if your plugin targets 2018.2+.</p> <p>All icon files must be placed in the same directory following this naming pattern (replace <code>.png</code> with <code>.svg</code> for SVG icons):</p> <ul> <li>iconName.png W x H pixels (Will be used on non-Retina devices with default theme)</li> <li>iconName@2x.png 2*W x 2*H pixels (Will be used on Retina devices with default theme)</li> <li>iconName_dark.png W x H pixels (Will be used on non-Retina devices with Darcula theme)</li> <li>iconName@2x_dark.png 2*W x 2*H pixels (Will be used on Retina devices with Darcula theme)</li> </ul> <p>The <code>IconLoader</code> class will load the icon that matches the best depending on the current environment.</p> <p>Here are examples of toolWindowStructure.png icon representations:</p> Theme/Resolution File name Image Default <code>toolWindowStructure.png</code> Darcula <code>toolWindowStructure_dark.png</code> Default + Retina <code>toolWindowStructure@2x.png</code> Darcula + Retina <code>toolWindowStructure@2x_dark.png</code>"},{"location":"reference_guide/custom_language_support/additional_minor_features/","title":"Additional Minor Features","text":"<p>A number of minor features are listed in the following format:</p> <p>EP: <code>fully.qualified.extensionPointName</code> - Extension Point Name (must be specified in <code>plugin.xml</code>)</p> <p><code>com.extensionPoint.class</code> description text - Extension Point class/interface to provide functionality</p> <p>- Sample 1 - Sample implementation</p>"},{"location":"reference_guide/custom_language_support/additional_minor_features/#brace-matching","title":"Brace Matching","text":"<p>EP: <code>com.intellij.lang.braceMatcher</code></p> <p><code>PairedBraceMatcher</code> Returns an array of brace pairs (<code>BracePair</code>) specifying the characters for the opening and closing braces and the lexer token types for these characters. (In principle, it is possible to return multi-character tokens, like \"begin\" and \"end\", as the start and end tokens of a brace pair. The IDE will match such braces, but the highlighting for such braces will not be entirely correct.)</p> <p>Certain types of braces can be marked as structural. Structural braces have higher priority than regular braces: they are matched with each other even if there are unmatched braces of different types between them. An opening non-structural brace is not matched with a closing one if one of them is inside a pair of matched structural braces and another is outside.</p>"},{"location":"reference_guide/custom_language_support/additional_minor_features/#comment-code","title":"Comment Code","text":"<p>EP: <code>com.intellij.lang.commenter</code></p> <p><code>Commenter</code> returns the prefix for the line comment, and the prefix and suffix for the block comment if supported by the language.</p> <ul> <li><code>Commenter</code> for Properties language plugin</li> <li>Custom Language Support Tutorial: Commenter</li> </ul>"},{"location":"reference_guide/custom_language_support/additional_minor_features/#code-folding","title":"Code Folding","text":"<p>EP: <code>com.intellij.lang.foldingBuilder</code></p> <p><code>FoldingBuilder</code> returns the list of foldable text ranges (as an array of <code>FoldingDescriptor</code> objects), the replacement text which is shown for each range when it is folded, and the default state of each folding region (folded or unfolded).</p> <ul> <li>Custom Language Support Tutorial: Folding Builder</li> </ul>"},{"location":"reference_guide/custom_language_support/additional_minor_features/#join-lines","title":"Join Lines","text":"<p>EP: <code>com.intellij.joinLinesHandler</code></p> <p><code>JoinLinesHandlerDelegate</code> allows extending support smart/semantic Edit | Join Lines (e.g., String literal split on multiple lines).</p>"},{"location":"reference_guide/custom_language_support/additional_minor_features/#smart-enter","title":"Smart Enter","text":"<p>EP: <code>com.intellij.lang.smartEnterProcessor</code></p> <p><code>SmartEnterProcessor</code> handles Edit | Complete Statement (e.g., autocomplete missing semicolon/parentheses).</p>"},{"location":"reference_guide/custom_language_support/additional_minor_features/#naming-suggestions","title":"Naming Suggestions","text":"<p>EP: <code>com.intellij.nameSuggestionProvider</code></p> <p><code>NameSuggestionProvider</code> provides name suggestions for the given element, e.g., for Rename refactoring.</p>"},{"location":"reference_guide/custom_language_support/additional_minor_features/#semantic-highlight-usages","title":"Semantic Highlight Usages","text":"<p>EP: <code>com.intellij.highlightUsagesHandlerFactory</code></p> <p><code>HighlightUsagesHandlerFactory</code> allows highlighting e.g., Exit Points or Exceptions.</p>"},{"location":"reference_guide/custom_language_support/additional_minor_features/#parameter-info","title":"Parameter Info","text":"<p>EP: <code>com.intellij.codeInsight.parameterInfo</code></p> <p><code>ParameterInfoHandler</code> provides support for View | Parameter Info.</p>"},{"location":"reference_guide/custom_language_support/additional_minor_features/#to-do-view","title":"To Do View","text":"<p>EP: n/a</p> <p><code>ParserDefinition.getCommentTokens()</code> must return the set of tokens treated as comments to populate To Do View.</p>"},{"location":"reference_guide/custom_language_support/additional_minor_features/#context-info","title":"Context Info","text":"<p>EP: <code>com.intellij.declarationRangeHandler</code></p> <p><code>DeclarationRangeHandler</code> provides View | Context Info for custom languages with structure view implementation based on a <code>TreeBasedStructureViewBuilder</code>.</p>"},{"location":"reference_guide/custom_language_support/additional_minor_features/#spellchecking","title":"Spellchecking","text":"<p>EP: <code>com.intellij.spellchecker.support</code></p> <p><code>SpellcheckingStrategy</code> provides <code>Tokenizer</code> to use for given <code>PsiElement</code> (return <code>EMPTY_TOKENIZER</code> for no spellchecking).</p>"},{"location":"reference_guide/custom_language_support/additional_minor_features/#reference-injection","title":"Reference Injection","text":"<p>EP: <code>com.intellij.referenceInjector</code></p> <p><code>ReferenceInjector</code> allows users to inject pre-defined references (e.g., \"Encoding\", \"File Reference\") into <code>PsiLanguageInjectionHost</code> elements (IntelliLang plugin required).</p>"},{"location":"reference_guide/custom_language_support/additional_minor_features/#color-previewchooser","title":"Color Preview/Chooser","text":"<p>EP: <code>com.intellij.colorProvider</code></p> <p><code>ElementColorProvider</code> renders gutter icon for element containing color information.</p>"},{"location":"reference_guide/custom_language_support/code_completion/","title":"Code Completion","text":"<p>Two main types of code completion can be provided by custom language plugins: reference completion and contributor-based completion.</p> <p>Reference completion is easier to implement, but supports only the basic completion action. Contributor-based completion provides more features, supports all three completion types (basic, smart, and class name), and can be used, for example, to implement keyword completion.</p>"},{"location":"reference_guide/custom_language_support/code_completion/#reference-completion","title":"Reference Completion","text":"<p>To fill the completion list, the IDE calls <code>PsiReference.getVariants()</code> either on the reference at the caret location or on a dummy reference that would be placed at the caret. This method needs to return an array of objects containing either strings, <code>PsiElement</code> instances or instances of the <code>LookupElement</code> class (see Lookup Items below). If a <code>PsiElement</code> instance is returned in the array, the completion list shows the icon for the element.</p> <p>The most common way to implement <code>getVariants()</code> is to use the same function for walking up the tree as in <code>PsiReference.resolve()</code>, and a different implementation of <code>PsiScopeProcessor</code> which collects all declarations passed to its <code>processDeclarations()</code> method and returns them as an array for filling the completion list.</p>"},{"location":"reference_guide/custom_language_support/code_completion/#symbol-reference-completion","title":"Symbol Reference Completion","text":"<p>WARNING This API is available starting from 2020.3 and currently in development and thus in experimental state.</p> <p>To provide completion variants by a <code>PsiSymbolReference</code> implement <code>PsiCompletableReference</code>.</p>"},{"location":"reference_guide/custom_language_support/code_completion/#contributor-based-completion","title":"Contributor-Based Completion","text":"<p>Implementing the <code>CompletionContributor</code> interface gives you the greatest control over the operation of code completion for your language.</p> <p>NOTE Note that the JavaDoc of that class contains a detailed FAQ for implementing code completion.</p> <p>The core scenario of using <code>CompletionContributor</code> consists of calling the <code>extend()</code> method and passing in the pattern specifying the context in which this completion variant is applicable, as well as a completion provider which generates the items to show in the completion list.</p> <p>Keep in mind that the pattern is checked against the leaf PSI element. If you want to match a composite element, use <code>withParent()</code> or <code>withSuperParent()</code> methods.</p> <p>Examples: - <code>CompletionContributor</code> for completing keywords in MANIFEST.MF files. - Custom Language Support Tutorial: Completion Contributor</p>"},{"location":"reference_guide/custom_language_support/code_completion/#lookup-items","title":"Lookup Items","text":"<p>Items shown in the completion list are represented by instances of the <code>LookupElement</code> interface. These instances are typically created through the <code>LookupElementBuilder</code> class.</p> <p>For every lookup element, you can specify the following attributes:</p> <ul> <li>Text. Shown left-aligned.</li> <li>Tail text. Shown next to the main item text, is not used for prefix matching, and can be used, for example, to show the parameter list of the method.</li> <li>Type text. Shown right-aligned in the lookup list and can be used to show the return type or containing class of a method, for example.</li> <li>Icon</li> <li>Text attributes. Bold, Strikeout, etc.</li> <li>Insert handler. The insert handler is a callback which is called when the item is selected and can be used to perform additional modifications of the text (for example, to put in the parentheses for a method call)</li> </ul>"},{"location":"reference_guide/custom_language_support/code_formatting/","title":"Code Formatter","text":"<p>The Consulo includes a powerful framework for implementing custom language formatters. In this framework, the plugin specifies the constraints on the spacing between different syntax elements. The formatting engine, provided by the IDE, calculates the smallest number of whitespace modifications that need to be performed on the file to make it match the constraints.</p> <p>The process of formatting a file or a file fragment consists of the following main steps:</p> <ul> <li> <p>The formatting model builder (    <code>FormattingModelBuilder</code>    ), implemented by the plugin, provides a formatting model (    <code>FormattingModel</code>    ) for the document to be formatted</p> </li> <li> <p>The formatting model is requested to build the structure of the file as applies to formatting, as a tree of blocks (    <code>Block</code>    ) with an associated indent, wrap, alignment, and spacing settings.</p> </li> <li> <p>The formatting engine calculates the sequence of whitespace characters (spaces, tabs, and/or line breaks) that needs to be placed at every block boundary, based on the plugin's formatting model.</p> </li> <li> <p>The formatting model is requested to insert the calculated whitespace characters at necessary positions in the file.</p> </li> </ul> <p>The structure of blocks is usually built so that it mirrors the PSI structure of the file - for example, in Java code, the top-level formatting block covers the entire file. Its children cover individual classes in the file, blocks on the next level cover methods inside classes, etc. The formatter modifies only the characters between blocks, and the tree of blocks must be built so that the bottom-level blocks cover all non-whitespace characters in the file. Otherwise, the characters between blocks may be deleted by the formatter.</p> <p>If the formatting operation does not affect the entire file (for example, if the formatter is called to format the pasted block of text), a complete tree of blocks is not built. Rather, only blocks for the text range covered by the formatting operation and their parents are built.</p> <p>For every block, the plugin specifies the following properties:</p> <ul> <li> <p>The spacing (<code>Spacing</code>) specifies what spaces or line breaks are inserted between the specified children of the block.    The spacing object specifies the minimum and maximum number of spaces that must be placed between the specified child blocks, the minimum number of line breaks to put there, and whether the existing line breaks and blank lines should be preserved.    The formatting model can also specify that the spacing between the specified blocks may not be modified by the formatter.</p> </li> <li> <p>The indent specifies how the block is indented relative to its parent block.    There are different modes of indenting defined by factory methods in the Indent class.    The most commonly used are the none indent (which means the child block is not indented), the regular indent (the child block is indented by the number of spaces specified in the Project Code Style | General | Indent setting), and the continuation indent (based on Project Code Style | General | Continuation Indent setting).    If the formatting model does not specify an indent, the \"continuation without first\" mode is used.     This default means that the first block in a sequence of blocks with that type is not indented, and the following blocks are indented with a continuation indent.</p> </li> <li> <p>The wrap (<code>Wrap</code>) specifies whether the content of the block is wrapped to the next line.    Wrapping is performed by inserting a line break before the block content.    The plugin can specify that a particular block is never wrapped, always wrapped, or wrapped only if it exceeds the right margin.</p> </li> <li> <p>The alignment (<code>Alignment</code>) specifies which blocks should be aligned with each other.    If two blocks with the alignment property set to the same object instance are placed in different lines, and if the second block is the first non-whitespace block in its line, the formatter inserts white spaces before the second block, so that it starts from the same column as the first one.</p> </li> </ul> <p>For each of these properties, several particular use settings exist, described in the JavaDoc comments for the respective classes. See also <code>SpacingBuilder</code>, which aids in building rule-based configuration.</p> <p>An important special case in using the formatter is the smart indent performed when the user presses the <code>Enter</code> key in a source code file. To determine the indent for the new line, the formatter engine calls the method <code>getChildAttributes()</code> on either the block immediately before the caret or the parent of that block, depending on the return value of the <code>isIncomplete()</code> method for the block before the caret. If the block before the cursor is incomplete (contains elements that the user will probably type but has not yet typed, like a closing parenthesis of the parameter list or the trailing semicolon of a statement), <code>getChildAttributes()</code> is called on the block before the caret; otherwise, it's called on the parent block.</p> <p>New in IntelliJ IDEA 13: Code formatting can be suppressed per region via special comments.</p> <p>Example: Custom Language Support Tutorial: Formatter</p>"},{"location":"reference_guide/custom_language_support/code_formatting/#code-style-settings","title":"Code Style Settings","text":"<p>To specify the default indent size for the language provided by your plugin, and to allow the user to configure the tab size and indent size, you need to implement the <code>FileTypeIndentOptionsProvider</code> interface and to register the implementation in the <code>com.intellij.fileTypeIndentOptionsProvider</code> extension point. The return value of <code>createIndentOptions()</code> determines the default indent size.</p> <p>Example: Custom Language Support Tutorial: Code Style Settings</p>"},{"location":"reference_guide/custom_language_support/code_formatting/#rearranger","title":"Rearranger","text":"<p>New in IntelliJ IDEA 12: Allows custom languages to provide user-configurable arrangement/grouping rules for element types supported by language plugin. Rules can be refined via modifiers and name, ordering can be applied additionally. Please see <code>Rearranger</code> and related for JavaDoc.</p>"},{"location":"reference_guide/custom_language_support/code_inspections_and_intentions/","title":"Code Inspections and Intentions","text":""},{"location":"reference_guide/custom_language_support/code_inspections_and_intentions/#inspections","title":"Inspections","text":"<p>The code inspections for custom languages use the same API as all other code inspections, based on the <code>LocalInspectionTool</code> class.</p> <p>The functionality of <code>LocalInspectionTool</code> partially duplicates that of Annotator.</p> <p>The main differences are: - supports batch analysis of code (through the Analyze | Inspect Code... action) - the possibility to turn off the inspection (globally or by suppressing them on various levels) - ability to configure the inspection options.</p> <p>If none of that is required and the analysis only needs to run in the active editor, Annotator provides better performance (because it supports incremental analysis) and more flexibility for highlighting errors.</p> <p>Examples: - Code Inspections Tutorial - A simple inspection for Properties language plugin</p>"},{"location":"reference_guide/custom_language_support/code_inspections_and_intentions/#intentions","title":"Intentions","text":"<p>The code intentions for custom languages also use the standard API for intentions. The intention classes need to implement the <code>IntentionAction</code> interface and are registered using the <code>com.intellij.intentionAction</code> extension point.</p> <p>Examples: - Code Intentions Tutorial - A simple intention action for Groovy - Custom Language Support Tutorial: Quick Fix</p>"},{"location":"reference_guide/custom_language_support/declarations_and_references/","title":"Declarations and References","text":"<p>WARNING This API is available starting from 2020.3 and currently in development and thus in experimental state.</p>"},{"location":"reference_guide/custom_language_support/declarations_and_references/#declarations","title":"Declarations","text":"<p>Each symbol may be declared in zero or more places, for example: - a C# partial class is a symbol with several declarations; - a property key is a symbol possibly declared in several files simultaneously; - a Java local variable is a symbol with a single declaration; - and a file is a symbol without declarations; it has only references.</p> <p>Declarations are implementations of <code>SymbolDeclaration</code>.  Declarations in PSI elements are implementations of <code>PsiSymbolDeclaration</code>.</p> <p>To report a declaration in a PSI element, either: - implement and register    <code>PsiSymbolDeclarationProvider</code>; - or implement <code>PsiSymbolDeclaration</code> directly in the <code>PsiElement</code>.</p>"},{"location":"reference_guide/custom_language_support/declarations_and_references/#references","title":"References","text":"<p>References are implementations of  <code>SymbolReference</code> interface.  References from PSI elements are implementations of  <code>PsiSymbolReference</code> interface.</p> <p>The main method of <code>SymbolReference</code> is <code>resolveReference()</code>, which returns the collection of symbols to which the reference points,  plus additional data. If it is not possible to resolve the reference, for example, if it points to an undefined class, an empty collection gets returned. A counterpart to the <code>resolveReference()</code> method is <code>SymbolReference.resolvesTo()</code>,  which checks if the reference resolves to the specified symbol.  This method can be implemented to walk the tree only if the element's text is equal to the reference's text.</p> <p>For convenience, if the reference can possibly be resolved: - with a single result, then it might be extended from  <code>SingleResultReference</code>; - to a single symbol without additional data, then it might be extended from  <code>SingleTargetReference</code>; - to multiple symbols without additional data, then  <code>SymbolResolveResult.fromSymbol()</code> might be used.</p>"},{"location":"reference_guide/custom_language_support/declarations_and_references/#own-references","title":"Own References","text":"<p>Own references are the references found in PSI elements, which are considered as references by the language.</p> <p>Example: PSI element representing <code>x</code> in <code>x * 2</code> Java expression has an Own reference to a local Java variable, e.g., <code>var x = 42</code>, because this is a reference from Java language point of view, and Java language support uses it, e.g., for code analysis.</p> <p>To provide Own references by the <code>PsiElement</code>, implement  <code>PsiElement.getOwnReferences()</code> in the <code>PsiElement</code>. If the element contains a single reference, <code>Collections.singletonList()</code> can be used</p>"},{"location":"reference_guide/custom_language_support/declarations_and_references/#external-references","title":"External References","text":"<p>External references are the references which are not considered as references by the host language.  The language support should not rely on their existence/absence, because they might be contributed by other plugins.</p> <p>Example: PSI element representing <code>\"users.txt\"</code> in <code>new File(\"users.txt\")</code> Java expression is a string literal from Java language point of view, but there is a plugin which knows that this literal references a file name, and provides such reference.</p> <p>External references might be contributed to PSI elements that implement <code>PsiExternalReferenceHost</code>.  To allow other plugins to contribute references of <code>PsiElement</code>, implement <code>PsiExternalReferenceHost</code> in the <code>PsiElement</code>.  To contribute an External reference to the existing <code>PsiExternalReferenceHost</code>, implement and register  <code>PsiSymbolReferenceProvider</code>.</p>"},{"location":"reference_guide/custom_language_support/declarations_and_references/#implicit-references","title":"Implicit References","text":"<p>Implicit references are the references which should be part of the mechanism to obtain a target by a reference,  without the inverse ability to search or rename such references by a target.</p> <p>Example: <code>var</code> keyword in <code>var x = new Person()</code> Java declaration has an Implicit reference, because it doesn't make sense to obtain the reference by the target class. At the same time it's possible: - to navigate to the class by ctrl-clicking <code>var</code>; - to start a refactoring (e.g., rename) from the class targeted by this reference; - to view documentation of the class targeted by this reference.</p> <p>To provide an Implicit reference, implement and register  <code>ImplicitReferenceProvider</code>.</p>"},{"location":"reference_guide/custom_language_support/documentation/","title":"Documentation","text":"<p>To provide different kinds of documentation support, the plugin needs to provide an implementation of the <code>DocumentationProvider</code> interface and register it in the <code>com.intellij.lang.documentationProvider</code> extension point. A standard base class for such implementations is available in <code>AbstractDocumentationProvider</code>.</p> <p>The <code>getQuickNavigateInfo()</code> method returns the text to be displayed when the user holds the mouse over an element with Ctrl pressed.</p> <p>When generating complete documentation via <code>generateDoc()</code>, use <code>DocumentationMarkup</code> to layout contents (see JavaDoc for details).</p> <p>Additional custom actions can be added to documentation inlays and documentation popup via <code>com.intellij.codeInsight.documentation.DocumentationActionProvider</code> registered in <code>com.intellij.documentationActionProvider</code> extension point. (2020.3)</p> <p>Example: <code>DocumentationProvider</code> for Properties language plugin</p>"},{"location":"reference_guide/custom_language_support/find_usages/","title":"Find Usages","text":"<p>The Find Usages action is a multi-step process, and each step of the process requires involvement from the custom language plugin.</p> <p>The language plugin participates in the Find Usages process by registering an implementation of <code>FindUsagesProvider</code> in the <code>com.intellij.lang.findUsagesProvider</code> extension point, and through the PSI implementation using <code>PsiNamedElement</code> and <code>PsiReference</code> interfaces.</p> <p>Examples: - Implementation of <code>FindUsagesProvider</code> in Properties language plugin - Custom Language Support Tutorial: Find Usages</p> <p>The steps of the Find Usages action are the following: * Before the Find Usages action can be invoked, the IDE builds an index of words present in every file in the custom language.   Using the <code>WordsScanner</code> implementation returned from <code>FindUsagesProvider.getWordsScanner()</code>, the contents of every file are loaded and passes it to the words scanner, along with the words consumer.   The words scanner breaks the text into words, defines the context for each word (code, comments, or literals), and passes the word to the consumer.   The simplest way to implement the words scanner is to use the <code>DefaultWordsScanner</code> implementation, passing to it the sets of lexer token types which are treated as identifiers, literals, and comments.   The default words scanner will use the lexer to break the text into tokens and handle breaking the text of the comment and literal tokens into individual words. * When the user invokes the Find Usages action, the IDE locates the PSI element the references to be searched.   The PSI element at the cursor (the direct tree parent of the token at the cursor position) must be either a <code>PsiNamedElement</code> or a <code>PsiReference</code> which resolves to a <code>PsiNamedElement</code>.   The word cache will be used to search for the text returned from the <code>PsiNamedElement.getName()</code> method.   Also, if the text range of the <code>PsiNamedElement</code> includes some other text besides the identifier returned from <code>getName()</code> (for example, if the <code>PsiNamedElement</code> represents a JavaScript function and its text range includes the \"<code>function</code>\" keyword in addition to the name of the function), the method <code>getTextOffset()</code> must be overridden for the <code>PsiNamedElement</code>, and must return the start offset of the name identifier within the text range of the element. * Once the element is located, the IDE calls <code>FindUsagesProvider.canFindUsagesFor()</code> to ask the plugin if the Find Usages action applies to the specific element. * When showing the Find Usages dialog to the user, <code>FindUsagesProvider.getType()</code> and <code>FindUsagesProvider.getDescriptiveName()</code> are called to determine how the element should be presented to the user. * For every file containing the searched words, the IDE builds the PSI tree and recursively descends it.   The text of each element is broken into words and then scanned.   If the element was indexed as an identifier, every word is checked to be a <code>PsiReference</code> resolving to the element the usages of which are searched.   If the element was indexed as a comment or literal and the search in comments or literals is enabled, it checks if the word is equal to the searched element's name. * After the usages are collected, results are shown in the usages pane.   The text shown for each found element is taken from the <code>FindUsagesProvider.getNodeText()</code> method.</p> <p>To have the title of the found element be correctly displayed in the title of the Find Usages tool window, you need to provide an implementation of the <code>ElementDescriptionProvider</code> interface. The <code>ElementDescriptionLocation</code> passed to the provider in this case will be an instance of <code>UsageViewLongNameLocation</code>.</p> <p>Example: <code>ElementDescriptionProvider</code> for Properties language plugin</p> <p>TIP In cases like function parameters and local variables, consider overriding  <code>PsiElement.getUseScope()</code> to return a narrower scope. For instance, you might return just the scope of the nearest function definition. This optimization can significantly reduce the number of files that need to be parsed--and references that need to be resolved--when renaming a function parameter or local variable.</p>"},{"location":"reference_guide/custom_language_support/go_to_class_and_go_to_symbol/","title":"Go to Class and Go to Symbol","text":"<p>A custom language plugin can provide its own items to be included in the lists shown when the user chooses the Navigate | Class or Navigate | Symbol action. In order to do so, the plugin must provide implementations for the <code>ChooseByNameContributor</code> interface (separate implementations need to be provided for Class and Symbol respectively), and register them in the <code>com.intellij.gotoClassContributor</code> and <code>com.intellij.gotoSymbolContributor</code> extension points.</p> <p>TIP Please consider implementing <code>ChooseByNameContributorEx</code> for better performance.</p> <p>Each contributor needs to be able to return a complete list of names to show in the list for a specified project, which will then be filtered by the IDE according to the text typed by the user in the dialog. Using File-based or Stub indices to obtain matching candidates is highly recommended to improve performance.</p> <p>For each name in that list, the contributor needs to provide a list of <code>NavigationItem</code> instances (typically <code>PsiElement</code>), which specify the destinations to jump to when a specific name is selected from the list.</p> <p>Example: - Custom Language Support Tutorial: Go To Symbol Contributor</p>"},{"location":"reference_guide/custom_language_support/implementing_lexer/","title":"Implementing Lexer","text":"<p>The lexer, or lexical analyzer, defines how a file's contents are broken into tokens. The lexer serves as a foundation for nearly all of the features of custom language plugins, from basic syntax highlighting to advanced code analysis features. The API for the lexer is defined by the <code>Lexer</code> interface.</p> <p>The IDE invokes the lexer in three main contexts, and the plugin can provide different lexer implementations for these contexts:</p> <ul> <li> <p>Syntax highlighting: The lexer is returned from the implementation of the    <code>SyntaxHighlighterFactory</code>    interface which is registered in the <code>com.intellij.lang.syntaxHighlighterFactory</code> extension point.</p> </li> <li> <p>Building the syntax tree of a file: the lexer is expected to be returned from    <code>ParserDefinition.createLexer()</code>,    and the    <code>ParserDefinition</code>    interface is registered in the <code>com.intellij.lang.parserDefinition</code> extension point.</p> </li> <li> <p>Building the index of the words contained in the file:    if the lexer-based words scanner implementation is used, the lexer is passed to the    <code>DefaultWordsScanner</code>    constructor.</p> </li> </ul> <p>The lexer used for syntax highlighting can be invoked incrementally to process only the file's changed part. In contrast, lexers used in other contexts are always called to process an entire file or a complete language construction embedded in a different language file.</p> <p>A lexer that can be used incrementally may need to return its state, which means the context corresponding to each position in a file. For example, a Java lexer could have separate states for top-level context, comment context, and string literal context. An essential requirement for a syntax highlighting lexer is that its state must be represented by a single integer number returned from <code>Lexer.getState()</code>. That state will be passed to the <code>Lexer.start()</code> method, along with the start offset of the fragment to process, when lexing is resumed from the middle of a file. Lexers used in other contexts can always return <code>0</code> from the <code>getState()</code> method.</p> <p>The easiest way to create a lexer for a custom language plugin is to use JFlex. Classes <code>FlexLexer</code> and <code>FlexAdapter</code> adapt JFlex lexers to the Consulo Lexer API. We have a patched version of JFlex that can be used with the lexer skeleton file located at tools/lexer/idea-flex.skeleton in the IntelliJ IDEA Community Edition source to create lexers compatible with <code>FlexAdapter</code>. The patched version of JFlex provides a new command-line option <code>--charat</code> that changes the JFlex generated code to work with the Consulo skeleton. Enabling <code>--charat</code> option passes the source data for lexing as a <code>CharSequence</code> and not as an array of characters.</p> <p>For developing lexers using JFlex, the GrammarKit plugin can be useful. It provides syntax highlighting and other useful features for editing JFlex files.</p> <p>NOTE Lexers, and in particular JFlex-based lexers, need to be created so that they always match the entire contents of the file, without any gaps between tokens, and generate special tokens for characters which are not valid at their location. Lexers must never abort prematurely because of an invalid character.</p> <p>Example: - <code>Lexer</code> definition for Properties language plugin - Custom Language Support Tutorial: Lexer</p> <p>Types of tokens for lexers are defined by instances of <code>IElementType</code>. Many token types common for all languages are defined in the <code>TokenType</code> interface. Custom language plugins should reuse these token types wherever applicable. For all other token types, the plugin needs to create new <code>IElementType</code> instances and associate with the language in which the token type is used. The same <code>IElementType</code> instance should be returned every time a particular token type is encountered by the lexer.</p> <p>Example: Token types for Properties language plugin</p> <p>An important feature that can be implemented at the lexer level is mixing languages within a file, such as embedding fragments of Java code in some template language. Suppose a language supports embedding its fragments in another language. In that case, it needs to define the chameleon token types for different types of fragments that can be embedded, and these token types need to implement the <code>ILazyParseableElementType</code> interface. The enclosing language's lexer needs to return the entire fragment of the embedded language as a single chameleon token, of the type defined by the embedded language. To parse the contents of the chameleon token, the IDE will call the parser of the embedded language through a call to <code>ILazyParseableElementType.parseContents()</code>.</p>"},{"location":"reference_guide/custom_language_support/implementing_parser_and_psi/","title":"Implementing a Parser and PSI","text":"<p>Parsing files in Consulo is a two-step process. First, an abstract syntax tree (AST) is built, defining the structure of the program. AST nodes are created internally by the IDE and are represented by instances of the <code>ASTNode</code> class. Each AST node has an associated element type <code>IElementType</code> instance, and the element types are defined by the language plugin. The AST tree's top-level node for a file needs to have a special element type, which extends the <code>IFileElementType</code> class.</p> <p>The AST nodes have a direct mapping to text ranges in the underlying document. The bottom-most nodes of the AST match individual tokens returned by the lexer, and higher-level nodes match multiple-token fragments. Operations performed on nodes of the AST tree, such as inserting, removing, reordering nodes, and so on, are immediately reflected as changes to the underlying document's text.</p> <p>Second, a PSI, or Program Structure Interface, tree is built on top of the AST, adding semantics and methods for manipulating specific language constructs. Nodes of the PSI tree are represented by classes implementing the <code>PsiElement</code> interface and are created by the language plugin in the <code>ParserDefinition.createElement()</code> method. The top-level node of the PSI tree for a file needs to implement the <code>PsiFile</code> interface and is created in the <code>ParserDefinition.createFile()</code> method.</p> <p>Example: <code>ParserDefinition</code> for Properties language plugin</p> <p>The PSI's lifecycle is described in more detail in Fundamentals.</p> <p>The base classes for the PSI implementation, including <code>PsiFileBase</code>, the base implementation of <code>PsiFile</code>, and <code>ASTWrapperPsiElement</code>, the base implementation of <code>PsiElement</code>, are provided by Consulo.</p> <p>While coding parser manually is quite possible, we highly recommend generating parser and corresponding PSI classes from grammars using Grammar-Kit plugin. Besides code generation, it provides various features for editing grammar files: syntax highlighting, quick navigation, refactorings, etc. The Grammar-Kit plugin is built using its own engine; its source code can be found on GitHub.</p> <p>For re-using existing ANTLRv4 grammars, see antlr4-intellij-adaptor library.</p> <p>The language plugin provides the parser implementation as an implementation of the <code>PsiParser</code> interface, returned from <code>ParserDefinition.createParser()</code>. The parser receives an instance of the <code>PsiBuilder</code> class, which is used to get the stream of tokens from the lexer and to hold the intermediate state of the AST being built. The parser must process all tokens returned by the lexer up to the end of the stream, in other words, until <code>PsiBuilder.getTokenType()</code> returns <code>null</code>, even if the tokens are not valid according to the language syntax.</p> <p>Example: <code>PsiParser</code> implementation for Properties language plugin.</p> <p>The parser works by setting pairs of markers ( <code>PsiBuilder.Marker</code> instances) within the stream of tokens received from the lexer. Each pair of markers defines the range of lexer tokens for a single node in the AST tree. If a pair of markers is nested in another pair (starts after its start and ends before its end), it becomes the outer pair's child node.</p> <p>The element type for the marker pair and for the AST node created from it is specified when the end marker is set, which is done by making the call to <code>PsiBuilder.Marker.done()</code>. Also, it is possible to drop a start marker before its end marker has been set. The <code>drop()</code> method drops only a single start marker without affecting any markers added after it, and the <code>rollbackTo()</code> method drops the start marker and all markers added after it and reverts the lexer position to the start marker. These methods can be used to implement lookahead when parsing.</p> <p>The method <code>PsiBuilder.Marker.precede()</code> is useful for right-to-left parsing when you don't know how many markers you need at a specific position until you read more input. For example, a binary expression <code>a+b+c</code> needs to be parsed as <code>( (a+b) + c )</code>. Thus, two start markers are needed at the position of the token 'a', but that is not known until the token 'c' is read. When the parser reaches the '+' token following 'b', it can call <code>precede()</code> to duplicate the start marker at 'a' position, and then put its matching end marker after 'c'.</p> <p>An essential feature of <code>PsiBuilder</code> is its handling of whitespace and comments. The types of tokens which are treated as whitespace or comments are defined by the methods <code>getWhitespaceTokens()</code> and <code>getCommentTokens()</code> in the <code>ParserDefinition</code> class. <code>PsiBuilder</code> automatically omits whitespace and comment tokens from the stream of tokens it passes to <code>PsiParser</code> and adjusts the token ranges of AST nodes so that leading and trailing whitespace tokens are not included in the node.</p> <p>The token set returned from <code>ParserDefinition.getCommentTokens()</code> is also used to search for TODO items.</p> <p>To better understand the process of building a PSI tree for a simple expression, you can refer to the following diagram:</p> <p></p> <p>In general, there is no single right way to implement a PSI for a custom language, and the plugin author can choose the PSI structure and set of methods that are the most convenient for the code which uses the PSI (error analysis, refactorings, and so on). However, one base interface needs to be used by a custom language PSI implementation to support features like rename and find usages. Every element which can be renamed or referenced (a class definition, a method definition and so on) needs to implement the <code>PsiNamedElement</code> interface, with methods <code>getName()</code> and <code>setName()</code>.</p> <p>Several functions which can be used for implementing and using the PSI can be found in the <code>com.intellij.psi.util</code> package, and in particular in the <code>PsiUtilCore</code> and <code>PsiTreeUtil</code> classes.</p> <p>TIP A useful tool for debugging the PSI implementation is the PsiViewer plugin. It can show you the PSI structure built by your plugin, the properties of every PSI element, and highlight its text range.</p> <p>Please see Indexing and PSI Stubs for advanced topics.</p>"},{"location":"reference_guide/custom_language_support/navigation/","title":"Navigation","text":"<p>WARNING This API is available starting from 2020.3 and currently in development and thus in experimental state.</p> <p>The Go to Declaration or Usages action is performed in several steps.</p>"},{"location":"reference_guide/custom_language_support/navigation/#direct-navigation","title":"Direct Navigation","text":"<p>Direct navigation is the navigation from <code>PsiElement</code> to another <code>PsiElement</code>,  such as navigation from <code>break</code> keyword to the end of a loop in Java, without showing any popups.</p> <p>To provide <code>PsiElement</code> for direct navigation, implement and register  <code>DirectNavigationProvider</code>.</p>"},{"location":"reference_guide/custom_language_support/navigation/#symbol-navigation","title":"Symbol Navigation","text":"<p>If there is no Direct navigation available under the caret, then the Consulo proceeds with <code>Symbol</code> navigation. In this step the Consulo computes the navigation targets based on target symbols, which it obtains by resolving a reference.  If there are several target symbols or several navigation targets defined for a symbol,  then the IDE shows the navigation popup to ask the user to choose where to go.</p> <p>The <code>NavigationTarget</code> is essentially a pair of a <code>Navigatable</code> and  a <code>TargetPopupPresentation</code>  instances (where to go and what to show in the popup).</p> <p>To provide navigation targets by a <code>Symbol</code>, either: - implement and register    <code>SymbolNavigationProvider</code>; - or implement    <code>NavigatableSymbol</code>   in the <code>Symbol</code>.</p>"},{"location":"reference_guide/custom_language_support/navigation/#showing-usages","title":"Showing Usages","text":"<p>If there are no navigation targets available, then the Consulo starts finding usages of the target symbol obtained by resolving a reference  or from a declaration. </p>"},{"location":"reference_guide/custom_language_support/references_and_resolve/","title":"References and Resolve","text":"<p>One of the most important and tricky parts in implementing a custom language PSI is resolving references. Resolving references gives users the ability to navigate from a PSI element usage (accessing a variable, calling a method, etc.) to the declaration of that element (the variable's definition, a method declaration, and so on). This feature is needed in order to support the Go to Declaration action invoked by Ctrl-B and Ctrl-Click, and it is a prerequisite for implementing the Find Usages action, the Rename Refactoring and Code Completion.</p> <p>NOTE The Quick Definition action is based on the same mechanism, so it becomes automatically available for all references that can be resolved by the language plugin.</p> <p>All PSI elements which work as references (for which the Go to Declaration action applies) need to implement the <code>PsiElement.getReference()</code> method and to return a <code>PsiReference</code> implementation from that method. The <code>PsiReference</code> interface can be implemented by the same class as <code>PsiElement</code>, or by a different class. An element can also contain multiple references (for example, a string literal can contain multiple substrings which are valid fully-qualified class names), in which case it can implement <code>PsiElement.getReferences()</code> and return the references as an array.</p> <p>The primary method of the <code>PsiReference</code> interface is <code>resolve()</code>, which returns the element to which the reference points, or <code>null</code> if it was not possible to resolve the reference to a valid element (for example, should it point to an undefined class). The resolved element should implement the <code>PsiNamedElement</code> interface.</p> <p>NOTE While the referencing element and the referenced element both may have a name, only the element which introduces the name (e.g., the definition <code>int x = 42</code>) needs to implement the <code>PsiNamedElement</code> interface. The referencing element at the point of usage (e.g., the <code>x</code> in the expression <code>x + 1</code>) should not implement <code>PsiNamedElement</code> since it does not have a name.</p> <p>TIP In order to enable more advanced IntelliJ functionality, prefer implementing <code>PsiNameIdentifierOwner</code> over <code>PsiNamedElement</code> where possible.</p> <p>A counterpart to the <code>resolve()</code> method is <code>isReferenceTo()</code>, which checks if the reference resolves to the specified element. The latter method can be implemented by calling <code>resolve()</code> and comparing the result with the passed PSI element. Still, additional optimizations are possible (for example, performing the tree walk only if the element text is equal to the text of the reference).</p> <p>Examples: - Reference to a ResourceBundle in the Properties language plugin - Custom Language Support Tutorial: Reference Contributor</p> <p>TIP To optimize <code>getReferences()</code> performance, consider implementing <code>HintedReferenceHost</code> to provide additional hints. Please see also Cache Results of Heavy Computations in Working with PSI efficiently.</p> <p>There are a set of interfaces that can be used as a base for implementing resolve support, namely the <code>PsiScopeProcessor</code> interface and the <code>PsiElement.processDeclarations()</code> method. These interfaces have several extra complexities that are unnecessary for most custom languages (like support for substituting Java generics types). Still, they are required if the custom language can have references to Java code. If Java interoperability is not required, the plugin can forgo the standard interfaces and provide its own, different implementation of resolve.</p> <p>The implementation of resolve based on the standard helper classes contains the following components:</p> <ul> <li>A class implements the <code>PsiScopeProcessor</code> interface, which gathers the possible declarations for the reference and stops the resolve process when it has successfully completed.   The primary method which needs to be implemented is <code>execute()</code>, which is called to process every declaration encountered during the resolve, and returns <code>true</code> if the resolve needs to be continued or <code>false</code> if the declaration has been found.   The methods <code>getHint()</code> and <code>handleEvent()</code> are used for internal optimizations and can be left empty in the <code>PsiScopeProcessor</code> implementations for custom languages.</li> <li>A function which walks the PSI tree up from the reference location until the resolve has successfully completed or until the end of the resolve scope has been reached.   If the target of the reference is located in a different file, the file can be located, for example, using <code>FilenameIndex.getFilesByName()</code> (if the file name is known) or by iterating through all custom language files in the project (<code>iterateContent()</code> in the <code>ProjectFileIndex</code> interface obtained from <code>ProjectRootManager.getFileIndex()</code>).</li> <li>The individual PSI elements, on which the <code>processDeclarations()</code> method is called during the PSI tree walk.   If a PSI element is a declaration, it passes itself to the <code>execute()</code> method of the <code>PsiScopeProcessor</code> passed to it.   Also, if necessary, according to the language scoping rules, a PSI element can pass the <code>PsiScopeProcessor</code> to its child elements.</li> </ul>"},{"location":"reference_guide/custom_language_support/references_and_resolve/#resolving-to-multiple-targets","title":"Resolving to Multiple Targets","text":"<p>An extension of the <code>PsiReference</code> interface, which allows a reference to resolve to multiple targets, is the <code>PsiPolyVariantReference</code> interface. The targets to which the reference resolves are returned from the <code>multiResolve()</code> method. The Go to Declaration action for such references allows the user to choose a navigation target. The implementation of <code>multiResolve()</code> can be also based on <code>PsiScopeProcessor</code>, and can collect all valid targets for the reference instead of stopping when the first valid target is found.</p>"},{"location":"reference_guide/custom_language_support/registering_file_type/","title":"Registering a File Type","text":"<p>The first step in developing a custom language plugin is registering a file type associated with the language.</p> <p>The IDE typically determines the type of a file by looking at its file name or extension. In 2020.2, support for mapping via hashbang is available via <code>hashBangs</code> attribute in <code>com.intellij.fileType</code> extension point.</p> <p>A custom language file type is a class derived from <code>LanguageFileType</code>, which passes a <code>Language</code> subclass to its base class constructor.</p> <p>To register a file type, the plugin developer provides a subclass of <code>FileTypeFactory</code>, which is registered via the <code>com.intellij.fileTypeFactory</code> extension point.</p> <p>NOTE When targeting 2019.2 or later only, using <code>com.intellij.fileType</code> extension point is preferred to using dedicated <code>FileTypeFactory</code>.</p> <p>Examples: - <code>LanguageFileType</code> subclass in Properties language plugin - Custom Language Support Tutorial: Language and File Type</p> <p>To verify that the file type is registered correctly, you can implement the <code>LanguageFileType.getIcon()</code> method and verify that the correct icon (see Working with Icons and Images) is displayed for files associated with your file type.</p> <p>If you want IDEs to show a hint prompting users that your plugin supports a specific file type, see Plugin Recommendations.</p> <p>To control file type association with the IDE in the operating system, implement <code>com.intellij.openapi.fileTypes.OSFileIdeAssociation</code> (2020.3).</p>"},{"location":"reference_guide/custom_language_support/rename_refactoring/","title":"Rename Refactoring","text":"<p>The Rename refactoring operation is quite similar to that of Find Usages. It uses the same rules for locating the element to be renamed and the same index of words for finding the files that may have references to the element being renamed.</p> <p>When the rename refactoring is performed, the method <code>PsiNamedElement.setName()</code> is called for the renamed element, and <code>PsiReference.handleElementRename()</code> is called for all references to the renamed element. These methods perform basically the same action: replace the underlying AST node of the PSI element with the node containing the new text entered by the user. Creating an entirely correct AST node from scratch is quite tricky. Thus, surprisingly, the easiest way to get the replacement node is to create a dummy file in the custom language so that it would contain the necessary node in its parse tree, build the parse tree and extract the required node from it.</p> <p>Examples: - <code>setName()</code> implementation for a Properties language plugin - Custom Language Support Tutorial: Reference Contributor</p> <p>To disable renaming for specific elements, implement <code>com.intellij.openapi.util.Condition&lt;T&gt;</code> for PsiElement of type <code>T</code> and register it in <code>com.intellij.vetoRenameCondition</code> extension point.</p>"},{"location":"reference_guide/custom_language_support/rename_refactoring/#name-validation","title":"Name Validation","text":"<p><code>NamesValidator</code> allows a plugin to check if the name entered by the user in the <code>Rename</code> dialog is a valid identifier (and not a keyword) according to the custom language rules. If an implementation of this interface is not provided by the plugin, Java rules for validating identifiers are used. Implementations of <code>NamesValidator</code> are registered in the <code>com.intellij.lang.namesValidator</code> extension point.</p> <p>Example: <code>PropertiesNamesValidator</code> for Properties language plugin</p>"},{"location":"reference_guide/custom_language_support/rename_refactoring/#custom-rename-ui-and-workflow","title":"Custom Rename UI and Workflow","text":"<p>Further customization of the Rename refactoring processing is possible on multiple levels. Providing a custom implementation of the <code>RenameHandler</code> interface allows you to entirely replace the UI and workflow of the rename refactoring, and also to support renaming something which is not a <code>PsiElement</code> at all.</p> <p>Example: <code>RenameHandler</code> for renaming a resource bundle in the Properties language plugin</p> <p>If you're okay with the standard UI but need to extend the default logic of renaming, you can provide an implementation of the <code>RenamePsiElementProcessor</code> interface. This allows you to:</p> <ul> <li>Rename an element different from the one on which the action was invoked (a super method, for example)</li> <li>Rename multiple elements at once (if their names are linked according to the logic of your language)</li> <li>Check for name conflicts (existing names, etc.)</li> <li>Customize how a search for code references or text references is performed</li> <li>etc.</li> </ul> <p>Example: <code>RenamePsiElementProcessor</code> for renaming a property in Properties plugin language</p>"},{"location":"reference_guide/custom_language_support/safe_delete_refactoring/","title":"Safe Delete Refactoring","text":"<p>The Safe Delete refactoring also builds on the same Find Usages framework as Rename Refactoring.</p> <p>In addition to that, to support Safe Delete, a plugin needs to implement two things:</p> <ul> <li> <p>The    <code>RefactoringSupportProvider</code>    interface, registered in the <code>com.intellij.lang.refactoringSupport</code> extension point, and the <code>isSafeDeleteAvailable()</code> method, which checks if the Safe Delete refactoring is available for a specific PSI element</p> </li> <li> <p>The    <code>PsiElement.delete()</code>    method for the    <code>PsiElement</code>    subclasses for which Safe Delete is available.    Deleting PSI elements is implemented by deleting the underlying AST nodes from the AST tree (which, in turn, causes the text ranges corresponding to the AST nodes to be deleted from the document).</p> </li> </ul> <p>Example: <code>delete()</code> implementation for a Property in  Properties language plugin</p> <p>If needed, it's possible to further customize how Safe Delete is performed for a particular type of element (e.g., how references are searched) via <code>SafeDeleteProcessorDelegate</code>.</p> <p>Example: <code>SafeDeleteProcessorDelegate</code> implementation for Properties language plugin</p>"},{"location":"reference_guide/custom_language_support/structure_view/","title":"Structure View","text":"<p>The Structure View implementation used for a specific file type can be customized on many levels. If a custom language plugin provides an implementation of the <code>StructureView</code> interface, it can completely replace the standard structure view implementation with a custom user interface component. However, for most languages, this is not necessary, and the standard <code>StructureView</code> implementation provided by Consulo can be reused.</p> <p>The starting point for the structure view is the <code>PsiStructureViewFactory</code> interface, which is registered in the <code>com.intellij.lang.psiStructureViewFactory</code> extension point.</p> <p>Examples: - <code>PsiStructureViewFactory</code> for Properties language plugin - Custom Language Support Tutorial: Structure View</p> <p>To reuse the Consulo implementation of the <code>StructureView</code>, the plugin returns a <code>TreeBasedStructureViewBuilder</code> from its <code>PsiStructureViewFactory.getStructureViewBuilder()</code> method. As the builder model, the plugin can specify a subclass of <code>TextEditorBasedStructureViewModel</code>, and by overriding methods of this subclass, it customizes the structure view for a specific language.</p> <p>Example: <code>StructureViewModel</code> for Properties language plugin</p> <p>The main method to override is <code>getRoot()</code>, which returns the instance of a class implementing the <code>StructureViewTreeElement</code> interface. There exists no standard implementation of this interface, so a plugin will need to implement it completely.</p> <p>The structure view tree is usually built as a partial mirror of the PSI tree. In the implementation of <code>StructureViewTreeElement.getChildren()</code>, the plugin can specify which of the child elements of a specific PSI tree node need to be represented as elements in the structure view. Another important method is <code>getPresentation()</code>, which can be used to customize the text, attributes, and icon used to represent an element in the structure view.</p> <p>The implementation of <code>StructureViewTreeElement.getChildren()</code> needs to be matched by <code>TextEditorBasedStructureViewModel.getSuitableClasses()</code>. The latter method returns an array of <code>PsiElement</code>-derived classes, which can be shown as structure view elements. It is used to select the Structure View item matching the cursor position when the structure view is first opened or when the Autoscroll from source option is enabled.</p> <p>Example: <code>StructureViewTreeElement</code> for Properties language plugin</p>"},{"location":"reference_guide/custom_language_support/surround_with/","title":"Surround With","text":"<p>To support the Surround With action, the plugin needs to register one or more implementations of the <code>SurroundDescriptor</code> interface in the <code>com.intellij.lang.surroundDescriptor</code> extension point. Each of the surround descriptors defines a possible type of code fragment that can be surrounded - for example, one surround descriptor can handle surrounding expressions, and another can handle statements. Each surround descriptor, in turn, contains an array of <code>Surrounder</code> objects, defining specific templates which can be used for surrounding the selected code fragment (for example, Surround With if, Surround With for, and so on).</p> <p>When the Surround With action is invoked, the IDE queries all surround descriptors for the language until it finds one that returns a non-empty array from its <code>getElementsToSurround()</code> method. Then it calls the <code>Surrounder.isApplicable()</code> method for each surrounder in that descriptor to check if the specific template is applicable in the current context. Once the user selects a specific surrounder from the popup menu, the <code>Surrounder.surroundElements()</code> method is used to execute the surround action.</p> <p>Example: <code>SurroundDescriptor</code> for Groovy plugin</p>"},{"location":"reference_guide/custom_language_support/symbols/","title":"Symbols","text":"<p>WARNING This API is available starting from 2020.3 and currently in development and thus in experimental state.</p> <p>A symbol is a semantic element in some model, e.g., language model or framework model.  The Consulo uses <code>Symbol</code> to represent symbols, and <code>Symbol</code> serves as a link between Platform APIs, such as navigation, finding usages, or renaming.  The platform obtains the target symbol from a declaration  or by resolving a reference, and then uses it to perform an action. The <code>PsiElement</code> is considered as an element in the source tree (enhanced <code>ASTNode</code>). <code>Symbol</code> decouples semantic actions from PSI.</p> <p>A <code>Symbol</code> is not required to be backed by a <code>PsiElement</code>, and it is incorrect to try to obtain the <code>PsiElement</code> from a <code>Symbol</code>. <code>Symbol</code> is not required to be bound to a <code>Project</code> as well, meaning the same instance might be shared between projects.</p> <p>Examples: - Java local variable is a symbol in Java language model, it's backed by a <code>PsiVariable</code> element; - Compiled class is a symbol in JVM model, it's backed by JDK library stubs, and it's not bound to any project; - Spring Bean is a symbol in Spring framework model, it's defined on-the-fly by framework support    (not backed by a <code>PsiElement</code>) and bound to a <code>Project</code>; - Database column is a symbol defined by data source (not backed by a <code>PsiElement</code>) and not bound to a <code>Project</code> since DB elements might be shared between projects.</p>"},{"location":"reference_guide/custom_language_support/symbols/#lifecycle","title":"Lifecycle","text":"<p>The <code>Symbol</code> instance is expected to stay valid within a single read action, which means it's safe to pass the instance to different APIs. A <code>Symbol</code> instance should not be referenced between read actions. One should create a pointer via <code>Symbol.createPointer()</code>  in the current read action, and then call <code>Pointer.dereference()</code> to obtain a <code>Symbol</code> instance in the subsequent read action.</p>"},{"location":"reference_guide/custom_language_support/syntax_highlighting_and_error_highlighting/","title":"Syntax Highlighting and Error Highlighting","text":"<p>The class used to specify how a particular range of text should be highlighted is called <code>TextAttributesKey</code>. An instance of this class is created for every distinct type of item that should be highlighted (keyword, number, string, etc.). The <code>TextAttributesKey</code> defines the default attributes applied to items of the corresponding type (for example, keywords are bold, numbers are blue, strings are bold and green). Highlighting from multiple <code>TextAttributesKey</code> items can be layered - for example, one key may define an item's boldness and another color.</p>"},{"location":"reference_guide/custom_language_support/syntax_highlighting_and_error_highlighting/#color-settings","title":"Color Settings","text":"<p>The mapping of the <code>TextAttributesKey</code> to specific attributes used in an editor is defined by the <code>EditorColorsScheme</code> class.  It can be configured by the user by providing an implementation of <code>ColorSettingPage</code> registered in <code>com.intellij.colorSettingsPage</code> extension point.</p> <p>The Export to HTML feature uses the same syntax highlighting mechanism as the editor, so it will work automatically for custom languages, which provide a syntax highlighter.</p> <p>Examples: - <code>ColorSettingsPage</code> for Properties language plugin - Custom Language Support Tutorial: Color Settings Page</p> <p>NOTE New functionality about Language Defaults and support for additional color schemes are detailed in Color Scheme Management.</p> <p>TIP To force re-highlighting, use <code>DaemonCodeAnalyzer.restart()</code>.</p> <p>The syntax and error highlighting are performed on multiple levels: Lexer, Parser, and (External) Annotator.</p>"},{"location":"reference_guide/custom_language_support/syntax_highlighting_and_error_highlighting/#lexer","title":"Lexer","text":"<p>The first syntax highlighting level is based on the lexer output and is provided through the <code>SyntaxHighlighter</code> interface. The syntax highlighter returns the <code>TextAttributesKey</code> instances for each token type, which needs special highlighting. For highlighting lexer errors, the standard <code>TextAttributesKey</code> for bad characters <code>HighlighterColors.BAD_CHARACTER</code> can be used.</p> <p>Examples: - <code>SyntaxHighlighter</code> implementation for Properties language plugin - Custom Language Support Tutorial: Syntax Highlighter</p>"},{"location":"reference_guide/custom_language_support/syntax_highlighting_and_error_highlighting/#parser","title":"Parser","text":"<p>The second level of error highlighting happens during parsing. If a particular sequence of tokens is invalid according to the grammar of the language, the <code>PsiBuilder.error()</code> method can highlight the invalid tokens and display an error message showing why they are not valid.</p>"},{"location":"reference_guide/custom_language_support/syntax_highlighting_and_error_highlighting/#annotator","title":"Annotator","text":"<p>The third level of highlighting is performed through the <code>Annotator</code> interface. A plugin can register one or more annotators in the <code>com.intellij.annotator</code> extension point, and these annotators are called during the background highlighting pass to process the elements in the custom language's PSI tree.</p> <p>Annotators can analyze not only the syntax, but also the semantics using PSI, and thus can provide much more complex syntax and error highlighting logic. The annotator can also provide quick fixes to problems it detects. When the file is changed, the annotator is called incrementally to process only changed elements in the PSI tree.</p> <p>NOTE See also Code Inspections which offer a more fine-grained control and some additional features.</p>"},{"location":"reference_guide/custom_language_support/syntax_highlighting_and_error_highlighting/#errorswarning","title":"Errors/Warning","text":"<p>See Inspections topic in Consulo UI Guidelines on how to write message texts for highlighting/quick fixes.</p> <p>To highlight a region of text as a warning or error (2020.1 and later): <pre><code>    holder.newAnnotation(HighlightSeverity.WARNING, \"Invalid code\") // or HighlightSeverity.ERROR\n        .withFix(new MyFix(psiElement))\n        .create();\n</code></pre></p> <p>In previous versions, call <code>createWarningAnnotation()</code>/<code>createErrorAnnotation()</code> on the <code>AnnotationHolder</code>, and optionally calls <code>registerFix()</code> on the returned <code>Annotation</code> object to add a quick fix for the error or warning.</p>"},{"location":"reference_guide/custom_language_support/syntax_highlighting_and_error_highlighting/#syntax","title":"Syntax","text":"<p>To apply additional syntax highlighting (2020.1 and later):</p> <pre><code>    holder.newSilentAnnotation(HighlightSeverity.INFORMATION)\n            .range(rangeToHighlight).textAttributes(MyHighlighter.EXTRA_HIGHLIGHT_ATTRIBUTE).create();\n</code></pre> <p>In previous versions, call <code>AnnotationHolder.createInfoAnnotation()</code> with an empty message and then <code>Annotation.setTextAttributes()</code>.</p> <p>Examples: - <code>Annotator</code> for Properties language plugin - Custom Language Support Tutorial: Annotator</p>"},{"location":"reference_guide/custom_language_support/syntax_highlighting_and_error_highlighting/#external-tool","title":"External Tool","text":"<p>Finally, if the custom language employs external tools for validating files in the language (for example, uses the Xerces library for XML schema validation), it can provide an implementation of the <code>ExternalAnnotator</code> interface and register it in <code>com.intellij.externalAnnotator</code> extension point.</p> <p>The <code>ExternalAnnotator</code> highlighting has the lowest priority and is invoked only after all other background processing has completed. It uses the same <code>AnnotationHolder</code> interface for converting the output of the external tool into editor highlighting.</p> <p>To skip running specific <code>ExternalAnnotator</code> for given file, register <code>ExternalAnnotatorsFilter</code> extension in <code>com.intellij.daemon.externalAnnotatorsFilter</code> extension point.</p>"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/","title":"External System Integration","text":"<p>This page provides high-level overview of External System sub-system. There are multiple project management systems (Apache Maven, Gradle, sbt etc) and it's good to support them at the IDE. Luckily, they all provide a similar set of facilities from the integration point of view: * build IDE project from external system config (<code>pom.xml</code>, <code>build.gradle</code> etc); * provide a list of available tasks; * allow to execute a particular task; * ...</p> <p>That means that we can separate external system-specific logic and general IDE processing. 'External system' sub-system provides simple API for wrapping external system and extensible IDE-specific processing logic.</p>"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#project-management","title":"Project Management","text":""},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#project-data-domain","title":"Project Data Domain","text":"<p>General External system wrapper is required to be able to build project info on the basis of the given external system config. That information is built using in terms of <code>DataNode</code>, <code>Key</code> and <code>ExternalEntityData</code>.</p> <p></p> <p>Here DataNode class is just a holder for the target data (data type is defined by the Key). Multiple DataNode objects might be organized in directed graph where every edge identifies parent-child relation.</p> <p>For example, simple one-module project might look as below:</p> <p></p> <p>Consequence The IDE provides a set of built-in Keys and ExternalEntityDatas but any external system integration or third-party plugin developer might enhance project data by defining her own Key and ExternalEntityData and storing them at a child of appropriate DataNode.</p>"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#managing-project-data","title":"Managing Project Data","text":"<p>We need to process project data is built on external system config basis. Here comes <code>ProjectDataService</code>. It is a strategy which knows how to manage particular ExternalEntityData. For example, when we want to import a project from external model, we can start by the top level DataNode which references project info and then import its data using corresponding service.</p> <p>Custom services can be defined via 'externalProjectDataService' extension.</p> <p>The good thing is that we can separate project parsing and management here. That means that a set of DataNode, Key and ProjectDataServices can be introduced for particular technology and then every external system integration can build corresponding data if necessary using it.</p>"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#importing-from-external-model","title":"Importing from External Model","text":"<p>Consulo provides standard API for that. Namely, <code>ProjectImportBuilder</code> and <code>ProjectImportProvider</code>. There are two classes built on template method pattern - <code>AbstractExternalProjectImportBuilder</code> and <code>AbstractExternalProjectImportProvider</code>. Concrete implementations are registered in <code>plugin.xml</code>.</p> <p>Here is an example from the gradle integration plugin:</p> <pre><code>&lt;projectImportProvider implementation=\"org.jetbrains.plugins.gradle.service.settings.GradleProjectImportProvider\"/&gt;\n&lt;projectImportBuilder implementation=\"org.jetbrains.plugins.gradle.service.settings.GradleProjectImportBuilder\"/&gt;\n</code></pre> <p>Note that <code>AbstractExternalProjectImportBuilder</code> is built on top of the 'external system settings' controls.</p>"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#auto-import","title":"Auto-Import","text":"<p>It's possible to configure external system integration to automatically refresh project structure when external project's config files are modified.</p> <p>TIP Since 2020.1, auto-import cannot be disabled by user.</p>"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#auto-import-for-externalsystemmanager-implementation","title":"Auto-Import for <code>ExternalSystemManager</code> implementation","text":"<p>Describe project's settings files to track by having external system <code>ExternalSystemManager</code> implement <code>ExternalSystemAutoImportAware</code>.</p> <p>NOTE <code>ExternalSystemAutoImportAware.getAffectedExternalProjectPath()</code> is called quite often, that\u2019s why it\u2019s expected to return control as soon as possible. Helper <code>CachingExternalSystemAutoImportAware</code> class might be used for caching, i.e. <code>ExternalSystemManager</code> which implements <code>ExternalSystemAutoImportAware</code> can have a field like <code>new CachingExternalSystemAutoImportAware(new MyExternalSystemAutoImportAware())</code> and delegate <code>ExternalSystemAutoImportAware.getAffectedExternalProjectPath()</code> calls to it.</p>"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#auto-import-for-standalone-external-systems","title":"Auto-Import for Standalone External Systems","text":"<p>Some external systems don\u2019t have <code>ExternalSystemManager</code> (e.g., Maven), but they also can use auto-import core to track changes in settings files. For this, implement <code>ExternalSystemProjectAware</code> interface that describes settings files for tracking and an action to reload project model. Then register the instance with <code>ExternalSystemProjectTracker</code> to start tracking.</p> <p>NOTE Multiple <code>ExternalSystemProjectAware</code> instances can correspond to a single external system. It allows performing project reload differently depending on the set of settings files (project aware per settings file, per module, per external project, etc.).</p>"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#icon-for-reload-notification","title":"Icon for Reload Notification","text":"<p>Since 2020.1, the icon for reload notification can be specified per external system. Implement <code>ExternalSystemIconProvider</code> and register via <code>com.intellij.externalIconProvider</code> extension point in <code>plugin.xml</code>. Alternatively, set <code>reloadIcon</code> field external system implements <code>ExternalSystemIconProvider</code> directly.</p>"},{"location":"reference_guide/frameworks_and_external_apis/external_system_integration/#settings","title":"Settings","text":"<p>The general idea is that all external system settings controls are represented by implementations of <code>ExternalSystemSettingsControl</code> interface. There are also external system project-local settings and global external system settings. So, basically particular external system settings UI looks as below:</p> <p></p> <p>It's recommended to extend from <code>AbstractExternalProjectSettingsControl</code> for implementing project-level settings control as it already handles some of them.</p> <p>Similar approach is used for providing 'import from external system' UI - implementation is expected to extend <code>AbstractImportFromExternalSystemControl</code> and it has not linked external projects list but target external project path control:</p> <p></p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/","title":"XML DOM API","text":""},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#abstract","title":"Abstract","text":"<p>This article is intended for plugin writers who create custom web server integrations, or some UI for easy XML editing. It describes the Document Object Model (DOM) in Consulo --- an easy way to work with DTD or Schema-based XML models. The following topics will be covered: working with DOM itself (reading/writing tags content, attributes, and subtags) and easy XML editing in the UI by connecting UI to DOM.</p> <p>It's assumed that the reader is familiar with Java, Swing, Consulo XML PSI (classes <code>XmlTag</code>, <code>XmlFile</code>, <code>XmlTagValue</code>, etc.), Consulo plugin development basics (application and project components, file editors).</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#introduction","title":"Introduction","text":"<p>So, how to operate with XML from an Consulo plugin? Usually, one has to take <code>XmlFile</code>, get its root tag, and then find a required sub-tag by path. The path consists of tag names, each of them a string. Typing these everywhere is tedious and error-prone. Let's assume you have the following XML:</p> <pre><code>&lt;root&gt;\n    &lt;foo&gt;\n        &lt;bar&gt;42&lt;/bar&gt;\n        &lt;bar&gt;239&lt;/bar&gt;\n    &lt;/foo&gt;\n&lt;/root&gt;\n</code></pre> <p>Let's say you want to read the contents of the second bar element, namely, \"239\".</p> <p>It's not correct to create chained calls like</p> <pre><code>file.getDocument().getRootTag().findFirstSubTag(\"foo\").\nfindSubTags(\"bar\")[1].getValue().getTrimmedText()\n</code></pre> <p>because each call here may return <code>null</code>.</p> <p>So the code would probably look like this:</p> <pre><code>XmlFile file = ...;\nfinal XmlDocument document = file.getDocument();\nif (document != null) {\n    final XmlTag rootTag = document.getRootTag();\n    if (rootTag != null) {\n        final XmlTag foo = rootTag.findFirstSubTag(\"foo\");\n        if (foo != null) {\n            final XmlTag[] bars = foo.findSubTags(\"bar\");\n            if (bars.length &gt; 1) {\n                String s = bars[1].getValue().getTrimmedText();\n                // do something\n            }\n        }\n    }\n}\n</code></pre> <p>Looks awful, doesn't it? But there's a better way to do the same thing. You just need to extend a special interface --- <code>DomElement</code>.</p> <p>For example, let's create several interfaces:</p> <pre><code>interface Root extends com.intellij.util.xml.DomElement {\n    Foo getFoo();\n}\n\ninterface Foo extends com.intellij.util.xml.DomElement {\n    List&lt;Bar&gt; getBars();\n}\n\ninterface Bar extends com.intellij.util.xml.DomElement {\n    String getValue();\n}\n</code></pre> <p>Next, you should create a <code>DomFileDescription</code> object, pass to its constructor the root tag name and root element interface, and register it with extension point <code>com.intellij.dom.fileDescription</code>.</p> <p>NOTE If your plugin targets 2019.1 or later, please use extension point <code>com.intellij.dom.fileMetaData</code> instead and specify <code>rootTagName</code> and <code>domVersion</code>/<code>stubVersion</code> in <code>plugin.xml</code>.</p> <p>You can now get the file element from <code>DomManager</code>. To get the \"239\" value, you only have to write the following code:</p> <pre><code>DomManager manager = DomManager.getDomManager(project);\nRoot root = manager.getFileElement(file).getRootElement();\nList&lt;Bar&gt; bars = root.getFoo().getBars();\nif (bars.size() &gt; 1) {\n    String s = bars.get(1).getValue();\n    // do something\n}\n</code></pre> <p>I suppose this looks a little bit nicer. You often work with your model in more than one place. Re-creating the model is too inefficient, so we cache it for you, and any subsequent calls to <code>DomManager.getFileElement()</code> will return the same instance. So, it is useful to invoke this method just once, and then keep everywhere only the \"root\" object you've obtained. In this case you wont need to repeat that scary first line, and the code will look even nicer.</p> <p>It is also important to note that with this scenario we avoid potential <code>NullPointerException</code>: our DOM guarantees that every method accessing a tags child will return a not-null element, even if the correspondingly-named sub-tag doesn't exist. That may seem strange at a first glance, but it appears to be rather convenient. How does it work? Simple. Given those interfaces, DOM generates all code for accessing correct sub-tags and creating model elements at runtime. The sub-tag names and element types are taken from method names, return types and method annotations, if any. In most cases annotations can be omitted, as in our example, but this is discussed further in this article anyway.</p> <p>Now let us explore more thoroughly what the DOM can do, and look at possible ways of representing various XML concepts such as tag content, attributes or sub-tags. Later we will discuss basic methods for working with the model, as well as cover more advanced functionality. Finally, we'll see how to easily create an UI editor for DOM model elements.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#building-the-model","title":"Building the Model","text":""},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#tag-content","title":"Tag Content","text":"<p>In XML PSI, tag content is referred to as tag value, so well do the same for consistency. To read and change a tag value, you have to add two methods (getter and setter) to your interface, like this:</p> <pre><code>String getValue();\nvoid setValue(String s);\n</code></pre> <p>These method names (<code>getValue</code> and <code>setValue</code>) are standard, and they are used for accessing tag values by default. If you want to use custom method names for the same goal, you should annotate these methods with <code>@TagValue</code>, for example:</p> <pre><code>@TagValue\nString getTagValue();\n\n@TagValue\nvoid setTagValue(String s);\n</code></pre> <p>As you can see, our accessors work with <code>String</code> values. This is natural, since XML represents a text format, and tag content is always text. But sometimes you may want to operate with integers, booleans, enums, or even class names (they, of course, will be represented as <code>PsiClass</code>), and more generic Java types (<code>PsiType</code>). In such cases, you just need to change the type in methods to the one you need, and everything will keep working correctly.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#custom-value-types","title":"Custom Value Types","text":"<p>If you operate with even more exotic types, you should tell DOM how to deal with them. First, annotate your accessor methods with the <code>@Convert</code> annotation, and specify your own class that should extend the <code>Converter&lt;T&gt;</code> class in the annotation. Here <code>T</code> is your exotic type, while <code>Converter&lt;T&gt;</code> is a thing that knows how to convert values between <code>String</code> and <code>T</code>. If the value cannot be converted (for example, \"foo\" is not convertible into <code>Integer</code>), the converter may return <code>null</code>. Please also note that your implementation should have a no-argument constructor.</p> <p>Let us consider an interesting case when <code>T</code> represents an enum value. Usually, the converter just searches for enum elements with the names specified in XML. But sometimes, for their names, you may need or want to use values that are not valid Java identifiers. For example, CMP version in EJB may be \"1.x\" or \"2.x\", but you can't create Java enums with such names. For such cases, let your enum implement <code>NamedEnum</code> interface, and then name your enum elements as you wish. Now, just provide the <code>getValue()</code> implementation that will return the right value to match with XML contents, and voil\u00e0! In our example, the code will look as follows:</p> <pre><code>enum CmpVersion implements NamedEnum {\n    CmpVersion_1_X (\"1.x\"),\n    CmpVersion_2_X (\"2.x\");\n\n    private final String value;\n\n    private CmpVersion(String value) {\n        this.value = value;\n    }\n\n    public String getValue() { return value; }\n}\n</code></pre> <p>As we have already mentioned, an XML tag may have lots of artifacts besides its value: there can be attributes, children, but rather often (e.g., according to DTD or Schema) it should have only the value. Of course such tags also need a DOM element to associate with. And we provide such an element:</p> <pre><code>interface GenericDomValue&lt;T&gt; {\n    T getValue();\n    void setValue(T t);\n\n    @TagValue\n    String getStringValue();\n\n    @TagValue\n    void setStringValue(String s);\n}\n</code></pre> <p>So, you can just specify a particular <code>T</code> when using this interface --- and everything will work. Methods that work with <code>String</code> are provided for many reasons. For example, your <code>T</code> is <code>PsiClass</code>. It would be useful to highlight invalid values in UI. To get the value to highlight (the string from the XML file) we have the <code>getStringValue()</code> method. The error message will be taken from the converter via <code>getErrorMessage()</code>.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#attributes","title":"Attributes","text":"<p>Attributes are also rather simple to deal with. You can read their values, set them, and operate with different types. So it's natural to create something like <code>GenericDomValue&lt;T&gt;</code> and then work as usual. \"Something like\" will be an inheritor, as shown below:</p> <pre><code>interface GenericAttributeValue&lt;T&gt; extends GenericDomValue&lt;T&gt; {\n    XmlAttribute getXmlAttribute();\n}\n</code></pre> <p>Consider that you want to work with an attribute named some-class having a value of type <code>PsiClass</code>:</p> <pre><code>@Attribute(\"some-class\")\nGenericAttributeValue&lt;PsiClass&gt; getMyAttributeValue();\n</code></pre> <p>That's all! Now you can get/set values, resolve this <code>PsiClass</code>, get its <code>String</code> representation, etc. The name of the attribute will be taken from the method name (see next paragraph). If you name your method in a special way, you can even omit the annotation. For example:</p> <pre><code>GenericAttributeValue&lt;PsiClass&gt; getSomeClass();\n</code></pre> <p>The <code>DomNameStrategy</code> interface specifies how to convert accessor names to XML element names. Or more precisely, not the full accessor names, but rather the names minus any \"get\", \"set\" or \"is\" prefixes. The strategy class is specified in the <code>@NameStrategy</code> annotation in any DOM element interface. Then any descendants and children of this interface will use this strategy. The default strategy is <code>HyphenNameStrategy</code>, where words are delimited by hyphens (see sample above). Another common variant is <code>JavaNameStrategy</code> that capitalizes the first letter of each word, as in Java's naming convention. In our example, the attribute name would be \"someClass\".</p> <p>If attribute doesn't define a <code>PsiClass</code>, but some other custom <code>T</code> that needs a converter, you just need to specify the <code>@Convert</code> annotation to the getter.</p> <p>Please note that the attributes getter method will never return <code>null</code>, even if the attribute isn't specified in XML. Its <code>getValue()</code>, <code>getStringValue()</code> and <code>getXmlAttribute()</code> methods will return <code>null</code>, but the DOM interface instance will exist and be valid. If the element has an underlying attribute, this can be easily fixed (surely, only if you need that): just call the <code>undefine()</code> method (defined in <code>DomElement</code>), and the XML attribute disappears, while <code>GenericAttributeValue</code> remains valid.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#children-fixed-number","title":"Children: Fixed Number","text":"<p>You may often deal with tags that have at most one sub-tag with the given name (e.g. <code>&lt;ejb-name&gt;</code>, <code>&lt;ejb-class&gt;</code> or <code>&lt;cmp-field&gt;</code>) in tags defining entity EJBs. To work with such children, provide getters for them. These getters should have a return type that extends <code>DomElement</code>:</p> <pre><code>GenericDomValue&lt;String&gt; getEjbName();\nGenericDomValue&lt;String&gt; getEjbClass();\nCmpField getCmpField();\n</code></pre> <p>There's also an annotation to designate such children explicitly: <code>@SubTag</code>. Its \"value\" attribute contains a tag name. If it is not specified, the name is implied from the method name using the current name strategy.</p> <p>Sometimes it is the sub-tag's presence that means something, rather than its content --- <code>&lt;unchecked&gt;</code> in EJB method permissions, for example. If it exists, then permissions are unchecked, otherwise checked. For such things one should create a special <code>GenericDomValue&lt;Boolean&gt;</code> child. Usually its <code>getValue()</code> returns <code>true</code> if there's \"true\" in a tag value, <code>false</code> if there's \"false\" in a tag value, and <code>null</code> otherwise. In the <code>@SubTag</code> annotation, you can specify the attribute like <code>indicator=true</code>. In this case, <code>getValue()</code> will return <code>true</code> if the tag exists and <code>false</code> otherwise.</p> <p>Let's consider another interesting example inspired by EJB, where there is a relation that has two roles, each designating one relation end: first role and second role. Both are represented by tags with the same values. So, we could create a collection of role elements, and every time we access some role we would check if this collection has sufficient number of elements. But one of the main purposes of the DOM is to eliminate unnecessary checks. So why cant we have a fixed (more than one) number of children with the same tag name? Let's have them!</p> <pre><code>@SubTag(value = \"ejb-relationship-role\", index = 0)\nEjbRelationshipRole getEjbRelationshipRole1();\n\n@SubTag(value = \"ejb-relationship-role\", index = 1)\nEjbRelationshipRole getEjbRelationshipRole2();\n</code></pre> <p>The first method will return the DOM element for the first subtag named <code>&lt;ejb-relationship-role&gt;</code>, and the second --- for the second one. Hence the term \"fixed-number\" for such children. According to DTD or Schema, there should be fixed number of subtags with the given name. Most often this fixed number is 1; in our case with the relations it is 2. Just like attributes, fixed-number children exist regardless of underlying tag existence. If you need to delete tags, it can be done with the help of the same <code>undefine()</code> method.</p> <p>For children of <code>GenericDomValue</code> type, you can also specify a converter, just as you can for attributes.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#children-collections","title":"Children: Collections","text":"<p>One more common case in DTD and Schemas is when children have the same tag name and a non-fixed upper limit in count. Their accessors differ from those of the fixed-number children in the following: the return result is <code>Collection</code> or <code>List</code> of a special type that extends <code>DomElement</code>, and if you want to use name strategies, the method name must be in pluralized form. For example, in EJB we would have the following method:</p> <pre><code>List&lt;Entity&gt; getEntities();\n</code></pre> <p>There's also an annotation <code>@SubTagList</code> where you can explicitly specify the tag name.</p> <p>Returned collections cannot be modified directly. To delete an element from collection, just call <code>undefine()</code> on this element. The tag will then be removed, and element will become invalid (<code>DomElement.isValid() == false</code>). Note that this behavior differs from that of fixed-number children and attributes: they are always valid, even after <code>undefine()</code>. Again, unlike those children types, collection children always have valid underlying XML tags.</p> <p>Adding elements is a little bit harder. Since all DOM elements are created internally, you can't just pass some of your DOM elements to some method, to add the element to the collection. In fact, you have to ask a parent element to add a child to the collection. In our example it's done in the following way:</p> <pre><code>Entity addEntity(int index);\n</code></pre> <p>which adds an element to wherever you want, or</p> <pre><code>Entity addEntity();\n</code></pre> <p>which adds a new DOM element to the end of the collection. Please note the singular tense of the word \"Entity\". That's because here we deal with one <code>Entity</code> object, while in the collection getter we dealt with potentially many entities.</p> <p>Now, you can do anything you want with the returned value: modify, define the tag's value, children, etc.</p> <p>The last common case is also a collection, but one consisting of tags with different names that are arbitrarily mixed. To work with it, you should define collection getters for all tag names within the mixed collection, and then define an additional specially annotated getter:</p> <pre><code>// &lt;foo&gt; elements\nList&lt;Foo&gt; getFoos();\n\n// &lt;bar&gt; elements\nList&lt;Bar&gt; getBars();\n\n// all &lt;foo&gt; and &lt;bar&gt; elements\n@SubTagsList({\"foo\", \"bar\"})\nList&lt;FooBar&gt; getMergedListOfFoosAndBars();\n</code></pre> <p>The annotation here is mandatory - we cannot guess several tag names from one method name.</p> <p>To add elements to such mixed collections, you should create \"add\" methods for each possible tag name:</p> <pre><code>@SubTagsList(value={\"foo\",\"bar\"}, tagName=\"foo\") Fubar addFoo();\n@SubTagsList(value={\"foo\",\"bar\"}, tagName=\"bar\") Fubar addBar(int index);\n</code></pre> <p>The index parameter in the last example means the index in the merged collection, not in the collection of tags named \"bar\".</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#dynamic-definition","title":"Dynamic Definition","text":"<p>You can extend existing DOM model at runtime by implementing <code>com.intellij.util.xml.reflect.DomExtender&lt;T&gt;</code>. Register it in \"extenderClass\" attribute of EP <code>com.intellij.dom.extender</code>, where \"domClass\" specifies DOM class <code>&lt;T&gt;</code> to be extended. <code>DomExtensionsRegistrar</code> provides various methods to register dynamic attributes and children.</p> <p>If the contributed elements depend on anything other than plain XML file content (used framework version, libraries in classpath, ...), make sure to return <code>false</code> from <code>DomExtender.supportsStubs()</code>.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#generating-dom-from-existing-xsd","title":"Generating DOM from Existing XSD","text":"<p>DOM can be generated automatically from existing XSD/DTD. Output correctness/completeness will largely depend on the input scheme and may require additional manual adjustments.</p> <p>Follow these steps:</p> <ul> <li>Run IntelliJ IDEA with Plugin DevKit enabled in internal mode</li> <li>Select Tools | Internal Actions | DevKit | Generate DOM Model</li> <li>Select Scheme file and set options, then click \"Generate\" to generate sources</li> <li>Modify generated sources according to your needs</li> </ul>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#ide-support","title":"IDE Support","text":"<p>Plugin DevKit supports the following features for working with DOM related code:</p> <ul> <li><code>DomElement</code> - provide implicit usages for all DOM-related methods defined in inheriting classes (to suppress \"unused method\" warning)</li> <li><code>DomElementVisitor</code> - provide implicit usages for all DOM-related visitor methods defined in inheriting classes (to suppress \"unused method\" warning)</li> </ul>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#working-with-the-dom","title":"Working with the DOM","text":""},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#class-choosers","title":"Class Choosers","text":"<p>It often happens that a collection contains same-named tags that may have different structure or even be represented by different types in the DTD or Schema. As an example, JSF Managed Beans may be of three types. If a <code>&lt;managed-bean&gt;</code> tag contains a <code>&lt;map-entries&gt;</code> sub-tag, then the Managed Bean type is <code>MapEntriesBean</code>. If it contains a <code>&lt;list-entries&gt;</code> sub-tag \u2014 can you guess? Right \u2014 <code>ListEntriesBean</code>! Otherwise it's a <code>PropertyBean</code> (all three interfaces extend <code>ManagedBean</code>). And when we write <code>List&lt;ManagedBean&gt; getManagedBeans()</code>, we expect to get not only a list where all elements are instances of the <code>ManagedBean</code> interface, but a list where each element is of a certain type, i.e. <code>MapEntriesBean</code>, <code>ListEntriesBean</code>, or <code>PropertyBean</code>.</p> <p>In such cases one should decide which interface the DOM element should actually implement (according to the given tag). This is achieved by extending the <code>TypeChooser</code> abstract class:</p> <pre><code>public abstract class TypeChooser {\n    public abstract Type chooseType(XmlTag tag);\n    public abstract void distinguishTag(XmlTag tag, Type aClass) throws IncorrectOperationException;\n    public abstract Type[] getChooserTypes();\n}\n</code></pre> <p>Here, the first method (<code>chooseType()</code>) does exactly what it is named after (chooses the particular type, most often it's a class). The second one (<code>distinguishTag()</code>) acts in reverse: it modifies a tag so that when the element is read from an XML file next time (for example, after the user has closed and opened the project again), the newly created DOM element will implement the same interface and no model data will be lost. Finally, <code>getChooserTypes()</code> just returns all the types that could be returned by <code>chooseType()</code>.</p> <p>To make your <code>TypeChooser</code> work, register it in your overridden <code>DomFileDescription.initializeFileDescription()</code> method by calling <code>registerTypeChooser()</code>.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#useful-methods-of-domelement-and-dommanager","title":"Useful Methods of DomElement and DomManager","text":""},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#psi-connection","title":"PSI Connection","text":"<p>Of course, DOM is tightly connected to XML PSI, so there's always a way of getting the <code>XmlTag</code> instance (which can be <code>null</code> for fixed-number children and attributes) using the <code>getXmlTag()</code> method. We remember that in <code>GenericAttributeValue</code> there's also the <code>getXmlAttribute()</code> method. In general case there is <code>getXmlElement()</code> method. You can also get a DOM element by its underlying XML PSI element using the <code>DomManager.getDomElement()</code> method.</p> <p>If DOM element has no underlying XML element, it can be created by calling <code>ensureTagExists()</code>. To delete a tag, use the already known <code>undefine()</code> method. This method will always delete the underlying XML element (tag or attribute). If the element was a collection child, then neither it nor its entire sub-tree will be valid anymore.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#tree-structure","title":"Tree Structure","text":"<p>In every normal tree there's always a possibility to walk up. <code>DomElement</code> is no exception. Method <code>getParent()</code> just returns element's parent in tree.</p> <p>The method <code>&lt;T extends DomElement&gt; T getParentOfType(Class&lt;T&gt; requiredClass, boolean strict)</code> returns the tree ancestor of the given class. You can see the standard strict parameter, that can return the DOM element itself, if it's <code>false</code> and your current DOM element is an instance of requiredClass.</p> <p>Finally, <code>getRoot()</code> will return the <code>DomFileElement</code>, which is the root of every DOM tree.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#validity","title":"Validity","text":"<p>An element becomes invalid if it has been deleted explicitly or due to external PSI changes. Fixed-number children and attributes are meant to stay valid as long as possible, no matter what happens with XML. They can become invalid only if they have collection tree ancestor that has been deleted.</p> <p>Newly created DOM elements are always correct and valid, so their <code>isValid()</code> methods will return <code>true</code>.</p> <p>Element validity is very important, since you cannot invoke any methods on invalid elements (except, of course, <code>isValid()</code> itself).</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#dom-reflection","title":"DOM Reflection","text":"<p>DOM also has a kind of reflection, called \"Generic Info\". One would use it to be able to access children by tag names directly, instead of calling getter methods. See <code>DomGenericInfo</code> interface and <code>getGenericInfo()</code> methods in <code>DomElement</code> and <code>DomManager</code> for more information. There's also <code>DomElement.getXmlElementName()</code> method that returns the name of a corresponding tag or attribute.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#presentation","title":"Presentation","text":"<p><code>DomElement.getPresentation()</code> returns an instance of <code>ElementPresentation</code>, an interface that knows presentable element type, name, and sometimes even its icon. Presentations are actually obtained from presentation factory objects that, like ClassChoosers's, should be registered in <code>ElementPresentationManager</code> as early as possible. You can specify type name and icon for all elements of some class, ways of getting type name, icon and presentable name for particular objects. When not specified, presentable name is taken from the object itself, if it contains a method annotated with <code>@NameValue</code> annotation, that returns <code>String</code> or <code>GenericValue</code>. If there's no such method, it will return <code>null</code>. For <code>DomElement</code>, there's another way to get this presentable name: <code>DomElement.getGenericInfo().getElementName()</code>.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#events","title":"Events","text":"<p>If you want to be notified on every change in the DOM model, add <code>DomEventListener</code> to <code>DomManager</code>. DOM supports the following events: tag value changed, element defined/undefined/changed, and collection child added/removed.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#highlighting-annotations","title":"Highlighting Annotations","text":"<p>The DOM supports error checking and highlighting. It's based on annotations which you add to the DOM element in a special place (don't confuse these annotations with the ones of Java 5 \u2014 they are very different). You need to implement the <code>DomElementAnnotator</code> interface, and override <code>DomFileDescription.createAnnotator()</code> method, and create this annotator there. In <code>DomElementsAnnotator.annotate(DomElement element, DomElementsProblemsHolder annotator)</code> you should report about all errors and warnings in the element's sub-tree to the annotator (<code>DomElementsProblemsHolder.createProblem()</code>). You should return this annotator in the corresponding virtual method of the <code>DomFileDescription</code>.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#automatic-highlighting-basicdomelementsinspection","title":"Automatic Highlighting (BasicDomElementsInspection)","text":"<p>The following errors can be highlighted automatically by providing an instance of <code>BasicDomElementsInspection</code>:</p> <ul> <li><code>@Required</code> element missing or having empty text</li> <li>XML value cannot be converted by some <code>Converter</code></li> <li>name is not unique while it should be</li> </ul> <p>The latter case requires you to specify the name getter with <code>@NameValue</code> annotation. The checking uses the <code>DomFileDescription.getIdentityScope()</code> method to get the element defining the root scope in which the name should be unique.</p> <p>To suppress spellchecking annotate your DomElement with <code>@com.intellij.spellchecker.xml.NoSpellchecking</code>.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#required-children","title":"Required Children","text":"<p>There is a common case in error highlighting, when one needs to say, that some required sub-tag or attribute is missing. DOM will do this for you automatically, if you annotate the getter for that child with the <code>@Required</code> annotation. For collection children getters, this annotation will mean, that the collection should be not empty (corresponding to '+' sign in DTD). Also, when you create a new element that has required fixed-number or attribute children, their tags or attributes will also be created in XML.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#resolving","title":"Resolving","text":"<p>Remember the interface <code>GenericDomValue&lt;T&gt;</code> and its sub-interface <code>GenericAttributeValue&lt;T&gt;</code>? Remember, that ANY class may be passed as <code>T</code> \u2014 for example, let's interpret <code>GenericDomValue&lt;PsiClass&gt;</code> as a reference to a class. Then we can always consider it as a reference to an object of class <code>T</code>! With Strings or enums, it is not a very useful idea, but we'll use it in another way. Very often XML has such a structure that an object is declared at some place, and is referenced at some other place (more precisely, in a tag or attribute value). So, if you want to create a method like <code>GenericValue&lt;MyDomElement&gt; getMyDomElementReference()</code>, then you just have to specify a proper converter that will find an instance in your model of <code>MyDomElement</code> with the name specified in the <code>GenericDomValue</code>.</p> <p>That's the core idea. Since creating such converters is quite boring, we've done it for you. You don't have to annotate reference getters at all, as the name resolution will be made automatically. Elements will be searched by name, and the name will be taken from the method annotated with <code>@NameValue</code>. The converter used is <code>DomResolveConverter</code>. Its constructor takes a parameter, so it can't be referenced in <code>@Convert</code> annotation, but its subclasses (if you create them) \u2014 can. If you still want to specify explicitly that your reference to <code>DomElement</code> should be resolved \"model-wide\", use the <code>@Resolve</code> annotation parameterized with the desired class. The resolution scope will be taken from the <code>DomFileDescription.getResolveScope()</code>.</p> <p>In addition to the above, auto-resolving in DOM also provides some features in your XML text editor: error highlighting, completion, Find Usages, Rename Refactoring... Unresolved references will be highlighted, and even completed. If you want to create a custom converter and want to have this code insight with it, you should extend not only the <code>Converter</code> but <code>ResolvingConverter</code>. It has one more method <code>getVariants()</code>, where you'll have to provide the collection consisting of all targets your reference may resolve to. Those familiar with <code>PsiReference</code> will recognize the similarities here.</p> <p>If you need to choose a <code>Converter</code> depending on other values (e.g. in sibling/parent element) or any runtime condition (e.g. presence or version of library), you can use <code>WrappingConverter</code>. See also <code>GenericDomValueConvertersRegistry</code> for managing an extensible registry of available Converters to choose from.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#mock-and-stable-elements","title":"Mock and Stable Elements","text":"<p>Your DOM elements do not have to be tied to a physical file. <code>DomManager.createMockElement()</code> will help you to create a virtual element of a given class with the given module. An element may be physical or not. 'Physical' here means that DOM will create a mock document for it, so you can enjoy Undo functionality if you pass this document to the right place in file editor.</p> <p><code>DomElement.copyFrom()</code> allows you to copy information from one <code>DomElement</code> to another. In fact, it just replaces XML tags, and all the old data is lost. Nevertheless, the element's fixed-number children don't become invalid, they only contain new tag values, attribute values, etc. The tree is actually rather conservative.</p> <p>The combination of <code>createMockElement()</code> and <code>copyFrom()</code> is useful for editing element contents in dialogs. You create a mock copy of an element, work with it in the dialog and then, if the user doesn't cancel, copy the element back to the main model. Since it's a common case, a special shortcut method has been created in <code>DomElement</code>, called <code>createMockCopy()</code>.</p> <p>Consulo's XML parser is incremental: changes in text do not cause the whole file to be reparsed. But you should keep in mind that this rule may sometimes not work correctly. For example, your DOM elements can unexpectedly become broken as a result of manual editing of the XML file (even if it didn't happen inside those elements). If a file editor depends on such a broken element, this can lead to closing the tab, which isn't very nice from the user's point of view. For example, suppose you have an entity bean named \"SomeEntity\". You open an editor for it, then you go into the XML, change the tag name from entity to session, and then back to entity. Of course, no DOM element can survive after such blasphemy. But notwithstanding, you still want your editor to stay open! Well, there is a solution, and it's called <code>DomManager.createStableValue(Factory factory)</code>. This method creates a DOM element that delegates all its functionality to some real element (returned from the factory parameter). As soon as that real element becomes invalid, the factory is called once more, and if it returns something valid, it becomes the new delegate. And so on... In the example with EJB, the factory would once again look for an Entity Bean named \"SomeEntity\".</p> <p>Stable DOM elements also implement the <code>StableElement</code> interface, which has the following methods:</p> <ul> <li><code>DomElement getWrappedElement()</code> \u2014 just returns the current element to which all method calls are delegated;</li> <li><code>void invalidate()</code> \u2014 makes the wrapped element invalid. Any following method call will cause the factory to create a new delegate;</li> <li><code>void revalidate()</code> \u2014 calls the factory, and if it returns something new (i.e. not the same as the current wrapped element) invalidates the old value and adopts the new one.</li> </ul>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#visitor","title":"Visitor","text":"<p>Visitor is a very common design pattern. DOM model also has a visitor, and it's called <code>DomElementVisitor</code>. The <code>DomElement</code> interface has methods <code>accept()</code> and <code>acceptChildren()</code> that take this visitor as a parameter. If you look at the interface <code>DomElementVisitor</code> itself, you may be surprised, since it has only one method: <code>visitDomElement(DomElement)</code>. Where is the Visitor pattern? Where are all those methods with names like <code>visitT(T)</code> that are usually found in it? There are no such methods, because the actual interfaces (T's) aren't known to anyone except you. But when you instantiate the <code>DomElementVisitor</code> interface, you may add there these <code>visitT()</code> methods, and they will be called! You may even name them just <code>visit()</code>, specify the type of the parameter, and everything will be fine. For example, if you have two DOM element classes \u2014 <code>Foo</code> and <code>Bar</code> \u2014 your visitor may look like this:</p> <pre><code>class MyVisitor implements DomElementVisitor {\n    void visitDomElement(DomElement element) {}\n    void visitFoo(Foo foo) {}\n    void visitBar(Bar bar) {}\n}\n</code></pre>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#implementation","title":"Implementation","text":"<p>Sometimes you may want to extend your model with some functionality that isn't directly connected with XML, but relates to your program logic. And the most appropriate place for this functionality is the DOM element interface. What to do then?</p> <p>The simplest case is when you want to add to your interface a method that returns exactly what some other getter in this element (or in one of its children) returns. You can easily write this helper method and annotate it with the <code>@PropertyAccessor</code> annotation, in which you should specify the path consisting of property names (getter names without the \"get\" or \"is\" prefixes). For example, you can write:</p> <pre><code>GenericDomValue&lt;String&gt; getVeryLongName()\n\n@PropertyAccessor(\"very-long-name\")\nGenericDomValue&lt;String&gt; getName()\n</code></pre> <p>In this case, the second method will return just the same as the first one. If there were \"foo.bar.name\" instead of \"very-long-name\" in the annotation, the system would actually call <code>getFoo().getBar().getName()</code> and return the result to you. Such annotations are useful when you're extending some interface that is inconsistent with your model, or you try to extract a common super-interface from two model interfaces with differently named children that have the same sense (see <code>&lt;ejb-ref&gt;</code> and <code>&lt;ejb-local-ref&gt;</code>).</p> <p>The case just described is simple, but rare. More often, you really have to incorporate some logic into your model. Then nothing except Java code helps you. And it will. Add the desired methods to your interface, then create an abstract class implementing the interface, and implement there only methods that you added manually and that are not directly connected to your XML model. Note that the class should have a constructor with no arguments.</p> <p>Now you only have to let DOM know that you wish to use this implementation every time you're creating a model element that should implement the necessary interface. Simply register it using extension point <code>com.intellij.dom.implementation</code> and DOM will generate at run-time the class that not only implements the needed interface, but also extends your abstract class.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#models-across-multiple-files","title":"Models Across Multiple Files","text":"<p>Many frameworks require a set of XML configuration files (\"fileset\") to work as one model, so resolving/navigation works across all related DOM files. Depending on implementation/plugin, providing filesets implicitly (using existing framework's setup in project) or via user configuration (usually via dedicated <code>Facet</code>) can be achieved.</p> <p>Extend <code>DomModelFactory</code> (or <code>BaseDomModelFactory</code> for non-<code>Module</code> scope) and provide implementation of your <code>DomModel</code>. Usually you will want to add searcher/utility methods to work with your <code>DomModel</code> implementation. Example can be found in Struts 2 plugin (package <code>com.intellij.struts2.dom.struts.model</code>).</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#dom-stubs","title":"DOM Stubs","text":"<p>NOTE Please use it sparingly and only for heavily accessed parts in your DOM model, as it increases disk space usage/indexing run time.</p> <p>DOM elements can be stubbed, so (costly) access to XML/PSI is not necessary (see Indexing and PSI Stubs for similar feature for custom languages). Performance relevant elements, tag or attribute getters can simply be annotated with <code>@com.intellij.util.xml.Stubbed</code>. Return <code>true</code> from <code>DomFileDescription.hasStubs()</code> and increase <code>DomFileDescription.getStubVersion()</code> whenever you change <code>@Stubbed</code> annotations usage in your DOM hierarchy to trigger proper rebuilding of Stubs during indexing.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#building-a-dom-based-gui","title":"Building a DOM-Based GUI","text":""},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#forms","title":"Forms","text":"<p>All forms that deal with DOM are organized in a special way. They support two main things: getting data from XML into the UI, and saving UI data to XML. The former is called resetting, the latter \u2014 committing. There's <code>Committable</code> interface that has corresponding methods: <code>commit()</code> and <code>reset()</code>. There's also a way of structuring your forms into smaller parts, namely the Composite pattern: <code>CompositeCommittable</code>. Methods <code>commit()</code> and <code>reset()</code> are invoked automatically on editor tab switch or undo. So you only need to ensure that all your Swing structure is organized in a tree of <code>CompositeCommittable</code>, and all the hard work will be done by the IDE.</p> <p>DOM controls are special descendants of <code>Committable</code>. All of them implement <code>DomUIControl</code>. Note that they are not Swing components \u2014 they are only a way of connecting DOM model and Swing components. One end of the connection \u2014 the DOM element \u2014 is usually specified in the controls constructor. The other end \u2014 Swing component \u2014 can be obtained in 2 ways. The first is to ask DOM control to create it. But that is rather inconvenient if you want to create the forms in, say, IntelliJ IDEA's GUI Designer. In that case, you'll need the second way: ask the control to <code>bind()</code> to an existing Swing component of a correct type (that depends on the type of value that you're editing). After that, your Swing components will be synchronized with DOM, they'll even highlight errors reported by <code>DomElementsAnnotator</code>.</p> <p>Sometimes you may need to do some work (enable or disable some components, change their values) after a particular DOM control is committed. Then you should define the <code>addCommitListener()</code> method of that DOM control and override the <code>CommitListener.afterCommit()</code> method. This method will be invoked inside the same write action as the main <code>commit()</code>, so any changes you do in this method to the XML will be merged with the <code>commit()</code> in the Undo queue.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#simple-controls","title":"Simple Controls","text":"<p>With simple controls, you can edit <code>GenericDomValue</code>: simple text, class names, enums and boolean values. These controls take a special object as a constructor parameter. This object should implement the <code>DomWrapper</code> interface that knows how to set/get values to/from DOM model.</p> <p>We have three major DomWrapper's: <code>DomFixedWrapper&lt;T&gt;</code> redirecting calls to <code>GenericDomValue&lt;T&gt;</code>, <code>DomStringWrapper</code> redirecting calls to string accessors of <code>GenericDomValue</code>, and <code>DomCollectionWrapper</code> that gets/sets values of the first element of the given <code>GenericDomValue</code> collection. Some controls (those having a text field as part of itself) take additional boolean constructor parameter \u2014 commitOnEveryChange, whose meaning is evident from the name. We don't recommend using it anywhere except small dialogs, because committing on every change slows down the system significantly.</p> <p>Most often these controls are created by <code>DomUIFactory.createControl(GenericDomValue)</code>. This method understands which control to create by using DOM reflection (<code>DomGenericInfo</code>, as you probably remember). But sometimes you may want to create the controls directly. So let's look at the simple controls more closely.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#booleancontrol","title":"BooleanControl","text":"<p>It allows you to edit boolean values. The control is bound to <code>JCheckBox</code>.</p> <p></p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#combocontrol","title":"ComboControl","text":"<p>The control is bound to a non-editable <code>JComboBox</code>, so it can be used to choose something from a limited set. One case of such a limited set is enum. Or it can be a constructor where you can provide a <code>Factory&lt;List&lt;String&gt;&gt;</code>, and return from this factory anything you want (for example, a list of database names to choose from). By default, the wrong values (written in XML, but not present in the list you've given to the control) are displayed in red. Since it's common practice to specify custom <code>CellRenderer</code> for combo boxes, the control has the <code>isValidValue(String)</code> method. If it returns <code>false</code> on the value you're rendering, you can highlight it in some way, to achieve the same result as the default renderer. Or you can just delegate to that renderer in your own way.</p> <p></p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#booleanenumcontrol","title":"BooleanEnumControl","text":"<p>Sometimes, when there are only 2 alternatives, it's convenient to use a check box instead of combo box. This control is designed specially for such cases. While being (and being bound to) a check box, the control edits not just \"true\" or \"false\", but any two String values, or two enum elements. In the last case, it has a boolean invertedOrder parameter, to specify which element corresponds to the checked state. By default invertedOrder is set to <code>false</code>, so the first element corresponds to the unchecked state, and the second \u2014 to the checked one. If you set the parameter to <code>true</code>, the states will swap.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#editor-based-controls","title":"Editor-Based Controls","text":"<p>Please note that editor-based controls are built on Consulo's <code>Editor</code> instead of standard <code>JTextField</code>. Since there's currently no way to instantiate Editor directly through the Open API, controls are bound to special <code>JPanel</code> inheritors, and their <code>bind()</code> method adds the necessary content to those panels.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#textcontrol","title":"TextControl","text":"<p>This control allows you to edit simple string values. The control is bound to a <code>TextPanel</code> component. There's also an inheritor of that panel \u2014 <code>MultiLineTextPanel</code>. If you bind a <code>StringControl</code> to it, a big editor will appear on the screen. In case you don't have space for a big editor, bind it to a <code>BigTextPanel</code>. Then it will be filled with a text editor, and the browse button will be added to open a dialog with the big editor where you can type a longer string.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#psiclasscontrol","title":"PsiClassControl","text":"<p>This is a one-line editor with a browse button that opens the standard class selection dialog. The control accepts class names only. It is bound to <code>PsiClassPanel</code>.</p> <p></p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#psitypecontrol","title":"PsiTypeControl","text":"<p>This is almost the same as PsiClassControl, but allows entering not only class names, but also Java primitive types and even arrays. It is bound to <code>PsiTypePanel</code>.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#collection-control","title":"Collection Control","text":"<p>There is a special table component where each row represents one collection child. It's called <code>DomCollectionControl&lt;T&gt;</code>, where <code>T</code> is your collection element type. To function properly, it needs <code>DomElement</code> (parent of the collection), some description of the collection (sub-tag name or a <code>DomCollectionChildDescription</code> from DOM reflection), and a <code>ColumnInfo</code> array. This can be passed to the constructor, or can be created in a <code>DomCollectionControl</code> inheritor, in an overriden method <code>createColumnInfos()</code>.</p> <p>What is a column info? It's just a somewhat more comfortable way to work with the table model. It uses Java 5 generics and is more object-oriented. So, it's named <code>ColumnInfo&lt;Item,Aspect&gt;</code>, where <code>Item</code> is a type variable corresponding to the type of elements in the collection, and <code>Aspect</code> is a type variable corresponding to this particular column information type: <code>String</code>, <code>PsiClass</code>, <code>Boolean</code>, etc. The basic things that a column knows are: column name, column class, reading value (Aspect <code>valueOf(Item)</code>), writing value (<code>setValue(Item item, Aspect aspect)</code>), cell renderer (<code>getRenderer(Item)</code>), cell \"editability\" (<code>isCellEditable(Item)</code>), cell editor (<code>getEditor(Item)</code>), etc.</p> <p>There are a lot of predefined column infos, so you'll probably never create a new one.</p> <p>First, if a collection child is a <code>GenericDomValue</code>, it's usually convenient to edit it directly in the table. For this, you may need one of the following classes: <code>StringColumnInfo</code>, <code>BooleanColumnInfo</code>, or more generic <code>GenericValueColumnInfo</code>. But such collections are encountered very rarely.</p> <p>A more common case is when a collection element is more complex and has several <code>GenericDomValue</code> children. Then one may create a column for each of those children. The appropriate column info is <code>ChildGenericValueColumnInfo&lt;T&gt;</code>. It will ask you for a <code>DomFixedChildDescription</code> (one more thing from DOM reflection), a renderer and an editor \u2014 nothing else. So, the main things left to customize are the renderer and the editor.</p> <p>As for the renderer, there are two main choices: <code>DefaultTableCellRenderer</code>, and Consulo's <code>BooleanTableCellRenderer</code>. Editors are more complicated, but they closely resemble simple DOM controls.</p> <p><code>BooleanTableCellEditor</code>, <code>DefaultCellEditor(JTextField)</code>, <code>ComboTableCellEditor</code>, etc. <code>DomUIFactory.createCellEditor()</code> will create any of them automatically (including the editor for <code>PsiClass</code>), so that you won't need to think about which one to select every time.</p> <p>Collection control is a complex control, so it's bound to a complex Swing component. It's called <code>DomTableView</code>. It has a toolbar (you can override <code>DomTableView.getToolbarPosition()</code> to customize its location), with Add and Delete buttons. If you want, you may specify custom addition actions in <code>DomCollectionControl.createAdditionActions()</code> (it's recommended to extend <code>ControlAddAction</code>). If there is only one addition action, it will be invoked after pressing the Add button; if there are many, then a popup menu will be displayed. To change the removal policy, override the <code>DomCollectionControl.doRemove(List&lt;T&gt;)</code> method.</p> <p>The toolbar may also have an Edit button, if you specify that <code>DomCollectionControl.isEditable()</code>. To add a behavior to this button, override <code>DomCollectionControl.doEdit(T)</code>. There can also be a Help button, if you pass a non-null String helpId parameter while constructing your <code>DomTableView</code>.</p> <p>If there are no items in the collection, <code>DomTableView</code> may display a special text (<code>DomTableView.getEmptyPaneText()</code>), instead of an empty table.</p> <p>You can add your own popup menu to the control. Call the <code>DomTableView.installPopup()</code> method after construction, and pass a <code>DefaultActionGroup</code> with your popup actions.</p> <p>Tables can have single or multiple (default) row selection. If you want to change this behavior, override <code>DomTableView.allowMultipleRowsSelection()</code>.</p> <p></p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#ui-organization","title":"UI Organization","text":"<p>The easiest way to create a DOM-based UI form is to extend the <code>BasicDomElementComponent</code> class. This will require you to pass some DOM element to the constructor. Then you bind an IntelliJ IDEA GUI Designer form to your subclass and design a beautiful form there. You will surely want to bind some controls to DOM UI, in which case you should of course ensure that they have right types. Finally, you should create some DOM controls in class' constructor and bind them. But you can create controls and bind them to the <code>DomElement</code>'s children \u2014 <code>GenericDomValue</code>'s automatically.</p> <p>Just name your components properly and call the <code>bindProperties()</code> method in the constructor. The field names should correspond to the getter names for the element's children. They may also be prefixed with \"my\". Imagine that you have such DOM interface:</p> <pre><code>public interface Converter extends DomElement {\n    GenericDomValue&lt;String&gt; getConverterId();\n    GenericDomValue&lt;PsiClass&gt; getConverterClass();\n}\n</code></pre> <p>In this case, the UI form class can look like this:</p> <pre><code>public class ConverterComponent extends BasicDomElementComponent&lt;Converter&gt; {\n    private JPanel myRootPane;\n    private TextPanel myConverterId;\n    private PsiClassPanel myConverterClass;\n\n    public ConverterComponent(final Converter domElement) {\n        super(domElement);\n\n        bindProperties();\n    }\n}\n</code></pre> <p>All the fields here are now bound to controls in a GUI form.</p> <p>Very often you'll have to create your own file editor. Then, to use all the binding and undo functionality, it's suggested to inherit your <code>FileEditorProvider</code> from <code>PerspectiveFileEditorProvider</code>, create an instance of <code>DomFileEditor</code> there, and pass a <code>BasicDomElementComponent</code>. To easily create an editor with a caption at the top, like in our EJB and JSF, you may use the static method <code>DomFileEditor.createDomFileEditor()</code>. <code>DomFileEditor</code> automatically listens to all changes in the document corresponding to the given DOM element, and therefore refreshes your component on undo. If you want to listen to changes in additional documents, use the methods <code>addWatchedDocument()</code>, <code>removeWatchedDocument()</code>, <code>addWatchedElement()</code>, <code>removeWatchedElement()</code> in <code>DomFileEditor</code>.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#conclusion","title":"Conclusion","text":"<p>Thank you for your time and attention. We hope you've found this article really useful. You are welcome to post your questions and comments to our Open API and Plugin Development Forum.</p>"},{"location":"reference_guide/frameworks_and_external_apis/xml_dom_api/#further-material","title":"Further Material","text":"<p>The following bundled open-source plugins make (heavy) use of DOM:</p> <ul> <li>Android</li> <li>Ant</li> <li>Plugin DevKit</li> <li>Maven</li> <li>Struts 2 (Ultimate Edition)</li> </ul>"},{"location":"reference_guide/internal_actions/enabling_internal/","title":"Enabling Internal Mode","text":"<p>There are useful tools, such as the Internal Actions menu, that are only visible if internal mode is enabled in IntelliJ IDEA.</p>"},{"location":"reference_guide/internal_actions/enabling_internal/#setting-internal-mode-in-the-ide-properties-file","title":"Setting Internal Mode in the IDE Properties File","text":"<p>There are multiple ways to enable internal mode, but the simplest is within IntelliJ IDEA: * Start IntelliJ IDEA. * From the main menu, select Help | Edit Custom Properties. This selection opens IntelliJ IDEA's <code>idea.properties</code> file. If it does not exist, IntelliJ IDEA will prompt to create one. * Add the line shown below to the <code>idea.properties</code> file:</p> <p><pre><code>idea.is.internal=true\n</code></pre> * Save the <code>idea.properties</code> file and restart IntelliJ IDEA.</p> <p>The Internal Actions menu is available in Tools | Internal Actions.</p>"},{"location":"reference_guide/internal_actions/internal_actions_intro/","title":"Internal Actions Menu","text":"<p>The Internal Actions menu provides plugin developers with a suite of tools to help develop, debug, and test their Consulo plugins.</p> <p>TIP If the menu item Tools | Internal Actions is not available in IntelliJ IDEA, then the first step is to Enabling Internal Mode</p> <p>Click on the following topics to learn more about the Internal Actions menu. * Enabling Internal Mode provides instructions for enabling the Internal Actions menu in IntelliJ IDEA. * UI Tools has information about some of the Internal Actions menu tools for inspecting and testing plugin UI.</p>"},{"location":"reference_guide/internal_actions/internal_ui_inspector/","title":"Internal Actions - UI Inspector","text":"<p>The UI Inspector is a tool to interrogate elements of the IntelliJ IDEA UI to get an internal description of each element. UI elements can be tested interactively by clicking on the element while the UI Inspector is enabled.</p> <p>If the menu item Tools | Internal Actions | UI | UI Inspector is not available in IntelliJ IDEA, then the first step is to enable internal mode</p>"},{"location":"reference_guide/internal_actions/internal_ui_inspector/#enabling-the-ui-inspector","title":"Enabling the UI Inspector","text":"<p>Before using the UI Inspector, it must be enabled by selecting the menu item Tools | Internal Actions | UI | UI Inspector. The enabled state of the UI Inspector is modal; it remains enabled until it is disabled by selecting the UI Inspector menu item again.</p>"},{"location":"reference_guide/internal_actions/internal_ui_inspector/#using-the-ui-inspector","title":"Using the UI Inspector","text":"<p>While enabled, centering the cursor on a UI element and pressing Control/Cmd+Alt when clicking the mouse reveals the properties of the Swing component.</p> <p>For example, to get information about the Build Project button's icon (hammer) on the toolbar (highlighted in green), put the mouse cursor on the icon and press Control/Cmd+Alt while clicking the mouse.</p> <p>The UI Inspector displays that the icon has the internal path <code>AllIcons.Actions.Compile</code>:</p> <p></p>"},{"location":"reference_guide/internal_actions/internal_ui_inspector/#additional-properties","title":"Additional Properties","text":"<p>Various components used in the Consulo expose additional properties. These can be useful to locate the underlying implementation, related Action, etc.</p> Type Place Properties <code>AnAction</code> Action ButtonMenu Item <code>Action</code> - <code>AnAction</code> implementation<code>Action ID</code> - Action <code>id</code><code>Action Plugin ID</code> - contributing plugin <code>ActionToolbar</code> Action Toolbar <code>Toolbar Group</code> - Action Group ID<code>All Groups</code> - contained Action Group IDs <code>DialogWrapper</code> Modal Dialog <code>dialogWrapperClass</code> - <code>DialogWrapper</code> implementation <code>GutterMark</code> Editor Gutter Icon <code>gutter renderer</code> - <code>GutterMark</code> implementation <code>IntentionAction</code>/<code>QuickFix</code> Popup Menu in Editor <code>intention action</code>/<code>quick fix</code> - <code>IntentionAction</code> / <code>QuickFix</code> implementation <code>Tree</code> Tree <code>treeModelClass</code> - <code>javax.swing.tree.TreeModel</code> implementation <p>Custom Swing components can also provide additional properties via <code>UiInspectorContextProvider</code> (2020.1 and later).</p>"},{"location":"reference_guide/internal_actions/internal_ui_laf_defaults/","title":"Internal Actions - LaF Defaults","text":"<p>The LaF Defaults window provides a key-value pair lookup for UI Controls. It also allows interactive prototyping of UI Control color changes.</p> <p>If the menu item Tools | Internal Actions is not available in IntelliJ IDEA, then the first step is to enable internal mode</p>"},{"location":"reference_guide/internal_actions/internal_ui_laf_defaults/#opening-laf-defaults","title":"Opening LaF Defaults","text":"<p>The LaF Defaults window is opened by selecting the menu item Tools | Internal Actions | UI | LaF Defaults.</p> <p>The LaF Defaults window has two columns representing key-value pairs for UI Controls: * The Name column contains the UI Control <code>key</code> for each Consulo UI element available at runtime. * The Value column contains the UI Control color <code>value</code> for each Consulo UI element.</p>"},{"location":"reference_guide/internal_actions/internal_ui_laf_defaults/#using-the-laf-panel","title":"Using the LaF Panel","text":""},{"location":"reference_guide/internal_actions/internal_ui_laf_defaults/#finding-ui-controls","title":"Finding UI Controls","text":"<p>The LaF Defaults window is used interactively by entering a UI element type - e.g. <code>Panel</code> - in the Filter text box at the top. LaF Defaults shows the list of UI Control names matching the filter. Clicking on one of the names narrows the information to show only the key-value pair for that UI element:</p> <p></p>"},{"location":"reference_guide/internal_actions/internal_ui_laf_defaults/#prototyping-the-color-of-ui-controls","title":"Prototyping the Color of UI Controls","text":"<p>The color of UI Controls can be changed (in real time) by clicking in the Value column next to a Name (<code>key</code>) of interest. The Choose Color window is displayed. Color changes can be specified as RGB, hexadecimal, or using the color picker. Pressing the Choose button changes the UI Control color immediately.</p> <p>UI Control colors can be reset using the Choose Color window, or by resetting the UI Theme.</p>"},{"location":"reference_guide/internal_actions/internal_ui_sub/","title":"Internal Actions - UI Submenu","text":"<p>The Internal Actions UI submenu provides Consulo plugin developers with a suite of tools to help develop, debug, and test their Consulo project UI.</p> <p>TIP If the menu item Tools | Internal Actions is not available in IntelliJ IDEA, then the first step is to Enabling Internal Mode</p>"},{"location":"reference_guide/internal_actions/internal_ui_sub/#the-tools-available-on-the-ui-submenu","title":"The Tools Available on the UI Submenu","text":"<p>Here are some tools available on the UI submenu of the Internal Actions menu: * UI Inspector is a tool to get an internal description with each UI element's properties. * LaF Defaults provides a way to lookup the key-value pair for a UI element, and the ability to prototype the color of UI Controls.</p>"},{"location":"reference_guide/performance/performance/","title":"Optimizing Performance","text":"<p>TIP IDE Perf plugin provides on-the-fly performance diagnostic tools, including a dedicated view for <code>CachedValue</code> metrics.</p>"},{"location":"reference_guide/performance/performance/#working-with-psi-efficiently","title":"Working with PSI Efficiently","text":""},{"location":"reference_guide/performance/performance/#avoid-expensive-methods-in-psielement","title":"Avoid Expensive Methods in <code>PsiElement</code>","text":"<p>Avoid <code>PsiElement</code> methods which are expensive with deep trees.</p> <p><code>getText()</code> traverses the whole tree under the given element and concatenates strings, consider <code>textMatches()</code> instead.</p> <p><code>getTextRange()</code>, <code>getContainingFile()</code>, and <code>getProject()</code> traverse the tree up to the file, which can be long in very nested trees. If you only need PSI element length, use <code>getTextLength()</code>.</p> <p>File and project often can be computed once per some analysis and then stored in fields or passed via parameters.</p> <p>Additionally, <code>getText()</code>, <code>getNode()</code>, <code>getTextRange()</code>, etc., all need AST, which can be quite an expensive operation. See below.</p>"},{"location":"reference_guide/performance/performance/#avoid-using-many-psi-treesdocuments","title":"Avoid Using Many PSI Trees/Documents","text":"<p>Avoid loading too many parsed trees or documents into memory at the same time. Ideally, only AST nodes from files open in the editor should be present in the memory. Everything else, even if it's needed for resolve/highlighting purposes, can be accessed via PSI interfaces, but its implementations should use stubs underneath, which are less CPU- and memory-expensive.</p> <p>If stubs don't suit your case well (e.g., the information you need is large and/or very rarely needed, or you're developing a plugin for a language whose PSI you don't control), you can create a custom index or gist.</p> <p>You can use <code>AstLoadingFilter</code> in production and <code>PsiManagerEx.setAssertOnFileLoadingFilter()</code> in tests to ensure you're not loading AST accidentally.</p> <p>The same applies to documents: only the ones opened in editors should be loaded. Usually, you shouldn't need document contents (as most information can be retrieved from PSI). If you nevertheless need documents, consider saving the information you need to provide in a custom index or gist to get it more cheaply later. If you still need documents, then at least ensure you load them one by one and don't hold them on strong references to let GC free the memory as quickly as possible.</p>"},{"location":"reference_guide/performance/performance/#cache-results-of-heavy-computations","title":"Cache Results of Heavy Computations","text":"<p>These include <code>PsiElement.getReference(s)</code>, <code>PsiReference.resolve()</code> (and <code>multiResolve()</code> and other equivalents), expression types, type inference results, control flow graphs, etc.</p> <p>Usually, <code>CachedValue</code> works well.</p> <p>If the information you cache depends only on a subtree of the current PSI element (and nothing else: no resolve results or other files), you can cache it in a field in that <code>PsiElement</code> and drop the cache in an override of <code>ASTDelegatePsiElement.subtreeChanged()</code>.</p>"},{"location":"reference_guide/performance/performance/#improving-indexing-performance","title":"Improving Indexing Performance","text":""},{"location":"reference_guide/performance/performance/#avoid-using-ast","title":"Avoid Using AST","text":"<p>Use lexer information instead of parsed trees if possible.</p> <p>If impossible, use light AST which doesn't create memory-hungry AST nodes inside, so traversing it might be faster. Make sure to traverse only the nodes you need to.</p> <p>For stub index, implement <code>LightStubBuilder</code>. For other indices, you can obtain the light AST manually via <code>((PsiDependentFileContent) fileContent).getLighterAST()</code>.</p> <p>If a custom language contains lazy-parseable elements that never or rarely contain any stubs, consider implementing <code>StubBuilder.skipChildProcessingWhenBuildingStubs()</code> (preferably using Lexer/node text).</p>"},{"location":"reference_guide/performance/performance/#consider-prebuilt-stubs","title":"Consider Prebuilt Stubs","text":"<p>If your language has a massive standard library, which is mostly the same for all users, you can avoid stub-indexing it in each installation by providing prebuilt stubs with your distribution. See <code>PrebuiltStubsProvider</code> extension.</p>"},{"location":"reference_guide/performance/performance/#avoiding-ui-freezes","title":"Avoiding UI Freezes","text":""},{"location":"reference_guide/performance/performance/#do-not-perform-long-operations-in-ui-thread","title":"Do not Perform Long Operations in UI Thread","text":"<p>In particular, don't traverse VFS, parse PSI, resolve references or query <code>FileBasedIndex</code>.</p> <p>There are cases when the platform itself invokes such expensive code (e.g., resolve in <code>AnAction.update()</code>). We're trying to eliminate them. Meanwhile, you can try to speed up what you can in your plugin, it'll be beneficial anyway, as it'll also improve background highlighting performance.</p> <p><code>WriteAction</code>s currently have to happen on UI thread, so to speed them up, you can try moving as much as possible out of write action into a preparation step which can be then invoked in background (e.g., using <code>ReadAction.nonBlocking()</code>).</p> <p>Don't do anything expensive in event listeners. Ideally, you should only clear some caches. You can also schedule background processing of events, but be prepared that some new events might be delivered before your background processing starts, and thus the world might have changed by that moment or even in the middle of background processing. Consider using <code>MergingUpdateQueue</code> and <code>ReadAction.nonBlocking()</code> to mitigate these issues.</p> <p>Massive batches of VFS events can be pre-processed in background, see <code>AsyncFileListener</code> (2019.2 or later).</p>"},{"location":"reference_guide/performance/performance/#dont-block-edt-by-long-non-cancellable-readactions-in-background-threads","title":"Don't block EDT by long non-cancellable <code>ReadAction</code>s in background threads","text":"<p>See General Threading Rules, especially its section on Read Action Cancellability.</p>"},{"location":"reference_guide/project_model/library/","title":"Library","text":"<p>A library is an archive of compiled code (such as JAR files) that modules depend on.</p> <p>The Consulo supports three types of libraries: * Module Library: the library classes are visible only in this module and the library information is recorded in the module <code>.iml</code> file. * Project Library: the library classes are visible within the project and the library information is recorded under <code>.idea/libraries</code> directory or in the project <code>.ipr</code> file. * Global Library: the library information is recorded in the <code>applicationLibraries.xml</code> file in <code>&lt;User Home&gt;/.IntelliJIdea/config/options</code> directory. Global libraries are similar to project libraries, but are visible for different projects.</p> <p>For more information about libraries, refer to Libraries.</p> <p>A particular type of programmatically defined libraries is Predefined Libraries.</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"reference_guide/project_model/library/#accessing-libraries-and-jars","title":"Accessing Libraries and Jars","text":"<p>Package <code>libraries</code> provides functionality for working with project libraries and jars.</p>"},{"location":"reference_guide/project_model/library/#getting-a-list-of-libraries-a-module-depends-on","title":"Getting a List of Libraries a Module Depends On","text":"<p>To get the list of libraries that a module depends on, use <code>OrderEnumerator.forEachLibrary</code> as follows.</p> <pre><code>final List&lt;String&gt; libraryNames = new ArrayList&lt;String&gt;();\nModuleRootManager.getInstance(module).orderEntries().forEachLibrary(library -&gt; {\n  libraryNames.add(library.getName());\n  return true;\n});\nMessages.showInfoMessage(StringUtil.join(libraryNames, \"\\n\"), \"Libraries in Module\");\n</code></pre> <p>This sample code outputs a list of libraries that the given module depends on.</p>"},{"location":"reference_guide/project_model/library/#getting-a-list-of-all-libraries","title":"Getting a List of All Libraries","text":"<p>To manage the lists of application and project libraries, use <code>LibraryTable</code>. The list of application-level library tables is accessed by calling <code>LibraryTablesRegistrar.getInstance().getLibraryTable()</code>, whereas the list of project-level library tables is accessed through <code>LibraryTablesRegistrar.getInstance().getLibraryTable()</code>. Once you have a <code>LibraryTable</code>, you can get the libraries in it by calling <code>LibraryTable.getLibraries()</code>.</p> <p>To get the list of all module libraries defined in a given module, use the following API:</p> <pre><code>OrderEntryUtil.getModuleLibraries(ModuleRootManager.getInstance(module));\n</code></pre>"},{"location":"reference_guide/project_model/library/#getting-the-library-content","title":"Getting the Library Content","text":"<p><code>Library</code> provides the <code>getUrls()</code> method you can use to get a list of source roots and classes the library includes. To clarify, consider the following code snippet:</p> <pre><code>StringBuilder roots = new StringBuilder(\"The \" + lib.getName() + \" library includes:\\n\");\nroots.append(\"Sources:\\n\");\nfor (String each : lib.getUrls(OrderRootType.SOURCES)) {\n  roots.append(each).append(\"\\n\");\n}\nroots.append(\"Classes:\\n\");\nfor (String each : lib.getUrls(OrderRootType.CLASSES)) {\n  strRoots.append(each).append(\"\\n\");\n}\nMessages.showInfoMessage(roots.toString(), \"Library Info\");\n</code></pre>"},{"location":"reference_guide/project_model/library/#creating-a-library","title":"Creating a Library","text":"<p>To create a library, perform the following steps:   * Get a write action   * Obtain the library table to which you want to add the library. Use one of the following, depending on the library level:       * <code>LibraryTablesRegistrar.getInstance().getLibraryTable()</code>       * <code>LibraryTablesRegistrar.getInstance().getLibraryTable(Project)</code>       * <code>ModuleRootManager.getInstance(module).getModifiableModel().getModuleLibraryTable()</code>   * Create the library by calling <code>LibraryTable.createLibrary()</code>   * Add contents to the library (see below)   * For a module-level library, commit the modifiable model returned by <code>ModuleRootManager.getInstance(module).getModifiableModel()</code>.</p> <p>For module-level libraries, you can also use simplified APIs in the <code>ModuleRootModificationUtil</code> class to add a library with a single API call. You can find an example of using these APIs in the project_model code sample.</p>"},{"location":"reference_guide/project_model/library/#adding-contents-or-modifying-a-library","title":"Adding Contents or Modifying a Library","text":"<p>To add or change the roots of a library, you need to perform the following steps:   * Get a write action   * Get a modifiable model for the library, using <code>Library.getModifiableModel()</code>   * Use methods such as <code>Library.ModifiableModel.addRoot()</code> to perform the necessary changes   * Commit the model using <code>Library.ModifiableModel.commit()</code>.</p>"},{"location":"reference_guide/project_model/library/#adding-a-library-dependency-to-a-module","title":"Adding a Library Dependency to a Module","text":"<p>Use <code>ModuleRootModificationUtil.addDependency(module, library)</code> from under a write action.</p>"},{"location":"reference_guide/project_model/library/#checking-belonging-to-a-library","title":"Checking Belonging to a Library","text":"<p>The <code>ProjectFileIndex</code> interface implements a number of methods you can use to check whether the specified file belongs to the project library classes or library sources. You can use the following methods:</p> <ul> <li>To check if a specified virtual file is a compiled class file use   <pre><code>  ProjectFileIndex.isLibraryClassFile(virtualFile)\n</code></pre></li> <li>To check if a specified virtual file or directory belongs to library classes use   <pre><code>  ProjectFileIndex.isInLibraryClasses(virtualFileorDirectory)\n</code></pre></li> <li>To check if the specified virtual file or directory belongs to library sources use   <pre><code>  ProjectFileIndex.isInLibrarySource(virtualFileorDirectory)\n</code></pre></li> </ul> <p>See the project_model to see how the method mentioned above can be applied.</p> <p>More details on libraries can be found in the plugin_model code sample.</p>"},{"location":"reference_guide/project_model/library/#predefined-libraries","title":"Predefined Libraries","text":"<p>EP: <code>com.intellij.additionalLibraryRootsProvider</code></p> <p><code>AdditionalLibraryRootsProvider</code> Allows providing synthetic/predefined libraries (<code>SyntheticLibrary</code>) in a project without exposing them in the model. By default, they're also hidden from UI.</p>"},{"location":"reference_guide/project_model/module/","title":"Module","text":"<p>A module is a discrete unit of functionality that can be run, tested, and debugged independently. Modules include such things as source code, build scripts, unit tests, deployment descriptors, etc.</p> <p>The key components of a module are:</p> <ul> <li>Content roots - the directories where the files belonging to the module (source code, resources, etc.) are stored.   Each directory can belong to one and only one module; it's not possible to share a content root between multiple modules.</li> <li>Source roots - A content root can have multiple source roots underneath it.   Source roots can have different types: regular source roots, test source roots, resource roots, etc.   In Consulo, source roots are used as roots of the package hierarchy structure.   Java classes directly under a source root will be in the root package.   Source roots can also be used to implement more fine-grained dependency checks.    Code under a regular source root cannot depend on code under a test source root.</li> <li>Order entries - the dependencies of a module, which are stored in an ordered list.   A dependency can be a reference to an SDK, a library, or another module.</li> <li>Extensions - the extensions of a module, which can store framework(or language) settings. Each extension can provide own per module setting page.</li> </ul> <p>In addition to that, a module can store other settings, such as a module-specific SDK, compile output path settings, etc. Plugins can store additional data associated with a module by creating module extensions or module-level components.</p> <p>The Consulo provides a number of classes and interfaces you can use to work with modules:</p> <ul> <li><code>Module</code></li> <li><code>ModuleUtil</code></li> <li><code>ModuleManager</code></li> <li><code>ModuleRootManager</code></li> <li><code>ModuleRootModel</code></li> <li><code>ModifiableModuleModel</code></li> <li><code>ModifiableRootModel</code></li> </ul> <p>This section discusses how to complete some common tasks related to management of modules.</p>"},{"location":"reference_guide/project_model/module/#how-do-i-get-a-list-of-modules-the-project-includes","title":"How do I get a list of modules the project includes?","text":"<p>Use the <code>ModuleManager.getModules()</code> method.</p>"},{"location":"reference_guide/project_model/module/#how-do-i-get-dependencies-and-classpath-of-a-module","title":"How do I get dependencies and classpath of a module?","text":"<p>Order entries include SDK, libraries and other modules the module uses. With the Consulo UI, you can view order entries for a module on the Dependencies tab of the Project Structure dialog box.</p> <p>To explore the module dependencies, use the <code>OrderEnumerator</code> class.</p> <p>The following code snippet illustrates how you can get classpath (classes root of all dependencies) for a module:</p> <pre><code>VirtualFile[] roots = ModuleRootManager.getInstance(module).orderEntries().classes().getRoots();\n</code></pre>"},{"location":"reference_guide/project_model/module/#how-do-i-get-the-sdk-the-module-uses","title":"How do I get the SDK the module uses?","text":"<p>Use the <code>ModuleRootManager.getSdk()</code> method. This method returns a value of the <code>Sdk</code> type.</p> <p>The following code snippet illustrates how you can get detailed information on SDK the specified module uses:</p> <pre><code>ModuleRootManager moduleRootManager = ModuleRootManager.getInstance(module);\nSdk SDK = moduleRootManager.getSdk();\nString jdkInfo = \"Module: \" + module.getName() + \" SDK: \" + SDK.getName() + \" SDK version: \"\n                 + SDK.getVersionString() + \" SDK home directory: \" + SDK.getHomePath();\n</code></pre>"},{"location":"reference_guide/project_model/module/#how-do-i-get-a-list-of-modules-on-which-this-module-directly-depends","title":"How do I get a list of modules on which this module directly depends?","text":"<p>Use the <code>ModuleRootManager.getDependencies()</code> method to get an array of the <code>Module</code> type values or the <code>ModuleRootManager.getDependencyModuleNames()</code> to get an array of module names. To clarify, consider the following code snippet:</p> <pre><code>ModuleRootManager moduleRootManager = ModuleRootManager.getInstance(module);\nModule[] dependentModules = moduleRootManager.getDependencies();\nString[] dependentModulesNames = moduleRootManager.getDependencyModuleNames();\n</code></pre>"},{"location":"reference_guide/project_model/module/#how-do-i-get-a-list-of-modules-that-depend-on-this-module","title":"How do I get a list of modules that depend on this module?","text":"<p>Use the <code>ModuleManager.getModuleDependentModules(module)</code> method.</p> <p>Note that you can also check whether a module (module1) depends on another specified module (module2) using the <code>ModuleManager.isModuleDependent()</code> method in the following way:</p> <pre><code>boolean isDependent = ModuleManager.getInstance(project).isModuleDependent(module1,module2);\n</code></pre>"},{"location":"reference_guide/project_model/module/#how-do-i-get-a-module-to-which-the-specified-file-or-psi-element-belongs","title":"How do I get a module to which the specified file or PSI element belongs?","text":"<ul> <li> <p>To get the project module to which the specified file belongs, use the <code>ModuleUtil.findModuleForFile()</code> static method.</p> <p>To clarify, consider the following code snippet:</p> </li> </ul> <pre><code>String pathToFile = \"C:\\\\users\\\\firstName.LastName\\\\plugins\\\\myPlugin\\src\\MyAction.java\";\nVirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(pathToFile);\nModule module = ModuleUtil.findModuleForFile(virtualFile,myProject);\nString moduleName = module == null ? \"Module not found\" : module.getName();\n</code></pre> <ul> <li>To get the project module to which the specified PSI element belongs, use the <code>ModuleUtil.findModuleForPsiElement()</code> method.</li> </ul>"},{"location":"reference_guide/project_model/module/#accessing-module-roots","title":"Accessing Module Roots","text":"<p>Information about module roots can be accessed via <code>ModuleRootManager</code>. For example, the following snippet shows how to access the content roots of a module:</p> <pre><code>VirtualFile[] contentRoots = ModuleRootManager.getInstance(module).getContentRoots();\n</code></pre>"},{"location":"reference_guide/project_model/module/#checking-belonging-to-a-module-source-root","title":"Checking Belonging to a Module Source Root","text":"<p>To check if a virtual file or directory belongs to a module source root, use the <code>ProjectFileIndex.getSourceRootForFile()</code> method. This method returns <code>null</code> if the file or directory does not belong to any source root of modules in the project.</p> <pre><code>VirtualFile moduleSourceRoot = ProjectRootManager.getInstance(project).getFileIndex().getSourceRootForFile(virtualFileOrDirectory);\n</code></pre>"},{"location":"reference_guide/project_model/module/#receiving-notifications-about-module-changes","title":"Receiving Notifications About Module Changes","text":"<p>To receive notifications about module changes (modules being added, removed or renamed), use the message bus and the <code>ProjectTopics.MODULES</code> topic:</p> <pre><code>project.getMessageBus().connect().subscribe(ProjectTopics.MODULES, new ModuleListener() {\n  @Override\n  public void moduleAdded(@NotNull Project project, @NotNull Module module) {\n\n  }\n});\n</code></pre>"},{"location":"reference_guide/project_model/module_extenions/","title":"Module Extensions","text":"<p>To be documented...</p>"},{"location":"reference_guide/project_model/project/","title":"Project","text":"<p>In the Consulo, a project encapsulates all the source code, libraries, and build instructions into a single organizational unit. Everything done in the IDE is accomplished within the context of a project. A project defines some collections referred to as modules and libraries. Depending on the logical and functional requirements for the project, a single-module or a multi-module project is possible.</p>"},{"location":"reference_guide/project_model/project/#working-with-projects","title":"Working with Projects","text":"<p>The Consulo stores the project configuration data in XML files. The list of those files depends on the chosen project format.</p> <p>For file-based format projects (legacy), the information core to the project itself (e.g., location of the component modules, compiler settings, etc.) is stored in the <code>%project_name%.ipr</code> file. The information about modules the project includes is stored in <code>%module_name%.iml</code> files. Module files are created for each module.</p> <p>For directory-based format projects, the project and workspace settings are stored in a number of XML files under the <code>%project_home_directory%/.idea</code> directory. Each XML file is responsible for its own set of settings and can be recognized by its name: <code>projectCodeStyle.xml</code>, <code>encodings.xml</code>, <code>vcs.xml</code> etc. As for the file-based format projects, <code>.iml</code> files describe modules.</p> <p>Note that direct access to project files isn't required to load or save settings. See Persisting State of Components for more information.</p> <p>To work with projects and project files, use the following classes and interfaces: * <code>Project</code> * <code>ProjectRootManager</code> * <code>ProjectManager</code> * <code>ProjectFileIndex</code></p> <p>Other classes for working with the project model are located in the <code>projectModel-api.openapi</code> package. Basic API classes and interfaces for the concepts of <code>Project</code>, <code>Module</code> and <code>Application</code>  are placed in the <code>core-api.openapi</code> package.</p>"},{"location":"reference_guide/project_model/project/#getting-a-list-of-source-roots-for-all-modules-in-a-project","title":"Getting a List of Source Roots for All Modules in a Project","text":"<p>Use the <code>ProjectRootManager.getContentSourceRoots()</code> method. To clarify this, consider the following code snippet:</p> <pre><code>String projectName = project.getName();\nVirtualFile[] vFiles = ProjectRootManager.getInstance(project).getContentSourceRoots();\nString sourceRootsList = Arrays.stream(vFiles).map(VirtualFile::getUrl).collect(Collectors.joining(\"\\n\"));\nMessages.showInfoMessage(\"Source roots for the \" + projectName + \" plugin:\\n\" + sourceRootsList, \"Project Properties\");\n</code></pre>"},{"location":"reference_guide/project_model/project/#checking-if-a-file-belongs-to-a-project","title":"Checking if a File Belongs to a Project","text":"<p>Use <code>ProjectFileIndex</code> to get this information:</p> <pre><code>ProjectFileIndex projectFileIndex = ProjectRootManager.getInstance(project).getFileIndex();\n</code></pre>"},{"location":"reference_guide/project_model/project/#getting-the-content-or-source-root-to-which-the-a-file-or-directory-belongs","title":"Getting the Content or Source Root to Which the a File or Directory Belongs","text":"<p>Use the <code>ProjectFileIndex.getContentRootForFile()</code> and <code>ProjectFileIndex.getSourceRootForFile()</code> methods. For example:</p> <pre><code>VirtualFile moduleContentRoot = ProjectRootManager.getInstance(project).getFileIndex().getContentRootForFile(virtualFileOrDirectory);\nVirtualFile moduleSourceRoot = ProjectRootManager.getInstance(project).getFileIndex().getSourceRootForFile(virtualFileOrDirectory);\n</code></pre> <p>Note that this method returns <code>null</code> if the file or directory does not belong to any source root of modules in the project.</p>"},{"location":"reference_guide/project_model/project/#checking-whether-a-file-or-directory-is-related-to-the-project-libraries","title":"Checking Whether a File or Directory Is Related to the Project Libraries","text":"<p>The <code>ProjectFileIndex</code> interface implements a number of methods you can use to check whether the specified file belongs to the project library classes or library sources: * <code>isLibraryClassFile()</code>: Returns <code>true</code> if the specified <code>virtualFile</code> is a compiled class file. * <code>isInLibraryClasses()</code>: Returns <code>true</code> if the specified <code>virtualFileOrDirectory</code> belongs to library classes. * <code>isInLibrarySource()</code>: Returns <code>true</code> if the specified <code>virtualFileOrDirectory</code> belongs to library sources.</p>"},{"location":"reference_guide/project_model/project/#getting-the-project-sdk","title":"Getting the Project SDK","text":"<p>Note that by default, the project modules use the project SDK. Optionally, you can configure an individual SDK for each module. See SDK for more details.</p>"},{"location":"reference_guide/project_model/project/#changing-the-project-structure","title":"Changing the Project Structure","text":"<p>Utility classes used for modifying the project structure can be found in the package <code>projectModel-impl.openapi</code>. Its <code>roots</code> subpackage contains instances and utilities intended for work with project and module source roots, including <code>ModuleRootModificationUtil</code> and <code>ProjectRootUtil</code>. Project structure changes need to be performed in a write action.</p> <p>Refer to the project_model code sample to learn how project structure modification can be implemented.</p>"},{"location":"reference_guide/project_model/project/#receiving-notifications-about-project-structure-changes","title":"Receiving Notifications About Project Structure Changes","text":"<p>To receive notifications about changes in project structure (modules or libraries being added or removed, module dependencies being changed, and so on), use the message bus and the <code>ProjectTopics.PROJECT_ROOTS</code> topic:</p> <pre><code>project.getMessageBus().connect().subscribe(ProjectTopics.PROJECT_ROOTS, new ModuleRootListener() {\n  @Override\n  public void rootsChanged(ModuleRootEvent event) {\n  }\n});\n</code></pre> <p>The event only notifies that something has changed; if more details are needed about what changes have occurred, keep a copy of the state of the project structure model which is relevant, and to compare it with the state after the change.</p>"},{"location":"reference_guide/project_model/sdk/","title":"SDK","text":"<p>Every project uses a Software Development Kit (SDK). For Java projects, the SDK is referred to as the JDK (Java Development Kit). The SDK determines which API library is used to build the project. If a project is multi-module, the project SDK by default is common for all modules within the project. Optionally, individual SDKs for each module can be configured. For more information about SDKs, see SDK in the IntelliJ IDEA Web Help.</p>"},{"location":"reference_guide/project_model/sdk/#getting-project-sdk-information","title":"Getting Project SDK Information","text":"<p>The information about the project SDK is accessed via <code>ProjectRootManager</code> like the following example shows</p> <pre><code>Sdk projectSdk = ProjectRootManager.getInstance(project).getProjectSdk();\n</code></pre>"},{"location":"reference_guide/project_model/sdk/#getting-and-setting-project-sdk-attributes","title":"Getting and Setting Project SDK Attributes","text":"<ul> <li>To get the project level SDK</li> </ul> <pre><code>Sdk projectSDK = ProjectRootManager.getInstance(project).getProjectSdk();\n</code></pre> <ul> <li>To get the project level SDK name:</li> </ul> <pre><code>String projectSDKName = ProjectRootManager.getInstance(project).getProjectSdkName();\n</code></pre> <ul> <li>To set the project level SDK:</li> </ul> <pre><code>ProjectRootManager.getInstance(project).setProjectSdk(Sdk jdk);\n</code></pre> <ul> <li>To set the project level SDK name:</li> </ul> <pre><code>ProjectRootManager.getInstance(project).setProjectSdkName(String name);\n</code></pre> <p>See the project_model code sample to get more familiar with SDK manipulation toolset.</p>"},{"location":"reference_guide/project_model/sdk/#available-sdks","title":"Available SDKs","text":"<p><code>ProjectJdkTable</code> can be used to query and modify configured SDKs.</p>"},{"location":"reference_guide/project_model/sdk/#working-with-a-custom-sdk","title":"Working with a Custom SDK","text":"<p>To create a custom SDK, provide a class extending <code>SdkType</code>, leave <code>saveAdditionalData()</code> blank, and register it in the <code>com.intellij.sdkType</code> extension point.</p> <p>To make SDK settings persistent, override <code>setupSdkPaths()</code> and save settings by <code>modificator.commitChanges()</code>:</p> <pre><code>@Override\npublic boolean setupSdkPaths(@NotNull Sdk sdk, @NotNull SdkModel sdkModel) {\n    SdkModificator modificator = sdk.getSdkModificator();\n    modificator.setVersionString(getVersionString(sdk));\n    modificator.commitChanges(); // save\n    return true;\n}\n</code></pre> <p>To let a user select an SDK, see <code>ProjectJdksEditor</code>.</p> <p>However, it is not recommended to use \"SDK\" in non-IntelliJ IDEA IDEs. Although \"SDK\" is available in most JetBrains products, <code>ProjectJdksEditor</code> is specific to Java, making the operation around \"SDK\" difficult. The recommended way of managing \"SDK\" settings is to create a <code>CustomStepProjectGenerator</code> implementation and save settings in a <code>PersistentStateComponent</code>.</p>"},{"location":"reference_guide/project_model/sdk/#assisting-in-setting-up-an-sdk","title":"Assisting in Setting Up an SDK","text":"<p>Register the implementation of <code>ProjectSdkSetupValidator</code> in extension point <code>com.intellij.projectSdkSetupValidator</code> to provide quick fix.</p>"},{"location":"tutorials/action_system/","title":"IntelliJ Action System Tutorial","text":"<p>This tutorial leads you through a series of steps which show how to create, register, and customize custom actions and action groups. By registering actions, you can add your own menu items, toolbar buttons and keyboard shortcuts to the IDE user interface. * Creating Actions * Grouping Actions</p> <p>The source code for the <code>action_basics</code> code sample is used throughout this tutorial.</p>"},{"location":"tutorials/build_system/","title":"Building Plugins with Gradle","text":"<p>The gradle-intellij-plugin Gradle plugin is the recommended solution for building IntelliJ plugins. The plugin takes care of the dependencies of your plugin project - both the base IDE and other plugin dependencies.</p> <p>TIP Consulo Plugin Template makes it easier to create and maintain your IDE plugins, having the Gradle plugin already integrated and CI covered with GitHub Actions.</p> <p>NOTE If a new plugin will be Scala-based, a dedicated SBT plugin sbt-idea-plugin is available.</p> <p>The gradle-intellij-plugin provides tasks to run the IDE with your plugin and to publish your plugin to the JetBrains Plugins Repository. To make sure that your plugin is not affected by API changes, which may happen between major releases of the platform, you can quickly build your plugin against many versions of the base IDE.</p> <p>WARNING When adding additional repositories to your Gradle build script, always use HTTPS protocol.</p> <p>NOTE Please make sure to always upgrade to the latest version of <code>gradle-intellij-plugin</code>. Follow releases on GitHub.</p> <p>Below are a series of guides to developing and deploying Gradle-based Consulo Plugins:</p> <ul> <li>Getting Started with Gradle</li> <li>Configuring Gradle Projects</li> <li>Publishing Plugins with Gradle</li> </ul>"},{"location":"tutorials/code_inspections/","title":"Code Inspections","text":"<p>The Consulo provides tools designed for static code analysis called code inspections, which help the user maintain and clean up code without actually executing it. Custom code inspections can be implemented as Consulo plugins. Examples of the plugin approach are the Consulo SDK code samples inspection_basics and comparing_references_inspection. In addition, the comparing_references_inspection code sample demonstrates implementing a unit test.</p> <p>You can also create custom inspections through the IntelliJ IDEA user interface. See Code Inspection and Creating Custom Inspections for more information.</p> <p>See Inspections topic in Consulo UI Guidelines on naming, writing description, and message texts for inspections.</p>"},{"location":"tutorials/code_inspections/#creating-an-inspection-plugin","title":"Creating an Inspection Plugin","text":"<p>The comparing_references_inspection code sample adds a new inspection to the Java | Probable Bugs group in the Inspections list. The inspection reports when the <code>==</code> or <code>!=</code> operator is used between Java expressions of reference types. It illustrates the components for a custom inspection plugin: * Describing an inspection in the plugin configuration file. * Implementing a local inspection class to inspect Java code in the Consulo-based IDE editor. * Creating a visitor to traverse the PSI tree of the Java file being edited, inspecting for problematic syntax. * Implementing a quick fix class to correct syntax problems by altering the PSI tree as needed.   Quick fixes are displayed to the user like intentions. * Implementing an inspection preferences panel to display information about the inspection. * Writing an HTML description of the inspection for display in the inspection preferences panel. * Optionally, create a unit test for the plugin.</p> <p>Although the Consulo SDK code samples illustrate implementations of these components, it is often useful to see examples of inspections implemented in the intellij_community code base. This process can help find inspection descriptions and implementations based on what is visible in the IDE UI. The overall approach works for inspections aimed at other languages as well. * Find an existing inspection that is similar to the one you want to implement in the Preferences | Editor | Inspections panel.   Note the display name of the inspection.   For example, the Java/Probable Bugs inspection \"Object comparison using '==', instead of 'equals()'\" is very similar to <code>comparing_references_inspection</code>. * Use the display name text as the target for a search within the intellij_community project.   This will identify a bundle file if the display name is localized.   If it is not localized, the search finds either the plugin configuration (<code>plugin.xml</code>) file where it is an attribute in the inspection description, or the implementation where it is provided by an overridden method. * In the case of localization, copy the key from the bundle file identified by the search.   * Use the key text as the target for a search within the intellij_community project.     This search locates the plugin configuration file that describes the inspection.   * From the inspection description entry find the <code>implementationClass</code> attribute value. * Use the <code>implementationClass</code> text as the target of a class search in the intellij_community codebase to find the implementation.</p>"},{"location":"tutorials/code_inspections/#creating-an-inspection","title":"Creating an Inspection","text":"<p>The comparing_references_inspection code sample reports when the <code>==</code> or <code>!=</code> operators are used between Java expressions of reference types. The user can apply a quick fix to change <code>a==b</code> to <code>a.equals(b)</code>, or <code>a!=b</code> to <code>!a.equals(b)</code>.</p> <p>The details of the <code>comparing_references_inspection</code> implementation illustrate the components of an inspection plugin.</p>"},{"location":"tutorials/code_inspections/#plugin-configuration-file","title":"Plugin Configuration File","text":"<p>The <code>comparing_references_inspection</code> is described as a <code>&lt;localInspection&gt;</code> extension point in the <code>comparing_references_inspection</code> plugin configuration (<code>plugin.xml</code>) file.</p> <p>There exist two types of inspection extensions: * The <code>com.intellij.localInspection</code> extension point is used for inspections that operate on one file at a time, and also operate \"on-the-fly\" as the user edits the file. * The <code>com.intellij.globalInspection</code> extension point is used for inspections that operate across multiple files, and the associated fix might, for example, refactor code between files.</p> <p>The minimum inspection description must contain the <code>implementationClass</code> attribute. As shown in the <code>comparing_references_inspection</code> plugin configuration file, other attributes can be defined in the <code>localInspection</code> element, either with or without localization. In most cases, it is simplest to define the attributes in the plugin configuration file because the underlying parent classes handle most of the class responsibilities based on the configuration file description. Note that some attributes are not displayed to the user, so they are never localized.</p> <p>If required, inspections can define all of the attribute information (except <code>implementationClass</code>) by overriding methods in the inspection implementation class (not recommended in general).</p>"},{"location":"tutorials/code_inspections/#inspection-implementation-java-class","title":"Inspection Implementation Java Class","text":"<p>Inspection implementations for Java files, like <code>ComparingReferencesInspection</code>, are often based on the Java class <code>AbstractBaseJavaLocalInspectionTool</code>. The <code>AbstractBaseJavaLocalInspectionTool</code> implementation class offers methods to inspect Java classes, fields, and methods.</p> <p>More generally, <code>localInspection</code> types are based on the class <code>LocalInspectionTool</code>. Examining the class hierarchy for <code>LocalInspectionTool</code> shows that the Consulo provides many child inspection classes for a variety of languages and frameworks. One of these classes is a good basis for a new inspection implementation, but a bespoke implementation can also be based directly on <code>LocalInspectionTool</code>.</p> <p>The primary responsibilities of the inspection implementation class are to provide: * A <code>PsiElementVisitor</code> object to traverse the PSI tree of the file being inspected. * A <code>LocalQuickFix</code> class to change the syntax of an identified problem. * A <code>JPanel</code> to be displayed in the Inspections dialog.</p> <p>The <code>ComparingReferencesInspection</code> class defines two <code>String</code> fields: * <code>QUICK_FIX_NAME</code> defines the string users see when prompted to apply the quick fix. * <code>CHECKED_CLASSES</code> holds a list of class names of interest to the inspection.</p> <p>The overridden <code>ComparingReferencesInspection</code> methods are discussed in the sections below.</p>"},{"location":"tutorials/code_inspections/#visitor-implementation-class","title":"Visitor Implementation Class","text":"<p>The visitor class evaluates whether elements of the file's PSI tree are of interest to an inspection.</p> <p>The <code>ComparingReferencesInspection.buildVisitor()</code> method creates an anonymous visitor class based on <code>JavaElementVisitor</code> to traverse the PSI tree of the Java file being edited, inspecting for suspect syntax. The anonymous class overrides three methods in particular. * <code>visitReferenceExpression()</code> to prevent any duplicate visitation of reference-type expressions. * <code>visitBinaryExpression()</code>, which does all the heavy lifting.   It is called to evaluate a <code>PsiBinaryExpression</code>, and it checks to see if the operands are <code>==</code> or <code>!=</code>, and if the operands are classes relevant to this inspection. * <code>isCheckedType()</code> evaluates the <code>PsiType</code> of the operands to determine if they are of interest to this inspection.</p>"},{"location":"tutorials/code_inspections/#quick-fix-implementation","title":"Quick Fix Implementation","text":"<p>The quick fix class acts much like an intention, allowing the user to invoke it on the <code>PsiElement</code> (or <code>TextRange</code>) highlighted by the inspection.</p> <p>The <code>ComparingReferencesInspection</code> implementation uses the nested class <code>CriQuickFix</code> to implement a quick fix based on <code>LocalQuickFix</code>. The <code>CriQuickFix</code> class gives a user the option to change the use of <code>a == b</code> and <code>a != b</code> expression to <code>a.equals(b)</code> and <code>!a.equals(b)</code> respectively.</p> <p>The heavy lifting is done in <code>CriQuickFix.applyFix()</code>, which manipulates the PSI tree to convert the expressions. The change to the PSI tree is accomplished by the usual approach to modification: * Getting a <code>PsiElementFactory</code>. * Creating a new <code>PsiMethodCallExpression</code>. * Substituting the original left and right operands into the new <code>PsiMethodCallExpression</code>. * Replacing the original binary expression with the <code>PsiMethodCallExpression</code>.</p>"},{"location":"tutorials/code_inspections/#inspection-preferences-panel","title":"Inspection Preferences Panel","text":"<p>The inspection preferences panel is used to display information and provide additional options for the inspection.</p> <p>The panel created by <code>ComparingReferencesInspection.createOptionsPanel()</code> just defines a single <code>JTextField</code> to display in a <code>JPanel</code>. This <code>JPanel</code> gets added to the default Consulo Inspections Preferences dialog when the <code>comparing_references_inspection</code> short name is selected. The <code>JTextField</code> allows editing of the <code>CHECKED_CLASSES</code> field while displayed in the panel.</p> <p>Note that the Consulo provides most of the UI displayed in the Inspections Preferences panel. As long as the inspection attributes and inspection description are defined correctly, the Consulo displays the information in the Inspections Preferences UI.</p>"},{"location":"tutorials/code_inspections/#inspection-description","title":"Inspection Description","text":"<p>The inspection description is an HTML file. The description is displayed in the upper right panel of the Inspections Preferences dialog when an inspection is selected from the list.</p> <p>Implicit in using <code>LocalInspectionTool</code> in the class hierarchy of the inspection implementation means following some conventions. * The inspection description file is expected to be located under <code>&lt;resources root&gt;/inspectionDescriptions/</code>.   If the inspection description file is to be located elsewhere, override <code>getDescriptionUrl()</code> in the inspection implementation class. * The name of the description file is expected to be the inspection <code>&lt;short name&gt;.html</code> as provided by the inspection description, or the inspection implementation class.   If a short name is not provided by the plugin, the Consulo computes one by removing <code>Inspection</code> suffix from the implementation class name.</p>"},{"location":"tutorials/code_inspections/#inspection-unit-test","title":"Inspection Unit Test","text":"<p>NOTE Please note that running the test requires setting system property <code>idea.home.path</code> in <code>test {}</code> block of <code>build.gradle</code></p> <p>The <code>comparing_references_inspection</code> code sample provides a unit test for the inspection. See the Testing Plugins section for general information about plugin testing.</p> <p>The <code>comparing_references_inspection</code> test is based on the <code>UsefulTestCase</code> class, part of the JUnit framework APIs. This class handles much of the underlying boilerplate for tests.</p> <p>By convention, the folder <code>&lt;project root&gt;/testData/</code> contains the test files. The folder contains pairs of files for each test using the name convention <code>*.java</code> and <code>*.after.java</code>.</p> <p>In the case of <code>comparing_references_inspection</code> the test files are <code>Eq.java</code> / <code>Eq.after.java</code>, and <code>Neq.java</code> / <code>Neq.after.java</code>.</p> <p>The <code>comparing_references_inspection</code> tests run the inspection on the <code>*.java</code> files, implement the quick fix, and compare the results with the respective <code>*.after.java</code> files.</p>"},{"location":"tutorials/code_inspections/#running-the-comparing-references-inspection-code-sample","title":"Running the Comparing References Inspection Code Sample","text":"<p>The comparing_references_inspection code sample adds a new inspection to the Java | Probable Bugs group in the Inspections list. The inspection reports when the <code>==</code> or <code>!=</code> operator is used between Java expressions of reference types.</p> <p>To run the sample plugin: * Start IntelliJ IDEA, open the <code>intellij-sdk-docs</code> project, and highlight the comparing_references_inspection module. * Open the Project Structure dialog and ensure that the project settings are valid for your environment. * If necessary, modify the Run/Debug Configurations for the <code>comparing_references_inspection</code> module. * Run the plugin by choosing Run on the main menu.</p>"},{"location":"tutorials/code_inspections/#configuring-the-plugin","title":"Configuring the Plugin","text":"<p>Once the plugin is launched, you can set the plugin options. You can specify the Java classes to participate in the code inspection and the severity level of the found probable bugs.</p> <p>On the main menu, open the Preferences | Editor | Inspections dialog. In the list of the IntelliJ IDEA Java inspections, expand the Probable bugs node, and then click SDK: '==' or '!=' instead of 'equals()'.</p> <p></p> <p>Under Options, you can specify the following plugin settings: * From the Severity list, select the severity level of probable bugs the plugin finds such as Warning, Info, etc. * In the text box under Severity, specify the semicolon separated list of Java classes to participate in this code inspection. * When finished, click OK.</p>"},{"location":"tutorials/code_inspections/#how-does-it-work","title":"How does it work?","text":"<p>The plugin inspects your code opened in the IntelliJ IDEA editor or the code you are typing. The plugin highlights the code fragments where two variables of the reference type are separated by <code>==</code> or <code>!=</code> and proposes to replace this code fragment with <code>.equals()</code>:</p> <p></p> <p>In this example, the <code>str1</code> and <code>str2</code> are variables of the String type. Clicking SDK: Use equals() replaces:</p> <pre><code>return (str1==str2);\n</code></pre> <p>with the code:</p> <pre><code>return (str1.equals(str2));\n</code></pre>"},{"location":"tutorials/code_intentions/","title":"Code Intentions","text":"<p>This topic describes the conditional_operator_intention, a sample plugin that adds a new intention action to the Consulo Intentions list. In addition, the sample plugin contains a JUnit-based test.</p>"},{"location":"tutorials/code_intentions/#about-intention-actions","title":"About Intention Actions","text":"<p>The Consulo analyzes your code and helps handle situations that may result in errors. When a possible problem is suspected, the IDE suggests an appropriate intention action, denoted with special icons. For more information, refer to Intention Actions in the IntelliJ IDEA Web Help.</p> <p>You can view a list of all available intention actions using the Intention List provided by the IDE.</p> <p>To display Intention List</p> <ol> <li>Open the Settings dialog box.</li> <li>Under IDE Settings, click Intentions. This displays the list of all intention actions currently available in IntelliJ IDEA.</li> <li>The intention actions are grouped according to the areas of their use.</li> <li>To enable/disable an intention action, select/deselect the check box to its left.</li> </ol>"},{"location":"tutorials/code_intentions/#techniques-used","title":"Techniques Used","text":"<p>The conditional_operator_intention sample plugin illustrates the use of the following techniques:</p> <ul> <li>How to analyze a PSI tree.</li> <li>How to find a Java token of interest in the PSI tree.</li> <li>How to invoke a quick fix action for a token element under cursor using the <code>PsiElementBaseIntentionAction</code> class.</li> <li>How to create a JUnit test for this plugin using the <code>IdeaTestFixtureFactory</code> class.</li> </ul>"},{"location":"tutorials/code_intentions/#sample-plugin","title":"Sample Plugin","text":"<p>The ConditionalOperatorConverter sample plugin is available in the <code>&lt;%IntelliJ SDK Docs project%&gt;/code_samples/conditional_operator_intention</code> directory. When launched, this plugin adds the Convert ternary operator if statement item to the Conditional Operator node in the IDEA Intentions list:</p> <p></p>"},{"location":"tutorials/code_intentions/#running-the-plugin","title":"Running the Plugin","text":"<p>To run the sample plugin</p> <ol> <li>Start IntelliJ IDEA and open the conditionalOperatorConvertor plugin project saved into the <code>&lt;%IntelliJ SDK Docs project%&gt;/code_samples/conditional_operator_intention</code> directory.</li> <li>Open the Project Structure dialog and ensure that the project settings are valid for your environment.</li> <li>If necessary, modify the Run/Debug Configurations and Run the plugin by choosing the Run on the main menu.</li> </ol>"},{"location":"tutorials/code_intentions/#how-does-it-work","title":"How does it work?","text":"<p>The plugin analyzes symbols under the cursor in your code opened in the IDEA editor. If the cursor is positioned on the \"?\" conditional operator, IntelliJ IDEA proposes to replace this conditional (ternary) operator with the \"if-then-else\" statement:</p> <p></p> <p>In this example, the code:</p> <pre><code>return (n&gt;=0) ? n : -n;\n</code></pre> <p>will be replaced with the code:</p> <pre><code>if ((n&gt;=0)) {\n    return n;\n} else {\n    return -n;\n}\n</code></pre>"},{"location":"tutorials/code_intentions/#testing-the-plugin","title":"Testing the Plugin","text":"<p>NOTE Please note that running the test requires setting system property <code>idea.home.path</code> in <code>test {}</code> block of <code>build.gradle</code></p> <p>The sample plugin contains the <code>ConditionalOperatorConverterTest</code> Java class and the test data in the <code>test/testData/</code> directory. To perform the plugin test, run the <code>ConditionalOperatorConverterTest.testIntention()</code> method.</p> <p>For detailed information about testing and all related procedures, refer to Testing in the IntelliJ IDEA Web Help.</p>"},{"location":"tutorials/custom_language_support_tutorial/","title":"Custom Language Support Tutorial","text":"<p>In this tutorial we will add support for a .properties language and its usages within Java code.</p> <p>TIP Consulo support for custom languages is discussed in more depth in the Custom Language Support section. Corresponding parts are linked under \"Reference\" on top of each page in this tutorial.</p> <p>The example plugin used in this tutorial is the <code>simple_language_plugin</code> code sample. This a step-by-step tutorial, and it requires completing each step, in order:</p> <ul> <li>1. Prerequisites</li> <li>2. Language and File Type</li> <li>3. Grammar and Parser</li> <li>4. Lexer and Parser Definition</li> <li>5. Syntax Highlighter and Color Settings Page</li> <li>6. PSI Helpers and Utilities</li> <li>7. Annotator</li> <li>8. Line Marker Provider</li> <li>9. Completion Contributor</li> <li>10. Reference Contributor</li> <li>11. Find Usages Provider</li> <li>12. Folding Builder</li> <li>13. Go To Symbol Contributor</li> <li>14. Structure View Factory</li> <li>15. Formatter</li> <li>16. Code Style Settings</li> <li>17. Commenter</li> <li>18. Quick Fix</li> </ul>"},{"location":"tutorials/editor_basics/","title":"Basics of Working with the Editor","text":"<p>This tutorial will lead you through the series of steps showing how to work with the Consulo Editor, how to access and modify text it contains, and how to handle events sent to the editor. * 1. Working With Text * 2. Editor coordinate systems: positions and offsets * 3. Handling Editor Events</p> <p>Note: The part of the API described in this tutorial only allows operations with text. For operations that require access to the PSI please see the PSI Cookbook section.</p> <p>See also: The following are referenced in the tutorial: * The editor_basics plugin code sample, * editor-ui-api package, * Those not found in editor-ui-api package:   * <code>EditorActionManager</code>,   * <code>EditorActionHandler</code>,   * <code>TypedActionHandler</code>,   * <code>TypedAction</code>.</p> <p>Related topics: * Action System * Threading Issues</p>"},{"location":"tutorials/github_template/","title":"Consulo Plugin Template","text":"<p>Consulo Plugin Template is a repository that provides a pure boilerplate template to make it easier to create a new plugin project using the recommended Gradle setup.</p> <p>The main goal of this template is to speed up the setup phase of plugin development for both new and experienced developers by preconfiguring the project scaffold and CI, linking to the proper documentation pages, and keeping everything organized.</p> <p>GitHub Template allows you to create a new repository from the scaffold without having to copy and paste content, clone repositories, or clear the history manually. All you have to do is click the Use this template button on the GitHub project page. After that, the GitHub Actions workflow will be triggered to override or remove any template-specific configurations, such as the plugin name, current changelog, etc.</p> <p>Once this is complete, the project is ready to be cloned to your local environment and opened with IntelliJ IDEA.</p> <p>For more details, please refer to the Consulo Plugin Template project documentation.</p>"},{"location":"tutorials/live_templates/","title":"Live Templates","text":"<p>Live Templates are customizable rules that allow developers to abbreviate repetitive patterns of text in the editor. When a user types the designated abbreviation followed by a configurable expansion key (usually <code>Tab</code>), the IDE transforms the preceding input sequence to its full-length output, and update the cursor position.</p> <p>For example, consider a <code>for</code> loop. Typically, the end user would need to type <code>for (int i = 0; i &lt; 10; i++) {&lt;Enter&gt;&lt;Tab&gt;&lt;Enter&gt;&lt;Enter&gt;}&lt;Up&gt;</code>. This pattern may be shortened to <code>fori&lt;Tab&gt;</code> and the remaining contents will be expanded, leaving the following structure:</p> <pre><code>for (int i = [|]; i &lt; []; i++) {\n    []\n}\n</code></pre> <p>As the user completes each section of the <code>for</code> loop and presses <code>Tab</code>, the cursor advances to the next position in the editor. For more information about creating Custom Live Templates, refer to the corresponding documentation.</p> <p>These sections describe how to add Live Templates, and their associated building blocks, to plugins.  * Adding Live Templates to a Plugin  * Creating New Functions for Live Templates  * Surround Templates</p>"},{"location":"tutorials/run_configurations/","title":"Run Configurations","text":"<p>These series of steps show how to register and implement a simple Run Configuration. Run Configurations are used to run internal and external processes from within Consulo based products. To get familiar with the concept of a Run Configuration refer Run/Debug Configuration section of  IntelliJ IDEA Web Help</p>"},{"location":"tutorials/run_configurations/#pre-requirements","title":"Pre-Requirements","text":"<p>Create an empty plugin project as described in Creating a Plugin Project.</p>"},{"location":"tutorials/run_configurations/#1-register-a-new-configurationtype","title":"1. Register a New ConfigurationType","text":"<p>Add new <code>configurationType</code> extension to the plugin.xml</p> <pre><code>&lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n  &lt;configurationType implementation=\"org.jetbrains.sdk.runConfiguration.DemoRunConfigurationType\"/&gt;\n&lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/run_configurations/#2-implement-configurationtype","title":"2. Implement ConfigurationType","text":"<p>Implement  <code>ConfigurationType</code>  interface registered in the Step 1.</p> <pre><code>public class DemoRunConfigurationType implements ConfigurationType {\n    @Override\n    public String getDisplayName() {\n        return \"Demo\";\n    }\n\n    @Override\n    public String getConfigurationTypeDescription() {\n        return \"Demo Run Configuration Type\";\n    }\n\n    @Override\n    public Icon getIcon() {\n        return AllIcons.General.Information;\n    }\n\n    @NotNull\n    @Override\n    public String getId() {\n        return \"DemoRunConfiguration\";\n    }\n\n    @Override\n    public ConfigurationFactory[] getConfigurationFactories() {\n        return new ConfigurationFactory[]{new DemoConfigurationFactory(this)};\n    }\n}\n</code></pre>"},{"location":"tutorials/run_configurations/#3-implement-a-configurationfactory","title":"3. Implement a ConfigurationFactory","text":"<p>Implement a new <code>ConfigurationFactory</code> through which custom run configurations will be created.</p> <pre><code>public class DemoConfigurationFactory extends ConfigurationFactory {\n    private static final String FACTORY_NAME = \"Demo configuration factory\";\n\n    protected DemoConfigurationFactory(ConfigurationType type) {\n        super(type);\n    }\n\n    @Override\n    public RunConfiguration createTemplateConfiguration(Project project) {\n        return new DemoRunConfiguration(project, this, \"Demo\");\n    }\n\n    @Override\n    public String getName() {\n        return FACTORY_NAME;\n    }\n}\n</code></pre>"},{"location":"tutorials/run_configurations/#4-implement-a-run-configuration","title":"4. Implement a Run Configuration","text":"<p>To make your changes visible from the UI, implement a new Run Configuration.</p> <p>Note: In most of the cases you can derive a custom Run Configuration class from the <code>RunConfigurationBase</code>. If you need to implement specific settings externalization rules and I/O behaviour, use <code>RunConfiguration</code> interface.</p> <pre><code>public class DemoRunConfiguration extends RunConfigurationBase {\n    protected DemoRunConfiguration(Project project, ConfigurationFactory factory, String name) {\n        super(project, factory, name);\n    }\n\n    @NotNull\n    @Override\n    public SettingsEditor&lt;? extends RunConfiguration&gt; getConfigurationEditor() {\n        return new DemoSettingsEditor();\n    }\n\n    @Override\n    public void checkConfiguration() throws RuntimeConfigurationException {\n\n    }\n\n    @Nullable\n    @Override\n    public RunProfileState getState(@NotNull Executor executor, @NotNull ExecutionEnvironment executionEnvironment) throws ExecutionException {\n        return null;\n    }\n}\n</code></pre>"},{"location":"tutorials/run_configurations/#5-create-and-implement-run-configuration-ui-form","title":"5. Create and Implement Run Configuration UI Form","text":"<p>Make sure UI Designer plugin is enabled.</p> <p>Create a new  UI form  that defines, how an inner part of the new Run Configuration should look like.</p> <p>Default Run Configuration will be looking like this:</p> <p></p>"},{"location":"tutorials/run_configurations/#6-bind-the-ui-form","title":"6. Bind the UI Form","text":"<p>The UI Form should be bound with a Java class responsible for handling UI components logic.</p> <pre><code>public class DemoSettingsEditor extends SettingsEditor&lt;DemoRunConfiguration&gt; {\n    private JPanel myPanel;\n    private LabeledComponent&lt;ComponentWithBrowseButton&gt; myMainClass;\n\n    @Override\n    protected void resetEditorFrom(DemoRunConfiguration demoRunConfiguration) {\n\n    }\n\n    @Override\n    protected void applyEditorTo(DemoRunConfiguration demoRunConfiguration) throws ConfigurationException {\n\n    }\n\n    @NotNull\n    @Override\n    protected JComponent createEditor() {\n        return myPanel;\n    }\n\n    private void createUIComponents() {\n        myMainClass = new LabeledComponent&lt;ComponentWithBrowseButton&gt;();\n        myMainClass.setComponent(new TextFieldWithBrowseButton());\n    }\n}\n</code></pre>"},{"location":"tutorials/run_configurations/#7-compile-and-run-the-plugin","title":"7. Compile and Run the Plugin","text":"<p>Refer to Running and Debugging a Plugin.</p> <p>After going through the steps described above you can create a custom Run Configuration from your plugin.</p> <p></p>"},{"location":"tutorials/settings_tutorial/","title":"Settings Tutorial","text":""},{"location":"tutorials/settings_tutorial/#introduction","title":"Introduction","text":"<p>As discussed in the Settings Guide, plugins can add Settings to Consulo-based IDEs. The IDE displays the Settings in response to a user choosing Settings/Preferences. Custom Settings are displayed and function just like those native to the IDE.</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/settings_tutorial/#overview-of-a-custom-settings-implementation","title":"Overview of a Custom Settings Implementation","text":"<p>Using the SDK code sample <code>settings</code>, this tutorial illustrates the steps to create custom Application-level Settings. Many Consulo Settings implementations use fewer classes, but the <code>settings</code> code sample factors the functionality into three classes for clarity: * The <code>AppSettingsConfigurable</code> is analogous to a Controller in the MVC model - it interacts with the other two Settings classes and the Consulo, * The <code>AppSettingsState</code> is like a Model because it stores the Settings persistently, * The <code>AppSettingsComponent</code> is similar to a View because it displays and captures edits to the values of the Settings.</p> <p>The structure of the implementation is the same for Project Settings, but there are minor differences in the <code>Configurable</code> implementation and Extension Point (EP) declaration.</p>"},{"location":"tutorials/settings_tutorial/#the-appsettingsstate-class","title":"The AppSettingsState Class","text":"<p>The <code>AppSettingsState</code> class persistently stores the custom Settings. It is based on the Consulo Persistence Model.</p>"},{"location":"tutorials/settings_tutorial/#declaring-appsettingsstate","title":"Declaring AppSettingsState","text":"<p>Given a Light Service is not used, the persistent data class must be declared as a Service EP in the <code>plugin.xml</code> file. If these were Project Settings, the <code>com.intellij.projectService</code> EP would be used. However, because these are Application Settings, the <code>com.intellij.applicationService</code> EP is used with the FQN of the implementation class:</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;applicationService serviceImplementation=\"org.intellij.sdk.settings.AppSettingsState\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/settings_tutorial/#creating-the-appsettingstate-implementation","title":"Creating the AppSettingState Implementation","text":"<p>As discussed in Implementing the PersistentStateComponent Interface, <code>AppSettingsState</code> uses the pattern of implementing <code>PersistentStateComponent</code> itself:</p> <pre><code>{% include /code_samples/settings/src/main/java/org/intellij/sdk/settings/AppSettingsState.java %}\n</code></pre>"},{"location":"tutorials/settings_tutorial/#storage-annotation","title":"Storage Annotation","text":"<p>The <code>@State</code> annotation, located just above the class declaration, defines the data storage location. For <code>AppSettingsState</code>, the data <code>name</code> parameter is the FQN of the class. Using FQN is a best practice to follow, and is required if custom data gets stored in the standard project or workspace files.</p> <p>The <code>storages</code> parameter utilizes the <code>@Storage</code> annotation to define a custom file name for the <code>AppSettingsState</code> data. In this case, the file is located in the <code>options</code> directory of the configuration directory for the IDE.</p>"},{"location":"tutorials/settings_tutorial/#persistent-data-fields","title":"Persistent Data Fields","text":"<p>The <code>AppSettingState</code> implementation has two public fields: a <code>String</code> and a <code>boolean</code>. Conceptually these fields hold the name of a user, and whether that person is an IntelliJ IDEA user, respectively. See Implementing the State Class for more information about how <code>PersistentStateComponent</code> serializes public fields.</p>"},{"location":"tutorials/settings_tutorial/#appsettingstate-methods","title":"AppSettingState Methods","text":"<p>The fields are so limited and straightforward for this class that encapsulation is not used for simplicity. All that's needed for functionality is to override the two methods called by the Consulo when a new component state is loaded (<code>PersistentStateComponent.loadState()</code>), and when a state is saved (<code>PersistentStateComponent.getState()</code>). See <code>PersistentStateComponent</code> for more information about these methods.</p> <p>One static convenience method has been added - <code>AppSettingState.getInstance()</code> - which allows <code>AppSettingsConfigurable</code> to easily acquire a reference to <code>AppSettingState</code>.</p>"},{"location":"tutorials/settings_tutorial/#the-appsettingscomponent-class","title":"The AppSettingsComponent Class","text":"<p>The role of the <code>AppSettingsComponent</code> is to provide a <code>JPanel</code> for the custom Settings to the IDE Settings Dialog. The <code>AppSettingsComponent</code> has-a <code>JPanel</code>, and is responsible for its lifetime. The <code>AppSettingsComponent</code> is instantiated by <code>AppSettingsConfigurable</code>.</p>"},{"location":"tutorials/settings_tutorial/#creating-the-appsettingscomponent-implementation","title":"Creating the AppSettingsComponent Implementation","text":"<p>The <code>AppSettingsComponent</code> defines a <code>JPanel</code> containing a <code>JBTextField</code> and a <code>JBCheckBox</code> to hold and display the data that maps to the data fields of <code>AppSettingsState</code>:</p> <pre><code>{% include /code_samples/settings/src/main/java/org/intellij/sdk/settings/AppSettingsComponent.java %}\n</code></pre>"},{"location":"tutorials/settings_tutorial/#appsettingscomponent-methods","title":"AppSettingsComponent Methods","text":"<p>The constructor builds the <code>JPanel</code> using the convenient <code>FormBuilder</code>, and saves a reference to the <code>JPanel</code>. The rest of the class are simple accessors and mutators to encapsulate the UI components used on the <code>JPanel</code>.</p>"},{"location":"tutorials/settings_tutorial/#the-appsettingsconfigurable-class","title":"The AppSettingsConfigurable Class","text":"<p>The methods of <code>AppSettingsConfigurable</code> are called by the Consulo, and <code>AppSettingsConfigurable</code> in turn interacts with <code>AppSettingsComponent</code> and <code>AppSettingState</code>.</p>"},{"location":"tutorials/settings_tutorial/#declaring-the-appsettingsconfigurable","title":"Declaring the AppSettingsConfigurable","text":"<p>As described in Declaring Application Settings, the <code>com.intellij.applicationConfigurable</code> is used as the EP. An explanation of this declaration can be found in Declaring Application Settings:</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;applicationConfigurable parentId=\"tools\" instance=\"org.intellij.sdk.settings.AppSettingsConfigurable\"\n                             id=\"org.intellij.sdk.settings.AppSettingsConfigurable\"\n                             displayName=\"SDK: Application Settings Example\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/settings_tutorial/#creating-the-appsettingsconfigurable-implementation","title":"Creating the AppSettingsConfigurable Implementation","text":"<p>The <code>AppSettingsConfigurable</code> class implements <code>Configurable</code> interface. The class has one field to hold a reference to the <code>AppSettingsComponent</code>.</p> <pre><code>{% include /code_samples/settings/src/main/java/org/intellij/sdk/settings/AppSettingsConfigurable.java %}\n</code></pre>"},{"location":"tutorials/settings_tutorial/#appsettingsconfigurable-methods","title":"AppSettingsConfigurable Methods","text":"<p>All the methods in this class are overrides of the methods in the <code>Configurable</code> interface. Readers are encouraged to review the Javadoc comments for the <code>Configurable</code> methods. Also review notes about Consulo Interactions with <code>Configurable</code> methods.</p>"},{"location":"tutorials/settings_tutorial/#testing-the-custom-settings-plugin","title":"Testing the Custom Settings Plugin","text":"<p>After performing the steps described above, compile and run the plugin in a Development Instance to see the custom Settings available in the Settings Dialog. Open the IDE Settings by selecting Settings/Preferences | Tools | SDK: Application Settings Example. The settings are preloaded with the default values:</p> <p>{:width=\"600px\"}</p> <p>Now edit the settings values to \"John Doe\" and click the checkbox. Click on the OK button to close the Settings dialog and save the changes. Exit the Development Instance.</p> <p>Open the file <code>SdkSettingsPlugin.xml</code> to see the Settings persistently stored. In this demonstration the file resides in <code>code_samples/settings/build/idea-sandbox/config/options/</code>, but see IDE Development Instances for the general Development Instance case, or Default IDE directories if you are testing the <code>settings</code> plugin directly in an IDE.</p> <p>{:width=\"600px\"}</p>"},{"location":"tutorials/tree_structure_view/","title":"Tree Structure View","text":"<p>This tutorial is meant to illustrate how the project tree structure view appearance can be modified programmatically. If you need to know more about basic concepts of a project view in IntelliJ-based IDEs, please refer to Exploring The Project Structure of  IntelliJ IDEA Web Help.</p> <p>Series of step below show how to filter out and keep visible only text files and directories in the Project View Panel.</p>"},{"location":"tutorials/tree_structure_view/#pre-requirements","title":"Pre-Requirements","text":"<p>Create an empty plugin project. See Creating a Plugin Project.</p>"},{"location":"tutorials/tree_structure_view/#1-register-custom-treestructure-provider","title":"1. Register Custom TreeStructure Provider","text":"<p>Add new treeStructureProvider extension to the plugin.xml</p> <pre><code>&lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n  &lt;treeStructureProvider implementation=\"org.intellij.sdk.treeStructureProvider.TextOnlyTreeStructureProvider\"/&gt;\n&lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/tree_structure_view/#2-implement-custom-treestructureprovider","title":"2. Implement Custom TreeStructureProvider","text":"<p>To provide custom Structure View behaviour you need to implement TreeStructureProvider interface.</p> <pre><code>public class TextOnlyTreeStructureProvider implements TreeStructureProvider {\n    @NotNull\n    @Override\n    public Collection&lt;AbstractTreeNode&gt; modify(@NotNull AbstractTreeNode parent, @NotNull Collection&lt;AbstractTreeNode&gt; children, ViewSettings settings) {\n        return null;\n    }\n\n    @Nullable\n    @Override\n    public Object getData(Collection&lt;AbstractTreeNode&gt; collection, String s) {\n        return null;\n    }\n}\n</code></pre>"},{"location":"tutorials/tree_structure_view/#3-override-modify-method","title":"3. Override modify() Method","text":"<p>To implement Tree Structure nodes filtering logic, override <code>modify()</code> method. The example below shows how to filter out all the Project View nodes except those which correspond to text files and directories.</p> <pre><code>{% include /code_samples/tree_structure_provider/src/main/java/org/intellij/sdk/treeStructureProvider/TextOnlyTreeStructureProvider.java %}\n</code></pre>"},{"location":"tutorials/tree_structure_view/#4-compile-and-run-the-plugin","title":"4. Compile and Run the Plugin","text":"<p>Compile and run the code sample from this tutorial. Refer to Running and Debugging a Plugin.</p> <p>After going through the steps described above you can see only text files and directories belonging to a project in the Project View.</p> <p></p> <p>Check out plugin source code and build the project to see how TreeStructureView provider works in practice.</p>"},{"location":"tutorials/action_system/grouping_action/","title":"Grouping Actions","text":"<p>If an implementation requires several actions, or there are simply too many actions that overload the menu, the actions can be placed into groups. This tutorial demonstrates adding an action to an existing group, creating a new action group, and action groups with a variable number of actions. The sample code discussed in this tutorial is from the code sample <code>action_basics</code>.</p> <p>Some content in this tutorial assumes the reader is familiar with the tutorial for Creating Actions.</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/action_system/grouping_action/#simple-action-groups","title":"Simple Action Groups","text":"<p>In this first example, the action group will be available as a top-level menu item, and actions are represented as drop-down menu items. The group is based on a default Consulo implementation.</p>"},{"location":"tutorials/action_system/grouping_action/#creating-simple-groups","title":"Creating Simple Groups","text":"<p>Grouping can be registered by adding a <code>&lt;group&gt;</code> element to the <code>&lt;actions&gt;</code> section of a plugin's <code>plugin.xml</code> file. This example has no <code>class</code> attribute in the <code>&lt;group&gt;</code> element because the Consulo framework will supply a default implementation class for the group. This default implementation is used if a set of actions belonging to the group is static, i.e., does not change at runtime, which is the majority of cases. The <code>id</code> attribute must be unique, so incorporating the plugin ID or package name is the best practice.</p> <p>The <code>popup</code> attribute determines whether actions in the group are placed in a submenu. The <code>icon</code> attribute specifies the FQN of an <code>Icon</code> object to be displayed. No <code>compact</code> attribute is specified, which means this group will support submenus. See Registering Actions in plugin.xml for more information about these attributes.</p> <pre><code>    &lt;group id=\"org.intellij.sdk.action.GroupedActions\" text=\"Static Grouped Actions\" popup=\"true\" icon=\"SdkIcons.Sdk_default_icon\"&gt;\n    &lt;/group&gt;\n</code></pre>"},{"location":"tutorials/action_system/grouping_action/#binding-action-groups-to-ui-components","title":"Binding Action Groups to UI Components","text":"<p>The following sample shows how to use an <code>&lt;add-to-group&gt;</code> element to place a custom action group relative to an entry in the Tools menu. The attribute <code>relative-to-action</code> references the action <code>id</code> for <code>PopupDialogAction</code>, not a native IntelliJ menu entry. Rather <code>PopupDialogAction</code> is defined in the same <code>plugin.xml</code> file. This group is placed after the single entry for the action <code>PopupDialogAction</code>, as defined in the tutorial Creating Actions.</p> <pre><code>    &lt;group id=\"org.intellij.sdk.action.GroupedActions\" text=\"Static Grouped Actions\" popup=\"true\" icon=\"SdkIcons.Sdk_default_icon\"&gt;\n      &lt;add-to-group group-id=\"ToolsMenu\" anchor=\"after\" relative-to-action=\"org.intellij.sdk.action.PopupDialogAction\"/&gt;\n    &lt;/group&gt;\n</code></pre>"},{"location":"tutorials/action_system/grouping_action/#adding-a-new-action-to-the-static-grouped-actions","title":"Adding a New Action to the Static Grouped Actions","text":"<p>The <code>PopupDialogAction</code> implementation will be reused and registered in the newly created static group. The <code>id</code> attribute for the reused <code>PopupDialogAction</code> implementation is set to a unique value, <code>org.intellij.sdk.action.GroupPopDialogAction</code>. This value differentiates this new <code>&lt;action&gt;</code> entry from the <code>id</code> previously used to register this action implementation in the Creating Actions tutorial. A unique <code>id</code> supports reuse of action classes in more than one menu or group. The action in this group will display the menu text \"A Group Action\".</p> <pre><code>    &lt;group id=\"org.intellij.sdk.action.GroupedActions\" text=\"Static Grouped Actions\" popup=\"true\" icon=\"SdkIcons.Sdk_default_icon\"&gt;\n      &lt;add-to-group group-id=\"ToolsMenu\" anchor=\"after\" relative-to-action=\"org.intellij.sdk.action.PopupDialogAction\"/&gt;\n      &lt;action class=\"org.intellij.sdk.action.PopupDialogAction\" id=\"org.intellij.sdk.action.GroupPopDialogAction\"\n              text=\"A Group Action\" description=\"SDK static grouped action example\" icon=\"SdkIcons.Sdk_default_icon\"&gt;\n      &lt;/action&gt;\n    &lt;/group&gt;\n</code></pre> <p>After performing the steps described above, the action group and its content will be available in the Tools menu. The underlying <code>PopupDialogAction</code> implementation is reused for two entries in the Tools menu: * Once for the top menu entry Tools | Pop Dialog Action with the action <code>id</code> equal to <code>org.intellij.sdk.action.PopupDialogAction</code> as set in the Creating Actions tutorial. * A second time for the menu entry Tools | Static Grouped Actions | A Group Action with the action <code>id</code> equal to <code>org.intellij.sdk.action.GroupPopDialogAction</code>.</p> <p>{:width=\"550px\"}</p>"},{"location":"tutorials/action_system/grouping_action/#implementing-custom-action-group-classes","title":"Implementing Custom Action Group Classes","text":"<p>In some cases, the specific behavior of a group of actions needs to depend on the context. The solution is analogous to making a single action entry dependent on context.</p> <p>The steps below show how to make a group of actions available and visible if certain conditions are met. In this case, the condition is having an instance of an editor is available. This condition is needed because the custom action group is added to an IntelliJ menu that is only enabled for editing.</p>"},{"location":"tutorials/action_system/grouping_action/#extending-defaultactiongroup","title":"Extending DefaultActionGroup","text":"<p>The <code>DefaultActionGroup</code> is an implementation of <code>ActionGroup</code>. The <code>DefaultActionGroup</code> class is used to add child actions and separators between them to a group. This class is used if a set of actions belonging to the group does not change at runtime.</p> <p>As an example, extend <code>DefaultActionGroup</code>  to create the <code>CustomDefaultActionGroup</code> class in the <code>action_basics</code> code sample:</p> <pre><code>  public class CustomDefaultActionGroup extends DefaultActionGroup {\n    @Override\n    public void update(AnActionEvent event) {\n      // Enable/disable depending on whether user is editing...\n    }\n  }\n</code></pre>"},{"location":"tutorials/action_system/grouping_action/#registering-the-custom-action-group","title":"Registering the Custom Action Group","text":"<p>As in the case with the static action group, the action <code>&lt;group&gt;</code> should be declared in the <code>&lt;actions&gt;</code> section of the <code>plugin.xml</code> file, for example, the action_basics plugin. For demonstration purposes, this implementation will use localization.</p> <p>The <code>&lt;group&gt;</code> element declaration below shows: * An optional resource bundle declaration outside of the <code>&lt;actions&gt;</code> section for localizing actions. * The presence of the <code>class</code> attribute in the <code>&lt;group&gt;</code> element tells the Consulo framework to use <code>CustomDefaultActionGroup</code> rather than the default implementation. * Setting the group's <code>popup</code> attribute to allow submenus. * The <code>text</code> and <code>description</code> attributes are omitted in the <code>&lt;group&gt;</code> declaration in favor of using the localization resource bundle to define them. * There is no <code>icon</code> attribute for the group; the <code>CustomDefaultActionGroup</code> implementation will add an icon for the group. * The <code>&lt;add-to-group&gt;</code> element specifies adding the group in the first position of the existing <code>EditorPopupMenu</code>.</p> <pre><code>  &lt;resource-bundle&gt;messages.BasicActionsBundle&lt;/resource-bundle&gt;\n\n  &lt;actions&gt;\n    &lt;group id=\"org.intellij.sdk.action.CustomDefaultActionGroup\"\n           class=\"org.intellij.sdk.action.CustomDefaultActionGroup\"\n           popup=\"true\"&gt;\n      &lt;add-to-group group-id=\"EditorPopupMenu\" anchor=\"first\"/&gt;\n    &lt;/group&gt;\n  &lt;/actions&gt;\n</code></pre>"},{"location":"tutorials/action_system/grouping_action/#adding-actions-to-the-custom-group","title":"Adding Actions to the Custom Group","text":"<p>As in Static Grouped Actions, the <code>PopupDialogAction</code> action is added as an <code>&lt;action&gt;</code> element in the <code>&lt;group&gt;</code> element. In the <code>&lt;action&gt;</code> element declaration below: * The <code>class</code> attribute in the <code>&lt;action&gt;</code> element has the same FQN to reuse this action implementation. * The <code>id</code> attribute is unique to distinguish it from other uses of the implementation in the Action System. * The <code>text</code> and <code>description</code> attributes are omitted in the <code>&lt;action&gt;</code> declaration; they are instead defined using the localization resource bundle. * The SDK icon is declared for use with this action.</p> <pre><code>    &lt;group id=\"org.intellij.sdk.action.CustomDefaultActionGroup\"\n           class=\"org.intellij.sdk.action.CustomDefaultActionGroup\"\n           popup=\"true\" icon=\"SdkIcons.Sdk_default_icon\"&gt;\n      &lt;add-to-group group-id=\"EditorPopupMenu\" anchor=\"first\"/&gt;\n      &lt;action id=\"org.intellij.sdk.action.CustomGroupedAction\" class=\"org.intellij.sdk.action.PopupDialogAction\"\n              icon=\"SdkIcons.Sdk_default_icon\"/&gt;\n    &lt;/group&gt;\n</code></pre> <p>Now the translations for the <code>text</code> and <code>description</code> attributes must be provided in the resource bundle <code>BasicActionsBundle.properties</code> file according to Localizing Actions and Groups. Note there are two sets of <code>text</code> and <code>description</code> translations, one for the action and one for the group. Conceivably, there could be another set of translations for the action if it used the <code>&lt;override-text&gt;</code> attribute.</p> <pre><code>action.org.intellij.sdk.action.CustomGroupedAction.text=A Popup Action[en]\naction.org.intellij.sdk.action.CustomGroupedAction.description=SDK popup grouped action example[en]\ngroup.org.intellij.sdk.action.CustomDefaultActionGroup.text=Popup Grouped Actions[en]\ngroup.org.intellij.sdk.action.CustomDefaultActionGroup.description=Custom defaultActionGroup demo[en]\n</code></pre>"},{"location":"tutorials/action_system/grouping_action/#providing-specific-behavior-for-the-custom-group","title":"Providing Specific Behavior for the Custom Group","text":"<p>Override the <code>CustomDefaultActionGroup.update()</code> method to make the group visible only if there's an instance of the editor available. Also, a custom icon is added to demonstrate that group icons can be changed depending on the action context:</p> <pre><code>public class CustomDefaultActionGroup extends DefaultActionGroup {\n  @Override\n  public void update(AnActionEvent event) {\n    // Enable/disable depending on whether user is editing\n    Editor editor = event.getData(CommonDataKeys.EDITOR);\n    event.getPresentation().setEnabled(editor != null);\n    // Take this opportunity to set an icon for the group.\n    event.getPresentation().setIcon(SdkIcons.Sdk_default_icon);\n  }\n}\n</code></pre> <p>After compiling and running the code sample above and opening a file in the editor and right-clicking, the Editing menu will pop up containing a new group of actions in the first position. Note the group and actions come from the resource file as all contain the suffix \"[en]\". The new group will also have an icon:</p> <p></p>"},{"location":"tutorials/action_system/grouping_action/#action-groups-with-variable-actions-sets","title":"Action Groups with Variable Actions Sets","text":"<p>If a set of actions belonging to a custom group varies depending on the context, the group must extend <code>ActionGroup</code>. The set of actions in the <code>ActionGroup</code> is dynamically defined.</p>"},{"location":"tutorials/action_system/grouping_action/#creating-variable-action-group","title":"Creating Variable Action Group","text":"<p>To create a group of actions with a variable number of actions, extend <code>ActionGroup</code>. For example, as in the <code>action_basics</code> class <code>DynamicActionGroup</code> code:</p> <pre><code>public class DynamicActionGroup extends ActionGroup {\n}\n</code></pre>"},{"location":"tutorials/action_system/grouping_action/#registering-a-variable-action-group","title":"Registering a Variable Action Group","text":"<p>To register the dynamic menu group, a <code>&lt;group&gt;</code> attribute needs to be placed in the <code>&lt;actions&gt;</code> section of <code>plugin</code>.xml. When enabled, this group appears at the entry just below the Static Grouped Actions in the Tools menu:</p> <pre><code>    &lt;group id=\"org.intellij.sdk.action.DynamicActionGroup\" class=\"org.intellij.sdk.action.DynamicActionGroup\" popup=\"true\"\n            text=\"Dynamically Grouped Actions\" description=\"SDK dynamically grouped action example\" icon=\"SdkIcons.Sdk_default_icon\"&gt;\n      &lt;add-to-group group-id=\"ToolsMenu\" anchor=\"after\" relative-to-action=\"org.intellij.sdk.action.GroupedActions\"/&gt;\n    &lt;/group&gt;\n</code></pre> <p>WARNING If a<code>&lt;group&gt;</code> element's <code>class</code> attribute names a class derived from <code>ActionGroup</code>, then any static <code>&lt;action&gt;</code> declarations in that group throw an exception. For a statically defined group, use <code>DefaultActionGroup</code>.</p>"},{"location":"tutorials/action_system/grouping_action/#adding-child-actions-to-the-dynamic-group","title":"Adding Child Actions to the Dynamic Group","text":"<p>To add actions to the <code>DynamicActionGroup</code>, a non-empty array of <code>AnAction</code> instances should be returned from the <code>DynamicActionGroup.getChildren()</code> method. Here again, reuse the <code>PopupDialogAction</code> implementation. This use case is why <code>PopupDialogAction</code> overrides a constructor:</p> <pre><code>public class DynamicActionGroup extends ActionGroup {\n  @NotNull\n  @Override\n  public AnAction[] getChildren(AnActionEvent e) {\n    return new AnAction[]{ new PopupDialogAction(\"Action Added at Runtime\",\n                                                 \"Dynamic Action Demo\",\n                                                 SdkIcons.Sdk_default_icon) };\n  }\n}\n</code></pre> <p>After providing the implementation of <code>DynamicActionGroup</code> and making it return a non-empty array of actions, the third position in the Tools menu will contain a new group of actions:</p> <p>{:width=\"600px\"}</p>"},{"location":"tutorials/action_system/working_with_custom_actions/","title":"Creating Actions","text":""},{"location":"tutorials/action_system/working_with_custom_actions/#introduction","title":"Introduction","text":"<p>Plugins can add actions to existing IDE menus and toolbars, as well as add new menus and toolbars. The Consulo calls the actions of plugins in response to user interactions with the IDE. However, the actions of a plugin must first be defined and registered with the Consulo.</p> <p>Using the SDK code sample <code>action_basics</code>, this tutorial illustrates the steps to create an action for a plugin.</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/action_system/working_with_custom_actions/#creating-a-custom-action","title":"Creating a Custom Action","text":"<p>Custom actions extend the abstract class <code>AnAction</code>. Classes that extend it should override <code>AnAction.update()</code>, and must override <code>AnAction.actionPerformed()</code>. * The <code>update()</code> method implements the code that enables or disables an action. * The <code>actionPerformed()</code> method implements the code that executes when an action is invoked by the user.</p> <p>As an example, <code>PopupDialogAction</code> overrides <code>AnAction</code> for the <code>action_basics</code> code sample.</p> <pre><code>public class PopupDialogAction extends AnAction {\n\n  @Override\n  public void update(AnActionEvent e) {\n    // Using the event, evaluate the context, and enable or disable the action.\n  }\n\n  @Override\n  public void actionPerformed(@NotNull AnActionEvent e) {\n    // Using the event, implement an action. For example, create and show a dialog.\n  }\n\n}\n</code></pre> <p>WARNING <code>AnAction</code> classes do not have class fields of any kind. This restriction prevents memory leaks. For more information about why, see Action Implementation.</p> <p>At this stage, <code>update()</code> implicitly defaults always to enable this action. The implementation of <code>actionPerformed()</code> does nothing. These methods fully implemented in Developing the AnAction Methods below.</p> <p>Before fleshing out those methods, to complete this minimal implementation, <code>PopupDialogAction</code> must be registered with the Consulo.</p>"},{"location":"tutorials/action_system/working_with_custom_actions/#registering-a-custom-action","title":"Registering a Custom Action","text":"<p>Actions are registered by declaring them in code or by declaring them in the <code>&lt;actions&gt;</code> section of a plugin configuration (<code>plugin.xml</code>) file. This section describes using IDE tooling - the New Action Form - to add a declaration to the <code>plugin.xml</code> file, and then tuning registration attributes manually. A more comprehensive explanation of action registration is available in the Action Registration section of this guide.</p>"},{"location":"tutorials/action_system/working_with_custom_actions/#registering-an-action-with-the-new-action-form","title":"Registering an Action with the New Action Form","text":"<p>IntelliJ IDEA has an embedded inspection that spots unregistered actions. Verify the inspection is enabled at Settings/Preferences | Editor | Inspections | Plugin DevKit | Code | Component/Action not registered. Here is an example for this stage of the <code>PopupDialogAction</code> class:</p> <p>{:width=\"600px\"}</p> <p>To register <code>PopupDialogAction</code> and set up its basic attributes press Alt + Shift + Enter. Fill out the New Action form to set up the parameters for <code>PopupDialogAction</code>:</p> <p>{:width=\"800px\"}</p> <p>The fields of the form are: * Action ID - Every action must have a unique ID.   If the action class is used in only one place in the IDE UI, then the class FQN is a good default for the ID.   Using the action class in multiple places requires mangling the ID, such as adding a suffix to the FQN, for each ID. * Class Name - The FQN implementation class for the action.   If the same action is used in multiple places in the IDE UI, the implementation FQN can be reused with a different Action ID. * Name - The text to appear in the menu. * Description - Hint text to be displayed. * Add to Group - The action group - menu or toolbar - to which the action is added.   Clicking in the list of groups and typing invokes a search, such as \"ToolsMenu.\" * Anchor - Where the menu action should be placed in the Tools menu relative to the other actions in that menu.</p> <p>In this case, <code>PopupDialogAction</code> would be available in the Tools menu, it would be placed at the top, and would have no shortcuts.</p> <p>After finishing the New Action form and applying the changes, the <code>&lt;actions&gt;</code> section of the plugin's <code>plugins.xml</code> file would contain:</p> <pre><code>  &lt;actions&gt;\n    &lt;action id=\"org.intellij.sdk.action.PopupDialogAction\" class=\"org.intellij.sdk.action.PopupDialogAction\"\n          text=\"Pop Dialog Action\" description=\"SDK action example\"&gt;\n      &lt;add-to-group group-id=\"ToolsMenu\" anchor=\"first\"/&gt;\n    &lt;/action&gt;\n  &lt;/actions&gt;\n</code></pre> <p>The <code>&lt;action&gt;</code> element declares the Action ID (<code>id</code>,) Class Name (<code>class</code>,) Name (<code>text</code>,) and Description from the New Action form. The <code>&lt;add-to-group&gt;</code> element declares where the action will appear and mirrors the names of entries from the form.</p> <p>This declaration is adequate, but adding more attributes is discussed in the next section.</p>"},{"location":"tutorials/action_system/working_with_custom_actions/#setting-registration-attributes-manually","title":"Setting Registration Attributes Manually","text":"<p>An action declaration can be added manually to the <code>plugin.xml</code> file. An exhaustive list of declaration elements and attributes is presented in Registering Actions in plugin.xml. Attributes are added by selecting them from the New Action form, or by editing the registration declaration directly in the plugin.xml file.</p> <p>The <code>&lt;action&gt;</code> declaration for <code>PopupDialogAction</code> in the <code>action_basics</code> plugin.xml file. It also contains an attribute for an <code>Icon</code> and encloses elements declaring text overrides, keyboard and mouse shortcuts, and to which menu group the action should be added.</p> <p>The full declaration is:</p> <pre><code>    &lt;action id=\"org.intellij.sdk.action.PopupDialogAction\" class=\"org.intellij.sdk.action.PopupDialogAction\"\n            text=\"Action Basics Plugin: Pop Dialog Action\" description=\"SDK action example\" icon=\"SdkIcons.Sdk_default_icon\"&gt;\n      &lt;override-text place=\"MainMenu\" text=\"Pop Dialog Action\"/&gt;\n      &lt;keyboard-shortcut first-keystroke=\"control alt A\" second-keystroke=\"C\" keymap=\"$default\"/&gt;\n      &lt;mouse-shortcut keystroke=\"control button3 doubleClick\" keymap=\"$default\"/&gt;\n      &lt;add-to-group group-id=\"ToolsMenu\" anchor=\"first\"/&gt;\n    &lt;/action&gt;\n</code></pre>"},{"location":"tutorials/action_system/working_with_custom_actions/#using-override-text-for-an-action","title":"Using Override-Text for an Action","text":"<p>By using the <code>override-text</code> element introduced in 2020.1 of the Consulo, the action text can be different depending on the context of where the action appears: menu, toolbar, etc. The example above uses this element to ensure the shorter text \"Pop Dialog Action\" is shown anywhere the action appears in the Main Menu structure. Otherwise, the default, more explanatory text \"Action Basics Plugin: Pop Dialog Action\" is shown. For more information, see Setting the Override-Text Element</p>"},{"location":"tutorials/action_system/working_with_custom_actions/#testing-the-minimal-custom-action-implementation","title":"Testing the Minimal Custom Action Implementation","text":"<p>After performing the steps described above, compile and run the plugin to see the newly created action available as a Tools Menu item, which is within the context of the Main Menu:</p> <p>{:width=\"350px\"}</p> <p>To see the alternate, more verbose text declared by the <code>override-text</code> element, use Help | Find Action... and search for \"Pop Dialog Action\". The search shows the verbose menu text in a context outside of the Main Menu:</p> <p>{:width=\"500px\"}</p> <p>Selecting the action from the menu, keyboard/mouse shortcuts, or Find Action won't do anything at this point because the implementations are empty. However, it confirms the new entry appears at Tools | Pop Dialog Action and Help | Find Action....</p>"},{"location":"tutorials/action_system/working_with_custom_actions/#developing-the-anaction-methods","title":"Developing the <code>AnAction</code> Methods","text":"<p>At this point, the new action <code>PopupDialogAction</code> is registered with the Consulo and functions in the sense that  <code>update()</code> and <code>actionPerformed()</code> are called in response to user interaction with the IDE Tools menu. However, neither method implements any code to perform useful work.</p> <p>This section describes adding useful code to these methods. The <code>update()</code> method defaults to always enable the action, which is satisfactory for intermediate testing. So <code>actionPerformed()</code> will be developed first.</p>"},{"location":"tutorials/action_system/working_with_custom_actions/#extending-the-actionperformed-method","title":"Extending the <code>actionPerformed()</code> Method","text":"<p>Adding code to the <code>PopupDialogAction.actionPerformed()</code> method makes the action do something useful. The code below gets information from the <code>anActionEvent</code> input parameter and constructs a message dialog. A generic icon, and the <code>dlgMsg</code> and <code>dlgTitle</code> attributes from the invoking menu action are displayed. However, code in this method could manipulate a project, invoke an inspection, change the contents of a file, etc.</p> <p>For demonstration purposes the <code>AnActionEvent.getData()</code> method tests if a <code>Navigatable</code> object is available. If so, information about the selected element is added to the dialog.</p> <p>See Determining the Action Context for more information about accessing information from the <code>AnActionEvent</code> input parameter.</p> <pre><code>  @Override\n  public void actionPerformed(@NotNull AnActionEvent event) {\n    // Using the event, create and show a dialog\n    Project currentProject = event.getProject();\n    StringBuffer dlgMsg = new StringBuffer(event.getPresentation().getText() + \" Selected!\");\n    String dlgTitle = event.getPresentation().getDescription();\n    // If an element is selected in the editor, add info about it.\n    Navigatable nav = event.getData(CommonDataKeys.NAVIGATABLE);\n    if (nav != null) {\n      dlgMsg.append(String.format(\"\\nSelected Element: %s\", nav.toString()));\n    }\n    Messages.showMessageDialog(currentProject, dlgMsg.toString(), dlgTitle, Messages.getInformationIcon());\n  }\n</code></pre>"},{"location":"tutorials/action_system/working_with_custom_actions/#extending-the-update-method","title":"Extending the <code>update()</code> Method","text":"<p>Adding code to <code>PopupDialogAction.update()</code> gives finer control of the action's visibility and availability. The action's state and(or) presentation can be dynamically changed depending on the context.</p> <p>WARNING This method needs to execute very quickly. For more information about this constraint, see the warning in Overriding the AnAction.update Method.</p> <p>In this example, the <code>update()</code> method relies on a <code>Project</code> object being available. This requirement means the user must have at least one project open in the IDE for the <code>PopupDialogAction</code> to be available. So the <code>update()</code> method disables the action for contexts where a <code>Project</code> object isn't defined.</p> <p>The availability (enabled and visible) is set on the <code>Presentation</code> object. Setting both the enabled state and visibility produces consistent behavior despite possible host menu settings, as discussed in Grouping Actions.</p> <pre><code>  @Override\n  public void update(AnActionEvent e) {\n    // Set the availability based on whether a project is open\n    Project project = e.getProject();\n    e.getPresentation().setEnabledAndVisible(project != null);\n  }\n</code></pre> <p>The <code>update()</code> method does not check to see if a <code>Navigatable</code> object is available before enabling <code>PopupDialogAction</code>. This check is unnecessary because using the <code>Navigatable</code> object is opportunistic in <code>actionPerformed()</code>. See Determining the Action Context for more information about accessing information from the <code>AnActionEvent</code> input parameter.</p>"},{"location":"tutorials/action_system/working_with_custom_actions/#other-method-overrides","title":"Other Method Overrides","text":"<p>A constructor is overridden in <code>PopupDialogAction</code>, but this is an artifact of reusing this class for a dynamically created menu action. Otherwise, overriding constructors for <code>AnAction</code> is not required.</p>"},{"location":"tutorials/action_system/working_with_custom_actions/#testing-the-custom-action","title":"Testing the Custom Action","text":"<p>After compiling and running the plugin project and invoking the action, the dialog will pop up:</p> <p>{:width=\"800px\"}</p>"},{"location":"tutorials/build_system/deployment/","title":"Publishing Plugins with Gradle","text":"<p>Once you have configured Gradle support, you can automatically build and deploy your plugin to the JetBrains Plugins Repository. To automatically deploy a plugin, you need to have already published the plugin to the plugin repository at least once. Please see the guide page for manually publishing a plugin for the first time.</p> <p>TIP Please see Marketing for remarks on how to prepare your plugin for optimal presentation.</p> <p>WARNING When adding additional repositories to your Gradle build script, always use HTTPS protocol.</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/build_system/deployment/#building-distribution","title":"Building Distribution","text":"<p>For manual distribution or local installation, invoke the <code>buildPlugin</code> Gradle task to create the plugin distribution. The resulting JAR/ZIP is located in <code>build/distributions</code> and can then be installed either manually or uploaded to a custom plugin repository.</p>"},{"location":"tutorials/build_system/deployment/#providing-your-hub-permanent-token-to-gradle","title":"Providing Your Hub Permanent Token to Gradle","text":"<p>To deploy a plugin to the JetBrains Plugins Repository, you need to supply your JetBrains Hub Permanent Token.</p> <p>This section describes two options to supply your Hub Permanent Token via Gradle using: * Environment variables, * Parameters to the Gradle task.</p>"},{"location":"tutorials/build_system/deployment/#using-environment-variables","title":"Using Environment Variables","text":"<p>Start by defining an environment variable such as:</p> <pre><code>export ORG_GRADLE_PROJECT_intellijPublishToken='YOUR_HUB_TOKEN_HERE'\n</code></pre> <p>NOTE On macOS systems, environment variables set in <code>.bash_profile</code> are only visible to processes you run from bash. Environment variables visible to all processes need to be defined in Environment.plist.</p> <p>Now provide the environment variable in the run configuration with which you run the <code>publishPlugin</code> task locally. To do so, create a Gradle run configuration (if not already done), choose your Gradle project, specify the <code>publishPlugin</code> task, and then add the environment variable.</p> <pre><code>publishPlugin {\n  token = System.getenv(\"ORG_GRADLE_PROJECT_intellijPublishToken\")\n}\n</code></pre> <p>Note that you still need to put some default values (can be empty) in the Gradle properties because otherwise, you will get a compilation error.</p>"},{"location":"tutorials/build_system/deployment/#using-parameters-for-the-gradle-task","title":"Using Parameters for the Gradle Task","text":"<p>Like using environment variables, you can also pass your token as a parameter to the Gradle task. For example, you can provide the parameter <code>-Dorg.gradle.project.intellijPublishToken=YOUR_HUB_TOKEN_HERE</code> on the command line or by putting it in the arguments of your Gradle run configuration.</p> <p>Note that also, in this case, you still need to put some default values in your Gradle properties.</p>"},{"location":"tutorials/build_system/deployment/#deploying-a-plugin-with-gradle","title":"Deploying a Plugin with Gradle","text":"<p>The first step when deploying a plugin is to confirm that it works correctly. You may wish to verify this by installing your plugin from disk on a fresh instance of your target IDE(s).</p>"},{"location":"tutorials/build_system/deployment/#publishing-a-plugin","title":"Publishing a Plugin","text":"<p>Once you are confident, the plugin works as intended, make sure the plugin version is updated, as the JetBrains Plugins Repository won't accept multiple artifacts with the same version.</p> <p>To deploy a new version of your plugin to the JetBrains Plugins Repository, invoke the <code>publishPlugin</code> Gradle task.</p> <p>Now check the most recent version of your plugin on the JetBrains Plugins Repository. If successfully deployed, any users who currently have your plugin installed on an available version of the Consulo are notified of a new update available as soon as the update has been verified.</p>"},{"location":"tutorials/build_system/deployment/#specifying-a-release-channel","title":"Specifying a Release Channel","text":"<p>You may also deploy plugins to a release channel of your choosing, by configuring the <code>publishPlugin.channels</code> property. For example:</p> <pre><code>publishPlugin {\n    channels 'beta'\n}\n</code></pre> <p>When empty, this uses the default plugin repository, available to all JetBrains Plugins Repository users. However, you can publish it to an arbitrarily-named channel. These non-default release channels are treated as separate repositories.</p> <p>When using a non-default release channel, users need to configure a new custom plugin repository in their IDE to install your plugin. For example, if you specify <code>publishPlugin.channels 'canary'</code>, then users need to add the <code>https://plugins.jetbrains.com/plugins/canary/list</code> repository to install the plugin and receive updates.</p> <p>Popular channel names include: * <code>alpha</code>: https://plugins.jetbrains.com/plugins/alpha/list * <code>beta</code>: https://plugins.jetbrains.com/plugins/beta/list * <code>eap</code>: https://plugins.jetbrains.com/plugins/eap/list</p> <p>More information about the available configuration options is in the documentation of the IntelliJ Gradle plugin.</p>"},{"location":"tutorials/build_system/gradle_guide/","title":"Configuring Gradle Projects","text":"<p>This page serves as a guide to the Gradle-based plugin configuration for Consulo projects. The IntelliJ IDEA Ultimate and Community editions bundle the Gradle and Plugin DevKit plugins to support Gradle-based development.</p> <p>The Getting Started with Gradle page provides a tutorial for creating Gradle-based Consulo plugins. It may be useful to review the Consulo page, particularly the description of versioning in the Open Source section.</p> <p>WARNING When adding additional repositories to your Gradle build script, always use HTTPS protocol.</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/build_system/gradle_guide/#overview-of-the-gradle-plugin","title":"Overview of the Gradle Plugin","text":"<p>The Gradle plugin is built from the open-source project gradle-intellij-plugin. This plugin adds Gradle tasks that enable developing Consulo plugins. The README file has a reference for configuring these tasks.</p> <p>When getting started, there are several items to note on the README page: * At the top of the page, the latest production version of the plugin is listed.   It is advised to upgrade to the latest available version regularly. * Also, at the top is the minimum required version of Gradle. * The table of extended Gradle Tasks has a succinct description for each task added by the plugin.   This documentation will focus on the configuration and use four of those tasks:   * Setup DSL - <code>intellij { ... }</code>.   * Running DSL - <code>runIde { ... }</code>   * Patching DSL - <code>patchPluginXml { ... }</code>   * Publishing DSL - <code>publishPlugin { ... }</code> * Examples are always a helpful resource, and at the bottom of the page are links to example open-source Consulo plugin projects based on Gradle. * Almost every Gradle plugin attribute has a default value that will work to get started on a Gradle-based Consulo plugin project.</p>"},{"location":"tutorials/build_system/gradle_guide/#guide-to-configuring-gradle-plugin-functionality","title":"Guide to Configuring Gradle Plugin Functionality","text":"<p>This section presents a guided tour of Gradle plugin attributes to achieve the commonly desired functionality.</p>"},{"location":"tutorials/build_system/gradle_guide/#configuring-the-gradle-plugin-for-building-consulo-plugin-projects","title":"Configuring the Gradle Plugin for Building Consulo Plugin Projects","text":"<p>By default, the Gradle plugin will build a plugin project against the Consulo defined by the latest EAP snapshot of the IntelliJ IDEA Community Edition.</p> <p>NOTE Using EAP versions of the Consulo requires adding the Snapshots repository to the <code>build.gradle</code> file (see Consulo Artifacts Repositories).</p> <p>If a matching version of the specified Consulo is not available on the local machine, the Gradle plugin downloads the correct version and type. IntelliJ IDEA then indexes the build and any associated source code and JetBrains Java Runtime.</p>"},{"location":"tutorials/build_system/gradle_guide/#consulo-configuration","title":"Consulo Configuration","text":"<p>Explicitly setting the Setup DSL attributes <code>intellij.version</code> and <code>intellij.type</code> tells the Gradle plugin to use that configuration of the Consulo to create the plugin project.</p> <p>All available platform versions can be browsed in the Consulo Artifacts Repositories.</p> <p>If the chosen platform version is not available in the repositories, or a local installation of the target IDE is the desired type and version of the Consulo, use <code>intellij.localPath</code> to point to that installation. If the <code>intellij.localPath</code> attribute is set, do not set the <code>intellij.version</code> and <code>intellij.type</code> attributes as this could result in undefined behavior.</p>"},{"location":"tutorials/build_system/gradle_guide/#plugin-dependencies","title":"Plugin Dependencies","text":"<p>Consulo plugin projects may depend on either bundled or third-party plugins. In that case, a project should build against a version of those plugins that match the Consulo version used to build the plugin project. The Gradle plugin will fetch any plugins in the list defined by <code>intellij.plugins</code>. See the Gradle plugin README for information about specifying the plugin and version.</p> <p>Note that this attribute describes a dependency so that the Gradle plugin can fetch the required artifacts. The runtime dependency must be added in the Plugin Configuration (<code>plugin.xml</code>) file as described in Plugin Dependencies.</p>"},{"location":"tutorials/build_system/gradle_guide/#configuring-the-gradle-plugin-for-running-consulo-plugin-projects","title":"Configuring the Gradle Plugin for Running Consulo Plugin Projects","text":"<p>By default, the Gradle plugin will use the same version of the Consulo for the IDE Development Instance, as was used for building the plugin. Using the corresponding JetBrains Runtime is also the default, so for this use case, no further configuration is required.</p>"},{"location":"tutorials/build_system/gradle_guide/#running-against-alternate-versions-and-types-of-consulo-based-ides","title":"Running Against Alternate Versions and Types of Consulo-Based IDEs","text":"<p>The Consulo IDE used for the Development Instance can be different from that used to build the plugin project. Setting the Running DSL attribute <code>runIde.ideDirectory</code> will define an IDE to be used for the Development Instance. This attribute is commonly used when running or debugging a plugin in an alternate Consulo-based IDE.</p>"},{"location":"tutorials/build_system/gradle_guide/#running-against-alternate-versions-of-the-jetbrains-runtime","title":"Running Against Alternate Versions of the JetBrains Runtime","text":"<p>Every version of the Consulo has a corresponding version of the JetBrains Runtime. A different version of the runtime can be used by specifying the <code>runIde.jbrVersion</code> attribute, describing a version of the JetBrains Runtime that should be used by the IDE Development Instance. The Gradle plugin will fetch the specified JetBrains Runtime as needed.</p>"},{"location":"tutorials/build_system/gradle_guide/#managing-directories-used-by-the-gradle-plugin","title":"Managing Directories Used by the Gradle Plugin","text":"<p>There are several attributes to control where the Gradle plugin places directories for downloads and use by the IDE Development Instance.</p> <p>The location of the sandbox home directory and its subdirectories can be controlled with Gradle plugin attributes. The <code>intellij.sandboxDirectory</code> attribute is used to set the path for the sandbox directory to be used while running the plugin in an IDE Development Instance. Locations of the sandbox subdirectories can be controlled using the <code>runIde.configDirectory</code>, <code>runIde.pluginsDirectory</code>, and <code>runIde.systemDirectory</code> attributes. If the <code>intellij.sandboxDirectory</code> path is explicitly set, the subdirectory attributes default to the new sandbox directory.</p> <p>The storage location of downloaded IDE versions and components defaults to the Gradle cache directory. However, it can be controlled by setting the <code>intellij.ideaDependencyCachePath</code> attribute.</p>"},{"location":"tutorials/build_system/gradle_guide/#controlling-downloads-by-the-gradle-plugin","title":"Controlling Downloads by the Gradle Plugin","text":"<p>As mentioned in the section about configuring the Consulo used for building plugin projects, the Gradle plugin will fetch the version of the Consulo specified by the default or by the <code>intellij</code> attributes. Standardizing the versions of the Gradle plugin and the Gradle system across projects will minimize the time spent downloading versions.</p> <p>There are controls for managing the <code>gradle-intellij-plugin</code> version, and the version of the Gradle itself. The plugin version is defined in the <code>plugins {}</code> section of a project's <code>build.gradle</code> file. The version of the Gradle is defined in <code>&lt;PROJECT ROOT&gt;/gradle/wrapper/gradle-wrapper.properties</code>.</p>"},{"location":"tutorials/build_system/gradle_guide/#patching-the-plugin-configuration-file","title":"Patching the Plugin Configuration File","text":"<p>A plugin project's <code>plugin.xml</code> file has element values that are \"patched\" at build time from the attributes of the <code>patchPluginXml</code> task (Patching DSL). As many as possible of the attributes in the Patching DSL will be substituted into the corresponding element values in a plugin project's <code>plugin.xml</code> file: * If a <code>patchPluginXml</code> attribute default value is defined, the attribute value will be patched in <code>plugin.xml</code> regardless of whether the <code>patchPluginXml</code> task appears in the <code>build.gradle</code> file.   * For example, the default values for the attributes <code>patchPluginXml.sinceBuild</code> and <code>patchPluginXml.untilBuild</code> are defined based on the declared (or default) value of <code>intellij.version</code>.     So by default <code>patchPluginXml.sinceBuild</code> and <code>patchPluginXml.untilBuild</code> are substituted into the <code>&lt;idea-version&gt;</code> element's <code>since-build</code> and <code>until-build</code> attributes in the <code>plugin.xml</code> file. * If a <code>patchPluginXml</code> attribute value is explicitly defined, the attribute value will be substituted in <code>plugin.xml</code>.   * If both <code>patchPluginXml.sinceBuild</code> and <code>patchPluginXml.untilBuild</code> attributes are explicitly set, both are substituted in <code>plugin.xml</code>.   * If one attribute is explicitly set (e.g. <code>patchPluginXml.sinceBuild</code>) and one is not (e.g. <code>patchPluginXml.untilBuild</code> has a default value,) both attributes are patched at their respective (explicit and default) values. * For no substitution of the <code>&lt;idea-version&gt;</code> element's <code>since-build</code> and <code>until-build</code> attributes, one of the following must appear in the <code>build.gradle</code> file:   * Either set <code>intellij.updateSinceUntilBuild = false</code>, which will disable substituting both <code>since-build</code> and <code>until-build</code> attributes,   * Or, for independent control, set <code>patchPluginXml.sinceBuild(null)</code> and <code>patchPluginXml.untilBuild(null)</code> depending on whether the intention is to disable one or both substitutions.</p> <p>A best practice to avoid confusion is to replace the elements in <code>plugin.xml</code> the Gradle plugin will patch that with a comment. That way, the values for these parameters do not appear in two places in the source code. The Gradle plugin will add the necessary elements as part of the patching process. For those <code>patchPluginXml</code> attributes that contain descriptions such as <code>changeNotes</code> and <code>pluginDescription</code>, a <code>CDATA</code> block is not necessary when using HTML elements.</p> <p>TIP To maintain and generate an up-to-date changelog, try using Gradle Changelog Plugin.</p> <p>As discussed in Components of a Wizard-Generated Gradle Consulo Plugin, the Gradle properties <code>project.version</code>, <code>project.group</code>, and <code>rootProject.name</code> are all generated based on the input to the Wizard. However, the <code>gradle-intellij-plugin</code> does not combine and substitute those Gradle properties for the default <code>&lt;id&gt;</code> and <code>&lt;name&gt;</code> elements in the <code>plugin.xml</code> file.</p> <p>The best practice is to keep <code>project.version</code> current. By default, if you modify <code>project.version</code> in <code>build.gradle</code>, the Gradle plugin will automatically update the <code>&lt;version&gt;</code> value in the <code>plugin.xml</code> file. This practice keeps all version declarations synchronized.</p>"},{"location":"tutorials/build_system/gradle_guide/#verifying-plugin","title":"Verifying Plugin","text":"<p>The Gradle plugin provides two tasks that allow for running integrity and compatibility tests: - <code>verifyPlugin</code> - validates completeness and contents of <code>plugin.xml</code> descriptors as well as plugin\u2019s archive structure, - <code>runPluginVerifier</code> - runs the IntelliJ Plugin Verifier tool to check the binary compatibility with specified IntelliJ IDE builds.</p> <p>Plugin Verifier integration task allows for configuring the exact IDE versions that your plugin will be checked against. Please check the Plugin Verifier DSL for more details.</p>"},{"location":"tutorials/build_system/gradle_guide/#publishing-with-the-gradle-plugin","title":"Publishing with the Gradle Plugin","text":"<p>Please review the Publishing Plugins with Gradle page before using the Publishing DSL attributes. That documentation explains different ways to use Gradle for plugin uploads without exposing account credentials.</p>"},{"location":"tutorials/build_system/gradle_guide/#common-gradle-plugin-configurations-for-development","title":"Common Gradle Plugin Configurations for Development","text":"<p>Different combinations of Gradle plugin attributes are needed to create the desired build or IDE Development Instance environment. This section reviews some of the more common configurations.</p>"},{"location":"tutorials/build_system/gradle_guide/#plugins-targeting-intellij-idea","title":"Plugins Targeting IntelliJ IDEA","text":"<p>Consulo plugins targeting IntelliJ IDEA have the most straightforward Gradle plugin configuration. * Determine the version of IntelliJ IDEA to use for building the plugin project; this is the desired version of the Consulo.   This can be EAP (default) or determined from the build number ranges.   * If a production version of IntelliJ IDEA is the desired target, set the <code>intellij</code> version attributes accordingly.   * Set the necessary plugin dependencies, if any. * If the plugin project should be run or debugged in an IDE Development Instance based on the same IntelliJ IDEA version, no further attributes need to be set for the IDE Development Instance.   This is the default behavior and is the most common use case.   * If the plugin project should be run or debugged in an IDE Development Instance based on an alternate version of the Consulo, set the Running DSL attribute accordingly.   * If the plugin project should be run using a JetBrains Runtime other than the default for the IDE Development Instance, specify the JetBrains Runtime version. * Set the appropriate attributes for patching the <code>plugin.xml</code> file.</p>"},{"location":"tutorials/build_system/gradle_guide/#plugins-targeting-alternate-consulo-based-ides","title":"Plugins Targeting Alternate Consulo-Based IDEs","text":"<p>Gradle also supports developing plugins to run in IDEs that are based on the Consulo. For more information, see the Developing for Multiple Products page of this guide.</p>"},{"location":"tutorials/build_system/prerequisites/","title":"Getting Started with Gradle","text":"<p>Gradle is the preferred solution for creating Consulo plugins. The IntelliJ IDEA Ultimate and Community editions bundle the necessary plugins to support Gradle-based development. These IntelliJ IDEA plugins are Gradle and Plugin DevKit, which are enabled by default. To verify these plugins are installed and enabled, see the help section about Managing Plugins.</p> <p>TIP Consulo Plugin Template makes it easier to create and maintain your IDE plugins, having the Gradle plugin already integrated and CI covered with GitHub Actions.</p> <p>WARNING When adding additional repositories to your Gradle build script, always use HTTPS protocol.</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/build_system/prerequisites/#creating-a-gradle-based-consulo-plugin-with-new-project-wizard","title":"Creating a Gradle-Based Consulo Plugin with New Project Wizard","text":"<p>Creating new Gradle-based Consulo plugin projects is performed using the New Project Wizard. The Wizard creates all the necessary project files based on a few template inputs.</p> <p>Before creating a new Gradle project, familiarize yourself with the help topic Creating a new Gradle project, which is a tutorial for creating general Gradle projects in IntelliJ IDEA. This page emphasizes the steps in the process of creating Consulo plugin projects that are Gradle-based.</p> <p>WARNING Please note that Gradle 6.1 has a known bug that prevents using it for developing plugins, please upgrade to 6.1.1 or later.</p> <p>Launch the New Project Wizard. It guides you through the Gradle project creation process with two screens.</p>"},{"location":"tutorials/build_system/prerequisites/#new-project-configuration-screen","title":"New Project Configuration Screen","text":"<p>On the first screen, the type of project is configured: * From the project type pane on the left, choose Gradle. * Specify the Project SDK based on the Java 8 JDK.   This SDK will be the default JRE used to run Gradle, and the JDK version used to compile the plugin Java sources.</p> <p>NOTE When targeting 2020.3 and later only, using Java 11 is now required, please see blog post </p> <ul> <li>In the Additional Libraries and Frameworks panel, select Java and Consulo Plugin.   These settings will be used for the remainder of this tutorial.</li> </ul> <p>Optionally: * To include support for the Kotlin language in the plugin, check the Kotlin/JVM box (circled in green below).   This option can be selected with or without the Java language. * To create the <code>build.gradle</code> file as a Kotlin build script (<code>build.gradle.kts</code>) rather than Groovy, check the Kotlin DSL build script box (circled in magenta below).</p> <p>Then click Next:</p> <p>{:width=\"800px\"}</p>"},{"location":"tutorials/build_system/prerequisites/#project-namingartifact-coordinates-screen","title":"Project Naming/Artifact Coordinates Screen","text":"<p>Expand the Artifact Coordinates section and specify a GroupId, ArtifactId, and Version using Maven naming conventions. * GroupId is typically a Java package name, and it is used for the Gradle property <code>project.group</code> value in the project's <code>build.gradle</code> file.   For this example, enter <code>com.your.company</code>. * ArtifactId is the default name of the project JAR file (without version).   It is also used for the Gradle property <code>rootProject.name</code> value in the project's <code>settings.gradle</code> file.   For this example, enter <code>my_gradle_plugin</code>. * Version is used for the Gradle property <code>project.version</code> value in the <code>build.gradle</code> file.   For this example, enter <code>1.0</code>.</p> <p>The Name field is synced automatically with the specified ArtifactId.</p> <p>Specify the path for the new project in Location and click Finish to continue and generate the project.</p>"},{"location":"tutorials/build_system/prerequisites/#components-of-a-wizard-generated-gradle-consulo-plugin","title":"Components of a Wizard-Generated Gradle Consulo Plugin","text":"<p>For the example <code>my_gradle_plugin</code>, the New Project Wizard creates the following directory content:</p> <pre><code>my_gradle_plugin\n\u251c\u2500\u2500 build.gradle\n\u251c\u2500\u2500 gradle\n\u2502   \u2514\u2500\u2500 wrapper\n\u2502       \u251c\u2500\u2500 gradle-wrapper.jar\n\u2502       \u2514\u2500\u2500 gradle-wrapper.properties\n\u251c\u2500\u2500 gradlew\n\u251c\u2500\u2500 gradlew.bat\n\u251c\u2500\u2500 settings.gradle\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 main\n    \u2502   \u251c\u2500\u2500 java\n    \u2502   \u2514\u2500\u2500 resources\n    \u2502       \u2514\u2500\u2500 META-INF\n    \u2502           \u2514\u2500\u2500 plugin.xml\n    \u2514\u2500\u2500 test\n        \u251c\u2500\u2500 java\n        \u2514\u2500\u2500 resources\n</code></pre> <ul> <li>The default Consulo <code>build.gradle</code> file (see next paragraph).</li> <li>The Gradle Wrapper files, and in particular the <code>gradle-wrapper.properties</code> file, which specifies the version of the Gradle to be used to build the plugin.   If needed, the IntelliJ IDEA Gradle plugin downloads the version of the Gradle specified in this file.</li> <li>The <code>settings.gradle</code> file, containing a definition of the <code>rootProject.name</code>.</li> <li>The <code>META-INF</code> directory under the default <code>main</code> SourceSet contains the plugin configuration file.</li> </ul> <p>The generated <code>my_gradle_plugin</code> project <code>build.gradle</code> file:</p> <pre><code>  plugins {\n      id 'java'\n      id 'org.jetbrains.intellij' version '0.6.5'\n  }\n\n  group 'com.your.company'\n  version '1.0'\n  sourceCompatibility = 1.8\n\n  repositories {\n      mavenCentral()\n  }\n  dependencies {\n      testImplementation group: 'junit', name: 'junit', version: '4.12'\n  }\n\n  // See https://github.com/JetBrains/gradle-intellij-plugin/\n  intellij {\n      version '2020.1'\n  }\n  patchPluginXml {\n      changeNotes \"\"\"\n        Add change notes here.&lt;br&gt;\n        &lt;em&gt;most HTML tags may be used&lt;/em&gt;\"\"\"\n  }\n</code></pre> <ul> <li>Two plugins to Gradle are explicitly declared:</li> <li>The Gradle Java plugin.</li> <li>The gradle-intellij-plugin.</li> <li>The GroupId from the Wizard Project Naming/Artifact Coordinates Screen is the <code>project.group</code> value.</li> <li>The Version from the Wizard Project Naming/Artifact Coordinates Screen is the <code>project.version</code> value.</li> <li>The <code>sourceCompatibility</code> line is injected to enforce using Java 8 JDK to compile Java sources.</li> <li>The only comment in the file is a link to the README.md for the gradle-intellij-plugin, which is a reference for its configuration DSL.</li> <li>The value of the Setup DSL attribute <code>intellij.version</code> specifies the version of the Consulo to be used to build the plugin.   It defaults to the version of IntelliJ IDEA that was used to run the New Project Wizard.</li> <li>The value of the Patching DSL attribute <code>patchPluginXml.changeNotes</code> is set to a place holder text.</li> </ul>"},{"location":"tutorials/build_system/prerequisites/#plugin-gradle-properties-and-plugin-configuration-file-elements","title":"Plugin Gradle Properties and Plugin Configuration File Elements","text":"<p>The Gradle properties <code>rootProject.name</code> and <code>project.group</code> will not, in general, match the respective plugin configuration file <code>plugin.xml</code> elements <code>&lt;name&gt;</code> and <code>&lt;id&gt;</code>. There is no Consulo-related reason they should as they serve different functions.</p> <p>The <code>&lt;name&gt;</code> element (used as the plugin's display name) is often the same as <code>rootProject.name</code>, but it can be more explanatory.</p> <p>The <code>&lt;id&gt;</code> value must be a unique identifier over all plugins, typically a concatenation of the specified GroupId and ArtifactId. Please note that it is impossible to change the <code>&lt;id&gt;</code> of a published plugin without losing automatic updates for existing installations.</p>"},{"location":"tutorials/build_system/prerequisites/#adding-gradle-support-to-an-existing-devkit-based-consulo-plugin","title":"Adding Gradle Support to an Existing DevKit-Based Consulo Plugin","text":"<p>Converting a DevKit-based plugin project to a Gradle-based plugin project can be done using the New Project Wizard to create a Gradle-based project around the existing DevKit-based project: * Ensure the directory containing the DevKit-based Consulo plugin project can be fully recovered if necessary. * Delete all the artifacts of the DevKit-based project:   * <code>.idea</code> directory   * <code>[modulename].iml</code> file   * <code>out</code> directory * Arrange the existing source files within the project directory in the Gradle SourceSet format. * Use the New Project Wizard as though creating a new Gradle project from scratch. * On the Project Naming/Artifact Coordinates Screen set the values to:   * GroupId to the existing package in the initial source set.   * ArtifactId to the name of the existing plugin.   * Version to the same as the existing plugin.   * Name to the name of the existing plugin.     (It should be pre-filled from the ArtifactId)   * Set the Location to the directory of the existing plugin. * Click Finish to create the new Gradle-based plugin. * Add more modules using Gradle Source Sets as needed.</p>"},{"location":"tutorials/build_system/prerequisites/#running-a-simple-gradle-based-consulo-plugin","title":"Running a Simple Gradle-Based Consulo Plugin","text":"<p>Gradle projects are run from the IDE's Gradle Tool window.</p>"},{"location":"tutorials/build_system/prerequisites/#adding-code-to-the-project","title":"Adding Code to the Project","text":"<p>Before running <code>my_gradle_project</code>, some code can be added to provide simple functionality. See the Creating Actions tutorial for step-by-step instructions for adding a menu action.</p>"},{"location":"tutorials/build_system/prerequisites/#executing-the-plugin","title":"Executing the Plugin","text":"<p>Open the Gradle tool window and search for the <code>runIde</code> task: * If it\u2019s not in the list, hit the Refresh button at the top of the Gradle window. * Or Create a new Gradle Run Configuration.</p> <p>{:width=\"398px\"}</p> <p>Double-click on the runIde task to execute it. See the IntelliJ IDEA help for more information about Working with Gradle tasks.</p> <p>Finally, when <code>my_gradle_plugin</code> launches in the IDE development instance, there should be a new menu under the Tools menu.</p>"},{"location":"tutorials/custom_language_support/annotator/","title":"7. Annotator","text":"<p>An <code>Annotator</code> helps highlight and annotate any code based on specific rules. This section adds annotation functionality to support the Simple Language in the context of Java code.</p> <p>Reference: Annotator</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/custom_language_support/annotator/#required-project-configuration-changes","title":"Required Project Configuration Changes","text":"<p>Classes defined in this step of the tutorial depend on <code>com.intellij.psi.PsiLiteralExpression</code> at runtime. Using <code>PsiLiteralExpression</code> introduces a dependency on <code>com.intellij.modules.java</code>. Beginning in version 2019.2 of the Consulo these dependencies are declared in <code>plugin.xml</code>:</p> <pre><code>  &lt;depends&gt;com.intellij.modules.java&lt;/depends&gt;\n</code></pre> <p>The dependency is also declared in the <code>build.gradle</code> file:</p> <pre><code>intellij {\n  plugins = ['java']\n}\n</code></pre>"},{"location":"tutorials/custom_language_support/annotator/#71-define-an-annotator","title":"7.1. Define an Annotator","text":"<p>The <code>SimpleAnnotator</code> subclasses <code>Annotator</code>. Consider a literal string that starts with \"simple:\" as a prefix of a Simple Language key. It isn't part of the Simple Language, but it is a useful convention for detecting Simple Language keys embedded as string literals in other languages, like Java. Annotate the <code>simple:key</code> literal expression, and differentiate between a well-formed vs. an unresolved property.</p> <p>NOTE The use of new <code>AnnotationHolder</code> syntax starting 2020.2, which uses the builder format.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleAnnotator.java %}\n</code></pre> <p>TIP If the above code is copied at this stage of the tutorial, then remove the line below the comment \"** Tutorial step 18.3 \u2026\" The quick fix class in that line is not defined until later in the tutorial.</p>"},{"location":"tutorials/custom_language_support/annotator/#72-register-the-annotator","title":"7.2. Register the Annotator","text":"<p>Using the <code>com.intellij.annotator</code> extension point in the plugin configuration file, register the Simple Language annotator class with the Consulo:</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;annotator language=\"JAVA\" implementationClass=\"org.intellij.sdk.language.SimpleAnnotator\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/custom_language_support/annotator/#73-run-the-project","title":"7.3. Run the Project","text":"<p>As a test, define the following Java file containing a Simple Language <code>prefix:value</code> pair:</p> <pre><code>public class Test {\n    public static void main(String[] args) {\n        System.out.println(\"simple:website\");\n    }\n}\n</code></pre> <p>Open this Java file in an IDE Development Instance running the <code>simple_language_plugin</code> to check if the IDE resolves a property:</p> <p>{:width=\"800px\"}</p> <p>If the property is an undefined name, the annotator flags the code with an error.</p> <p>{:width=\"800px\"}</p> <p>Try changing the Simple Language color settings to differentiate the annotation from the default language color settings.</p>"},{"location":"tutorials/custom_language_support/code_style_settings/","title":"16. Code Style Settings","text":"<p>Code style settings enable defining formatting options. A code style settings provider creates an instance of the settings and also creates an options page in settings/preferences. This example creates a settings/preferences page that uses the default language code style settings, customized by a language code style settings provider.</p> <p>Reference: Code Style Settings</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/custom_language_support/code_style_settings/#161-define-code-style-settings","title":"16.1. Define Code Style Settings","text":"<p>Define a code style settings for Simple Language by subclassing <code>CustomCodeStyleSettings</code>.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleCodeStyleSettings.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/code_style_settings/#162-define-code-style-settings-provider","title":"16.2. Define Code Style Settings Provider","text":"<p>The code style settings provider gives the Consulo a standard way to instantiate <code>CustomCodeStyleSettings</code> for the Simple Language. Define a code style settings provider for Simple Language by subclassing <code>CodeStyleSettingsProvider</code>.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleCodeStyleSettingsProvider.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/code_style_settings/#163-register-the-code-style-settings-provider","title":"16.3. Register the Code Style Settings Provider","text":"<p>The <code>SimpleCodeStyleSettingsProvider</code> implementation is registered with the Consulo in the plugin configuration file using the <code>com.intellij.codeStyleSettingsProvider</code> extension point.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;codeStyleSettingsProvider implementation=\"org.intellij.sdk.language.SimpleCodeStyleSettingsProvider\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/custom_language_support/code_style_settings/#164-define-the-language-code-style-settings-provider","title":"16.4. Define the Language Code Style Settings Provider","text":"<p>Define a code style settings provider for Simple Language by subclassing <code>LanguageCodeStyleSettingsProvider</code>, which provides common code style settings for a specific language.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleLanguageCodeStyleSettingsProvider.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/code_style_settings/#165-register-the-language-code-style-settings-provider","title":"16.5. Register the Language Code Style Settings Provider","text":"<p>The <code>SimpleLanguageCodeStyleSettingsProvider</code> implementation is registered with the Consulo in the plugin configuration file using the <code>com.intellij.langCodeStyleSettingsProvider</code> extension point.</p> <pre><code> &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;langCodeStyleSettingsProvider\n            implementation=\"org.intellij.sdk.language.SimpleLanguageCodeStyleSettingsProvider\"/&gt;\n &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/custom_language_support/code_style_settings/#166-run-the-project","title":"16.6. Run the Project","text":"<p>In the IDE Development Instance, open the Simple Language code formatting page: Preferences/Settings | Editor | Code Style | Simple.</p> <p></p>"},{"location":"tutorials/custom_language_support/commenter/","title":"17. Commenter","text":"<p>A commenter enables the user to comment-out a line of code at the cursor or selected code automatically. The <code>Commenter</code> defines support for Code | Comment with Line Comment and Code | Comment with Block Comment actions.</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/custom_language_support/commenter/#171-define-a-commenter","title":"17.1. Define a Commenter","text":"<p>The commenter for Simple Language defines the line comment prefix as <code>#</code>.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleCommenter.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/commenter/#172-register-the-commenter","title":"17.2. Register the Commenter","text":"<p>The <code>SimpleCommenter</code> implementation is registered in the plugin configuration file using the <code>com.intellij.lang.commenter</code> extension point.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;lang.commenter language=\"Simple\" implementationClass=\"org.intellij.sdk.language.SimpleCommenter\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/custom_language_support/commenter/#173-run-the-project","title":"17.3. Run the Project","text":"<p>Open the example Simple Language properties file  in the IDE Development Instance. Place the cursor at the <code>website</code> line. Select Code | Comment with Line Comment. The line is converted to a comment. Select Code | Comment with Line Comment again, and the comment is converted back to active code.</p> <p></p>"},{"location":"tutorials/custom_language_support/completion_contributor/","title":"9. Completion Contributor","text":"<p>Custom languages provide code completion using one of two approaches: Contributor and Reference-based (see 10. Reference Contributor) completion.</p> <p>Reference: Code Completion</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/custom_language_support/completion_contributor/#91-define-a-completion-contributor","title":"9.1. Define a Completion Contributor","text":"<p>For this tutorial, the <code>simple_language_plugin</code> provides custom completion for values in Simple Language property files. Create a completion contributor by subclassing <code>CompletionContributor</code>. This rudimentary completion contributor always adds \"Hello\" to the results set, regardless of context:</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleCompletionContributor.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/completion_contributor/#92-register-the-completion-contributor","title":"9.2. Register the Completion Contributor","text":"<p>The <code>SimpleCompletionContributor</code> implementation is registered in the plugin configuration file with the Consulo using the <code>com.intellij.completion.contributor</code> extension point.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;completion.contributor language=\"Simple\"\n            implementationClass=\"org.intellij.sdk.language.SimpleCompletionContributor\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/custom_language_support/completion_contributor/#93-run-the-project","title":"9.3. Run the Project","text":"<p>Run the <code>simple_language_plugin</code> in a Development Instance and open the <code>test.simple</code> file. Erase the property \"English\" and invoke Basic Code Completion. The choice \"Hello\" is shown:</p> <p></p>"},{"location":"tutorials/custom_language_support/find_usages_provider/","title":"11. Find Usages Provider","text":"<p>A <code>FindUsagesProvider</code> uses a word scanner to build an index of words in every file. A scanner breaks the text into words and defines the context for each word.</p> <p>Reference: Find Usages</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/custom_language_support/find_usages_provider/#111-define-a-find-usages-provider","title":"11.1. Define a Find Usages Provider","text":"<p>The <code>SimpleFindUsagesProvider</code> implements <code>FindUsagesProvider</code>. Using the <code>DefaultWordsScanner</code> ensures the scanner implementation is thread-safe. See the comments in <code>FindUsagesProvider</code> for more information.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleFindUsagesProvider.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/find_usages_provider/#112-register-the-find-usages-provider","title":"11.2. Register the Find Usages Provider","text":"<p>The <code>SimpleFindUsagesProvider</code> implementation is registered with the Consulo in the plugin configuration file using the <code>com.intellij.lang.findUsagesProvider</code> extension point.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;lang.findUsagesProvider language=\"Simple\"\n            implementationClass=\"org.intellij.sdk.language.SimpleFindUsagesProvider\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/custom_language_support/find_usages_provider/#113-run-the-project","title":"11.3. Run the Project","text":"<p>Rebuild the project, and run <code>simple_language_plugin</code> in a Development Instance. The IDE now supports Find Usages for any property with a reference:</p> <p></p>"},{"location":"tutorials/custom_language_support/folding_builder/","title":"12. Folding Builder","text":"<p>A folding builder identifies the folding regions in the code. In this step of the tutorial, the folding builder is used to identify folding regions and replace the regions with specific text. Rather than the usual practice of using a folding builder to collapse a class, method, or comments to fewer lines, the folding builder replaces Simple Language keys with their corresponding values.</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/custom_language_support/folding_builder/#121-define-a-folding-builder","title":"12.1. Define a Folding Builder","text":"<p>The <code>SimpleFoldingBuilder</code> replaces usages of properties with their values by default. Start by subclassing <code>FoldingBuilderEx</code></p> <p>Note that <code>SimpleFoldingBuilder</code> also implements <code>DumbAware</code>, which means the class is allowed to run in dumb mode, when indices are in background update.</p> <p>NOTE A folding builder must implement <code>DumbAware</code> to function in this tutorial and pass tests.</p> <p>The <code>buildFoldRegions()</code> method searches down a PSI tree from <code>root</code> to find all literal expressions containing the simple prefix <code>simple:</code>. The remainder of such a string is expected to contain a Simple Language key, and so the text range is stored as a <code>FoldingDescriptor</code>.</p> <p>The <code>getPlaceholderText()</code> method retrieves the Simple Language value corresponding to the key associated with the (ASTNode) provided. The Consulo uses the value to substitute for the key when the code gets folded.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleFoldingBuilder.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/folding_builder/#122-register-the-folding-builder","title":"12.2. Register the Folding Builder","text":"<p>The <code>SimpleFoldingBuilder</code> implementation is registered with the Consulo in the plugin configuration file using the <code>com.intellij.lang.foldingBuilder</code> extension point.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;lang.foldingBuilder language=\"JAVA\"\n            implementationClass=\"org.intellij.sdk.language.SimpleFoldingBuilder\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/custom_language_support/folding_builder/#123-run-the-project","title":"12.3. Run the Project","text":"<p>Rebuild the project, and run <code>simple_language_plugin</code> in a Development Instance. Now when a Java file is opened in the Editor, it shows the property's value instead of the key. This is because <code>SimpleFoldingBuilder.isCollapsedByDefault()</code> always returns <code>true</code>. Try using Code | Folding | Expand All to show the key rather than the value.</p> <p></p>"},{"location":"tutorials/custom_language_support/formatter/","title":"15. Formatter","text":"<p>The Consulo includes a powerful framework for implementing formatting for custom languages. A formatter enables reformatting code automatically based on code style settings. The formatter controls spaces, indents, wrap, and alignment.</p> <p>Reference: Code Formatter</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/custom_language_support/formatter/#151-define-a-block","title":"15.1. Define a Block","text":"<p>The formatting model represents the formatting structure of a file as a tree of <code>Block</code> objects, with associated indent, wrap, alignment and spacing settings. The goal is to cover each PSI element with such a block. Since each block builds its children's blocks, it can generate extra blocks or skip any PSI elements. Define <code>SimpleBlock</code> based on <code>AbstractBlock</code>.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleBlock.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/formatter/#152-define-a-formatting-model-builder","title":"15.2. Define a Formatting Model Builder","text":"<p>Define a formatter that removes extra spaces except for the single spaces around the property separator. For example, reformat \"foo  = \u00a0\u00a0\u00a0\u00a0bar\" to \"foo = bar\".</p> <p>Create <code>SimpleFormattingModelBuilder</code> by subclassing <code>FormattingModelBuilder</code>.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleFormattingModelBuilder.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/formatter/#153-register-the-formatter","title":"15.3. Register the Formatter","text":"<p>The <code>SimpleFormattingModelBuilder</code> implementation is registered with the Consulo in the plugin configuration file using the <code>com.intellij.lang.formatter</code> extension point.</p> <pre><code> &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;lang.formatter language=\"Simple\"\n            implementationClass=\"org.intellij.sdk.language.SimpleFormattingModelBuilder\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/custom_language_support/formatter/#154-run-the-project","title":"15.4. Run the Project","text":"<p>Add some extra spaces around the <code>=</code> separator between <code>language</code> and <code>English</code>. Reformat the code by selecting Code | Show Reformat File Dialog and choose Run.</p> <p></p>"},{"location":"tutorials/custom_language_support/go_to_symbol_contributor/","title":"13. Go To Symbol Contributor","text":"<p>A Go to Symbol Contributor helps the user to navigate to any PSI element by its name.</p> <p>Reference: Go to Class and Go to Symbol</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/custom_language_support/go_to_symbol_contributor/#131-define-a-helper-method-for-generated-psi-elements","title":"13.1. Define a Helper Method for Generated PSI Elements","text":"<p>To specify how a PSI element looks like in the Go To Symbol popup window, Structure tool window, or other components, it should implement <code>getPresentation()</code>. This method gets defined in the utility class <code>SimplePsiImplUtil</code>, and the parser and PSI classes must be regenerated. Add the following method to <code>SimplePsiImplUtil</code>:</p> <pre><code>public static ItemPresentation getPresentation(final SimpleProperty element) {\n    return new ItemPresentation() {\n        @Nullable\n        @Override\n        public String getPresentableText() {\n            return element.getKey();\n        }\n\n        @Nullable\n        @Override\n        public String getLocationString() {\n            return element.getContainingFile().getName();\n        }\n\n        @Nullable\n        @Override\n        public Icon getIcon(boolean unused) {\n            return SimpleIcons.FILE;\n        }\n    };\n}\n</code></pre>"},{"location":"tutorials/custom_language_support/go_to_symbol_contributor/#132-update-grammar-and-regenerate-the-parser","title":"13.2. Update Grammar and Regenerate the Parser","text":"<p>Now add the <code>SimplePsiImplUtil.getPresentation()</code> to the <code>property</code> methods definition in the <code>Simple.bnf</code> grammar file by replacing the <code>property</code> definition with the lines below. Don't forget to regenerate the parser after updating the file! Right-click on the <code>Simple.bnf</code> file and select Generate Parser Code.</p> <pre><code>property ::= (KEY? SEPARATOR VALUE?) | KEY {\n  mixin=\"org.intellij.sdk.language.psi.impl.SimpleNamedElementImpl\"\n  implements=\"org.intellij.sdk.language.psi.SimpleNamedElement\"\n  methods=[getKey getValue getName setName getNameIdentifier getPresentation]\n}\n</code></pre>"},{"location":"tutorials/custom_language_support/go_to_symbol_contributor/#133-define-a-go-to-symbol-contributor","title":"13.3. Define a Go to Symbol Contributor","text":"<p>To enable the <code>simple_language_plugin</code> to contribute items to Navigate | Class..., File..., Symbol... lists, subclass <code>ChooseByNameContributor</code> to create <code>SimpleChooseByNameContributor</code>:</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleChooseByNameContributor.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/go_to_symbol_contributor/#134-register-the-go-to-symbol-contributor","title":"13.4. Register the Go To Symbol Contributor","text":"<p>The <code>SimpleChooseByNameContributor</code> implementation is registered with the Consulo in the plugin configuration file using the <code>com.intellij.gotoSymbolContributor</code> extension point.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;gotoSymbolContributor\n            implementation=\"org.intellij.sdk.language.SimpleChooseByNameContributor\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/custom_language_support/go_to_symbol_contributor/#135-run-the-project","title":"13.5. Run the Project","text":"<p>Rebuild the project, and run <code>simple_language_plugin</code> in a Development Instance. The IDE now supports navigating to a property definition by name pattern via Navigate | Symbol action.</p> <p>{:width=\"800px\"}</p>"},{"location":"tutorials/custom_language_support/grammar_and_parser/","title":"3. Grammar and Parser","text":"<p>In order for the Consulo to parse a Simple Language file, tokens and elements must be defined based on <code>IElementType</code>. The Simple Language grammar must also be defined to generate a parser.</p> <p>Reference: Implementing a Parser and PSI</p> <ul> <li>bullet item {:toc}</li> </ul>"},{"location":"tutorials/custom_language_support/grammar_and_parser/#31-define-a-token-type","title":"3.1. Define a Token Type","text":"<p>Create <code>SimpleTokenType</code> in the <code>org.intellij.sdk.language.psi</code> package (see the <code>simple_language_plugin</code> code sample) by subclassing <code>IElementType</code>.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/psi/SimpleTokenType.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/grammar_and_parser/#32-define-an-element-type","title":"3.2. Define an Element Type","text":"<p>Create the <code>SimpleElementType</code> in the <code>org.intellij.sdk.language.psi</code> package by subclassing <code>IElementType</code>.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/psi/SimpleElementType.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/grammar_and_parser/#33-define-the-grammar","title":"3.3. Define the Grammar","text":"<p>Define a grammar for the Simple Language in the <code>com/intellij/sdk/language/Simple.bnf</code> file.</p> <pre><code>{\n  parserClass=\"org.intellij.sdk.language.parser.SimpleParser\"\n\n  extends=\"com.intellij.extapi.psi.ASTWrapperPsiElement\"\n\n  psiClassPrefix=\"Simple\"\n  psiImplClassSuffix=\"Impl\"\n  psiPackage=\"org.intellij.sdk.language.psi\"\n  psiImplPackage=\"org.intellij.sdk.language.psi.impl\"\n\n  elementTypeHolderClass=\"org.intellij.sdk.language.psi.SimpleTypes\"\n  elementTypeClass=\"org.intellij.sdk.language.psi.SimpleElementType\"\n  tokenTypeClass=\"org.intellij.sdk.language.psi.SimpleTokenType\"\n}\n\nsimpleFile ::= item_*\n\nprivate item_ ::= (property|COMMENT|CRLF)\n\nproperty ::= (KEY? SEPARATOR VALUE?) | KEY\n</code></pre> <p>As shown, a properties file can contain properties, comments, and line breaks.</p> <p>Please see Grammar Kit documentation for more details on BNF syntax.</p> <p>The grammar defines the flexibility of the support for a language. The above grammar specifies that a property may have or may not have key and value. This flexibility allows the Consulo to recognize incorrectly defined properties and provide corresponding code analysis and quick-fixes.</p> <p>Note that the <code>SimpleTypes</code> class in the <code>elementTypeHolderClass</code> field above specifies the name of a class that gets generated from the grammar; it doesn't exist at this point.</p>"},{"location":"tutorials/custom_language_support/grammar_and_parser/#34-generate-a-parser","title":"3.4. Generate a Parser","text":"<p>Now that the grammar is defined generate a parser with PSI classes via Generate Parser Code from the context menu on the Simple.bnf file. This step generates a parser and PSI elements in the <code>/src/main/gen</code> folder of the project. Mark this folder as Generated Sources Root and make sure everything compiles without errors.</p> <p>TIP Gradle plugin gradle-grammarkit-plugin can be used alternatively.</p> <p>{:width=\"800px\"}</p>"},{"location":"tutorials/custom_language_support/language_and_filetype/","title":"2. Language and File Type","text":"<p>The Consulo determines file type by examining the name of a file. Each language has Language and LanguageFileType objects defining the language. Register the <code>LanguageFileType</code> with the Consulo in the plugin configuration file.</p> <p>Reference: Registering a File Type</p> <ul> <li>bullet item {:toc}</li> </ul>"},{"location":"tutorials/custom_language_support/language_and_filetype/#21-define-the-language","title":"2.1. Define the Language","text":"<p>The language implemented in this tutorial is named \"Simple\" - note the case of the name. The <code>SimpleLanguage</code> class is defined in the <code>org.intellij.sdk.language</code> package of the <code>simple_language_plugin</code> code sample:</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleLanguage.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/language_and_filetype/#22-define-an-icon","title":"2.2. Define an Icon","text":"<p>The icon for the Simple Language is defined by the <code>SimpleIcons</code> class. There is nothing uniquely Simple Language-specific about defining the icon itself. The definition follows a pattern similar to defining, e.g., <code>SdkIcons</code>.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleIcons.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/language_and_filetype/#23-define-a-filetype","title":"2.3. Define a FileType","text":"<p>The Simple Language file type is defined by subclassing <code>LanguageFileType</code>:</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleFileType.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/language_and_filetype/#24-register-the-filetype-directly","title":"2.4. Register the FileType Directly","text":"<p>Direct registration is possible when targeting version 2019.2 (and later) of the Consulo - no <code>FileTypeFactory</code> is required.</p> <p>Instead, the file type is registered via the <code>com.intellij.fileType</code> extension point in <code>plugin.xml</code>:</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;fileType name=\"Simple File\" implementationClass=\"org.intellij.sdk.language.SimpleFileType\"\n            fieldName=\"INSTANCE\" language=\"Simple\" extensions=\"simple\"/&gt;\n  &lt;/extensions&gt;\n</code></pre> <p>Skip to section 2.6.</p>"},{"location":"tutorials/custom_language_support/language_and_filetype/#25-register-the-filetype-using-a-factory","title":"2.5. Register the FileType Using a Factory","text":"<p>This pattern is necessary when targeting versions of the Consulo prior to 2019.2</p>"},{"location":"tutorials/custom_language_support/language_and_filetype/#251-define-a-filetype-factory","title":"2.5.1 Define a FileType Factory","text":"<p>First, define <code>SimpleFileTypeFactory</code> as a subclass of <code>FileTypeFactory</code>.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleFileTypeFactory.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/language_and_filetype/#252-register-the-filetype-factory","title":"2.5.2 Register the FileType Factory","text":"<p>The <code>SimpleFileTypeFactory</code> is registered using the <code>com.intellij.openapi.fileTypes.FileTypeFactory</code> extension point in <code>plugin.xml</code>.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;fileTypeFactory implementation=\"org.intellij.sdk.language.SimpleFileTypeFactory\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/custom_language_support/language_and_filetype/#26-run-the-project","title":"2.6. Run the Project","text":"<p>Create an empty file with the extension <code>*.simple</code>, and IntelliJ IDEA automatically associates it with our language. Note the appearance of the Simple Language file icon next to the <code>test.simple</code> file in the Project Tool Window, and the editor tab for the file.</p> <p>{:width=\"800px\"}</p>"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/","title":"4. Lexer and Parser Definition","text":"<p>The lexical analyzer defines how the contents of a file are broken into tokens, which is the basis for supporting custom language features. The easiest way to create a lexer is to use JFlex.</p> <p>Reference: Implementing Lexer</p> <ul> <li>bullet item {:toc}</li> </ul>"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/#required-project-configuration-change","title":"Required Project Configuration Change","text":"<p>The previous tutorial step Grammar and Parser, and this page, generate source files in the directory <code>src/main/gen</code>. To include those files, the project's <code>sourceSets</code> must be expanded by inserting the following line in the project's <code>build.gradle</code> file:</p> <pre><code>  sourceSets.main.java.srcDirs 'src/main/gen'\n</code></pre> <p>Or the following line in the project's <code>build.gradle.kts</code> file: <pre><code>  sourceSets[\"main\"].java.srcDirs(\"src/main/gen\")\n</code></pre></p>"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/#41-define-a-lexer","title":"4.1. Define a Lexer","text":"<p>Define a <code>Simple.flex</code> file with rules for the Simple Language lexer, as demonstrated in <code>org.intellij.sdk.language.Simple.flex</code>.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/Simple.flex %}\n</code></pre>"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/#42-generate-a-lexer-class","title":"4.2. Generate a Lexer Class","text":"<p>Now generate a lexer class via JFlex Generator from the context menu on <code>Simple.flex</code> file.</p> <p>The Grammar-Kit plugin uses the JFlex lexer generation. When running for the first time, JFlex prompts for a destination folder to download the JFlex library and skeleton. Choose the project root directory, for example <code>code_samples/simple_language_plugin</code>.</p> <p>After that, the IDE generates the lexer under the <code>gen</code> directory, for example in <code>simple_language_plugin/src/main/gen/org/intellij/sdk/language/SimpleLexer</code>.</p> <p>TIP Gradle plugin gradle-grammarkit-plugin can be used alternatively.</p> <p>See Implementing Lexer for more information about using JFlex with the Consulo.</p>"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/#43-define-a-lexer-adapter","title":"4.3. Define a Lexer Adapter","text":"<p>The JFlex lexer needs to be adapted to the Consulo Lexer API. This is done by subclassing <code>FlexAdapter</code>.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleLexerAdapter.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/#44-define-a-root-file","title":"4.4. Define a Root File","text":"<p>The <code>SimpleFile</code> implementation is the top-level node of the tree of <code>PsiElements</code> for a Simple Language file.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/psi/SimpleFile.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/#45-define-a-parser","title":"4.5. Define a Parser","text":"<p>The Simple Language parser is defined by subclassing <code>ParserDefinition</code>.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleParserDefinition.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/#46-register-the-parser-definition","title":"4.6. Register the Parser Definition","text":"<p>Registering the parser definition in the <code>plugin.xml</code> file makes it available to the Consulo. Use the <code>com.intellij.lang.parserDefinition</code> extension point for registration. For example, see <code>simple_language_plugin/src/main/resources/META-INF/plugin.xml</code>.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;lang.parserDefinition language=\"Simple\"\n            implementationClass=\"org.intellij.sdk.language.SimpleParserDefinition\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/custom_language_support/lexer_and_parser_definition/#47-run-the-project","title":"4.7. Run the Project","text":"<p>With the <code>simple_language_plugin</code> loaded in a Development Instance, create a <code>test.simple</code> properties file with the following content:</p> <pre><code># You are reading the \".properties\" entry.\n! The exclamation mark can also mark text as comments.\nwebsite = https://en.wikipedia.org/\nlanguage = English\n# The backslash below tells the application to continue reading\n# the value onto the next line.\nmessage = Welcome to \\\n          Wikipedia!\n# Add spaces to the key\nkey\\ with\\ spaces = This is the value that could be looked up with the key \"key with spaces\".\n# Unicode\ntab : \\u0009\n</code></pre> <p>Now open the PsiViewer tool window and check how the lexer breaks the content of the file into tokens, and the parser parsed the tokens into PSI elements.</p> <p></p>"},{"location":"tutorials/custom_language_support/line_marker_provider/","title":"8. Line Marker Provider","text":"<p>Line markers help annotate code with icons on the gutter. These markers can provide navigation targets to related code.</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/custom_language_support/line_marker_provider/#81-define-a-line-marker-provider","title":"8.1. Define a Line Marker Provider","text":"<p>A line marker provider annotates usages of Simple Language properties within Java code and provides navigation to the definition of these properties. The visual marker is a Simple Language icon in the gutter of the Editor window.</p> <p>The Simple Language marker provider subclasses <code>RelatedItemLineMarkerProvider</code>. For this example, override the <code>collectNavigationMarkers()</code> method to collect usage of a Simple Language key and separators:</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleLineMarkerProvider.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/line_marker_provider/#82-best-practices-for-implementing-line-marker-providers","title":"8.2. Best Practices for Implementing Line Marker Providers","text":"<p>This section addresses important details about implementing a marker provider. The <code>collectNavigationMarkers()</code> method should: * Only return line marker information consistent with the element passed into the method.   For example, do not return a class marker if <code>getLineMarkerInfo()</code> was called with an element that corresponds to a method. * Return line marker information for the appropriate element at the correct scope of the PSI tree.   For example, do not return method marker for <code>PsiMethod</code>.   Instead, return it for the <code>PsiIdentifier</code> which contains the name of the method.</p> <p>{:width=\"900px\"}</p> <p>What happens when a <code>LineMarkerProvider</code> returns marker information for a <code>PsiElement</code> that is a higher node in the PSI tree? For example, if <code>MyWrongLineMarkerProvider()</code> erroneously returns a <code>PsiMethod</code> instead of a <code>PsiIdentifier</code> element:</p> <pre><code>public class MyWrongLineMarkerProvider implements LineMarkerProvider {\n  public LineMarkerInfo getLineMarkerInfo(@NotNull PsiElement element) {\n    if (element instanceof PsiMethod) return new LineMarkerInfo(element, ...);\n    return null;\n  }\n}\n</code></pre> <p>The consequences of the <code>MyWrongLineMarkerProvider()</code> implementation have to do with how the Consulo performs inspections. For performance reasons, inspection, and specifically the <code>LineMarkersPass</code> queries all <code>LineMarkerProviders</code> in two phases: * The first pass is for all elements visible in the Editor window, * The second pass is for the rest of the elements in the file.</p> <p>If providers return nothing for either area, the line markers get cleared. However, if a method like <code>actionPerformed()</code> is not completely visible in the Editor window (as shown in the image above,) and <code>MyWrongLineMarkerProvider()</code> returns marker info for the <code>PsiMethod</code> instead of <code>PsiIdentifier</code>, then: * The first pass removes line marker info because whole <code>PsiMethod</code> isn't visible. * The second pass tries to add a line marker because <code>MyWrongLineMarkerProvider()</code> is called for the <code>PsiMethod</code>.</p> <p>As a result, the line marker icon would blink annoyingly. To fix this problem, rewrite <code>MyWrongLineMarkerProvider</code> to return info for <code>PsiIdentifier</code> instead of <code>PsiMethod</code> as shown below:</p> <pre><code>public class MyCorrectLineMarkerProvider implements LineMarkerProvider {\n  public LineMarkerInfo getLineMarkerInfo(@NotNull PsiElement element) {\n    if (element instanceof PsiIdentifier &amp;&amp; element.getParent() instanceof PsiMethod) return new LineMarkerInfo(element, ...);\n    return null;\n  }\n}\n</code></pre>"},{"location":"tutorials/custom_language_support/line_marker_provider/#83-register-the-line-marker-provider","title":"8.3. Register the Line Marker Provider","text":"<p>The <code>SimpleLineMarkerProvider</code> implementation is registered with the Consulo in the plugin configuration file using the <code>com.intellij.codeInsight.lineMarkerProvider</code> extension point.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;codeInsight.lineMarkerProvider language=\"JAVA\"\n            implementationClass=\"org.intellij.sdk.language.SimpleLineMarkerProvider\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/custom_language_support/line_marker_provider/#84-run-the-project","title":"8.4. Run the Project","text":"<p>Run the <code>simple_language_plugin</code> in a Development Instance and open the Test file. Now the icon appears next to line 3 on the gutter. A user can click on the icon to navigate to the property definition.</p> <p></p>"},{"location":"tutorials/custom_language_support/prerequisites/","title":"1. Prerequisites","text":""},{"location":"tutorials/custom_language_support/prerequisites/#11-download-and-install-intellij-idea","title":"1.1. Download and Install IntelliJ IDEA","text":"<p>Download and install either IntelliJ IDEA Ultimate or IntelliJ IDEA Community Edition from here.</p>"},{"location":"tutorials/custom_language_support/prerequisites/#12-check-out-community-edition-source-files","title":"1.2. Check out Community Edition Source Files","text":"<p>NOTE While not required, having the full sources of the platform and all bundled plugins available for browsing allows finding related implementations.</p> <p>Download the IntelliJ IDEA Community Edition source files as described in the IntelliJ IDEA Community Edition README file.</p>"},{"location":"tutorials/custom_language_support/prerequisites/#13-install-required-plugins","title":"1.3. Install Required Plugins","text":"<p>Make sure that the bundled Plugin DevKit plugin is enabled. Install and enable Grammar-Kit and PsiViewer plugins.</p>"},{"location":"tutorials/custom_language_support/prerequisites/#14-create-a-project","title":"1.4. Create a Project","text":"<p>Create an Consulo Plugin project.</p>"},{"location":"tutorials/custom_language_support/psi_helper_and_utilities/","title":"6. PSI Helpers and Utilities","text":"<p>Helper classes and utilities can be embedded in the code generated by Grammar-Kit.</p> <ul> <li>bullet item {:toc}</li> </ul>"},{"location":"tutorials/custom_language_support/psi_helper_and_utilities/#61-define-helper-methods-for-generated-psi-elements","title":"6.1. Define Helper Methods for Generated PSI Elements","text":"<p>Custom methods in PSI classes are defined separately, and Grammar-Kit embeds them into generated code. Define a utility class with these helper methods:</p> <pre><code>package org.intellij.sdk.language.psi.impl;\n\nimport com.intellij.lang.ASTNode;\n\npublic class SimplePsiImplUtil {\n  public static String getKey(SimpleProperty element) {\n    ASTNode keyNode = element.getNode().findChildByType(SimpleTypes.KEY);\n    if (keyNode != null) {\n      // IMPORTANT: Convert embedded escaped spaces to simple spaces\n      return keyNode.getText().replaceAll(\"\\\\\\\\ \", \" \");\n    } else {\n      return null;\n    }\n  }\n\n  public static String getValue(SimpleProperty element) {\n    ASTNode valueNode = element.getNode().findChildByType(SimpleTypes.VALUE);\n    if (valueNode != null) {\n      return valueNode.getText();\n    } else {\n      return null;\n    }\n  }\n}\n</code></pre> <p>The parser generates the <code>SimpleProperty</code> interface referenced in the code above.</p>"},{"location":"tutorials/custom_language_support/psi_helper_and_utilities/#62-update-grammar-and-regenerate-the-parser","title":"6.2. Update Grammar and Regenerate the Parser","text":"<p>Now the utility class is added to the grammar file via the <code>psiImplUtilClass</code> attribute. Add methods for a particular rule to specify which one should be used for PSI classes. Compare the last line of the grammar below to the previous definition.</p> <pre><code>{\n  parserClass=\"org.intellij.sdk.language.parser.SimpleParser\"\n\n  extends=\"com.intellij.extapi.psi.ASTWrapperPsiElement\"\n\n  psiClassPrefix=\"Simple\"\n  psiImplClassSuffix=\"Impl\"\n  psiPackage=\"org.intellij.sdk.language.psi\"\n  psiImplPackage=\"org.intellij.sdk.language.psi.impl\"\n\n  elementTypeHolderClass=\"org.intellij.sdk.language.psi.SimpleTypes\"\n  elementTypeClass=\"org.intellij.sdk.language.psi.SimpleElementType\"\n  tokenTypeClass=\"org.intellij.sdk.language.psi.SimpleTokenType\"\n\n  psiImplUtilClass=\"org.intellij.sdk.language.psi.impl.SimplePsiImplUtil\"\n}\n\nsimpleFile ::= item_*\n\nprivate item_ ::= (property|COMMENT|CRLF)\n\nproperty ::= (KEY? SEPARATOR VALUE?) | KEY {methods=[getKey getValue]}\n</code></pre> <p>After making changes to the grammar, regenerate the parser and PSI classes.</p>"},{"location":"tutorials/custom_language_support/psi_helper_and_utilities/#63-define-a-utility-to-search-properties","title":"6.3. Define a Utility to Search Properties","text":"<p>Create a utility class to search PSI elements for defined properties over the project. This utility will be used later when implementing code completion.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleUtil.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/quick_fix/","title":"18. Quick Fix","text":"<p>A quick fix for a custom language supports the Consulo-based IDE feature Intention Actions. For the Simple Language, this tutorial adds a quick fix that helps to define an unresolved property from its usage.</p> <p>Reference: Code Inspections and Intentions</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/custom_language_support/quick_fix/#181-update-the-element-factory","title":"18.1. Update the Element Factory","text":"<p>The <code>SimpleElementFactory</code> is updated to include two new methods to support the user choice of creating a new property for the Simple Language quick fix. The new <code>createCRLF()</code> method supports adding a newline to the end of the <code>test.simple</code> file before adding a new property. A new overload of <code>createProperty()</code> creates a new <code>key</code>-<code>value</code> pair for Simple Language.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/psi/SimpleElementFactory.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/quick_fix/#182-define-an-intention-action","title":"18.2. Define an Intention Action","text":"<p>The <code>SimpleCreatePropertyQuickFix</code> creates a property in the file chosen by the user - in this case, a Java file containing a <code>prefix:key</code> - and navigate to this property after creation. Under the hood, <code>SimpleCreatePropertyQuickFix</code> is an Intention Action. For a more in-depth example of an Intention Action, see <code>conditional_operator_intention</code>.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleCreatePropertyQuickFix.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/quick_fix/#183-update-the-annotator","title":"18.3. Update the Annotator","text":"<p>When a <code>badProperty</code> annotation is created, the <code>badProperty.registerFix()</code> method is called. This method call registers the <code>SimpleCreatePropertyQuickFix</code> as the Intention Action for the Consulo to use to correct the problem.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleAnnotator.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/quick_fix/#184-run-the-project","title":"18.4. Run the Project","text":"<p>Open the test Java file in an IDE Development Instance running the <code>simple_language_plugin</code>.</p> <p>To test <code>SimpleCreatePropertyQuickFix</code>, change <code>simple:website</code> to <code>simple:website.url</code>. The key <code>website.url</code> is highlighted by <code>SimpleAnnotator</code> as an invalid key, as shown below. Choose \"Create Property\".</p> <p>{:width=\"800px\"}</p> <p>The IDE opens the <code>test.simple</code> file and adds <code>website.url</code> as a new key. Add the new value <code>jetbrains.com</code> for the new <code>website.url</code> key.</p> <p></p> <p>Now switch back to the Java file; the new key is highlighted as valid.</p>"},{"location":"tutorials/custom_language_support/reference_contributor/","title":"10. Reference Contributor","text":"<p>The references functionality is one of the most important parts in the implementation of custom language support. Resolving references means the ability to go from the usage of an element to its declaration, completion, rename refactoring, find usages, etc.</p> <p>NOTE Every PSI element that can be renamed or referenced needs to implement <code>PsiNamedElement</code> interface.</p> <p>Reference: References and Resolve</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/custom_language_support/reference_contributor/#101-define-a-named-element-class","title":"10.1. Define a Named Element Class","text":"<p>The classes below show how the Simple Language fulfills the need to implement <code>PsiNamedElement</code>.</p> <p>The <code>SimpleNamedElement</code> interface is subclassed from <code>PsiNameIdentifierOwner</code>.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/psi/SimpleNamedElement.java %}\n</code></pre> <p>The <code>SimpleNamedElementImpl</code> class implements the <code>SimpleNamedElement</code> interface and extends <code>ASTWrapperPsiElement</code>.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/psi/impl/SimpleNamedElementImpl.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/reference_contributor/#102-define-helper-methods-for-generated-psi-elements","title":"10.2. Define Helper Methods for Generated PSI Elements","text":"<p>Modify <code>SimplePsiImplUtil</code> to support new methods that get added to the PSI class for Simple Language. Note that <code>SimpleElementFactory</code> isn't defined until the next step, so for now it shows as an error.</p> <pre><code>public class SimplePsiImplUtil {\n\n  // ...\n\n  public static String getName(SimpleProperty element) {\n      return getKey(element);\n  }\n\n  public static PsiElement setName(SimpleProperty element, String newName) {\n      ASTNode keyNode = element.getNode().findChildByType(SimpleTypes.KEY);\n      if (keyNode != null) {\n\n          SimpleProperty property = SimpleElementFactory.createProperty(element.getProject(), newName);\n          ASTNode newKeyNode = property.getFirstChild().getNode();\n          element.getNode().replaceChild(keyNode, newKeyNode);\n      }\n      return element;\n  }\n\n  public static PsiElement getNameIdentifier(SimpleProperty element) {\n      ASTNode keyNode = element.getNode().findChildByType(SimpleTypes.KEY);\n      if (keyNode != null) {\n          return keyNode.getPsi();\n      } else {\n          return null;\n      }\n  }\n\n  // ...\n}\n</code></pre>"},{"location":"tutorials/custom_language_support/reference_contributor/#103-define-an-element-factory","title":"10.3. Define an Element Factory","text":"<p>The <code>SimpleElementFactory</code> provides methods for creating <code>SimpleFile</code>.</p> <pre><code>package org.intellij.sdk.language.psi;\n\nimport com.intellij.openapi.project.Project;\nimport com.intellij.psi.*;\nimport org.intellij.sdk.language.SimpleFileType;\n\npublic class SimpleElementFactory {\n  public static SimpleProperty createProperty(Project project, String name) {\n    final SimpleFile file = createFile(project, name);\n    return (SimpleProperty) file.getFirstChild();\n  }\n\n  public static SimpleFile createFile(Project project, String text) {\n    String name = \"dummy.simple\";\n    return (SimpleFile) PsiFileFactory.getInstance(project).\n                createFileFromText(name, SimpleFileType.INSTANCE, text);\n  }\n}\n</code></pre>"},{"location":"tutorials/custom_language_support/reference_contributor/#104-update-grammar-and-regenerate-the-parser","title":"10.4. Update Grammar and Regenerate the Parser","text":"<p>Now make corresponding changes to the <code>Simple.bnf</code> grammar file by replacing the <code>property</code> definition with the lines below. Don't forget to regenerate the parser after updating the file! Right-click on the <code>Simple.bnf</code> file and select Generate Parser Code.</p> <pre><code>property ::= (KEY? SEPARATOR VALUE?) | KEY {\n  mixin=\"org.intellij.sdk.language.psi.impl.SimpleNamedElementImpl\"\n  implements=\"org.intellij.sdk.language.psi.SimpleNamedElement\"\n  methods=[getKey getValue getName setName getNameIdentifier]\n}\n</code></pre>"},{"location":"tutorials/custom_language_support/reference_contributor/#105-define-a-reference","title":"10.5. Define a Reference","text":"<p>Now define a reference class to resolve a property from its usage. This requires extending <code>PsiReferenceBase</code> and implementing <code>PsiPolyVariantReference</code>. The latter enables the reference to resolve to more than one element or to resolve result(s) for a superset of valid resolve cases.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleReference.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/reference_contributor/#106-define-a-reference-contributor","title":"10.6. Define a Reference Contributor","text":"<p>A reference contributor allows the <code>simple_language_plugin</code> to provide references to Simple Language from elements in other languages such as Java. Create <code>SimpleReferenceContributor</code> by subclassing <code>PsiReferenceContributor</code>. Contribute a reference to each usage of a property:</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleReferenceContributor.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/reference_contributor/#107-register-the-reference-contributor","title":"10.7. Register the Reference Contributor","text":"<p>The <code>SimpleReferenceContributor</code> implementation is registered with the Consulo using the <code>com.intellij.psi.referenceContributor</code> extension point.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;psi.referenceContributor implementation=\"org.intellij.sdk.language.SimpleReferenceContributor\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/custom_language_support/reference_contributor/#108-run-the-project","title":"10.8. Run the Project","text":"<p>Rebuild the project, and run <code>simple_language_plugin</code> in a Development Instance. The IDE now resolves the property and provides completion suggestions:</p> <p>{:width=\"800px\"}</p> <p>The Rename refactoring functionality is now available from definition and usages.</p> <p>{:width=\"800px\"}</p>"},{"location":"tutorials/custom_language_support/reference_contributor/#109-define-a-refactoring-support-provider","title":"10.9. Define a Refactoring Support Provider","text":"<p>Support for in-place refactoring is specified explicitly in a refactoring support provider. Create <code>SimpleRefactoringSupportProvider</code> by subclassing <code>RefactoringSupportProvider</code> As long as an element is a <code>SimpleProperty</code> it is allowed to be refactored:</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleRefactoringSupportProvider.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/reference_contributor/#1010-register-the-refactoring-support-provider","title":"10.10. Register the Refactoring Support Provider","text":"<p>The <code>SimpleRefactoringSupportProvider</code> implementation is registered with the Consulo in the plugin configuration file using the <code>com.intellij.lang.refactoringSupport</code> extension point.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;lang.refactoringSupport language=\"Simple\"\n            implementationClass=\"org.intellij.sdk.language.SimpleRefactoringSupportProvider\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/custom_language_support/reference_contributor/#1011-run-the-project","title":"10.11. Run the Project","text":"<p>Rebuild the project, and run <code>simple_language_plugin</code> in a Development Instance. The IDE now supports refactoring suggestions:</p> <p>{:width=\"800px\"}</p>"},{"location":"tutorials/custom_language_support/structure_view_factory/","title":"14. Structure View Factory","text":"<p>The structure view can be customized for a specific file type. Creating a structure view factory allows showing the structure of any file in a Structure Tool Window for easy navigation between items in the current editor.</p> <p>Reference: Structure View</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/custom_language_support/structure_view_factory/#141-define-a-structure-view-factory","title":"14.1. Define a Structure View Factory","text":"<p>The structure view factory implements <code>PsiStructureViewFactory</code>. The <code>getStructureViewBuilder()</code> implementation reuses the Consulo class <code>TreeBasedStructureViewBuilder</code>. At this point the project will not compile until <code>SimpleStructureViewModel</code> is implemented below.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleStructureViewFactory.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/structure_view_factory/#142-define-a-structure-view-model","title":"14.2. Define a Structure View Model","text":"<p>The <code>SimpleStructureViewModel</code> is created by implementing <code>StructureViewModel</code>, which defines the model for data displayed in the standard structure view. It also extends <code>StructureViewModelBase</code>, an implementation that links the model to a text editor.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleStructureViewModel.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/structure_view_factory/#143-define-a-structure-view-element","title":"14.3. Define a Structure View Element","text":"<p>The <code>SimpleStructureViewElement</code> implements <code>StructureViewTreeElement</code> and <code>SortableTreeElement</code>. The <code>StructureViewTreeElement</code> represents an element in the Structure View tree model. The <code>SortableTreeElement</code> represents an item in a smart tree that allows using text other than the presentable text as a key for alphabetic sorting.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleStructureViewElement.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/structure_view_factory/#144-register-the-structure-view-factory","title":"14.4. Register the Structure View Factory","text":"<p>The <code>SimpleStructureViewFactory</code> implementation is registered with the Consulo in the plugin configuration file using the <code>com.intellij.lang.psiStructureViewFactory</code> extension point.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;lang.psiStructureViewFactory language=\"Simple\"\n            implementationClass=\"org.intellij.sdk.language.SimpleStructureViewFactory\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/custom_language_support/structure_view_factory/#145-run-the-project","title":"14.5. Run the Project","text":"<p>Rebuild the project, and run <code>simple_language_plugin</code> in a Development Instance. Open the <code>test.simple</code> file and choose View | Tool Windows | Structure. The IDE now supports a structure view of the Simple Language:</p> <p></p>"},{"location":"tutorials/custom_language_support/syntax_highlighter_and_color_settings_page/","title":"5. Syntax Highlighter and Color Settings Page","text":"<p>The first level of syntax highlighting is based on the lexer output, and is provided by <code>SyntaxHighlighter</code>. A plugin can also define color settings based on <code>ColorSettingPage</code> so the user can configure highlight colors. The <code>SimpleSyntaxHighlighter</code>, <code>SimpleSyntaxHighlighterFactory</code>, and <code>SimpleColorSettingsPage</code> discussed on this page are demonstrated in the <code>simple_language_plugin</code> code sample.</p> <p>Reference: Syntax Highlighting and Error Highlighting</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/custom_language_support/syntax_highlighter_and_color_settings_page/#51-define-a-syntax-highlighter","title":"5.1. Define a Syntax Highlighter","text":"<p>The Simple Language syntax highlighter class extends <code>SyntaxHighlighterBase</code>. As recommended in Color Scheme Management, the Simple Language highlighting text attributes are specified as a dependency on one of standard Consulo keys. For the Simple Language, define only one scheme.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleSyntaxHighlighter.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/syntax_highlighter_and_color_settings_page/#52-define-a-syntax-highlighter-factory","title":"5.2. Define a Syntax Highlighter Factory","text":"<p>The factory provides a standard way for the Consulo to instantiate the syntax highlighter for Simple Language files. Here, <code>SimpleSyntaxHighlighterFactory</code> subclasses <code>SyntaxHighlighterFactory</code>.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleSyntaxHighlighterFactory.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/syntax_highlighter_and_color_settings_page/#53-register-the-syntax-highlighter-factory","title":"5.3. Register the Syntax Highlighter Factory","text":"<p>Register the factory with the Consulo in the plugin configuration file using the <code>com.intellij.lang.syntaxHighlighterFactory</code> extension point.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;lang.syntaxHighlighterFactory language=\"Simple\"\n                implementationClass=\"org.intellij.sdk.language.SimpleSyntaxHighlighterFactory\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/custom_language_support/syntax_highlighter_and_color_settings_page/#54-run-the-project","title":"5.4. Run the Project","text":"<p>Open the example Simple Language properties file  (<code>test.simple</code>) in the IDE Development Instance. The colors for Simple Language Key, Separator, and Value highlighting default to the IDE Language Defaults for Keyword, Braces, Operators, and Strings, respectively.</p> <p></p>"},{"location":"tutorials/custom_language_support/syntax_highlighter_and_color_settings_page/#55-define-a-color-settings-page","title":"5.5. Define a Color Settings Page","text":"<p>The color settings page adds the ability for users to customize color settings for the highlighting in Simple Language files. The <code>SimpleColorSettingsPage</code> implements <code>ColorSettingsPage</code>.</p> <pre><code>{% include /code_samples/simple_language_plugin/src/main/java/org/intellij/sdk/language/SimpleColorSettingsPage.java %}\n</code></pre>"},{"location":"tutorials/custom_language_support/syntax_highlighter_and_color_settings_page/#56-register-the-color-settings-page","title":"5.6. Register the Color Settings Page","text":"<p>Register the Simple Language color settings page with the Consulo in the plugin configuration file using the <code>com.intellij.colorSettingsPage</code> extension point.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;colorSettingsPage implementation=\"org.intellij.sdk.language.SimpleColorSettingsPage\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/custom_language_support/syntax_highlighter_and_color_settings_page/#57-run-the-project","title":"5.7. Run the Project","text":"<p>In the IDE Development Instance, open the Simple Language highlight settings page: Preferences/Settings | Editor | Color Scheme | Simple. Each color initially inherits from a Language Defaults value.</p> <p></p>"},{"location":"tutorials/editor_basics/coordinates_system/","title":"Editor Coordinate Systems - Caret Positions and Offsets","text":"<p>The previous tutorial Working with Text demonstrated how to use actions to access a caret placed in a document open in an editor. The examples replaced selected text in a document by using information about the caret.</p> <p>Every caret has a set of properties describing its position in one of several coordinate systems. This tutorial describes how to access information about the caret(s) in an editor. The tutorial presents the following sections:</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/editor_basics/coordinates_system/#introduction","title":"Introduction","text":"<p>In this tutorial, the editor_basics code sample is used to explore caret positions. In particular, the Caret Position action added by <code>editor_basics</code> to the editor context menu is used to retrieve information about the current caret position. A keyboard shortcut can also initiate the action.</p> <p>{:width=\"600px\"}</p> <p>The source code for the Java class behind the menu action is EditorAreaIllustration. The focus of discussion will be the <code>EditorAreaIllustration.actionPerformed()</code> method. For more information about creating action classes, see the Actions Tutorial which covers the topic in depth.</p>"},{"location":"tutorials/editor_basics/coordinates_system/#caret-positions-from-the-caretmodel-and-caret-objects","title":"Caret Positions from the CaretModel and Caret Objects","text":"<p>The properties of a caret can be accessed by obtaining an instance of the <code>CaretModel</code> object. As in the Working with Text tutorial, the <code>AnActionEvent</code> is used to get the <code>Editor</code> object. The <code>Editor</code> object provides access to the <code>CaretModel</code> object, as shown below:</p> <pre><code>public class EditorAreaIllustration extends AnAction {\n    @Override\n    public void actionPerformed(@NotNull final AnActionEvent e) {\n      // Get access to the editor and caret model. update() validated editor's existence.\n      final Editor editor = e.getRequiredData(CommonDataKeys.EDITOR);\n      final CaretModel caretModel = editor.getCaretModel();\n    }\n}\n</code></pre>"},{"location":"tutorials/editor_basics/coordinates_system/#editor-coordinate-systems","title":"Editor Coordinate Systems","text":"<p>When a <code>Document</code> is opened, the <code>Editor</code> assigns an internal, zero-based coordinate system to lines and columns in the <code>Document</code>. The first line in a <code>Document</code> and the first character in each line are assigned the zero position. Every character in a <code>Document</code> is assigned an Offset, which is a zero-based count of the characters from the beginning of the file to that character. These LogicalPosition coordinates are used to describe the line and column number for a caret position. Note that the Logical Position coordinate system is different from the editor UI, which is one-based rather than zero-based.</p> <p>Logical Position coordinates and other coordinate systems discussed in this tutorial can be used to characterize any location in an <code>Editor</code>, not just carets. Hints used for code insights are characterized in terms of these coordinates, for example <code>HintManager.getHintPosition()</code>. Custom visual elements displayed in an <code>Editor</code>, called <code>Inlay</code> objects, are also expressed in terms of these coordinate systems.</p> <p>The diagram below shows the Logical Position coordinate system applied to some example content. The character \"s\" in the red box represents placing the cursor on that character. It has the caret position of line 1, column 9, and Offset 28. More about caret Offsets is discussed below.</p> <p>{:width=\"800px\"}</p> <p>The Multiple Carets documentation covers the subject of more than one caret in an Editor. For this tutorial, be aware there may be more than one caret in an <code>Editor</code> at any given time. Consequently, examples use the Primary Caret in an <code>Editor</code>. If there is only one caret in an <code>Editor</code>, it is the Primary Caret. For the case of multiple carets in an <code>Editor</code>, the Primary Caret is the one on which query and update methods in the model operate at the moment.</p>"},{"location":"tutorials/editor_basics/coordinates_system/#caret-logical-position","title":"Caret Logical Position","text":"<p>The caret Logical Position is a zero-based, (line and column) position of the caret in the Editor. Logical Position information is obtained from the <code>LogicalPosition</code> object for that caret.</p> <p>The Logical Position line number of a caret ignores the effects of settings that change the presentation of a <code>Document</code> within the Editor. Examples of these settings are Code (Line) Folding and Soft Line Wrap. These effects mean regardless of whether one or more lines in an Editor are folded or soft-wrapped, the caret Logical Position line number will not change.</p> <p>In the example Java file below, Logical Position line numbers 1-3 are folded into line 0. The caret - a blue block - is placed on the letter \"p\" in \"public.\" Using the <code>editor_basics</code> Caret Position action to inspect the caret, it is reported to be at Logical Position (5,0) - which is line 5, character 0 - the first character in the line. This means that caret Logical Position is not changed by Code Folding:</p> <p>{:width=\"800px\"}</p> <p>However, note that applying Code Folding does change the reported Visual Position of the caret even if the Logical Position stays constant. More about Visual Position is discussed below. However, it's clear combinations of Code Folding and Soft Wrap means that one Logical Position of a caret could map to multiple Visual Positions. The <code>Editor</code> interface provides methods to work with a caret Logical and Visual Position, such as the method <code>Editor.logicalToVisualPosition()</code>.</p>"},{"location":"tutorials/editor_basics/coordinates_system/#caret-visual-position","title":"Caret Visual Position","text":"<p>A caret's Visual Position differs from Logical Position in that it takes into account editor presentation settings such as Code Folding and Soft Line Wrap. In doing so, <code>VisualPosition</code> counts - zero-based - the lines of a <code>Document</code> that can be displayed in an Editor. Consequently, Visual Positions can't be uniquely mapped to Logical Positions or corresponding lines in the underlying <code>Document</code>.</p> <p>For example, Soft Line Wrap affects the Visual Position of succeeding lines. In the image below, Soft Line Wrap is applied to Logical line three. With the caret placed at the same character location as in previous tests, it is evident the Logical Position has not changed. However, the Visual Position line number has increased by one! The comments on each line illustrate how the Soft Wrap portion of Logical line three is evaluated as Visual Position line four, as though it was a separate line.</p> <p>{:width=\"800px\"}</p> <p>The Logical and Visual Position objects for a caret are obtained from the <code>Caret</code> object, as shown in the code snippet below.</p> <pre><code>public class EditorAreaIllustration extends AnAction {\n    @Override\n    public void actionPerformed(@NotNull final AnActionEvent e) {\n      // Get access to the editor and caret model.\n      final Editor editor = e.getRequiredData(CommonDataKeys.EDITOR);\n      final CaretModel caretModel = editor.getCaretModel();\n      final Caret primaryCaret = caretModel.getPrimaryCaret();\n      LogicalPosition logicalPos = primaryCaret.getLogicalPosition();\n      VisualPosition visualPos = primaryCaret.getVisualPosition();\n    }\n}\n</code></pre>"},{"location":"tutorials/editor_basics/coordinates_system/#caret-column-position","title":"Caret Column Position","text":"<p>The Column Position is a count of characters from the beginning of a Logical (Position) line to the current caret position in that line. Characters are counted using a zero-based numbering system, so the first character of a line is numbered zero. Note that Column Position is different from the editor UI, which uses a one-based numbering scheme.</p> <p>Column Position includes: * Whitespace, such as tabs.   Tabs can occupy multiple columns, up to the tab size set for the editor. * The character selected by the caret.</p>"},{"location":"tutorials/editor_basics/coordinates_system/#caret-lean","title":"Caret Lean","text":"<p>The Column Position of a caret is the boundary between two characters. A caret can be associated with either a preceding or succeeding character. The association is important in bidirectional text, where mapping from Logical Column Position to Visual Column Position is not continuous.</p> <p>As defined in the <code>LogicalPosition</code> class, if a caret position is associated with a succeeding character it Leans Forward. Otherwise, it is associated with the preceding character.</p> <p>As defined in the <code>VisualPosition</code> class, if a caret position is associated with a succeeding character it Leans Right. Otherwise, it is associated with the preceding character.</p>"},{"location":"tutorials/editor_basics/coordinates_system/#examples-of-caret-lean","title":"Examples of Caret Lean","text":"<p>In the example below, placing a (blue) block caret on the first visible character in Logical line three produces a column position of 0 for both Visual and Logical Positions. Note that the text is unidirectional in this example. In the Logical Position the caret leans forward, meaning it is associated with the succeeding character in the Logical line. For the Visual Position the caret leans right, indicating its association with the succeeding character in the Visual line.</p> <p>{:width=\"800px\"}</p> <p></p> <p>Consider the Java snippet below, and use the <code>editor_basics</code> Caret Position action to report caret information at each step. Be sure to use the keyboard shortcut to invoke the action so that the caret position is not disturbed.</p> <p>The line containing the <code>String</code> variable declaration contains bidirectional text. Starting on the left end of the line, and using the arrow key to advance a line-shaped cursor to between the <code>(\"</code> characters reveals discontinuities in caret coordinate column positions. * After the caret first moves from between <code>g(</code> to between <code>(\"</code>, the Logical and Visual Positions have equal column positions of 28, and neither leans.   Note the value of the caret positions you measure may have different starting values because of line indentation, but the sign and magnitude of the changes in position will be the same. * Advancing the caret once more does not appear to visually move the cursor.   However, the Logical Position column increases to 61, and although the Visual Position column does not change, it leans right. * Continuing to advance the cursor (to the right) through the string causes the Logical Position column to decrease, and the Visual Position column to increase. * Once the cursor advances to between the <code>\".</code> characters, the Logical Position column position is again 28, and leans forward.   The Visual Position column position is now 61. * Moving the caret right once more does not appear to visually advance the cursor.   However, the Logical Position and Visual Position column values are both 61, and both lean. * As the cursor advances to the right, both Logical and Visual column values increase.</p> <pre><code>  public void showNow() {\n//234567890123456789012345678901234567890123456789012345678901234567890\n    String str = new String(\"\u062a\u0639\u0637\u064a \u064a\u0648\u0646\u064a\u0643\u0648\u062f \u0631\u0642\u0645\u0627 \u0641\u0631\u064a\u062f\u0627 \u0644\u0643\u0644 \u062d\u0631\u0641\".getBytes(), java.nio.charset.StandardCharsets.UTF_8);\n    System.out.println( str );\n  }\n</code></pre> <p>The apparent discontinuity in Logical Position is because the RTL portion of the string is treated (or counted) in the logical character order in which it would be written. The apparent continuity in Visual Position is because the RTL portion of the string is counted in the visual order in which it is displayed in the code.</p>"},{"location":"tutorials/editor_basics/coordinates_system/#caret-offset","title":"Caret Offset","text":"<p>The Offset of a caret is a character count from the beginning of a <code>Document</code> to the caret position. Caret offsets are always calculated in terms of Logical Position. The caret Offset includes: * The first (0th) character in a document. * Whitespace characters, including newline and tabs. * Any characters after end-of-line if the IDE settings permit them.   (Preferences | Editor | General | Virtual Space) * The character selected by the caret.</p> <p>The example below demonstrates the Offset of a caret placed at the first character of Logical line one. Note the Offset is 22, which is one greater than the number of visible characters on line zero, and the first character on line one. This apparent discrepancy is actually correct because the Offset includes the newline character for line zero.</p> <p>{:width=\"800px\"}</p>"},{"location":"tutorials/editor_basics/coordinates_system/#displaying-caret-positions","title":"Displaying Caret Positions","text":"<p>To display the values of caret Logical and Visual positions, and Offset, a <code>Messages.showInfoMessage()</code> method shows them in the form of notification as the action is performed.</p> <pre><code>public class EditorAreaIllustration extends AnAction {\n\n  public void actionPerformed(@NotNull final AnActionEvent e) {\n    // Get access to the editor and caret model.\n    final Editor editor = e.getRequiredData(CommonDataKeys.EDITOR);\n    final CaretModel caretModel = editor.getCaretModel();\n\n    // Getting the primary caret ensures we get the correct one of a possible many.\n    final Caret primaryCaret = caretModel.getPrimaryCaret();\n    // Get the caret information\n    LogicalPosition logicalPos = primaryCaret.getLogicalPosition();\n    VisualPosition visualPos = primaryCaret.getVisualPosition();\n    int caretOffset = primaryCaret.getOffset();\n\n    // Build and display the caret report.\n    String report = logicalPos.toString() + \"\\n\" + visualPos.toString() + \"\\n\" +\n            \"Offset: \" + caretOffset;\n    Messages.showInfoMessage(report.toString(), \"Caret Parameters Inside The Editor\");\n  }\n\n}\n</code></pre>"},{"location":"tutorials/editor_basics/editor_events/","title":"3. Handling Editor Events","text":"<p>The previous tutorial Editor Coordinate Systems described working with caret coordinate systems in an editor window. Caret position was discussed in terms of Logical Position, Visual Position, and Offset. This tutorial introduces the Editor Action system, which handles actions activated by keystroke events in the editor. Two classes from the editor_basics code sample are used to illustrate: * Using an Consulo <code>EditorActionHandler</code> to manipulate a caret. * Creating and registering a custom <code>TypedActionHandler</code> to intercept keystrokes and change the document.</p> <p>The tutorial presents the following sections:</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/editor_basics/editor_events/#using-an-consulo-editoractionhandler","title":"Using an Consulo EditorActionHandler","text":"<p>In this portion of the tutorial, the editor_basics code sample is used to demonstrate cloning an existing caret. A custom action class will use <code>EditorActionManager</code> to access a specific <code>EditorActionHandler</code> for caret cloning. The <code>editor_basics</code> code sample adds an Editor Add Caret menu item to the editor context menu:</p> <p>{:width=\"600px\"}</p>"},{"location":"tutorials/editor_basics/editor_events/#creating-the-menu-action-class","title":"Creating the Menu Action Class","text":"<p>The source code for the Java action class is EditorHandlerIllustration, a subclass of <code>AnAction</code>. For more information about creating action classes, see the Actions Tutorial which covers the topic in depth.</p> <p>The <code>EditorHandlerIllustration</code> action is registered in the editor_basic <code>plugin.xml</code> file. Note that this action class is registered to appear on the Editor context menu.</p> <pre><code>&lt;actions&gt;\n    &lt;action id=\"EditorBasics.EditorHandlerIllustration\"\n            class=\"org.intellij.sdk.editor.EditorHandlerIllustration\"\n            text=\"Editor Add Caret\"\n            description=\"Adds a second caret below the existing one.\"\n            icon=\"SdkIcons.Sdk_default_icon\"&gt;\n      &lt;add-to-group group-id=\"EditorPopupMenu\" anchor=\"first\"/&gt;\n    &lt;/action&gt;\n&lt;/action&gt;\n</code></pre>"},{"location":"tutorials/editor_basics/editor_events/#setting-visibility-for-the-action-menu-entry","title":"Setting Visibility for the Action Menu Entry","text":"<p>Under what conditions should the <code>EditorHandlerIllustration</code> action be capable of cloning a caret? Only if the following conditions are met in the <code>EditorHandlerIllustration.update()</code> method: * A project is open, * An editor is available, * There is at least one caret active in the editor.</p> <p>After ensuring that <code>Project</code> and <code>Editor</code> objects are available, the <code>Editor</code> object is used to verify there is at least one caret:</p> <pre><code>public class EditorHandlerIllustration extends AnAction {\n  @Override\n  public void update(@NotNull final AnActionEvent e) {\n    final Project project = e.getProject();\n    final Editor editor = e.getData(CommonDataKeys.EDITOR);\n\n    // Make sure at least one caret is available\n    boolean menuAllowed = false;\n    if (editor != null &amp;&amp; project != null) {\n      // Ensure the list of carets in the editor is not empty\n      menuAllowed = !editor.getCaretModel().getAllCarets().isEmpty();\n    }\n    e.getPresentation().setEnabledAndVisible(menuAllowed);\n  }\n}\n</code></pre>"},{"location":"tutorials/editor_basics/editor_events/#acquiring-the-correct-editoractionhandler","title":"Acquiring the Correct EditorActionHandler","text":"<p>When the <code>EditorHandlerIllustration.actionPerformed()</code> method clones the caret, it should use the appropriate Consulo <code>EditorActionHandler</code>. An instance of <code>EditorActionManager</code> is required to obtain the correct <code>EditorActionHandler</code>. The <code>EditorActionManager</code> class provides a static method to do this.</p> <p>To request the correct <code>EditorActionHandler</code> from <code>EditorActionManager</code>, consult the <code>IdeActions</code> interface for the correct constant to pass into the <code>EditorActionManager.getActionHandler()</code> method. For cloning a caret below the primary caret, the constant is <code>ACTION_EDITOR_CLONE_CARET_BELOW</code>. Based on that constant, the <code>EditorActionManager</code> returns an instance of <code>CloneCaretActionHandler</code>, a subclass of <code>EditorActionHandler</code>.</p> <pre><code>    // Snippet from EditorHandlerIllustration.actionPerformed()\n    final EditorActionManager actionManager = EditorActionManager.getInstance();\n    final EditorActionHandler actionHandler = actionManager.getActionHandler(IdeActions.ACTION_EDITOR_CLONE_CARET_BELOW);\n</code></pre>"},{"location":"tutorials/editor_basics/editor_events/#using-an-editoractionhandler-to-clone-the-caret","title":"Using an EditorActionHandler to Clone the Caret","text":"<p>To clone the caret requires only calling the <code>EditorActionHandler.execute()</code> method and passing in the appropriate context.</p> <pre><code>public class EditorHandlerIllustration extends AnAction {\n  @Override\n  public void actionPerformed(@NotNull final AnActionEvent e) {\n    final Editor editor = e.getRequiredData(CommonDataKeys.EDITOR);\n    final EditorActionManager actionManager = EditorActionManager.getInstance();\n    final EditorActionHandler actionHandler = actionManager.getActionHandler(IdeActions.ACTION_EDITOR_CLONE_CARET_BELOW);\n    actionHandler.execute(editor, editor.getCaretModel().getPrimaryCaret(), e.getDataContext());\n  }\n}\n</code></pre>"},{"location":"tutorials/editor_basics/editor_events/#creating-a-custom-typedactionhandler","title":"Creating a Custom TypedActionHandler","text":"<p>The <code>TypedActionHandler</code> interface is the basis for classes that handle keystroke events from the editor. Custom implementations of the class are registered to handle editor keystroke events, and receive a callback for each keystroke. The steps below explain how to use <code>TypedActionHandler</code> to customize the behavior of the editor when keystroke events are received.</p>"},{"location":"tutorials/editor_basics/editor_events/#implementing-a-custom-typedactionhandler-class","title":"Implementing a Custom TypedActionHandler Class","text":"<p>First, a subclass such as <code>MyTypedHandler</code> is created based on <code>TypedActionHandler</code>. The class overrides the method <code>TypedActionHandler.execute()</code>, which is the callback for editor keystroke events.</p>"},{"location":"tutorials/editor_basics/editor_events/#implementing-the-keystroke-event-handling-logic","title":"Implementing the Keystroke Event Handling Logic","text":"<p>Override the <code>TypedActionHandler.execute()</code> method in <code>MyTypedHandler</code> to implement the logic for handling keystroke events. This method is called every time a key is pressed when the Editor Tool Window has focus.</p> <p>In the following example, the <code>MyTypedHandler.execute()</code> method inserts \"editor_basics\\n\" at the zero caret Offset position when a keystroke event occurs. As explained in Working with Text, safe modifications to the document must be in the context of a write action. So although a method on the <code>Document</code> interface does the <code>String</code> insertion, the write action ensures a stable context.</p> <pre><code>class MyTypedHandler implements TypedActionHandler {\n  @Override\n  public void execute(@NotNull Editor editor, char c, @NotNull DataContext dataContext) {\n    final Document document = editor.getDocument();\n    final Project project = editor.getProject();\n    Runnable runnable = () -&gt; document.insertString(0, \"editor_basics\\n\");\n    WriteCommandAction.runWriteCommandAction(project, runnable);\n  }\n}\n</code></pre>"},{"location":"tutorials/editor_basics/editor_events/#registering-a-custom-typedactionhandler","title":"Registering a Custom TypedActionHandler","text":"<p>A custom implementation of <code>TypedActionHandler</code> must be registered to replace the existing typing handler to receive editor keystroke events. The registration is done through the <code>TypedAction</code> class.</p> <p>As is shown in the snippet below, the <code>EditorActionManager</code> is used to get access to the <code>TypedAction</code> class. The method <code>TypedAction.setupHandler()</code> is used to register the custom <code>MyTypedHandler</code> class:</p> <pre><code>public class EditorHandlerIllustration extends AnAction {\n    static {\n        final EditorActionManager actionManager = EditorActionManager.getInstance();\n        final TypedAction typedAction = actionManager.getTypedAction();\n        typedAction.setupHandler(new MyTypedHandler());\n    }\n}\n</code></pre> <p>Placing the registration code in the <code>EditorHandlerIllustration</code> class is somewhat arbitrary in the sense that the registration of <code>MyTypedHandler</code> has nothing to do with the <code>EditorHandlerIllustration</code> class. However, the <code>EditorHandlerIllustration</code> class is convenient because as an action it gets instantiated at application startup. On instantiation, the <code>static</code> block of code in <code>EditorHandlerIllustration</code> gets evaluated. In the <code>editor_basics</code> code sample any of the <code>AnAction</code> derived classes would work for registering <code>MyTypedHandler</code>.</p>"},{"location":"tutorials/editor_basics/working_with_text/","title":"Working with Text","text":"<p>This tutorial shows how to use actions to access a caret placed in a document open in an editor. Using information about the caret, replace selected text in a document with a string. The tutorial presents the following sections:</p> <ul> <li>bullet list {:toc}</li> </ul>"},{"location":"tutorials/editor_basics/working_with_text/#introduction","title":"Introduction","text":"<p>The approach in this tutorial relies heavily on creating and registering actions. To review the fundamentals of creating and registering actions, refer to the Actions Tutorial.</p> <p>Multiple examples are used from the editor_basics plugin code sample from the Consulo SDK. It may be helpful to open that project in an Consulo-based IDE, build the project, run it, select some text in the editor, and invoke the Editor Replace Text menu item on the editor context menu.</p> <p>{:width=\"600px\"}</p>"},{"location":"tutorials/editor_basics/working_with_text/#creating-a-new-menu-action","title":"Creating a New Menu Action","text":"<p>In this example, we access the <code>Editor</code> from an action. The source code for the Java class in this example is EditorIllustrationAction.</p> <p>To register the action, we must add the corresponding elements to the <code>&lt;actions&gt;</code> section of the plugin configuration file plugin.xml. For more information, refer to the Registering Actions section of the Actions Tutorial. The <code>EditorIllustrationAction</code> action is registered in the group <code>EditorPopupMenu</code> so it will be available from the context menu when focus is on the editor:</p> <pre><code>    &lt;action id=\"EditorBasics.EditorIllustrationAction\"\n            class=\"org.intellij.sdk.editor.EditorIllustrationAction\"\n            text=\"Editor Replace Text\"\n            description=\"Replaces selected text with 'Replacement'.\"\n            icon=\"SdkIcons.Sdk_default_icon\"&gt;\n      &lt;add-to-group group-id=\"EditorPopupMenu\" anchor=\"first\"/&gt;\n    &lt;/action&gt;\n</code></pre>"},{"location":"tutorials/editor_basics/working_with_text/#defining-the-menu-actions-visibility","title":"Defining the Menu Action's Visibility","text":"<p>To determine conditions by which the action will be visible and available requires <code>EditorIllustrationAction</code> to override the <code>AnAction.update()</code> method. For more information, refer to Extending the Update Method section of the Actions Tutorial.</p> <p>To work with a selected part of the text, it's reasonable to make the menu action available only when the following requirements are met: * There is a <code>Project</code> object, * There is an instance of <code>Editor</code> available, * There is a text selection in <code>Editor</code>.</p> <p>Additional steps will show how to check these conditions through obtaining instances of <code>Project</code> and <code>Editor</code> objects, and how to show or hide the action's menu items based on them.</p>"},{"location":"tutorials/editor_basics/working_with_text/#getting-an-instance-of-the-active-editor-from-an-action-event","title":"Getting an Instance of the Active Editor from an Action Event","text":"<p>Using the <code>AnActionEvent</code> event passed into the <code>update</code> method, a reference to an instance of the <code>Editor</code> can be obtained by calling <code>getData(CommonDataKeys.EDITOR)</code>. Similarly, to obtain a project reference, we use the <code>getProject()</code> method.</p> <pre><code>public class EditorIllustrationAction extends AnAction {\n    @Override\n    public void update(@NotNull final AnActionEvent e) {\n      // Get required data keys\n      final Project project = e.getProject();\n      final Editor editor = e.getData(CommonDataKeys.EDITOR);\n    }\n}\n</code></pre> <p>Note: There are other ways to access an <code>Editor</code> instance: * If a <code>DataContext</code> object is available: <code>CommonDataKeys.EDITOR.getData(context);</code> * If only a <code>Project</code> object is available, use <code>FileEditorManager.getInstance(project).getSelectedTextEditor()</code></p>"},{"location":"tutorials/editor_basics/working_with_text/#obtaining-a-caret-model-and-selection","title":"Obtaining a Caret Model and Selection","text":"<p>After making sure a project is open, and an instance of the <code>Editor</code> is obtained, we need to check if any selection is available. The <code>SelectionModel</code> interface is accessed from the <code>Editor</code> object. Determining whether some text is selected is accomplished by calling the <code>SelectionModel.hasSelection()</code> method. Here's how the <code>EditorIllustrationAction.update(AnActionEvent e)</code> method should look:</p> <pre><code>public class EditorIllustrationAction extends AnAction {\n  @Override\n  public void update(@NotNull final AnActionEvent e) {\n    // Get required data keys\n    final Project project = e.getProject();\n    final Editor editor = e.getData(CommonDataKeys.EDITOR);\n\n    // Set visibility only in case of existing project and editor and if a selection exists\n    e.getPresentation().setEnabledAndVisible( project != null\n                                              &amp;&amp; editor != null\n                                              &amp;&amp; editor.getSelectionModel().hasSelection() );\n  }\n}\n</code></pre> <p>Note: <code>Editor</code> also allows access to different models of text representation. The model classes are located in editor, and include: * <code>CaretModel</code>, * <code>FoldingModel</code>, * <code>IndentsModel</code>, * <code>ScrollingModel</code>, * <code>SoftWrapModel</code></p>"},{"location":"tutorials/editor_basics/working_with_text/#safely-replacing-selected-text-in-the-document","title":"Safely Replacing Selected Text in the Document","text":"<p>Based on the evaluation of conditions by <code>EditorIllustrationAction.update()</code>, the <code>EditorIllustrationAction</code> action menu item is visible. To make the menu item do something, the <code>EditorIllustrationAction</code> class must override the <code>AnAction.actionPerformed()</code> method. As explained below, this will require the <code>EditorIllustrationAction.actionPerformed()</code> method to: * Gain access to the document. * Get the character locations defining the selection. * Safely replace the contents of the selection.</p> <p>Modifying the selected text requires an instance of the <code>Document</code> object, which is accessed from the <code>Editor</code> object. The Document represents the contents of a text file loaded into memory and opened in an Consulo-based IDE editor. An instance of the <code>Document</code> will be used later when a text replacement is performed.</p> <p>The text replacement will also require information about where the selection is in the document, which is provided by the primary <code>Caret</code> object, obtained from the <code>CaretModel</code>. Selection information is measured in terms of Offset, the count of characters from the beginning of the document to a caret location.</p> <p>Text replacement could be done by calling the <code>Document</code> object's <code>replaceString()</code> method. However, safely replacing the text requires the <code>Document</code> to be locked and any changes performed in a write action. See the Threading Issues section to learn more about synchronization issues and changes safety on the Consulo. This example changes the document within a <code>WriteCommandAction</code>.</p> <p>The complete <code>EditorIllustrationAction.actionPerformed()</code> method is shown below: * Note the selection in the document is replaced by a string using a method on the <code>Document</code> object, but the method call is wrapped in a write action. * After the document change, the new text is de-selected by a call to the primary caret.</p> <pre><code>public class EditorIllustrationAction extends AnAction {\n  @Override\n  public void actionPerformed(@NotNull final AnActionEvent e) {\n    // Get all the required data from data keys\n    final Editor editor = e.getRequiredData(CommonDataKeys.EDITOR);\n    final Project project = e.getRequiredData(CommonDataKeys.PROJECT);\n    final Document document = editor.getDocument();\n\n    // Work off of the primary caret to get the selection info\n    Caret primaryCaret = editor.getCaretModel().getPrimaryCaret();\n    int start = primaryCaret.getSelectionStart();\n    int end = primaryCaret.getSelectionEnd();\n\n    // Replace the selection with a fixed string.\n    // Must do this document change in a write action context.\n    WriteCommandAction.runWriteCommandAction(project, () -&gt;\n        document.replaceString(start, end, \"editor_basics\")\n    );\n\n    // De-select the text range that was just replaced\n    primaryCaret.removeSelection();\n  }\n}\n</code></pre>"},{"location":"tutorials/live_templates/new_macros/","title":"Creating New Functions for Live Templates","text":"<p>The Predefined Functions are the building blocks for creating Parameterized Templates and Surround Templates. However, sometimes the Predefined Functions are not enough.</p> <p>This tutorial illustrates how to add custom functions to an Consulo plugin and make them available for use by Live Templates. As an example, a function is created to convert a selection to Title Case. Refer to the SDK code sample <code>live_templates</code>.</p> <ul> <li>bullet {:toc}</li> </ul>"},{"location":"tutorials/live_templates/new_macros/#implementing-a-new-function","title":"Implementing a New Function","text":"<p>Under the hood, the predefined functions for Live Templates are called macros. A new custom function for Live Templates is implemented in <code>TitleCaseMacro</code>, which extends <code>MacroBase</code>. Three <code>TitleCaseMacro</code> methods are of particular interest: * The <code>TitleCaseMacro()</code> constructor passes the name and description of the macro to the parent constructor. * The <code>isAcceptableInContext()</code> method tests whether the macro is available in the current context.   The test relies on the <code>MarkdownContext</code> object previously defined in the <code>live_templates</code> plugin. * The <code>calculateResult()</code> method gets invoked when the titleCase function is used in a Live Template.   The text to be capitalized is retrieved from the Live Template and converted to Title Case.</p> <pre><code>{% include /code_samples/live_templates/src/main/java/org/intellij/sdk/liveTemplates/TitleCaseMacro.java%}\n</code></pre>"},{"location":"tutorials/live_templates/new_macros/#adding-a-live-template","title":"Adding a Live Template","text":"<p>Using the procedures previously discussed for Template Creation and Export the Live Template, add a Live Template to the Markdown.xml file for the plugin. The XML representation of an example Live Template using the new <code>titleCase</code> function is listed below.</p> <p>There is only one variable, <code>TITLE</code>. The expression for <code>TITLE</code> evaluates to the <code>titleCase</code> function provided by the plugin. The argument to the <code>titleCase</code> function is <code>SELECTION</code>, which tells the Consulo to operate on the current selection.</p> <pre><code>&lt;template name=\"mc\"\n        value=\"$TITLE$\"\n        description=\"SDK: Convert to title case\"\n        toReformat=\"true\"\n        toShortenFQNames=\"false\"&gt;\n  &lt;variable name=\"TITLE\" expression=\"titleCase(SELECTION)\" defaultValue=\"the quick brown fox\" alwaysStopAt=\"true\" /&gt;\n  &lt;context&gt;\n    &lt;option name=\"MARKDOWN\" value=\"true\" /&gt;\n  &lt;/context&gt;\n&lt;/template&gt;\n</code></pre>"},{"location":"tutorials/live_templates/new_macros/#register-extension-point","title":"Register Extension Point","text":"<p>Using the <code>com.intellij.liveTemplateMacro</code> extension point, register the implementation with the Consulo.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;liveTemplateMacro implementation=\"org.intellij.sdk.liveTemplates.TitleCaseMacro\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/live_templates/new_macros/#check-plugin","title":"Check Plugin","text":"<p>Now verify the plugin is working correctly. * Run the plugin in a Development Instance. * Create a new file <code>testing.md</code> and enter several words in lower case. * Highlight the text and enter \u2325\u2318J to open the Select Template popup.   Confirm that the SDK: Convert to title case is available in the popup, and select it.</p> <p>{:width=\"700px\"}</p> <p>Test that the Live Template works by entering m or return. The text will change to have each word capitalized:</p> <p>{:width=\"700px\"}</p>"},{"location":"tutorials/live_templates/template_support/","title":"Adding Live Templates to a Plugin","text":"<p>This tutorial illustrates how to add default Custom Live Templates to an Consulo plugin, and assign valid contexts for these templates based on the surrounding code and file type. In addition, the tutorial discusses how to export existing Live Templates, and bundle them within a plugin. Any Live Template that can be created and exported can be added to a plugin by following the Template Creation, Export, and Extension Point Registration processes.</p> <p>This tutorial uses the SDK code sample <code>live_templates</code>.</p> <ul> <li>bullet {:toc}</li> </ul>"},{"location":"tutorials/live_templates/template_support/#template-creation","title":"Template Creation","text":"<p>Get started by creating a new Live Template within the Consulo-based IDE: * Add a new Template Group, \"Markdown\" and create a new Live Template under this group. * Assign the template the abbreviation \"{\". * Assign the description \"SDK: New link reference\". * Paste the following snippet into the Template text field:</p> <pre><code>[$TEXT$]($LINK$)$END$\n</code></pre> <p>The variables <code>$TEXT$</code> and <code>$LINK$</code> may be further configured in the Edit variables dialogue to reorder their precedence and bind to functions that invoke auto-completion at the appropriate time. In the Edit variables dialog, set the <code>Expression</code> for the <code>LINK</code> to <code>complete()</code> using the combobox.</p> <p>There are many other predefined functions that developers should become familiar with before implementing any unique functionality in a plugin.</p> <p>TIP Consider iteratively testing the Live Template using the current editor and a markdown file to minimize debugging later.</p>"},{"location":"tutorials/live_templates/template_support/#export-the-live-template","title":"Export the Live Template","text":"<p>Once the Live Template produces the expected result, export the Live Template. The export produces a file called <code>Markdown.xml</code> with the following contents:</p> <pre><code>&lt;templateSet group=\"Markdown\"&gt;\n  &lt;template name=\"{\"\n            value=\"[$TEXT$]($LINK$)$END$\"\n            description=\"SDK: New link reference\"\n            toReformat=\"false\"\n            toShortenFQNames=\"false\"&gt;\n    &lt;variable name=\"TEXT\" expression=\"\" defaultValue=\"\" alwaysStopAt=\"true\" /&gt;\n    &lt;variable name=\"LINK\" expression=\"complete()\" defaultValue=\"\" alwaysStopAt=\"true\" /&gt;\n  &lt;/template&gt;\n&lt;/templateSet&gt;\n</code></pre> <p>The display <code>name</code> can also provide localized variants by specifying <code>key</code> and <code>resource-bundle</code> attributes additionally (2020.3 and later).</p> <p>Copy this file into the plugin's resources folder.</p>"},{"location":"tutorials/live_templates/template_support/#implement-templatecontexttype","title":"Implement TemplateContextType","text":"<p>A <code>TemplateContextType</code> tells the Consulo where the Live Template is applicable: Markdown files. Every context must have a unique <code>TemplateContextType</code> defined for it, and many context types are defined by the Platform. The <code>MarkdownContext</code> class defines it for Markdown files. Ultimately, a file's extension determines the applicable Markdown context.</p> <pre><code>{% include /code_samples/live_templates/src/main/java/org/intellij/sdk/liveTemplates/MarkdownContext.java%}\n</code></pre> <p>NOTE Once the <code>MarkdownContext</code> is defined, be sure to add the new context type to the previously created Live Template settings file.</p> <p>Within the <code>&lt;template&gt;...&lt;/template&gt;</code> elements in the <code>Markdown.xml</code> Live Template definition file, add the following context elements:</p> <pre><code>    &lt;variable.../&gt;\n    &lt;context&gt;\n      &lt;option name=\"MARKDOWN\" value=\"true\"/&gt;\n    &lt;/context&gt;\n  &lt;/template&gt;\n</code></pre> <p>It is not always necessary to define your own <code>TemplateContextType</code>, as there are many existing template contexts already defined in the Consulo. Consider reusing one of the many existing template context types that inherit from <code>TemplateContextType</code> if you are augmenting language support to an existing area.</p>"},{"location":"tutorials/live_templates/template_support/#completing-the-live-template-implementation","title":"Completing the Live Template Implementation","text":"<p>Depending on the version of the Consulo, different steps are used to complete the implementation of the feature.</p>"},{"location":"tutorials/live_templates/template_support/#versions-20201-and-later","title":"Versions 2020.1 and Later","text":"<p>For 2020.1 and later, follow this section to register the extension points and then proceed to the Check Plugin section.</p>"},{"location":"tutorials/live_templates/template_support/#register-extension-points","title":"Register Extension Points","text":"<p>Using the <code>com.intellij.defaultLiveTemplates</code> and <code>com.intellij.liveTemplateContext</code> extension points, register the implementations with the Consulo. The <code>file</code> attribute in the <code>defaultLiveTemplates</code> element specifies <code>path/filename</code> under the <code>src/main/resources</code> folder.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;defaultLiveTemplates file=\"/liveTemplates/Markdown.xml\"/&gt;\n    &lt;liveTemplateContext implementation=\"org.intellij.sdk.liveTemplates.MarkdownContext\"/&gt;\n  &lt;/extensions&gt;\n</code></pre> <p>Now go to the Check Plugin section to test the template.</p>"},{"location":"tutorials/live_templates/template_support/#versions-20193-and-earlier","title":"Versions 2019.3 and Earlier","text":"<p>For older versions of the Consulo follow this section to complete the implementation and register the extension points. Then proceed to the Check Plugin section.</p>"},{"location":"tutorials/live_templates/template_support/#implement-defaultlivetemplatesprovider","title":"Implement DefaultLiveTemplatesProvider","text":"<p>The <code>MarkdownTemplateProvider</code> tells the Platform where to find the Live Template settings file. Make sure to include the full path to the file, relative to the <code>src/main/resources</code> directory, excluding the file extension.</p> <pre><code>package org.intellij.sdk.liveTemplates;\n\nimport com.intellij.codeInsight.template.impl.DefaultLiveTemplatesProvider;\nimport org.jetbrains.annotations.Nullable;\n\npublic class MarkdownTemplateProvider implements DefaultLiveTemplatesProvider {\n  @Override\n  public String[] getDefaultLiveTemplateFiles() {\n    return new String[]{\"liveTemplates/Markdown\"};\n  }\n\n  @Nullable\n  @Override\n  public String[] getHiddenLiveTemplateFiles() {\n    return null;\n  }\n}\n</code></pre>"},{"location":"tutorials/live_templates/template_support/#register-extension-points_1","title":"Register Extension Points","text":"<p>Using the <code>com.intellij.defaultLiveTemplatesProvider</code> and <code>com.intellij.liveTemplateContext</code> extension points, register the implementations with the Consulo.</p> <pre><code>  &lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n    &lt;defaultLiveTemplatesProvider implementation=\"org.intellij.sdk.liveTemplates.MarkdownTemplateProvider\"/&gt;\n    &lt;liveTemplateContext implementation=\"org.intellij.sdk.liveTemplates.MarkdownContext\"/&gt;\n  &lt;/extensions&gt;\n</code></pre>"},{"location":"tutorials/live_templates/template_support/#check-plugin","title":"Check Plugin","text":"<p>Now verify the plugin is working correctly. Run the plugin in a Development Instance and verify there is a new entry under Settings/Preferenes | Live Templates | Markdown | { (SDK: New link reference).</p> <p>Finally, create a new file <code>test.md</code> and confirm that the Live Template works by entering a { character and then pressing Tab.</p>"},{"location":"user_interface_components/dialog_wrapper/","title":"Dialogs","text":""},{"location":"user_interface_components/dialog_wrapper/#dialogwrapper","title":"DialogWrapper","text":"<p>The <code>DialogWrapper</code> is the base class which is supposed to be used for all modal dialogs (and some non-modal dialogs) shown in Consulo.</p> <p>It provides the following features:</p> <ul> <li>Button layout (platform-specific order of OK/Cancel buttons, macOS-specific <code>Help</code> button)</li> <li>Context help</li> <li>Remembering the size of the dialog</li> <li>Non-modal validation (displaying an error message text when the data entered into the dialog is not valid)</li> <li>Keyboard shortcuts:<ul> <li>Esc for closing the dialog</li> <li>Left/Right for switching between buttons</li> <li>Y/N for Yes/No actions if they exist in the dialog</li> </ul> </li> <li>Optional Do not ask again checkbox</li> </ul> <p>When using the <code>DialogWrapper</code> class for a dialog, follow these steps:</p> <ul> <li>Call the base class constructor and provide either a project in the frame of which the dialog will be displayed, or a parent component for the dialog.</li> <li>Call the <code>init()</code> method from the constructor of the dialog class</li> <li>Call the <code>setTitle()</code> method to set the title for the dialog box</li> <li> <p>Implement the <code>createCenterPanel()</code> method to return the component comprising the main contents of the dialog.</p> </li> <li> <p>Optional: Override the <code>getPreferredFocusedComponent()</code> method and return the component that should be focused when the dialog is first displayed.</p> </li> <li>Optional: Override the <code>getDimensionServiceKey()</code> method to return the identifier which will be used for persisting the dialog dimensions.</li> <li>Optional: Override the <code>getHelpId()</code> method to return the context help topic associated with the dialog.</li> </ul> <p>The <code>DialogWrapper</code> class is often used together with GUI Designer forms. In this case, bind a GUI Designer form to the class extending <code>DialogWrapper</code>, bind the top-level panel of the form to a field and return that field from the <code>createCenterPanel()</code> method.</p> <p>TIP Existing dialogs can be inspected at runtime using UI Inspector, e.g., to locate the underlying implementation of UI components.</p> <p>To display the dialog, call the <code>show()</code> method and then use the <code>getExitCode()</code> method to check how the dialog was closed. The <code>showAndGet()</code> method can be used to combine these two calls.</p> <p>To customize the buttons displayed in the dialog (replacing the standard OK/Cancel/Help set of buttons), override either the <code>createActions()</code> or <code>createLeftActions()</code> methods. Both of these methods return an array of Swing Action objects. If a button closes the dialog, use <code>DialogWrapperExitAction</code> as the base class for the action. Use <code>action.putValue(DialogWrapper.DEFAULT_ACTION, true)</code> to set the default button.</p> <p>To validate the data entered into the dialog, override the <code>doValidate()</code> method. The method will be called automatically by timer. If the currently entered data is valid, return <code>null</code>. Otherwise, return a <code>ValidationInfo</code> object which encapsulates an error message, and an optional component associated with the invalid data. When specifying a component, an error icon will be displayed next to it, and it will be focused when the user tries to invoke the OK action.</p>"},{"location":"user_interface_components/dialog_wrapper/#example","title":"Example","text":"<p>Simple definition of a <code>DialogWrapper</code>:</p> <pre><code>public class SampleDialogWrapper extends DialogWrapper {\n\n    public SampleDialogWrapper() {\n        super(true); // use current window as parent\n        init();\n        setTitle(\"Test DialogWrapper\");\n    }\n\n    @Nullable\n    @Override\n    protected JComponent createCenterPanel() {\n        JPanel dialogPanel = new JPanel(new BorderLayout());\n\n        JLabel label = new JLabel(\"testing\");\n        label.setPreferredSize(new Dimension(100, 100));\n        dialogPanel.add(label, BorderLayout.CENTER);\n\n        return dialogPanel;\n    }\n}\n</code></pre> <p>Usage of <code>DialogWrapper</code>:</p> <pre><code>JButton testButton = new JButton();\ntestButton.addActionListener(actionEvent -&gt; {\n  if (new SampleDialogWrapper().showAndGet()) {\n    // user pressed OK\n  }\n});\n</code></pre>"},{"location":"user_interface_components/editor_components/","title":"Editor Components","text":""},{"location":"user_interface_components/editor_components/#editortextfield","title":"EditorTextField","text":"<p>Compared to Swing <code>JTextArea</code>, the Consulo's editor component has a ton of advantages: syntax highlighting support, code completion, code folding and much more. Editors are normally displayed in editor tabs, but they can be embedded in dialogs or tool windows, too. This is enabled by the <code>EditorTextField</code> component.</p> <p>The following attributes can be specified:</p> <ul> <li>The file type according to which the text in the text field is parsed;</li> <li>Whether the text field is read-only or editable;</li> <li>Whether the text field is single-line or multiline.</li> </ul> <p>Further customizations are possible by subclassing and overriding <code>createEditor()</code>.</p> <p>A common use case for <code>EditorTextField</code> is entering the name of a Java class or package. This can be accomplished with the following steps:</p> <ul> <li>Use <code>JavaCodeFragmentFactory.getInstance().createReferenceCodeFragment()</code> to create a code fragment representing the class or package name;</li> <li>Call <code>PsiDocumentManager.getInstance().getDocument()</code> to get the document corresponding to the code fragment;</li> <li>Pass the returned document to the <code>EditorTextField</code> constructor or its <code>setDocument()</code> method.</li> </ul> <p>E.g.:</p> <pre><code>PsiFile psiFile = PsiDocumentManager.getInstance(editor.getProject()).getPsiFile(editor.getDocument());\nPsiElement element = psiFile.findElementAt(editor.getCaretModel().getOffset());\n\nPsiExpressionCodeFragment code = JavaCodeFragmentFactory.getInstance(editor.getProject())\n                                   .createExpressionCodeFragment(\"\", element, null, true);\n\nDocument document = PsiDocumentManager.getInstance(editor.getProject()).getDocument(code);\n\nEditorTextField myInput = new EditorTextField(document, editor.getProject(), JavaFileType.INSTANCE);\n</code></pre> <p>TIPS:</p> <ul> <li>When creating more than one field two separate documents are needed.   This is accomplished by using separate instances of <code>PsiExpressionCodeFragment</code>.</li> <li><code>setText()</code> no longer works for the input field.   However, <code>createExpressionCodeFragment()</code> accepts the text for the field as an argument.   The empty string can be replaced and create a new document in lieu of <code>setText()</code>.</li> <li>Instances of <code>JTextField</code> in the GUI builder can be replaced with a custom replacement component using the right click in your IDE.   Make sure to use \"Custom Create\", so the initialization code works properly.</li> </ul>"},{"location":"user_interface_components/file_and_class_choosers/","title":"File and Class Choosers","text":""},{"location":"user_interface_components/file_and_class_choosers/#file-choosers","title":"File Choosers","text":""},{"location":"user_interface_components/file_and_class_choosers/#via-dialog","title":"Via Dialog","text":"<p>To let a user choose a file, directory or multiple files, use the <code>FileChooser.chooseFiles()</code> method. This method has multiple overloads. The best method to use is the one which returns void and takes a callback receiving the list of selected files as a parameter. This is the only overload which will display a native file open dialog on macOS.</p> <p>The <code>FileChooserDescriptor</code> class allows you to control which files can be selected. The constructor parameters specify whether files and/or directories can be selected, and whether multiple selection is allowed (see FileChooserDescriptorFactory for common variants).</p> <p>For more fine-grained control over the allowed selection, you can overload the <code>isFileSelectable()</code> method. You can also customize the presentation of files by overriding <code>getIcon()</code>, <code>getName()</code> and <code>getComment()</code> methods. Note that the native macOS file chooser does not support most of the customizations, so if you rely on them, you need to use an overload of <code>chooseFiles()</code> which displays the standard Consulo dialog.</p>"},{"location":"user_interface_components/file_and_class_choosers/#via-textfield","title":"Via Textfield","text":"<p>A very common way of using file choosers is to use a text field for entering the path with an ellipsis button (\"...\") for showing the file chooser. To create such a control, use the <code>TextFieldWithBrowseButton</code> component and call the <code>addBrowseFolderListener()</code> method on it to set up the file chooser. As an added bonus, this will enable filename completion when entering paths in the text box.</p>"},{"location":"user_interface_components/file_and_class_choosers/#via-tree","title":"Via Tree","text":"<p>An alternative UI for selecting files, which works best when the most common way of selecting a file is by typing its name, is available through the <code>TreeFileChooserFactory</code> class.</p> <p>The dialog shown by this API has two tabs:</p> <ul> <li> <p>One shows the project structure</p> </li> <li> <p>Another shows a list of files similar to the one used by the <code>Goto File</code> popup.</p> </li> </ul> <p>To show the dialog, call <code>showDialog()</code> on the chooser returned from <code>createFileChooser()</code>, and then call <code>getSelectedFile</code> to retrieve the user's selection.</p>"},{"location":"user_interface_components/file_and_class_choosers/#class-and-package-choosers","title":"Class and Package Choosers","text":"<p>If you want to offer the user a possibility to select a Java class, you can use the <code>TreeClassChooserFactory</code> class. Its different methods allow you to specify the scope from which the classes are taken, to restrict the choice to descendants of a specific class or implementations of an interface, and to include or exclude inner classes from the list.</p> <p>For choosing a Java package, you can use the <code>PackageChooserDialog</code> class.</p>"},{"location":"user_interface_components/lists_and_trees/","title":"List and Tree Controls","text":""},{"location":"user_interface_components/lists_and_trees/#jblist-and-tree","title":"JBList and Tree","text":"<p>Whenever you would normally use a standard Swing <code>JList</code> component, it's recommended to use the <code>JBList</code> class as drop-in replacement. <code>JBList</code> supports the following additional features on top of <code>JList</code>:</p> <ul> <li>Drawing a tooltip with complete text of an item if the item doesn't fit into the list box width.</li> <li>Drawing a gray text message in the middle of the list box when it contains no items.   The text can be customized by calling <code>getEmptyText().setText()</code>.</li> <li>Drawing a busy icon in the top right corner of the list box to indicate that a background operation is being performed.   This can be enabled by calling <code>setPaintBusy()</code>.</li> </ul> <p>Similarly, the <code>Tree</code> class provides a replacement for the standard <code>JTree</code> class. In addition to the features of <code>JBList</code>, it supports wide selection painting (Mac style) and auto-scroll on drag &amp; drop.</p>"},{"location":"user_interface_components/lists_and_trees/#coloredlistcellrenderer-and-coloredtreecellrenderer","title":"ColoredListCellRenderer and ColoredTreeCellRenderer","text":"<p>When you need to customize the presentation of items in a list box or a tree, it's recommended to use the <code>ColoredListCellRenderer</code> or <code>ColoredTreeCellRenderer</code> classes as the cell renderer. These classes allow you to compose the presentation out of multiple text fragments with different attributes by calling <code>append()</code> and to set an optional icon for the item by calling <code>setIcon</code>. The renderer automatically takes care of setting the correct text color for selected items and of many other platform-specific rendering details.</p>"},{"location":"user_interface_components/lists_and_trees/#listspeedsearch-and-treespeedsearch","title":"ListSpeedSearch and TreeSpeedSearch","text":"<p>To facilitate keyboard-based selection of items in a list box or a tree, you can install a speed search handler on it using the <code>ListSpeedSearch</code> and <code>TreeSpeedSearch</code>. This can be done simply by calling <code>new ListSpeedSearch(list)</code> or <code>new TreeSpeedSearch(tree)</code>. If you need to customize the text which is used to locate the element, you can override the <code>getElementText()</code> method. Alternatively, you can pass a function to convert items to strings. A function needs to be passed as <code>elementTextDelegate</code> to the <code>ListSpeedSearch</code> constructor or as <code>toString</code> to the <code>TreeSpeedSearch</code> constructor.</p>"},{"location":"user_interface_components/lists_and_trees/#toolbardecorator","title":"ToolbarDecorator","text":"<p>A very common task in plugin development is showing a list or a tree where the user is allowed to add, remove, edit or reorder the items. The implementation of this task is greatly facilitated by the <code>ToolbarDecorator</code> class. This class provides a toolbar with actions on items and automatically enables drag &amp; drop reordering of items in list boxes if supported by the underlying list model. The position of the toolbar above or below the list depends on the platform under which the IDE is running.</p> <p>To use a toolbar decorator:</p> <ul> <li>If you need to support removing and reordering of items in a list box, make sure the model of your list implements the <code>EditableModel</code> interface.   <code>CollectionListModel</code> is a handy model class that implements this interface.</li> <li>Call <code>ToolbarDecorator.createDecorator()</code> to create a decorator instance.</li> <li>If you need to support adding and/or removing items, call <code>setAddAction()</code> and/or <code>setRemoveAction()</code>.</li> <li>If you need other buttons in additional to the standard ones, call <code>addExtraAction()</code> or <code>setActionGroup()</code>.</li> <li>Call <code>createPanel()</code> and add the component it returns to your panel.</li> </ul>"},{"location":"user_interface_components/misc_swing_components/","title":"Miscellaneous Swing Components","text":""},{"location":"user_interface_components/misc_swing_components/#messages","title":"Messages","text":"<p>The <code>Messages</code> class provides a way to show simple message boxes, input dialogs (modal dialogs with a text field), and chooser dialogs (modal dialogs with a combo box). The function of different methods of the class should be clear from their names. When running on macOS, the message boxes shown by the <code>Messages</code> class use the native UI.</p> <p>The <code>showCheckboxMessageDialog()</code> function provides an easy way to implement a Do not show this again checkbox on messages.</p> <p>Note that it is recommended to use non-modal notifications instead of modal message boxes whenever it's appropriate. Please refer to the Notifications topic for more information.</p>"},{"location":"user_interface_components/misc_swing_components/#jbsplitter","title":"JBSplitter","text":"<p>The <code>JBSplitter</code> class is JetBrains' replacement for the standard <code>JSplitPane</code> class. Unlike some other JetBrains-enhanced Swing components, it's not a drop-in replacement and has a different API. However, to achieve a consistent user experience, it's recommended to use <code>JBSplitter</code> instead of the standard <code>JSplitPane</code>.</p> <p>To add components to the splitter, call the <code>setFirstComponent()</code> and <code>setSecondComponent()</code> methods.</p> <p><code>JBSplitter</code> supports automatic remembering of the split proportion. To enable it, call the <code>setSplitterProportionKey()</code> method and pass the ID under which the proportion will be stored.</p>"},{"location":"user_interface_components/misc_swing_components/#jbtabs","title":"JBTabs","text":"<p>The <code>JBTabs</code> class is JetBrains' implementation of the tab control, used for editor tabs and a few other components. It has a significantly different look &amp; feel compared to the standard Swing tabs, and looks less native on the macOS platform, so it's up to the developer to choose which tab control would be more appropriate.</p>"},{"location":"user_interface_components/misc_swing_components/#toolbars","title":"Toolbars","text":"<p>See Toolbar in Consulo UI Guidelines for an overview.</p> <p>Building UI from Actions covers creating <code>AnAction</code>-based toolbars.</p>"},{"location":"user_interface_components/notifications/","title":"Notifications","text":"<p>One of the leading design principles is avoiding the use of modal message boxes for notifying the user about errors and other situations that may warrant the user's attention. As a replacement, the Consulo provides multiple non-modal notification UI options.</p> <p>For an overview, refer to Notifications in Consulo UI Guidelines.</p>"},{"location":"user_interface_components/notifications/#dialogs","title":"Dialogs","text":"<p>When working in dialog, instead of checking the validity of the input when the OK button is pressed and notifying the user about invalid data with a modal dialog, the recommended approach is to use <code>DialogWrapper.doValidate()</code>, which was described previously.</p>"},{"location":"user_interface_components/notifications/#editor-hints","title":"Editor Hints","text":"<p>For actions invoked from the editor (such as refactorings, navigation actions and different code insight features), the best way to notify the user about the inability to perform an action is to use the <code>HintManager</code> class. Its method <code>showErrorHint()</code> displays a floating popup above the editor which is automatically hidden when the user starts performing another action in the editor. Other <code>HintManager</code> methods can be used for displaying other kinds of non-modal notification hints over an editor.</p>"},{"location":"user_interface_components/notifications/#top-level-notifications","title":"Top-Level Notifications","text":"<p>The most general way to display non-modal notifications is to use the <code>Notifications</code> class.</p> <p>It has two main advantages:</p> <ul> <li>The user can control the way each notification type is displayed under <code>Settings | Appearance &amp; Behavior | Notifications</code></li> <li>All displayed notifications are gathered in the Event Log tool window and can be reviewed later</li> </ul> <p>For UI reference, see Balloon in Consulo UI Guidelines.</p> <p>The specific method used to display a notification is <code>Notifications.Bus.notify()</code>. If the current Project is known, please use overload with <code>Project</code> parameter, so the notification is shown in its associated frame.</p> <p>The text of the notification can include HTML tags.</p> <p>Use <code>Notification.addAction(AnAction)</code> to add links below the content, use <code>NotificationAction</code> for convenience.</p> <p>The <code>groupId</code> parameter of the <code>Notification</code> constructor specifies a notification type. The user can choose the display type corresponding to each notification type under <code>Settings | Appearance and Behavior | Notifications</code>.</p> <p>To specify the preferred display type, you need to use <code>NotificationGroup</code> to create notifications.</p> <p>Please see the following two paragraphs for setup, depending on the target platform version.</p>"},{"location":"user_interface_components/notifications/#notificationgroup-20203-and-later","title":"NotificationGroup (2020.3 and later)","text":"<p><code>NotificationGroup</code> is registered in <code>plugin.xml</code> using <code>com.intellij.notificationGroup</code> extension point. Use <code>key</code> to provide a localized group display name.</p> <pre><code>&lt;extensions defaultExtensionNs=\"com.intellij\"&gt;\n  &lt;notificationGroup id=\"Custom Notification Group\" displayType=\"BALLOON\" key=\"notification.group.name\"/&gt;\n&lt;/extensions&gt;\n</code></pre> <p>Registered instances can then be obtained via their <code>id</code>.</p> <p>TIP Code insight is available for parameters expecting notification group <code>id</code>.</p> <pre><code>public class MyNotifier {\n\n  public static void notifyError(@Nullable Project project, String content) {\n    NotificationGroupManager.getInstance().getNotificationGroup(\"Custom Notification Group\")\n            .createNotification(content, NotificationType.ERROR)\n            .notify(project);\n  }\n\n}\n</code></pre>"},{"location":"user_interface_components/notifications/#notificationgroup-pre-20203","title":"NotificationGroup (Pre-2020.3)","text":"<p><code>NotificationGroup</code> is registered in code.</p> <pre><code>public class MyNotifier {\n\n  private static final NotificationGroup NOTIFICATION_GROUP =\n          new NotificationGroup(\"Custom Notification Group\", NotificationDisplayType.BALLOON, true);\n\n  public static void notifyError(@Nullable Project project, String content) {\n    NOTIFICATION_GROUP.createNotification(content, NotificationType.ERROR)\n                      .notify(project);\n  }\n\n}\n</code></pre>"},{"location":"user_interface_components/popups/","title":"Popups","text":""},{"location":"user_interface_components/popups/#popups","title":"Popups","text":"<p>The Consulo user interface makes extensive use of popups - semi-modal windows that have no chrome (explicit closing buttons) and disappear automatically on focus loss. Making use of these controls in your plugin ensures a consistent user experience between your plugin and the rest of the IDE.</p> <p>Popups can optionally display a title, are optionally movable and resizable (and support remembering their size), and can be nested (show another popup when an item is selected).</p> <p>The <code>JBPopupFactory</code> interface allows you to create popups that display different kinds of components, depending on your specific needs. The most commonly used methods are:</p> <ul> <li><code>createComponentPopupBuilder()</code> is the most generic one, allowing you to show any Swing component in the popup.</li> <li><code>createPopupChooserBuilder()</code> creates a popup for choosing one or more items from a plain <code>java.util.List</code></li> <li><code>createConfirmation()</code> creates a popup for choosing between two options, and performing different actions depending on which option is selected.</li> <li><code>createActionGroupPopup()</code> creates a popup which shows the actions from an action group and executes the action selected by the user.</li> </ul> <p>Action group popups support different ways of choosing an action from the keyboard, in additional to the normal arrow keys. By passing one of the constants in the <code>ActionSelectionAid</code> enumeration, you can choose whether an action can be selected by pressing a key corresponding to its sequential number, typing part of its text (speed search) or pressing a mnemonic character. For popups with a fixed set of items, the recommended selection method is sequential numbering; for popups with a variable and potentially large number of items, speed search typically works best.</p> <p>If you need to create a list-like popup which is more flexible than a simple <code>JList</code> but don't want to represent the possible choices as actions in an action group, you can work directly with the <code>ListPopupStep</code> interface and the <code>JBPopupFactory.createListPopup()</code> method. Normally you don't need to implement the entire interface; instead, you can derive from the <code>BaseListPopupStep</code> class. The key methods to override are <code>getTextFor()</code> (returning the text to display for an item) and <code>onChosen()</code> (called when an item is selected). By returning a new popup step from the <code>onChosen()</code> method, you can implement hierarchical (nested) popups.</p> <p>Once you've created the popup, you need to display it by calling one of the <code>show()</code> methods. You can let the Consulo automatically choose the position based on the context, by calling <code>showInBestPositionFor()</code>, or specify the position explicitly through methods like <code>showUnderneathOf()</code> and <code>showInCenterOf()</code>.</p> <p>NOTE  The <code>show()</code> methods return immediately and do not wait for the popup to be closed.</p> <p>If you need to perform some action when the popup is closed, you can either attach a listener to it using the <code>addListener()</code> method, override a method of the popup contents such as <code>PopupStep.onChosen()</code>, or attach an event handler to your own component within the popup.</p>"},{"location":"user_interface_components/tool_windows/","title":"Tool Windows","text":""},{"location":"user_interface_components/tool_windows/#tool-windows","title":"Tool Windows","text":"<p>Tool windows are child windows of the IDE used to display information. These windows generally have their own toolbars (referred to as tool window bars) along the outer edges of the main window containing one or more tool window buttons, which activate panels displayed on the left, bottom and right sides of the main IDE window. For detailed information about tool windows, please see IntelliJ IDEA Web Help and Tool window topic in Consulo UI Guidelines.</p> <p>Each side contains two tool window groups, the primary and the secondary one, and only one tool window from each group can be active at a time.</p> <p>Each tool window can show multiple tabs (or \"contents\", as they are called in the API). For example, the Run tool window displays a tab for each active run configuration, and the Changes/Version Control tool window displays a fixed set of tabs depending on the version control system used in the project.</p> <p>There are two main scenarios for the use of tool windows in a plugin. Using declarative setup, a tool window button is always visible, and the user can activate it and interact with the plugin functionality at any time. Alternatively, using programmatic setup, the tool window is created to show the results of a specific operation, and can be closed by the user after the operation is completed.</p>"},{"location":"user_interface_components/tool_windows/#declarative-setup","title":"Declarative Setup","text":"<p>The tool window is registered in <code>plugin.xml</code> using the <code>com.intellij.toolWindow</code> extension point. The extension point attributes specify all the data which is necessary to display the tool window button:</p> <ul> <li> <p>The <code>id</code> of the tool window (corresponds to the text displayed on the tool window button)</p> </li> <li> <p>The <code>anchor</code>, meaning the side of the screen on which the tool window is displayed (\"left\" (default), \"right\" or \"bottom\")</p> </li> <li> <p>The <code>secondary</code> attribute, specifying whether the tool window is displayed in the primary or the secondary group</p> </li> <li> <p>The <code>icon</code> to display on the tool window button (13x13 pixels, see Working with Icons and Images)</p> </li> </ul> <p>In addition to that, specify the <code>factoryClass</code> attribute - the name of a class implementing the <code>ToolWindowFactory</code> interface. When the user clicks on the tool window button, the <code>createToolWindowContent()</code> method of the factory class is called, and initializes the UI of the tool window. This procedure ensures that unused tool windows don't cause any overhead in startup time or memory usage: if a user does not interact with the tool window, no plugin code will be loaded or executed.</p> <p>If the tool window of a plugin doesn't need to be displayed for all projects: * For versions 2020.1 and later, also implement the <code>isApplicable(Project)</code> method. * For versions 2019.3 and earlier, also specify the <code>conditionClass</code> attribute: the FQN of a class implementing <code>Condition&lt;Project&gt;</code>, which can be the same class as the tool window factory implementation.</p> <p>Note the condition is evaluated only once when the project is loaded; to show and hide a tool window dynamically while the user is working with the project use the second method for tool window registration.</p> <p>To provide a localized text for the tool window button, specify matching <code>toolwindow.stripe.[id]</code> message key (escape spaces with <code>_</code>) in your message bundle (code insight supported in 2020.3 and later).</p>"},{"location":"user_interface_components/tool_windows/#programmatic-setup","title":"Programmatic Setup","text":"<p>The second method involves simply calling <code>ToolWindowManager.registerToolWindow()</code> from the plugin code. The method has multiple overloads that can be used depending on the task. When using an overload that takes a component, the component becomes the first content (tab) displayed in the tool window.</p>"},{"location":"user_interface_components/tool_windows/#contents-tabs","title":"Contents (Tabs)","text":"<p>Displaying the contents of many tool windows requires access to the indices. Because of that, tool windows are normally disabled while building indices unless the <code>ToolWindowFactory</code> implements <code>DumbAware</code>. For programmatic setup, parameter <code>canWorkInDumbMode</code> must be set to <code>true</code> in calls to <code>registerToolWindow()</code>.</p> <p>As mentioned previously, tool windows can contain multiple tabs, or contents. To manage the contents of a tool window, call <code>ToolWindow.getContentManager()</code>. To add a tab (content), first create it by calling <code>ContentManager.getFactory().createContent()</code>, and then to add it to the tool window using <code>ContentManager.addContent()</code>.</p> <p>A plugin can control whether the user is allowed to close tabs either globally or on a per-tab basis. The former is done by passing the <code>canCloseContents</code> parameter to the <code>registerToolWindow()</code> function, or by specifying <code>canCloseContents=\"true\"</code> in <code>plugin.xml</code>. The default value is <code>false</code>; calling <code>setClosable(true)</code> on <code>ContentManager</code> content will be ignored unless <code>canCloseContents</code> is explicitly set. If closing tabs is enabled in general, a plugin can disable closing of specific tabs by calling <code>Content.setCloseable(false)</code>.</p>"},{"location":"user_interface_components/tool_windows/#sample-plugin","title":"Sample Plugin","text":"<p>To clarify how to develop plugins that create tool windows, consider the toolWindow sample plugin available in the code_samples directory of the SDK documentation. This plugin creates the Sample Calendar tool window that displays the system date, time and time zone.</p> <p>To run the toolWindow plugin</p> <ol> <li>Start IntelliJ IDEA and open the tool_window project saved into the code_samples/tool_window directory.</li> <li>Ensure that the project settings are valid for the environment.    If necessary, modify the project settings.    To view or modify the project settings, open the Project Structure dialog.</li> <li>Run the plugin by choosing the Run | Run on the main menu.    If necessary, change the Run/Debug Configurations.</li> </ol> <p>The plugin creates the Sample Calendar tool window. When opened, this tool window is similar to the following screen:</p> <p></p>"},{"location":"user_interface_components/user_interface_components/","title":"User Interface Components","text":"<p>The Consulo includes a large number of custom Swing components. Using those components in your plugins will ensure that your plugin looks and works consistently with the UI of the rest of the IDE, and can often reduce the code size compared to using the default Swing components.</p> <p>TIP Use UI Inspector to locate the underlying Swing component implementation or to inspect an existing UI at runtime.</p> <p>Please refer to Writing short and clear in Consulo UI Guidelines on writing UI-related texts.</p> <p>The following components are particularly noteworthy:</p> <ul> <li>Menus and toolbars are built using the Action System</li> <li>Tool Windows</li> <li>Dialogs</li> <li>Popups</li> <li>Notifications</li> <li>File and Class Choosers</li> <li>Editor Components</li> <li>List and Tree Controls</li> <li>Tables (TableView) (TBD)</li> <li>Drag &amp; Drop Helpers (TBD)</li> <li>Miscellaneous Swing Components<ul> <li>Messages</li> <li>JBSplitter</li> <li>JBTabs</li> </ul> </li> </ul>"}]}